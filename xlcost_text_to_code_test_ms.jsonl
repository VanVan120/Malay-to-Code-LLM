{"text": "Minimum sum possible by removing all occurrences of any array element | C ++ program for the above approach ; Function to find minimum sum after deletion ; Stores frequency of array elements ; Traverse the array ; Calculate sum ; Update frequency of the current element ; Stores the minimum sum required ; Traverse map ; Find the minimum sum obtained ; Return minimum sum ; Driver code ; Input array ; Size of array", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minSum ( int A [ ] , int N ) { map < int , int > mp ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; mp [ A [ i ] ] ++ ; } int minSum = INT_MAX ; for ( auto it : mp ) { minSum = min ( minSum , sum - ( it . first * it . second ) ) ; } return minSum ; } int main ( ) { int arr [ ] = { 4 , 5 , 6 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minSum ( arr , N ) << \" STRNEWLINE \" ; }", "text_ms": "Jumlah minimum mungkin dengan mengeluarkan semua kejadian mana -mana elemen array | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari jumlah minimum selepas penghapusan; Kedai kekerapan elemen array; Melintasi array; Hitung jumlah; Kekerapan kemas kini elemen semasa; Menyimpan jumlah minimum yang diperlukan; Peta Traverse; Cari jumlah minimum yang diperoleh; Kembali jumlah minimum; Kod pemacu; Arahan input; Saiz array"}
{"text": "Maximum difference between a pair of adjacent elements by excluding every element once | C ++ program for the above approach ; Function to calculate maximum difference between adjacent elements excluding every array element once ; Traverse the array ; Stores the maximum diff ; Check for maximum adjacent element ; Exclude current element ; Update maximum difference ; Update previous value ; Append the result into a vector ; Print the result ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxAdjacent ( int * arr , int N ) { vector < int > res ; for ( int i = 1 ; i < N - 1 ; i ++ ) { int prev = arr [ 0 ] ; int maxi = INT_MIN ; for ( int j = 1 ; j < N ; j ++ ) { if ( i == j ) continue ; maxi = max ( maxi , abs ( arr [ j ] - prev ) ) ; prev = arr [ j ] ; } res . push_back ( maxi ) ; } for ( auto x : res ) cout << x << \" ▁ \" ; cout << endl ; } int main ( ) { int arr [ ] = { 1 , 3 , 4 , 7 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; maxAdjacent ( arr , N ) ; }", "text_ms": "Perbezaan maksimum antara sepasang elemen bersebelahan dengan tidak termasuk setiap elemen sekali | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira perbezaan maksimum antara elemen bersebelahan tidak termasuk setiap elemen array sekali; Melintasi array; Menyimpan perbezaan maksimum; Semak elemen bersebelahan maksimum; Tidak termasuk elemen semasa; Mengemas kini perbezaan maksimum; Mengemas kini nilai sebelumnya; Tambah hasilnya ke dalam vektor; Cetak hasilnya; Kod pemacu"}
{"text": "Count 1 s present in a range of indices [ L , R ] in a given array | C ++ Program to implement the above approach ; Function to find the size of the array if the array initially contains a single element ; Base case ; P / 2 -> findSize ( N / 2 ) P % 2 -> 1 P / 2 -> findSize ( N / 2 ) ; Function to return the count of 1 s in the range [ L , R ] ; Base Case ; PART 1 -> N / 2 [ 1 , Siz_M ] ; Update the right end point of the range to min ( Siz_M , R ) ; PART 2 -> N % 2 [ SizM + 1 , Siz_M + 1 ] ; PART 3 -> N / 2 [ SizM + 2 , 2 * Siz_M - 1 ] Same as PART 1 Property of Symmetricity Shift the coordinates according to PART 1 Subtract ( Siz_M + 1 ) from both L , R ; Driver Code ; Input ; Counts the number of 1 's in  the range [L, R]", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSize ( int N ) { if ( N == 0 ) return 1 ; if ( N == 1 ) return 1 ; int Size = 2 * findSize ( N / 2 ) + 1 ; return Size ; } int CountOnes ( int N , int L , int R ) { if ( L > R ) { return 0 ; } if ( N <= 1 ) { return N ; } int ret = 0 ; int M = N / 2 ; int Siz_M = findSize ( M ) ; if ( L <= Siz_M ) { ret += CountOnes ( N / 2 , L , min ( Siz_M , R ) ) ; } if ( L <= Siz_M + 1 && Siz_M + 1 <= R ) { ret += N % 2 ; } if ( Siz_M + 1 < R ) { ret += CountOnes ( N / 2 , max ( 1 , L - Siz_M - 1 ) , R - Siz_M - 1 ) ; } return ret ; } int main ( ) { int N = 7 , L = 2 , R = 5 ; cout << CountOnes ( N , L , R ) << endl ; return 0 ; }", "text_ms": "Kira 1 S hadir dalam pelbagai indeks [l, r] dalam array yang diberikan | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari saiz array jika array pada mulanya mengandungi elemen tunggal; Kes asas; P / 2 -> findSize (n / 2) p % 2 -> 1 p / 2 -> findSize (n / 2); Berfungsi untuk mengembalikan kiraan 1 s dalam julat [l, r]; Kes asas; Bahagian 1 -> n / 2 [1, siz_m]; Kemas kini titik akhir kanan julat ke min (Siz_m, r); Bahagian 2 -> n % 2 [Sizm + 1, Siz_m + 1]; Bahagian 3 -> n / 2 [Sizm + 2, 2 * Siz_m - 1] Sama seperti Bahagian 1 harta simetrik beralih koordinat mengikut bahagian 1 tolak (siz_m + 1) dari kedua -dua l, r; Kod pemacu; Input; Mengira bilangan 1 dalam julat [l, r]"}
{"text": "Find the pair ( a , b ) with minimum LCM such that their sum is equal to N | C ++ program for the above approach ; Function to check if number is prime or not ; As 1 is neither prime nor composite return false ; Check if it is divided by any number then it is not prime , return false ; Check if n is not divided by any number then it is prime and hence return true ; Function to find the pair ( a , b ) such that sum is N & LCM is minimum ; Check if the number is prime ; Now , if it is not prime then find the least divisior ; Check if divides n then it is a factor ; Required output is a = n / i & b = n / i * ( n - 1 ) ; Driver Code ; Function call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool prime ( int n ) { if ( n == 1 ) return false ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } void minDivisior ( int n ) { if ( prime ( n ) ) { cout << 1 << \" ▁ \" << n - 1 ; } else { for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { cout << n / i << \" ▁ \" << n / i * ( i - 1 ) ; break ; } } } } int main ( ) { int N = 4 ; minDivisior ( N ) ; return 0 ; }", "text_ms": "Cari pasangan (a, b) dengan LCM minimum supaya jumlahnya sama dengan n | Program C ++ untuk pendekatan di atas; Berfungsi untuk memeriksa sama ada nombor adalah perdana atau tidak; Kerana 1 bukan pulangan utama atau komposit palsu; Semak jika ia dibahagikan dengan mana -mana nombor maka ia bukan perdana, kembali palsu; Semak jika n tidak dibahagikan dengan mana -mana nombor maka ia adalah perdana dan oleh itu kembali benar; Fungsi untuk mencari pasangan (a, b) seperti jumlah yang N & LCM adalah minimum; Semak sama ada nombor itu adalah perdana; Sekarang, jika tidak perdana maka cari yang paling kurang divisior; Semak jika membahagikan n maka ia adalah faktor; Output yang diperlukan ialah A = N / I & B = N / I * (n - 1); Kod pemacu; Panggilan fungsi"}
{"text": "Find Landau 's function for a given number N | C ++ program for the above approach ; To store Landau 's function of the number ; Function to return gcd of 2 numbers ; Function to return LCM of two numbers ; Function to find max lcm value among all representations of n ; Calculate Landau 's value ; Recursive function to find different ways in which n can be written as sum of atleast one positive integers ; Check if sum becomes n , consider this representation ; Start from previous element in the representation till n ; Include current element from representation ; Call function again with reduced sum ; Backtrack - remove current element from representation ; Function to find the Landau 's function ; Using recurrence find different ways in which n can be written as a sum of atleast one + ve integers ; Print the result ; Driver Code ; Given N ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Landau = INT_MIN ; int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } int lcm ( int a , int b ) { return ( a * b ) / gcd ( a , b ) ; } void findLCM ( vector < int > & arr ) { int nth_lcm = arr [ 0 ] ; for ( int i = 1 ; i < arr . size ( ) ; i ++ ) nth_lcm = lcm ( nth_lcm , arr [ i ] ) ; Landau = max ( Landau , nth_lcm ) ; } void findWays ( vector < int > & arr , int i , int n ) { if ( n == 0 ) findLCM ( arr ) ; for ( int j = i ; j <= n ; j ++ ) { arr . push_back ( j ) ; findWays ( arr , j , n - j ) ; arr . pop_back ( ) ; } } void Landau_function ( int n ) { vector < int > arr ; findWays ( arr , 1 , n ) ; cout << Landau ; } int main ( ) { int N = 4 ; Landau_function ( N ) ; return 0 ; }", "text_ms": "Cari fungsi Landau untuk nombor tertentu n | Program C ++ untuk pendekatan di atas; Untuk menyimpan fungsi Landau nombor; Berfungsi untuk mengembalikan GCD sebanyak 2 nombor; Berfungsi untuk mengembalikan LCM dua nombor; Fungsi untuk mencari nilai lcm max di antara semua perwakilan n; Hitung nilai Landau; Fungsi rekursif untuk mencari cara yang berbeza di mana n boleh ditulis sebagai jumlah atleast satu bilangan bulat positif; Semak jika jumlah menjadi n, pertimbangkan perwakilan ini; Bermula dari elemen sebelumnya dalam perwakilan sehingga n; Termasuk elemen semasa dari perwakilan; Fungsi panggilan sekali lagi dengan jumlah yang dikurangkan; Backtrack - Keluarkan elemen semasa dari perwakilan; Berfungsi untuk mencari fungsi Landau; Menggunakan kambuhan mencari cara yang berbeza di mana n boleh ditulis sebagai sejumlah atleast satu + ve integer; Cetak hasilnya; Kod pemacu; Diberikan n; Panggilan fungsi"}
{"text": "Check if the remainder of N | C ++ implementation to check the following expression for an integer N is valid or not ; Function to check if a number holds the condition ( N - 1 ) ! % N = N - 1 ; Corner cases ; Number divisible by 2 or 3 are not prime ; Iterate from 5 and keep checking for prime ; Function to check the expression for the value N ; Driver Program", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n == 1 ) return true ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } void checkExpression ( int n ) { if ( isPrime ( n ) ) cout << \" Yes \" ; else cout << \" No \" ; } int main ( ) { int N = 3 ; checkExpression ( N ) ; return 0 ; }", "text_ms": "Semak jika baki N | Pelaksanaan C ++ untuk memeriksa ungkapan berikut untuk integer n adalah sah atau tidak; Fungsi untuk memeriksa sama ada nombor memegang syarat (n - 1)! % N = n - 1; Kes sudut; Nombor yang boleh dibahagikan dengan 2 atau 3 bukanlah perdana; Melangkah dari 5 dan terus memeriksa perdana; Fungsi untuk memeriksa ungkapan untuk nilai n; Program Pemandu"}
{"text": "Check if it is possible to split given Array into K odd | C ++ implementation to check if it is possible to split array into K subsets with odd sum ; Function to check if array can be split in required K subsets ; Store count of odd numbers ; Check if element is odd ; Check if split is possible ; Driver Program", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkArray ( int n , int k , int arr [ ] ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) cnt += 1 ; } if ( cnt >= k && cnt % 2 == k % 2 ) return true ; else return false ; } int main ( ) { int arr [ ] = { 1 , 3 , 4 , 7 , 5 , 3 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 4 ; if ( checkArray ( n , k , arr ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "text_ms": "Semak sama ada mungkin untuk memecah array yang diberikan ke dalam K Odd | C ++ pelaksanaan untuk memeriksa sama ada mungkin untuk memecah array ke dalam sub subset dengan jumlah ganjil; Fungsi untuk memeriksa sama ada array boleh dibahagikan dalam subset k yang diperlukan; Menyimpan kiraan nombor ganjil; Semak jika elemen ganjil; Semak jika perpecahan mungkin; Program Pemandu"}
{"text": "Sum of division of the possible pairs for the given Array | C ++ implementation to compute the sum of division of all the possible pairs for the given array ; Function to compute the sum ; counting frequency of each term and finding maximum among it ; Making cumulative frequency ; Taking the ceil value ; nos . in [ ( n - 0.5 ) X , ( n + 0.5 ) X ) range will add n to the ans ; Return the final result ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE #define ll  long long NEW_LINE using namespace std ; int func ( int arr [ ] , int n ) { double ans = 0 ; int maxx = 0 ; double freq [ 100005 ] = { 0 } ; int temp ; for ( int i = 0 ; i < n ; i ++ ) { temp = arr [ i ] ; freq [ temp ] ++ ; maxx = max ( maxx , temp ) ; } for ( int i = 1 ; i <= maxx ; i ++ ) { freq [ i ] += freq [ i - 1 ] ; } for ( int i = 1 ; i <= maxx ; i ++ ) { if ( freq [ i ] ) { i = ( double ) i ; double j ; ll value = 0 ; double cur = ceil ( 0.5 * i ) - 1.0 ; for ( j = 1.5 ; ; j ++ ) { int val = min ( maxx , ( int ) ( ceil ( i * j ) - 1.0 ) ) ; int times = ( freq [ i ] - freq [ i - 1 ] ) , con = j - 0.5 ; ans += times * con * ( freq [ ( int ) val ] - freq [ ( int ) cur ] ) ; cur = val ; if ( val == maxx ) break ; } } } return ( ll ) ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << func ( arr , n ) << endl ; return 0 ; }", "text_ms": "Jumlah pembahagian pasangan yang mungkin untuk array yang diberikan | C ++ pelaksanaan untuk mengira jumlah pembahagian semua pasangan yang mungkin untuk array yang diberikan; Berfungsi untuk mengira jumlah; Mengira kekerapan setiap istilah dan mencari maksimum di antara ia; Membuat kekerapan kumulatif; Mengambil nilai Ceil; nos. Dalam julat [(n - 0.5) x, (n + 0.5) x) akan menambah n ke ANS; Mengembalikan hasil akhir; Kod pemacu"}
{"text": "Count of elements to be inserted to make Array sum twice the XOR of Array | C ++ program to find the count of elements to be inserted to make Array sum twice the XOR of Array ; Function to find the minimum number of elements that need to be inserted such that the sum of the elements of the array is twice the XOR of the array ; Variable to store the Xor of all the elements ; Variable to store the sum of all elements ; Loop to find the Xor and the sum of the array ; If sum = 2 * Xor ; No need to insert more elements ; We insert one more element which is Sum ; We insert two more elements Sum + Xor and Xor . ; Print the number of elements inserted in the array ; Print the elements that are inserted in the array ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void insert_element ( int a [ ] , int n ) { int Xor = 0 ; int Sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { Xor ^= a [ i ] ; Sum += a [ i ] ; } if ( Sum == 2 * Xor ) { cout << \"0\" << endl ; return ; } if ( Xor == 0 ) { cout << \"1\" << endl ; cout << Sum << endl ; return ; } int num1 = Sum + Xor ; int num2 = Xor ; cout << \"2\" ; cout << num1 << \" ▁ \" << num2 << endl ; } int main ( ) { int a [ ] = { 1 , 2 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; insert_element ( a , n ) ; }", "text_ms": "Count of Elements hendaklah dimasukkan untuk membuat array Jumlah dua kali xor array | Program C ++ untuk mencari kiraan elemen yang akan dimasukkan untuk membuat jumlah array dua kali ganda XOR array; Fungsi untuk mencari bilangan elemen minimum yang perlu dimasukkan supaya jumlah unsur -unsur array adalah dua kali ganda XOR array; Pembolehubah untuk menyimpan XOR semua elemen; Pembolehubah untuk menyimpan jumlah semua elemen; Gelung untuk mencari XOR dan jumlah array; Jika jumlah = 2 * xor; Tidak perlu memasukkan lebih banyak elemen; Kami memasukkan satu lagi elemen yang jumlahnya; Kami memasukkan dua lagi elemen SUM + XOR dan XOR. ; Cetak bilangan elemen yang dimasukkan dalam array; Cetak unsur -unsur yang dimasukkan dalam array; Kod pemacu"}
{"text": "Check if roots of a Quadratic Equation are reciprocal of each other or not | C ++ program to check if roots of a Quadratic Equation are reciprocal of each other or not ; Function to check if the roots of a quadratic equation are reciprocal of each other or not ; Driver code", "code": "#include <iostream> NEW_LINE using namespace std ; void checkSolution ( int a , int b , int c ) { if ( a == c ) cout << \" Yes \" ; else cout << \" No \" ; } int main ( ) { int a = 2 , b = 0 , c = 2 ; checkSolution ( a , b , c ) ; return 0 ; }", "text_ms": "Periksa sama ada akar persamaan kuadrat adalah timbal balik antara satu sama lain atau tidak | Program C ++ untuk memeriksa sama ada akar persamaan kuadrat adalah timbal balik antara satu sama lain atau tidak; Berfungsi untuk memeriksa sama ada akar persamaan kuadratik adalah timbal balik antara satu sama lain atau tidak; Kod pemacu"}
{"text": "Sunny Number | C ++ program for the above approach ; Function check whether x is a perfect square or not ; Find floating point value of square root of x . ; If square root is an integer ; Function to check Sunny Number ; Check if ( N + 1 ) is a perfect square or not ; If ( N + 1 ) is not a perfect square ; Driver Code ; Given Number ; Function call", "code": "#include \" bits / stdc + + . h \" NEW_LINE using namespace std ; bool isPerfectSquare ( long double x ) { long double sr = sqrt ( x ) ; return ( ( sr - floor ( sr ) ) == 0 ) ; } void checkSunnyNumber ( int N ) { if ( isPerfectSquare ( N + 1 ) ) { cout << \" Yes STRNEWLINE \" ; } else { cout << \" No STRNEWLINE \" ; } } int main ( ) { int N = 8 ; checkSunnyNumber ( N ) ; return 0 ; }", "text_ms": "Nombor Sunny | Program C ++ untuk pendekatan di atas; Periksa fungsi sama ada x adalah persegi yang sempurna atau tidak; Cari nilai titik terapung akar persegi x. ; Jika akar persegi adalah integer; Berfungsi untuk memeriksa nombor cerah; Semak jika (n + 1) adalah persegi yang sempurna atau tidak; Jika (n + 1) bukan persegi yang sempurna; Kod pemacu; Nombor yang diberikan; Panggilan fungsi"}
{"text": "Count the numbers which can convert N to 1 using given operation | C ++ program to count the numbers which can convert N to 1 using the given operation ; Function to count the numbers which can convert N to 1 using the given operation ; Iterate through all the integers ; Check if N can be converted to 1 ; Incrementing the count if it can be converted ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countValues ( int n ) { int answer = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { int k = n ; while ( k >= i ) { if ( k % i == 0 ) k /= i ; else k -= i ; } if ( k == 1 ) answer ++ ; } return answer ; } int main ( ) { int N = 6 ; cout << countValues ( N ) ; return 0 ; }", "text_ms": "Kira nombor yang boleh menukar n hingga 1 menggunakan operasi yang diberikan | Program C ++ untuk mengira nombor yang boleh menukar n hingga 1 menggunakan operasi yang diberikan; Fungsi untuk mengira nombor yang boleh menukar n ke 1 menggunakan operasi yang diberikan; Melangkah melalui semua bilangan bulat; Semak jika n boleh ditukar kepada 1; Meningkatkan kiraan jika ia boleh ditukar; Kod pemacu"}
{"text": "Find K numbers with sum equal to N and sum of their squares maximized | C ++ program to find K numbers with sum equal to N and the sum of their squares maximized ; Function that prints the required K numbers ; Print 1 , K - 1 times ; Print ( N - K + 1 ) ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printKNumbers ( int N , int K ) { for ( int i = 0 ; i < K - 1 ; i ++ ) cout << 1 << \" ▁ \" ; cout << ( N - K + 1 ) ; } int main ( ) { int N = 10 , K = 3 ; printKNumbers ( N , K ) ; return 0 ; }", "text_ms": "Cari nombor k dengan jumlah yang sama dengan N dan jumlah kotak mereka dimaksimumkan | Program C ++ untuk mencari nombor K dengan jumlah yang sama dengan N dan jumlah kotak mereka dimaksimumkan; Fungsi yang mencetak nombor k yang diperlukan; Cetak 1, k - 1 kali; Cetak (n - k + 1); Kod pemacu"}
{"text": "Print Nth Stepping or Autobiographical number | C ++ implementation to find NaTMth stepping natural Number ; Function to find the Nth stepping natural number ; Declare the queue ; Enqueue 1 , 2 , ... , 9 in this order ; Perform K operation on queue ; Get the ith Stepping number ; Perform Dequeue from the Queue ; If x mod 10 is not equal to 0 ; then Enqueue 10 x + ( x mod 10 ) - 1 ; Enqueue 10 x + ( x mod 10 ) ; If x mod 10 is not equal to 9 ; then Enqueue 10 x + ( x mod 10 ) + 1 ; Return the dequeued number of the K - th operation as the Nth stepping number ; Driver Code ; initialise K", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int NthSmallest ( int K ) { queue < int > Q ; int x ; for ( int i = 1 ; i < 10 ; i ++ ) Q . push ( i ) ; for ( int i = 1 ; i <= K ; i ++ ) { x = Q . front ( ) ; Q . pop ( ) ; if ( x % 10 != 0 ) { Q . push ( x * 10 + x % 10 - 1 ) ; } Q . push ( x * 10 + x % 10 ) ; if ( x % 10 != 9 ) { Q . push ( x * 10 + x % 10 + 1 ) ; } } return x ; } int main ( ) { int N = 16 ; cout << NthSmallest ( N ) << \" STRNEWLINE \" ; return 0 ; }", "text_ms": "Cetak nth larian atau nombor autobiografi | C ++ pelaksanaan untuk mencari nombor semulajadi natmth; Berfungsi untuk mencari nombor semula jadi yang melangkah; Mengisytiharkan barisan; Enqueue 1, 2, ..., 9 dalam perintah ini; Melakukan operasi k pada barisan; Dapatkan nombor langkah itu; Melakukan dequeue dari barisan; Jika x mod 10 tidak sama dengan 0; Kemudian enqueue 10 x + (x mod 10) - 1; Enqueue 10 x + (x mod 10); Jika x mod 10 tidak sama dengan 9; Kemudian enqueue 10 x + (x mod 10) + 1; Kembalikan jumlah operasi K - th sebagai nombor loncatan n; Kod pemacu; permulaan k"}
{"text": "Least number to be added to or subtracted from N to make it a Perfect Square | C ++ implementation of the approach ; Function to return the Least number ; Get the perfect square before and after N ; Check which is nearest to N ; return the result ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int nearest ( int n ) { int prevSquare = sqrt ( n ) ; int nextSquare = prevSquare + 1 ; prevSquare = prevSquare * prevSquare ; nextSquare = nextSquare * nextSquare ; int ans = ( n - prevSquare ) < ( nextSquare - n ) ? ( prevSquare - n ) : ( nextSquare - n ) ; return ans ; } int main ( ) { int n = 14 ; cout << nearest ( n ) << endl ; n = 16 ; cout << nearest ( n ) << endl ; n = 18 ; cout << nearest ( n ) << endl ; return 0 ; }", "text_ms": "Paling kurang nombor yang akan ditambah atau dikurangkan dari n untuk menjadikannya persegi yang sempurna | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan nombor paling sedikit; Dapatkan persegi yang sempurna sebelum dan selepas n; Periksa yang paling dekat dengan n; mengembalikan hasilnya; Kod pemacu"}
{"text": "Value of Pi ( Î ) up to 50 decimal places | C ++ program to calculate the value of pi up to n decimal places ; Function that prints the value of pi upto N decimal places ; Find value of pi upto using acos ( ) function ; Print value of pi upto N decimal places ; Driver Code ; Function that prints the value of pi", "code": "#include \" bits / stdc + + . h \" NEW_LINE using namespace std ; void printValueOfPi ( int N ) { double pi = 2 * acos ( 0.0 ) ; printf ( \" % . * lf STRNEWLINE \" , N , pi ) ; } int main ( ) { int N = 45 ; printValueOfPi ( N ) ; return 0 ; }", "text_ms": "Nilai pi (Î) sehingga 50 tempat perpuluhan | Program C ++ untuk mengira nilai Pi sehingga tempat perpuluhan; Fungsi yang mencetak nilai tempat perpuluhan Pi; Cari nilai PI sehingga menggunakan fungsi ACOS (); Cetak nilai Pi sehingga tempat perpuluhan; Kod pemacu; Fungsi yang mencetak nilai pi"}
{"text": "Invert the Kth most significant bit of N | C ++ implementation of the approach ; Function to convert decimal number n to its binary representation stored as an array arr [ ] ; Function to convert the number represented as a binary array arr [ ] into its decimal equivalent ; Function to return the updated integer after flipping the kth bit ; Number of bits in n ; Find the binary representation of n ; The number of bits in n are less than k ; Flip the kth bit ; Return the decimal equivalent of the number ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void decBinary ( int arr [ ] , int n ) { int k = log2 ( n ) ; while ( n > 0 ) { arr [ k -- ] = n % 2 ; n /= 2 ; } } int binaryDec ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += arr [ i ] << ( n - i - 1 ) ; return ans ; } int getNum ( int n , int k ) { int l = log2 ( n ) + 1 ; int a [ l ] = { 0 } ; decBinary ( a , n ) ; if ( k > l ) return n ; a [ k - 1 ] = ( a [ k - 1 ] == 0 ) ? 1 : 0 ; return binaryDec ( a , l ) ; } int main ( ) { int n = 56 , k = 2 ; cout << getNum ( n , k ) ; return 0 ; }", "text_ms": "Balikkan kth yang paling penting n | C ++ pelaksanaan pendekatan; Berfungsi untuk menukar nombor perpuluhan n ke perwakilan binari yang disimpan sebagai array arr []; Berfungsi untuk menukar nombor yang diwakili sebagai array perduaan [] ke dalam setara perpuluhannya; Berfungsi untuk mengembalikan integer yang dikemas kini selepas membalikkan kth; Bilangan bit dalam n; Cari perwakilan binari n; Bilangan bit dalam N adalah kurang daripada k; Flip bit kth; Mengembalikan setara perpuluhan nombor; Kod pemacu"}
{"text": "Queries for the product of first N factorials | C ++ implementation of the approach ; Declare result array globally ; Function to precompute the product of factorials upto MAX ; Initialize base condition if n = 0 then factorial of 0 is equal to 1 and answer for n = 0 is 1 ; Iterate loop from 1 to MAX ; factorial ( i ) = factorial ( i - 1 ) * i ; Result for current n is equal to result [ i - 1 ] multiplied by the factorial of i ; Function to perform the queries ; Precomputing the result till MAX ; Perform queries ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long NEW_LINE #define MAX  1000000 NEW_LINE const ll MOD = 1e9 + 7 ; ll result [ MAX + 1 ] ; ll fact [ MAX + 1 ] ; void preCompute ( ) { fact [ 0 ] = 1 ; result [ 0 ] = 1 ; for ( int i = 1 ; i <= MAX ; i ++ ) { fact [ i ] = ( ( fact [ i - 1 ] % MOD ) * i ) % MOD ; result [ i ] = ( ( result [ i - 1 ] % MOD ) * ( fact [ i ] % MOD ) ) % MOD ; } } void performQueries ( int q [ ] , int n ) { preCompute ( ) ; for ( int i = 0 ; i < n ; i ++ ) cout << result [ q [ i ] ] << \" STRNEWLINE \" ; } int main ( ) { int q [ ] = { 4 , 5 } ; int n = sizeof ( q ) / sizeof ( q [ 0 ] ) ; performQueries ( q , n ) ; return 0 ; }", "text_ms": "Pertanyaan untuk produk Factorial N First | C ++ pelaksanaan pendekatan; Mengisytiharkan hasil hasil di seluruh dunia; Berfungsi untuk precompute produk faktorial sehingga max; Inisialisasi keadaan asas jika n = 0 maka faktorial 0 adalah sama dengan 1 dan jawapan untuk n = 0 ialah 1; Gelung berulang dari 1 hingga max; faktorial (i) = factorial (i - 1) * i; Keputusan untuk n semasa adalah sama dengan hasil [i - 1] didarabkan oleh faktorial i; Berfungsi untuk melakukan pertanyaan; Precomputing hasil sehingga max; Melakukan pertanyaan; Kod pemacu"}
{"text": "Nth number in a set of multiples of A , B or C | C ++ program to find nth term divisible by a , b or c ; Function to return gcd of a and b ; Function to return the count of integers from the range [ 1 , num ] which are divisible by either a , b or c ; Calculate the number of terms divisible by a , b and c then remove the terms which are divisible by both ( a , b ) or ( b , c ) or ( c , a ) and then add the numbers which are divisible by a , b and c ; Function for binary search to find the nth term divisible by a , b or c ; Set low to 1 and high to LONG_MAX ; If the current term is less than n then we need to increase low to mid + 1 ; If current term is greater than equal to n then high = mid ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } long divTermCount ( long a , long b , long c , long num ) { return ( ( num / a ) + ( num / b ) + ( num / c ) - ( num / ( ( a * b ) / gcd ( a , b ) ) ) - ( num / ( ( c * b ) / gcd ( c , b ) ) ) - ( num / ( ( a * c ) / gcd ( a , c ) ) ) + ( num / ( ( ( ( a * b ) / gcd ( a , b ) ) * c ) / gcd ( ( ( a * b ) / gcd ( a , b ) ) , c ) ) ) ) ; } int findNthTerm ( int a , int b , int c , long n ) { long low = 1 , high = LONG_MAX , mid ; while ( low < high ) { mid = low + ( high - low ) / 2 ; if ( divTermCount ( a , b , c , mid ) < n ) low = mid + 1 ; else high = mid ; } return low ; } int main ( ) { long a = 2 , b = 3 , c = 5 , n = 100 ; cout << findNthTerm ( a , b , c , n ) ; return 0 ; }", "text_ms": "Nombor nth dalam satu set gandaan a, b atau c | Program C ++ untuk mencari istilah n yang boleh dibahagi dengan a, b atau c; Berfungsi untuk mengembalikan GCD A dan B; Fungsi untuk mengembalikan kiraan bilangan bulat dari julat [1, num] yang boleh dibahagikan dengan sama ada A, B atau C; Kirakan bilangan istilah yang boleh dibahagi dengan A, B dan C kemudian keluarkan istilah yang boleh dibahagikan dengan kedua -dua (a, b) atau (b, c) atau (c, a) dan kemudian tambah nombor yang boleh dibahagikan dengan a, b dan c; Fungsi untuk carian binari untuk mencari istilah n yang boleh dibahagikan dengan a, b atau c; Tetapkan rendah hingga 1 dan tinggi ke long_max; Jika istilah semasa kurang daripada n maka kita perlu meningkat rendah hingga pertengahan + 1; Jika istilah semasa lebih besar daripada sama dengan n maka tinggi = pertengahan; Kod pemacu"}
{"text": "Angle between 3 given vertices in a n | C ++ implementation of the approach ; Function that checks whether given angle can be created using any 3 sides ; Initialize x and y ; Calculate the number of vertices between i and j , j and k ; Calculate the angle subtended at the circumference ; Angle subtended at j can be found using the fact that the sum of angles of a triangle is equal to 180 degrees ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; double calculate_angle ( int n , int i , int j , int k ) { int x , y ; if ( i < j ) x = j - i ; else x = j + n - i ; if ( j < k ) y = k - j ; else y = k + n - j ; double ang1 = ( 180 * x ) / n ; double ang2 = ( 180 * y ) / n ; double ans = 180 - ang1 - ang2 ; return ans ; } int main ( ) { int n = 5 ; int a1 = 1 ; int a2 = 2 ; int a3 = 5 ; cout << calculate_angle ( n , a1 , a2 , a3 ) ; return 0 ; }", "text_ms": "Sudut antara 3 simpang yang diberikan dalam n | C ++ pelaksanaan pendekatan; Fungsi yang memeriksa sama ada sudut yang diberikan boleh dibuat menggunakan mana -mana 3 sisi; Memulakan x dan y; Kirakan bilangan simpang antara i dan j, j dan k; Kirakan sudut yang diselaraskan di lilitan; Sudut yang diselaraskan di J boleh didapati menggunakan hakikat bahawa jumlah sudut segitiga adalah sama dengan 180 darjah; Kod pemacu"}
{"text": "Loss when two items are sold at same price and same percentage profit / loss | C ++ implementation of above approach . ; Function that will find loss ; Driver Code ; Calling Function", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void Loss ( int SP , int P ) { float loss = 0 ; loss = ( 2 * P * P * SP ) / float ( 100 * 100 - P * P ) ; cout << \" Loss ▁ = ▁ \" << loss ; } int main ( ) { int SP = 2400 , P = 30 ; Loss ( SP , P ) ; return 0 ; }", "text_ms": "Kerugian apabila dua item dijual pada harga yang sama dan keuntungan / kerugian peratusan yang sama | C ++ pelaksanaan pendekatan di atas. ; Fungsi yang akan mendapati kerugian; Kod pemacu; Fungsi panggilan"}
{"text": "Check for an array element that is co | C ++ implementation of the approach ; Stores smallest prime factor for every number ; Hash to store prime factors count ; Function to calculate SPF ( Smallest Prime Factor ) for every number till MAXN ; Marking smallest prime factor for every number to be itself ; Separately marking spf for every even number as 2 ; Checking if i is prime ; Marking SPF for all numbers divisible by i ; Marking spf [ j ] if it is not previously marked ; Function to store the prime factors after dividing by the smallest prime factor at every step ; Storing the count of prime factors in hash ; Function that returns true if there are no common prime factors between x and other numbers of the array ; Checking whether it common prime factor with other numbers ; Function that returns true if there is an element in the array which is coprime with all the other elements of the array ; Using sieve for generating prime factors ; Checking the common prime factors with other numbers ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAXN  1000001 NEW_LINE int spf [ MAXN ] ; int hash1 [ MAXN ] = { 0 } ; void sieve ( ) { spf [ 1 ] = 1 ; for ( int i = 2 ; i < MAXN ; i ++ ) spf [ i ] = i ; for ( int i = 4 ; i < MAXN ; i += 2 ) spf [ i ] = 2 ; for ( int i = 3 ; i * i < MAXN ; i ++ ) { if ( spf [ i ] == i ) { for ( int j = i * i ; j < MAXN ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } } void getFactorization ( int x ) { int temp ; while ( x != 1 ) { temp = spf [ x ] ; if ( x % temp == 0 ) { hash1 [ spf [ x ] ] ++ ; x = x / spf [ x ] ; } while ( x % temp == 0 ) x = x / temp ; } } bool check ( int x ) { int temp ; while ( x != 1 ) { temp = spf [ x ] ; if ( x % temp == 0 && hash1 [ temp ] > 1 ) return false ; while ( x % temp == 0 ) x = x / temp ; } return true ; } bool hasValidNum ( int arr [ ] , int n ) { sieve ( ) ; for ( int i = 0 ; i < n ; i ++ ) getFactorization ( arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) if ( check ( arr [ i ] ) ) return true ; return false ; } int main ( ) { int arr [ ] = { 2 , 8 , 4 , 10 , 6 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( hasValidNum ( arr , n ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "text_ms": "Semak elemen array iaitu CO | C ++ pelaksanaan pendekatan; Menyimpan faktor utama terkecil untuk setiap nombor; Hash untuk menyimpan kiraan faktor utama; Fungsi untuk mengira SPF (faktor utama terkecil) untuk setiap nombor sehingga maxn; Menandakan faktor utama terkecil untuk setiap nombor menjadi dirinya sendiri; Secara berasingan menandakan SPF untuk setiap nombor juga sebagai 2; Memeriksa jika saya adalah perdana; Menandakan SPF untuk semua nombor yang boleh dibahagi oleh i; Menandakan SPF [J] jika ia tidak ditandakan sebelum ini; Berfungsi untuk menyimpan faktor utama selepas membahagikan faktor utama terkecil di setiap langkah; Menyimpan kiraan faktor utama dalam hash; Fungsi yang mengembalikan benar jika tidak ada faktor utama yang sama antara x dan nombor array lain; Memeriksa sama ada faktor utama yang biasa dengan nombor lain; Fungsi yang mengembalikan benar jika terdapat elemen dalam array yang coprime dengan semua elemen lain dari array; Menggunakan ayak untuk menjana faktor utama; Memeriksa faktor utama biasa dengan nombor lain; Kod pemacu"}
{"text": "Ways to Remove Edges from a Complete Graph to make Odd Edges | C ++ implementation of the approach ; Function to return the number of ways to remove edges from the graph so that odd number of edges are left in the graph ; Total number of edges ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countWays ( int N ) { int E = ( N * ( N - 1 ) ) / 2 ; if ( N == 1 ) return 0 ; return pow ( 2 , E - 1 ) ; } int main ( ) { int N = 4 ; cout << countWays ( N ) ; return 0 ; }", "text_ms": "Cara untuk mengeluarkan tepi dari graf lengkap untuk membuat tepi ganjil | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan bilangan cara untuk mengeluarkan tepi dari graf supaya bilangan tepi yang ganjil ditinggalkan dalam graf; Jumlah bilangan tepi; Kod pemacu"}
{"text": "Calculate nCr using Pascal 's Triangle | C ++ implementation of the approach ; Initialize the matrix with 0 ; 0 C0 = 1 ; Set every nCr = 1 where r = 0 ; Value for the current cell of Pascal 's triangle ; Function to return the value of nCr ; Return nCr ; Driver code ; Build the Pascal 's triangle", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int l [ 1001 ] [ 1001 ] = { 0 } ; void initialize ( ) { l [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < 1001 ; i ++ ) { l [ i ] [ 0 ] = 1 ; for ( int j = 1 ; j < i + 1 ; j ++ ) { l [ i ] [ j ] = ( l [ i - 1 ] [ j - 1 ] + l [ i - 1 ] [ j ] ) ; } } } int nCr ( int n , int r ) { return l [ n ] [ r ] ; } int main ( ) { initialize ( ) ; int n = 8 ; int r = 3 ; cout << nCr ( n , r ) ; }", "text_ms": "Hitung NCR Menggunakan Segitiga Pascal | C ++ pelaksanaan pendekatan; Memulakan matriks dengan 0; 0 C0 = 1; Tetapkan setiap NCR = 1 di mana r = 0; Nilai untuk sel semasa segitiga Pascal; Berfungsi untuk mengembalikan nilai NCR; Kembali NCR; Kod pemacu; Bina Segitiga Pascal"}
{"text": "Closest sum partition ( into two subsets ) of numbers from 1 to n | C ++ implementation of the approach ; Function to return the minimum required absolute difference ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minAbsDiff ( int n ) { int mod = n % 4 ; if ( mod == 0 mod == 3 ) return 0 ; return 1 ; } int main ( ) { int n = 5 ; cout << minAbsDiff ( n ) ; return 0 ; }", "text_ms": "Partition Jumlah Paling Berdekatan (ke dalam dua subset) nombor dari 1 hingga N | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan perbezaan mutlak yang diperlukan minimum; Kod pemacu"}
{"text": "Check if the Xor of the frequency of all digits of a number N is zero or not | C ++ implementation of the above approach ; creating a frequency array ; Finding the last digit of the number ; Dividing the number by 10 to eliminate last digit ; counting frequency of each digit ; checking if the xor of all frequency is zero or not ; Driver function", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( int s ) { int freq [ 10 ] = { 0 } , r ; while ( s != 0 ) { r = s % 10 ; s = int ( s / 10 ) ; freq [ r ] += 1 ; } int xor__ = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { xor__ = xor__ ^ freq [ i ] ; if ( xor__ == 0 ) return true ; else return false ; } } int main ( ) { int s = 122233 ; if ( check ( s ) ) cout << \" Yes \" << endl ; else cout << \" No \" << endl ; }", "text_ms": "Semak sama ada xor kekerapan semua digit nombor n adalah sifar atau tidak | C ++ pelaksanaan pendekatan di atas; mewujudkan pelbagai frekuensi; Mencari digit terakhir nombor; Membahagikan nombor dengan 10 untuk menghapuskan digit terakhir; kekerapan mengira setiap digit; Memeriksa jika XOR semua kekerapan adalah sifar atau tidak; Fungsi pemacu"}
{"text": "Print N lines of 4 numbers such that every pair among 4 numbers has a GCD K | C ++ implementation of the above approach ; Function to print N lines ; Iterate N times to print N lines ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printLines ( int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { cout << k * ( 6 * i + 1 ) << \" ▁ \" << k * ( 6 * i + 2 ) << \" ▁ \" << k * ( 6 * i + 3 ) << \" ▁ \" << k * ( 6 * i + 5 ) << endl ; } } int main ( ) { int n = 2 , k = 2 ; printLines ( n , k ) ; return 0 ; }", "text_ms": "Cetak garis n 4 nombor supaya setiap pasangan di antara 4 nombor mempunyai gcd k | C ++ pelaksanaan pendekatan di atas; Berfungsi untuk mencetak garis N; Iterat n kali untuk mencetak garis n; Kod pemacu"}
{"text": "Sum of first n term of Series 3 , 5 , 9 , 17 , 33. ... | C ++ program to find sum of first n terms ; Sn = n * ( 4 * n * n + 6 * n - 1 ) / 3 ; Driver code ; number of terms to be included in sum ; find the Sn", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculateSum ( int n ) { return ( pow ( 2 , n + 1 ) + n - 2 ) ; } int main ( ) { int n = 4 ; cout << \" Sum ▁ = ▁ \" << calculateSum ( n ) ; return 0 ; }", "text_ms": "Jumlah pertama N Siri 3, 5, 9, 17, 33 ... | Program C ++ untuk mencari jumlah terma pertama N; Sn = n * (4 * n * n + 6 * n - 1) / 3; Kod pemacu; bilangan terma yang akan dimasukkan dalam jumlah; Cari SN"}
{"text": "Count the number of Special Strings of a given length N | C ++ Program to Count the number of Special Strings of a given length N ; Function to return count of special strings ; stores the answer for a particular value of n ; for n = 0 we have empty string ; for n = 1 we have 2 special strings ; calculate count of special string of length i ; fib [ n ] stores the count of special strings of length n ; Driver code ; initialise n", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define mod  1000000007 NEW_LINE long count_special ( long n ) { long fib [ n + 1 ] ; fib [ 0 ] = 1 ; fib [ 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) { fib [ i ] = ( fib [ i - 1 ] % mod + fib [ i - 2 ] % mod ) % mod ; } return fib [ n ] ; } int main ( ) { long n = 3 ; cout << count_special ( n ) << endl ; return 0 ; }", "text_ms": "Kira bilangan rentetan khas panjang n | Program C ++ untuk mengira bilangan rentetan khas panjang n; Berfungsi untuk mengembalikan kiraan rentetan khas; menyimpan jawapan untuk nilai tertentu n; Untuk n = 0 kita mempunyai rentetan kosong; Untuk n = 1 kita mempunyai 2 rentetan khas; Hitung kiraan rentetan panjang panjang i; Fib [n] menyimpan kiraan rentetan khas panjang n; Kod pemacu; permulaan n"}
{"text": "Counts Path in an Array | C ++ implementation of the above approach ; Find the number of ways to reach the end ; Base case ; Recursive structure ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int mod = 1e9 + 7 ; int ways ( int i , int arr [ ] , int n ) { if ( i == n - 1 ) return 1 ; int sum = 0 ; for ( int j = 1 ; j + i < n && j <= arr [ i ] ; j ++ ) { sum += ( ways ( i + j , arr , n ) ) % mod ; sum %= mod ; } return sum % mod ; } int main ( ) { int arr [ ] = { 5 , 3 , 1 , 4 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ways ( 0 , arr , n ) << endl ; return 0 ; }", "text_ms": "Mengira laluan dalam array | C ++ pelaksanaan pendekatan di atas; Cari bilangan cara untuk mencapai akhir; Kes asas; Struktur rekursif; Kod pemacu"}
{"text": "Counts Path in an Array | C ++ implementation ; find the number of ways to reach the end ; dp to store value ; base case ; Bottom up dp structure ; F [ i ] is dependent of F [ i + 1 ] to F [ i + k ] ; Return value of dp [ 0 ] ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int mod = 1e9 + 7 ; int ways ( int arr [ ] , int n ) { int dp [ n + 1 ] ; dp [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { dp [ i ] = 0 ; for ( int j = 1 ; ( ( j + i ) < n && j <= arr [ i ] ) ; j ++ ) { dp [ i ] += dp [ i + j ] ; dp [ i ] %= mod ; } } return dp [ 0 ] % mod ; } int main ( ) { int arr [ ] = { 5 , 3 , 1 , 4 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ways ( arr , n ) % mod << endl ; return 0 ; }", "text_ms": "Mengira laluan dalam array | C ++ pelaksanaan; Cari bilangan cara untuk mencapai akhir; DP untuk menyimpan nilai; Kes asas; Bawah struktur DP; F [i] bergantung kepada F [i + 1] ke F [i + k]; Nilai pulangan DP [0]; Kod pemacu"}
{"text": "Number of Subsequences with Even and Odd Sum | C ++ implementation ; Returns the count of odd and even subsequences ; Variables to store the count of even subsequences and odd subsequences ; Initialising count_even and count_odd to 0 since as there is no subsequence before the iteration with even or odd count . ; Find sum of all subsequences with even count and odd count and storing them as we iterate . ; if the number is even ; if the number is odd ; Driver code ; Calling the function", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; pair < int , int > countSum ( int arr [ ] , int n ) { int result = 0 ; int count_odd , count_even ; count_odd = 0 ; count_even = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] % 2 == 0 ) { count_even = count_even + count_even + 1 ; count_odd = count_odd + count_odd ; } else { int temp = count_even ; count_even = count_even + count_odd ; count_odd = count_odd + temp + 1 ; } } return { count_even , count_odd } ; } int main ( ) { int arr [ ] = { 1 , 2 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; pair < int , int > ans = countSum ( arr , n ) ; cout << \" EvenSum ▁ = ▁ \" << ans . first ; cout << \" ▁ OddSum ▁ = ▁ \" << ans . second ; return 0 ; }", "text_ms": "Bilangan berikutnya dengan jumlah yang lebih baik dan ganjil | C ++ pelaksanaan; Mengembalikan kiraan ganjil dan bahkan seterusnya; Pembolehubah untuk menyimpan kiraan bahkan seterusnya dan berikutnya yang ganjil; Inisialisasi count_even dan count_odd hingga 0 kerana kerana tidak ada berikutnya sebelum lelaran dengan kiraan yang lebih baik atau ganjil. ; Cari jumlah semua berikutnya dengan mengira dan mengira ganjil dan menyimpannya semasa kami melangkah. ; jika nombor itu juga; Jika nombor itu ganjil; Kod pemacu; Memanggil fungsi"}
{"text": "Count of integers of length N and value less than K such that they contain digits only from the given set | C ++ implementation of the approach ; Function to convert a number into vector ; Push all the digits of N from the end one by one to the vector ; If the original number was 0 ; Reverse the vector elements ; Return the required vector ; Function to return the count of B length integers which are less than C and they contain digits from set A [ ] only ; Convert number to digit array ; Case 1 : No such number possible as the generated numbers will always be greater than C ; Case 2 : All integers of length B are valid as they all are less than C ; contain 0 ; Case 3 ; Update the lower [ ] array such that lower [ i ] stores the count of elements in A [ ] which are less than i ; For first index we can 't use 0 ; Whether ( i - 1 ) digit of generated number can be equal to ( i - 1 ) digit of C ; Is digit [ i - 1 ] present in A ? ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  10 NEW_LINE vector < int > numToVec ( int N ) { vector < int > digit ; while ( N != 0 ) { digit . push_back ( N % 10 ) ; N = N / 10 ; } if ( digit . size ( ) == 0 ) digit . push_back ( 0 ) ; reverse ( digit . begin ( ) , digit . end ( ) ) ; return digit ; } int solve ( vector < int > & A , int B , int C ) { vector < int > digit ; int d , d2 ; digit = numToVec ( C ) ; d = A . size ( ) ; if ( B > digit . size ( ) d == 0 ) return 0 ; else if ( B < digit . size ( ) ) { if ( A [ 0 ] == 0 && B != 1 ) return ( d - 1 ) * pow ( d , B - 1 ) ; else return pow ( d , B ) ; } else { int dp [ B + 1 ] = { 0 } ; int lower [ MAX + 1 ] = { 0 } ; for ( int i = 0 ; i < d ; i ++ ) lower [ A [ i ] + 1 ] = 1 ; for ( int i = 1 ; i <= MAX ; i ++ ) lower [ i ] = lower [ i - 1 ] + lower [ i ] ; bool flag = true ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= B ; i ++ ) { d2 = lower [ digit [ i - 1 ] ] ; dp [ i ] = dp [ i - 1 ] * d ; if ( i == 1 && A [ 0 ] == 0 && B != 1 ) d2 = d2 - 1 ; if ( flag ) dp [ i ] += d2 ; flag = ( flag & ( lower [ digit [ i - 1 ] + 1 ] == lower [ digit [ i - 1 ] ] + 1 ) ) ; } return dp [ B ] ; } } int main ( ) { vector < int > A = { 0 , 1 , 2 , 5 } ; int N = 2 ; int k = 21 ; cout << solve ( A , N , k ) ; return 0 ; }", "text_ms": "Count integer panjang n dan nilai kurang daripada k sehingga ia mengandungi digit hanya dari set yang diberikan | C ++ pelaksanaan pendekatan; Berfungsi untuk menukar nombor menjadi vektor; Tolak semua digit n dari akhir satu demi satu ke vektor; Jika nombor asalnya adalah 0; Membalikkan elemen vektor; Mengembalikan vektor yang diperlukan; Berfungsi untuk mengembalikan bilangan bilangan bulat panjang b yang kurang daripada c dan mereka mengandungi digit dari set a [] sahaja; Menukar nombor ke array digit; Kes 1: Tidak ada bilangan sedemikian mungkin kerana nombor yang dihasilkan akan selalu lebih besar daripada C; Kes 2: Semua bilangan bulat panjang B adalah sah kerana mereka semua kurang daripada C; mengandungi 0; Kes 3; Kemas kini array yang lebih rendah [seperti yang lebih rendah [i] menyimpan kiraan unsur -unsur dalam [] yang kurang daripada saya; Untuk indeks pertama kita tidak boleh menggunakan 0; Sama ada (i - 1) digit nombor yang dihasilkan boleh sama dengan (i - 1) digit C; Adakah digit [i - 1] hadir dalam A? ; Kod pemacu"}
{"text": "Number of Paths of Weight W in a K | C ++ program to count the number of paths with weight W in a K - ary tree ; Function to return the number of ways having weight as wt in K - ary tree ; Return 0 if weight becomes less than zero ; Return one only if the current path has included edge weight of atleast M ; If the current edge weight is greater than or equal to M , set used as true ; Driver Code to test above function", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int solve ( int dp [ ] [ 2 ] , int wt , int K , int M , int used ) { if ( wt < 0 ) return 0 ; if ( wt == 0 ) { if ( used ) return 1 ; return 0 ; } if ( dp [ wt ] [ used ] != -1 ) return dp [ wt ] [ used ] ; int ans = 0 ; for ( int i = 1 ; i <= K ; i ++ ) { if ( i >= M ) ans += solve ( dp , wt - i , K , M , used 1 ) ; else ans += solve ( dp , wt - i , K , M , used ) ; } return dp [ wt ] [ used ] = ans ; } int main ( ) { int W = 3 , K = 3 , M = 2 ; int dp [ W + 1 ] [ 2 ] ; memset ( dp , -1 , sizeof ( dp ) ) ; cout << solve ( dp , W , K , M , 0 ) << endl ; return 0 ; }", "text_ms": "Bilangan jalur berat w dalam k | Program C ++ untuk mengira bilangan laluan dengan berat w dalam pokok k - ary; Berfungsi untuk mengembalikan bilangan cara yang mempunyai berat badan sebagai wt dalam pokok k - ary; Kembali 0 jika berat menjadi kurang daripada sifar; Kembali hanya jika laluan semasa telah memasukkan berat kelebihan mehaum m; Jika berat tepi semasa lebih besar daripada atau sama dengan m, set digunakan sebagai benar; Kod pemacu untuk menguji fungsi di atas"}
{"text": "Ways to write N as sum of two or more positive integers | Set | C ++ implementation of above approach ; Function to find the number of partitions of N ; Base case ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long long partitions ( int n ) { vector < long long > p ( n + 1 , 0 ) ; p [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { int k = 1 ; while ( ( k * ( 3 * k - 1 ) ) / 2 <= i ) { p [ i ] += ( k % 2 ? 1 : -1 ) * p [ i - ( k * ( 3 * k - 1 ) ) / 2 ] ; if ( k > 0 ) k *= -1 ; else k = 1 - k ; } } return p [ n ] ; } int main ( ) { int N = 20 ; cout << partitions ( N ) ; return 0 ; }", "text_ms": "Cara Menulis N sebagai Jumlah Dua atau Lebih Integer Positif | Set | C ++ pelaksanaan pendekatan di atas; Berfungsi untuk mencari bilangan partition n; Kes asas; Kod pemacu"}
{"text": "Longest Increasing Path in Matrix | CPP program to find longest increasing path in a matrix . ; Return the length of LIP in 2D matrix ; If value not calculated yet . ; If reach bottom left cell , return 1. ; If reach the corner of the matrix . ; If value greater than below cell . ; If value greater than left cell . ; Wrapper function ; Driven Program", "code": "#include <bits/stdc++.h> NEW_LINE #define MAX  10 NEW_LINE using namespace std ; int LIP ( int dp [ ] [ MAX ] , int mat [ ] [ MAX ] , int n , int m , int x , int y ) { if ( dp [ x ] [ y ] < 0 ) { int result = 0 ; if ( x == n - 1 && y == m - 1 ) return dp [ x ] [ y ] = 1 ; if ( x == n - 1 y == m - 1 ) result = 1 ; if ( mat [ x ] [ y ] < mat [ x + 1 ] [ y ] ) result = 1 + LIP ( dp , mat , n , m , x + 1 , y ) ; if ( mat [ x ] [ y ] < mat [ x ] [ y + 1 ] ) result = max ( result , 1 + LIP ( dp , mat , n , m , x , y + 1 ) ) ; dp [ x ] [ y ] = result ; } return dp [ x ] [ y ] ; } int wrapper ( int mat [ ] [ MAX ] , int n , int m ) { int dp [ MAX ] [ MAX ] ; memset ( dp , -1 , sizeof dp ) ; return LIP ( dp , mat , n , m , 0 , 0 ) ; } int main ( ) { int mat [ ] [ MAX ] = { { 1 , 2 , 3 , 4 } , { 2 , 2 , 3 , 4 } , { 3 , 2 , 3 , 4 } , { 4 , 5 , 6 , 7 } , } ; int n = 4 , m = 4 ; cout << wrapper ( mat , n , m ) << endl ; return 0 ; }", "text_ms": "Laluan Terpanjang dalam Matriks | Program CPP untuk mencari jalan yang paling lama dalam matriks. ; Kembalikan panjang bibir dalam matriks 2D; Jika nilai belum dikira. ; Jika mencapai sel kiri bawah, kembali 1 .; Jika sampai ke sudut matriks. ; Jika nilai lebih besar daripada sel bawah. ; Jika nilai lebih besar daripada sel kiri. ; Fungsi pembalut; Program yang didorong"}
{"text": "Counts paths from a point to reach Origin | C ++ program to count total number of paths from a point to origin ; Recursive function to count number of paths ; If we reach bottom or top left , we are have only one way to reach ( 0 , 0 ) ; Else count sum of both ways ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPaths ( int n , int m ) { if ( n == 0 m == 0 ) return 1 ; return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) ; } int main ( ) { int n = 3 , m = 2 ; cout << \" ▁ Number ▁ of ▁ Paths ▁ \" << countPaths ( n , m ) ; return 0 ; }", "text_ms": "Mengira laluan dari titik untuk mencapai asal | Program C ++ untuk mengira jumlah laluan dari titik ke asal; Fungsi rekursif untuk mengira bilangan laluan; Jika kita mencapai bahagian bawah atau kiri atas, kita hanya mempunyai satu cara untuk mencapai (0, 0); Lain mengira jumlah kedua -dua cara; Kod pemacu"}
{"text": "Gold Mine Problem | C ++ program to solve Gold Mine problem ; Returns maximum amount of gold that can be collected when journey started from first column and moves allowed are right , right - up and right - down ; Create a table for storing intermediate results and initialize all cells to 0. The first row of goldMineTable gives the maximum gold that the miner can collect when starts that row ; Gold collected on going to the cell on the right ( -> ) ; Gold collected on going to the cell to right up ( / ) ; Gold collected on going to the cell to right down ( \\ ) ; Max gold collected from taking either of the above 3 paths ; The max amount of gold collected will be the max value in first column of all rows ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; int getMaxGold ( int gold [ ] [ MAX ] , int m , int n ) { int goldTable [ m ] [ n ] ; memset ( goldTable , 0 , sizeof ( goldTable ) ) ; for ( int col = n - 1 ; col >= 0 ; col -- ) { for ( int row = 0 ; row < m ; row ++ ) { int right = ( col == n - 1 ) ? 0 : goldTable [ row ] [ col + 1 ] ; int right_up = ( row == 0 col == n - 1 ) ? 0 : goldTable [ row - 1 ] [ col + 1 ] ; int right_down = ( row == m - 1 col == n - 1 ) ? 0 : goldTable [ row + 1 ] [ col + 1 ] ; goldTable [ row ] [ col ] = gold [ row ] [ col ] + max ( right , max ( right_up , right_down ) ) ; } } int res = goldTable [ 0 ] [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) res = max ( res , goldTable [ i ] [ 0 ] ) ; return res ; } int main ( ) { int gold [ MAX ] [ MAX ] = { { 1 , 3 , 1 , 5 } , { 2 , 2 , 4 , 1 } , { 5 , 0 , 2 , 3 } , { 0 , 6 , 1 , 2 } } ; int m = 4 , n = 4 ; cout << getMaxGold ( gold , m , n ) ; return 0 ; }", "text_ms": "Masalah Tambang Emas | Program C ++ untuk menyelesaikan masalah lombong emas; Mengembalikan jumlah maksimum emas yang boleh dikumpulkan apabila perjalanan bermula dari lajur pertama dan bergerak yang dibenarkan adalah betul, kanan dan kanan - ke bawah; Buat jadual untuk menyimpan hasil pertengahan dan memulakan semua sel ke 0. Baris pertama Goldminetable memberikan emas maksimum yang dapat dikumpulkan oleh pelombong ketika memulakan baris itu; Emas yang dikumpulkan pergi ke sel di sebelah kanan ( ->); Emas yang dikumpulkan untuk pergi ke sel untuk ke atas ( /); Emas yang dikumpulkan untuk pergi ke sel ke kanan (\\); Max Gold yang dikumpulkan daripada mengambil salah satu daripada 3 laluan di atas; Jumlah maksimum emas yang dikumpulkan akan menjadi nilai maksimum dalam lajur pertama semua baris; Kod pemacu"}
{"text": "Find minimum adjustment cost of an array | C ++ program to find minimum adjustment cost of an array ; Function to find minimum adjustment cost of an array ; dp [ i ] [ j ] stores minimal adjustment cost on changing A [ i ] to j ; handle first element of array separately ; do for rest elements of the array ; replace A [ i ] to j and calculate minimal adjustment cost dp [ i ] [ j ] ; initialize minimal adjustment cost to INT_MAX ; consider all k such that k >= max ( j - target , 0 ) and k <= min ( M , j + target ) and take minimum ; return minimum value from last row of dp table ; Driver Program to test above functions", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define M  100 NEW_LINE int minAdjustmentCost ( int A [ ] , int n , int target ) { int dp [ n ] [ M + 1 ] ; for ( int j = 0 ; j <= M ; j ++ ) dp [ 0 ] [ j ] = abs ( j - A [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j <= M ; j ++ ) { dp [ i ] [ j ] = INT_MAX ; for ( int k = max ( j - target , 0 ) ; k <= min ( M , j + target ) ; k ++ ) dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + abs ( A [ i ] - j ) ) ; } } int res = INT_MAX ; for ( int j = 0 ; j <= M ; j ++ ) res = min ( res , dp [ n - 1 ] [ j ] ) ; return res ; } int main ( ) { int arr [ ] = { 55 , 77 , 52 , 61 , 39 , 6 , 25 , 60 , 49 , 47 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int target = 10 ; cout << \" Minimum ▁ adjustment ▁ cost ▁ is ▁ \" << minAdjustmentCost ( arr , n , target ) << endl ; return 0 ; }", "text_ms": "Cari Kos Pelarasan Minimum Array | Program C ++ untuk mencari kos pelarasan minimum array; Fungsi untuk mencari kos pelarasan minimum array; dp [i] [j] menyimpan kos pelarasan minimum untuk menukar [i] ke j; mengendalikan elemen pertama array secara berasingan; lakukan untuk elemen rehat array; Gantikan [i] ke J dan hitung kos pelarasan minimum DP [i] [j]; memulakan kos pelarasan minimum kepada int_max; Pertimbangkan semua k sedemikian rupa sehingga k> = max (j - sasaran, 0) dan k <= min (m, j + sasaran) dan ambil minimum; pulangan nilai minimum dari baris terakhir jadual DP; Program pemacu untuk menguji fungsi di atas"}
{"text": "Count triplets from a given range having sum of two numbers of a triplet equal to the third number | C ++ program for the above approach ; Function to find the number of triplets from the range [ L , R ] having sum of two numbers from the triplet equal to the third number ; Stores the total number of triplets ; Find the difference of the range ; Case 1 : If triplets can 't  be formed, then return 0 ; Otherwise ; Update the total number of triplets ; Return the count ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int totalCombination ( int L , int R ) { int count = 0 ; int K = R - L ; if ( K < L ) return 0 ; int ans = K - L ; count = ( ( ans + 1 ) * ( ans + 2 ) ) / 2 ; return count ; } int main ( ) { int L = 2 , R = 6 ; cout << totalCombination ( L , R ) ; return 0 ; }", "text_ms": "Kira tiga kali ganda dari julat tertentu yang mempunyai jumlah dua nombor triplet yang sama dengan nombor ketiga | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari bilangan tiga kali ganda dari julat [l, r] yang mempunyai jumlah dua nombor dari triplet yang sama dengan nombor ketiga; Menyimpan jumlah tiga tiga; Cari perbezaan julat; Kes 1: Jika tiga kali boleh dibentuk, maka kembali 0; Jika tidak; Mengemas kini jumlah tiga kali ganda; Mengembalikan kiraan; Kod pemacu"}
{"text": "Construct two N | C ++ program for the above approach ; Function to generate two arrays satisfying the given conditions ; Declare the two arrays A and B ; Iterate from range [ 1 , 2 * n ] ; Assign consecutive numbers to same indices of the two arrays ; Print the first array ; Print the second array , B ; Driver Code ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printArrays ( int n ) { vector < int > A , B ; for ( int i = 1 ; i <= 2 * n ; i ++ ) { if ( i % 2 == 0 ) A . push_back ( i ) ; else B . push_back ( i ) ; } cout << \" { ▁ \" ; for ( int i = 0 ; i < n ; i ++ ) { cout << A [ i ] ; if ( i != n - 1 ) cout << \" , ▁ \" ; } cout << \" ▁ } STRNEWLINE \" ; cout << \" { ▁ \" ; for ( int i = 0 ; i < n ; i ++ ) { cout << B [ i ] ; if ( i != n - 1 ) cout << \" , ▁ \" ; } cout << \" ▁ } \" ; } int main ( ) { int N = 5 ; printArrays ( N ) ; return 0 ; }", "text_ms": "Bina Dua N | Program C ++ untuk pendekatan di atas; Berfungsi untuk menghasilkan dua susunan yang memenuhi syarat yang diberikan; Mengisytiharkan kedua -dua array A dan B; Berulang dari julat [1, 2 * n]; Berikan nombor berturut -turut kepada indeks yang sama dari kedua -dua tatasusunan; Cetak array pertama; Cetak array kedua, b; Kod pemacu; Panggilan fungsi"}
{"text": "Numbers formed by flipping common set bits in two given integers | C ++ program to implement the above approach ; Function to flip bits of A and B which are set bits in A and B ; Iterater all possible bits of A and B ; If ith bit is set in both A and B ; Clear i - th bit of A ; Clear i - th bit of B ; Print A and B ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void flipBitsOfAandB ( int A , int B ) { for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( A & ( 1 << i ) ) && ( B & ( 1 << i ) ) ) { A = A ^ ( 1 << i ) ; B = B ^ ( 1 << i ) ; } } cout << A << \" ▁ \" << B ; } int main ( ) { int A = 7 , B = 4 ; flipBitsOfAandB ( A , B ) ; return 0 ; }", "text_ms": "Nombor yang dibentuk dengan membalikkan bit set biasa dalam dua bilangan bulat yang diberikan | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk membalikkan bit a dan b yang ditetapkan bit dalam a dan b; Iterater semua bit mungkin a dan b; Jika ia bit ditetapkan dalam kedua -dua A dan B; Jelas i - th bit a; Jelas i - th bit b; Cetak A dan B; Kod pemacu"}
{"text": "Count of distinct pair sum between two 1 to N value Arrays | C ++ implementation to find count of distinct pair sum between two 1 to N value Arrays ; Function to find the distinct sums ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findDistinctSums ( int N ) { return ( 2 * N - 1 ) ; } int main ( ) { int N = 3 ; cout << findDistinctSums ( N ) ; return 0 ; }", "text_ms": "Kira jumlah pasangan yang berbeza antara dua array nilai 1 hingga n | C ++ pelaksanaan untuk mencari kiraan jumlah pasangan yang berbeza antara dua array nilai 1 hingga n; Berfungsi untuk mencari jumlah yang berbeza; Kod pemacu"}
{"text": "Count of substrings from given Ternary strings containing characters at least once | C ++ program for above approach ; Function to count the number of substrings consists of 0 , 1 , and 2 ; Initialize frequency array of size 3 ; Stores the resultant count ; Traversing string str ; Update frequency array ; If all the characters are present counting number of substrings possible ; Update number of substrings ; Return the number of substrings ; Driver Code", "code": "#include <iostream> NEW_LINE #include <string> NEW_LINE using namespace std ; int countSubstrings ( string & str ) { int freq [ 3 ] = { 0 } ; int count = 0 ; int i = 0 ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) { freq [ str [ j ] - '0' ] ++ ; while ( freq [ 0 ] > 0 && freq [ 1 ] > 0 && freq [ 2 ] > 0 ) { freq [ str [ i ++ ] - '0' ] -- ; } count += i ; } return count ; } int main ( ) { string str = \"00021\" ; int count = countSubstrings ( str ) ; cout << count ; return 0 ; }", "text_ms": "Count Substrings Dari Diberi String Ternary yang Mengandungi Karakter Sekurang -kurangnya sekali | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira bilangan substrings terdiri daripada 0, 1, dan 2; Memulakan pelbagai frekuensi saiz 3; Menyimpan kiraan yang dihasilkan; Traversing string str; Arahan kekerapan kemas kini; Jika semua watak hadir mengira bilangan substrings mungkin; Kemas kini bilangan substring; Mengembalikan bilangan substring; Kod pemacu"}
{"text": "Minimum flips to remove any consecutive 3 0 s or 1 s in given Binary string | C ++ program for the above approach ; Function to find the minimum number of flips to make all three pairs of consecutive characters different ; Stores resultant count of pairs ; Base Case ; Iterate over the range [ 0 , N - 2 ] ; If the consecutive 3 numbers are the same then increment the count and the counter ; Return the answer ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minFlips ( string str ) { int count = 0 ; if ( str . size ( ) <= 2 ) { return 0 ; } for ( int i = 0 ; i < str . size ( ) - 2 ; ) { if ( str [ i ] == str [ i + 1 ] && str [ i + 2 ] == str [ i + 1 ] ) { i = i + 3 ; count ++ ; } else { i ++ ; } } return count ; } int main ( ) { string S = \"0011101\" ; cout << minFlips ( S ) ; return 0 ; }", "text_ms": "FLIPS MINIMUM UNTUK MENGURANGKAN SEBARANG TERBUKA 3 0 S atau 1 S DALAM RENCEN BINARY YANG DIPERLUKAN | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari bilangan minimum flip untuk membuat ketiga -tiga pasang aksara berturut -turut berbeza; Kedai -kedai yang dihasilkan pasangan pasangan; Kes asas; Melangkah ke atas julat [0, n - 2]; Jika nombor 3 berturut -turut adalah sama maka kenaikan kiraan dan kaunter; Kembalikan jawapannya; Kod pemacu"}
{"text": "Encrypt the string | C ++ program for the above approach ; Function to convert Decimal to Hex ; Function to encrypt the string ; Iterate the characters of the string ; Iterate until S [ i ] is equal to ch ; Update count and i ; Decrement i by 1 ; Convert count to hexadecimal representation ; Append the character ; Append the characters frequency in hexadecimal representation ; Reverse the obtained answer ; Return required answer ; Driver Code ; Given Input ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string convertToHex ( int num ) { string temp = \" \" ; while ( num != 0 ) { int rem = num % 16 ; char c ; if ( rem < 10 ) { c = rem + 48 ; } else { c = rem + 87 ; } temp += c ; num = num / 16 ; } return temp ; } string encryptString ( string S , int N ) { string ans = \" \" ; for ( int i = 0 ; i < N ; i ++ ) { char ch = S [ i ] ; int count = 0 ; string hex ; while ( i < N && S [ i ] == ch ) { count ++ ; i ++ ; } i -- ; hex = convertToHex ( count ) ; ans += ch ; ans += hex ; } reverse ( ans . begin ( ) , ans . end ( ) ) ; return ans ; } int main ( ) { string S = \" abc \" ; int N = S . size ( ) ; cout << encryptString ( S , N ) ; return 0 ; }", "text_ms": "Menyulitkan rentetan | Program C ++ untuk pendekatan di atas; Berfungsi untuk menukar perpuluhan ke hex; Berfungsi untuk menyulitkan rentetan; Melepasi watak -watak rentetan; Iterat sehingga S [i] sama dengan CH; Kemas kini kiraan dan saya; Penurunan I oleh 1; Menukar kiraan kepada perwakilan heksadesimal; Tambah watak; Tambah kekerapan aksara dalam perwakilan heksadesimal; Membalikkan jawapan yang diperoleh; Mengembalikan jawapan yang diperlukan; Kod pemacu; Diberikan input; Panggilan fungsi"}
{"text": "Count of Binary Strings of length N such that frequency of 1 ' s ▁ exceeds ▁ frequency ▁ of ▁ 0' s | C ++ Program to implement the above approach ; Function to calculate and return the value of Binomial Coefficient C ( n , k ) ; Since C ( n , k ) = C ( n , n - k ) ; Calculate the value of [ n * ( n - 1 ) * -- - * ( n - k + 1 ) ] / [ k * ( k - 1 ) * -- - * 1 ] ; Function to return the count of binary strings of length N such that frequency of 1 ' s ▁ exceed ▁ that ▁ of ▁ 0' s ; Count of N - length binary strings ; Count of N - length binary strings having equal count of 0 ' s ▁ and ▁ 1' s ; For even length strings ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned long int binomialCoeff ( unsigned long int n , unsigned long int k ) { unsigned long int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } unsigned long int countOfString ( int N ) { unsigned long int Stotal = pow ( 2 , N ) ; unsigned long int Sequal = 0 ; if ( N % 2 == 0 ) Sequal = binomialCoeff ( N , N / 2 ) ; unsigned long int S1 = ( Stotal - Sequal ) / 2 ; return S1 ; } int main ( ) { int N = 3 ; cout << countOfString ( N ) ; return 0 ; }", "text_ms": "Kiraan rentetan binari panjang n sedemikian rupa sehingga kekerapan 1 s ~ melebihi »frekuensi ~» s | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk mengira dan mengembalikan nilai pekali binomial C (n, k); Kerana c (n, k) = c (n, n - k); Kirakan nilai [n * (n - 1) * - - * (n - k + 1)] / [k * (k - 1) * - - * 1]; Berfungsi untuk mengembalikan kiraan rentetan binari panjang n sedemikian rupa sehingga kekerapan 1 's »s; Kiraan rentetan binari panjang n; Kiraan rentetan binari panjang n yang mempunyai kiraan yang sama dengan 0 dan 1 's; Untuk rentetan panjang; Kod pemacu"}
{"text": "Remove all occurrences of a character in a string | Recursive approach | C ++ program for the above approach ; Function to remove all occurrences of a character in the string ; Base Case ; Check the first character of the given string ; Pass the rest of the string to recursion Function call ; Add the first character of str and string from recursion ; Driver Code ; Given String ; Given character ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string removeCharRecursive ( string str , char X ) { if ( str . length ( ) == 0 ) { return \" \" ; } if ( str [ 0 ] == X ) { return removeCharRecursive ( str . substr ( 1 ) , X ) ; } return str [ 0 ] + removeCharRecursive ( str . substr ( 1 ) , X ) ; } int main ( ) { string str = \" geeksforgeeks \" ; char X = ' e ' ; str = removeCharRecursive ( str , X ) ; cout << str ; return 0 ; }", "text_ms": "Keluarkan semua kejadian watak dalam rentetan | Pendekatan Rekursif | Program C ++ untuk pendekatan di atas; Berfungsi untuk menghapuskan semua kejadian watak dalam rentetan; Kes asas; Semak watak pertama rentetan yang diberikan; Lulus sisa rentetan ke panggilan fungsi rekursi; Tambah watak pertama STR dan String dari rekursi; Kod pemacu; Diberikan rentetan; Diberikan watak; Panggilan fungsi"}
{"text": "Maximum time such that absolute difference between hour and minute lies in given range | C ++ program for the above approach ; Function checks whether given time is correct ; To check minute value of time ; To check hour value of time ; Changes in value is not allowed at position where ' ? ' is not present ; Function checks whether the absolute difference between hour and minute value is within [ L , R ] ; Checks if the difference is outside the give range ; Displays time in proper 24 - hour format ; Function find the desired value of time whose difference lies in the range [ L , R ] ; Decrease hour value from 23 to 0 ; Check if the hour value is valid if not valid then no need to change minute value , since time will still remain in valid , to check hour value flag is set to 1. ; Decrease minute value from 59 to 0 ; Check if the minute value is valid , if not valid then skip the current iteration , to check ' minute ' value flag is set to 0. ; Driver code ; Input time ; Difference range", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isValid ( char a1 , char a2 , string str , int flag ) { char v1 , v2 ; if ( flag == 0 ) { v1 = str [ 4 ] ; v2 = str [ 3 ] ; } else { v1 = str [ 1 ] ; v2 = str [ 0 ] ; } if ( v1 != a1 && v1 != ' ? ' ) return false ; if ( v2 != a2 && v2 != ' ? ' ) return false ; return true ; } bool inRange ( int hh , int mm , int L , int R ) { int a = abs ( hh - mm ) ; if ( a < L a > R ) return false ; return true ; } void displayTime ( int hh , int mm ) { if ( hh > 10 ) cout << hh << \" : \" ; else if ( hh < 10 ) cout << \"0\" << hh << \" : \" ; if ( mm > 10 ) cout << mm << endl ; else if ( mm < 10 ) cout << \"0\" << mm << endl ; } void maximumTimeWithDifferenceInRange ( string str , int L , int R ) { int i , j ; int h1 , h2 , m1 , m2 ; for ( i = 23 ; i >= 0 ; i -- ) { h1 = i % 10 ; h2 = i / 10 ; if ( ! isValid ( h1 + '0' , h2 + '0' , str , 1 ) ) { continue ; } for ( j = 59 ; j >= 0 ; j -- ) { m1 = j % 10 ; m2 = j / 10 ; if ( ! isValid ( m1 + '0' , m2 + '0' , str , 0 ) ) { continue ; } if ( inRange ( i , j , L , R ) ) { displayTime ( i , j ) ; return ; } } } if ( inRange ( i , j , L , R ) ) displayTime ( i , j ) ; else cout << \" - 1\" << endl ; } int main ( ) { string timeValue = \" ? ? : ? ? \" ; int L = 20 , R = 39 ; maximumTimeWithDifferenceInRange ( timeValue , L , R ) ; return 0 ; }", "text_ms": "Masa maksimum seperti perbezaan mutlak antara jam dan minit terletak pada julat yang diberikan | Program C ++ untuk pendekatan di atas; Pemeriksaan fungsi sama ada masa yang diberikan adalah betul; Untuk memeriksa nilai masa; Untuk memeriksa nilai jam masa; Perubahan nilai tidak dibenarkan di kedudukan di mana '? 'tidak hadir; Fungsi memeriksa sama ada perbezaan mutlak antara jam dan nilai minit berada dalam [l, r]; Cek jika perbezaan di luar julat memberi; Memaparkan masa dalam format 24 jam yang betul; Fungsi Cari nilai masa yang dikehendaki yang perbezaannya terletak dalam julat [l, r]; Menurunkan nilai jam dari 23 hingga 0; Semak jika nilai jam sah jika tidak sah maka tidak perlu menukar nilai minit, kerana masa masih akan sah, untuk memeriksa bendera nilai jam ditetapkan kepada 1 .; Mengurangkan nilai minit dari 59 hingga 0; Semak sama ada nilai minit sah, jika tidak sah kemudian langkau lelaran semasa, untuk memeriksa bendera nilai 'minit' ditetapkan kepada 0 .; Kod pemacu; Masa input; Julat Perbezaan"}
{"text": "Check if a string can be split into even length palindromic substrings | C ++ program for the above approach ; Function to check string str can be split a string into even length palindromic substrings ; Initialize a stack ; Iterate the string ; If the i - th character is same as that at the top of the stack then pop the top element ; Else push the current charactor into the stack ; If the stack is empty , then even palindromic substrings are possible ; Else not - possible ; Driver Code ; Given string ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( string s , int n ) { stack < char > st ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! st . empty ( ) && st . top ( ) == s [ i ] ) st . pop ( ) ; else st . push ( s [ i ] ) ; } if ( st . empty ( ) ) { return true ; } else { return false ; } } int main ( ) { string str = \" aanncddc \" ; int n = str . length ( ) ; if ( check ( str , n ) ) { cout << \" Yes \" << endl ; } else { cout << \" No \" << endl ; } return 0 ; }", "text_ms": "Semak jika rentetan boleh dibahagikan kepada substrings Palindromic panjang walaupun | Program C ++ untuk pendekatan di atas; Fungsi untuk memeriksa string str boleh memecah rentetan ke dalam substrings palindromik panjang; Memulakan timbunan; Melelehkan rentetan; Jika watak I - tH adalah sama seperti di bahagian atas timbunan kemudian pop elemen atas; Lain -lain menolak watak semasa ke dalam timbunan; Sekiranya timbunan kosong, maka substrings palindromik mungkin; Lain tidak - mungkin; Kod pemacu; Diberikan rentetan; Panggilan fungsi"}
{"text": "Number of strings in two array satisfy the given conditions | C ++ program for the above approach ; To store the frequency of string after bitmasking ; To store result for each string in arr2 [ ] ; Traverse the arr1 [ ] and bitmask each string in it ; Bitmasking for each string s ; Update the frequency of string with it 's bitmasking value ; Traverse the arr2 [ ] ; Bitmasking for each string s ; Check if temp is present in an unordered_map or not ; Check for next set bit ; Push the count for current string in resultant array ; Print the count for each string ; Driver Code ; Function call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findNumOfValidWords ( vector < string > & w , vector < string > & p ) { unordered_map < int , int > m ; vector < int > res ; for ( string & s : w ) { int val = 0 ; for ( char c : s ) { val = val | ( 1 << ( c - ' a ' ) ) ; } m [ val ] ++ ; } for ( string & s : p ) { int val = 0 ; for ( char c : s ) { val = val | ( 1 << ( c - ' a ' ) ) ; } int temp = val ; int first = s [ 0 ] - ' a ' ; int count = 0 ; while ( temp != 0 ) { if ( ( ( temp >> first ) & 1 ) == 1 ) { if ( m . find ( temp ) != m . end ( ) ) { count += m [ temp ] ; } } temp = ( temp - 1 ) & val ; } res . push_back ( count ) ; } for ( auto & it : res ) { cout << it << ' ' ; } } int main ( ) { vector < string > arr1 ; arr1 = { \" aaaa \" , \" asas \" , \" able \" , \" ability \" , \" actt \" , \" actor \" , \" access \" } ; vector < string > arr2 ; arr2 = { \" aboveyz \" , \" abrodyz \" , \" absolute \" , \" absoryz \" , \" actresz \" , \" gaswxyz \" } ; findNumOfValidWords ( arr1 , arr2 ) ; return 0 ; }", "text_ms": "Bilangan rentetan dalam dua array memenuhi syarat -syarat yang diberikan | Program C ++ untuk pendekatan di atas; Untuk menyimpan kekerapan rentetan selepas bitmasking; Untuk menyimpan hasil untuk setiap rentetan dalam ARR2 []; Melintasi arr1 [] dan bitmask setiap rentetan di dalamnya; Bitmasking untuk setiap rentetan s; Kemas kini kekerapan rentetan dengan nilai bitmasking; Melintasi arr2 []; Bitmasking untuk setiap rentetan s; Periksa sama ada temp ada dalam unstered_map atau tidak; Semak bit set seterusnya; Tolak kiraan untuk rentetan semasa dalam array yang dihasilkan; Cetak kiraan untuk setiap rentetan; Kod pemacu; Panggilan fungsi"}
{"text": "Maximize the decimal equivalent by flipping only a contiguous set of 0 s | C ++ implementation to Maximize the value of the decimal equivalent given in the binary form ; Function to print the binary number ; Check if the current number is 0 ; Find the continuous 0 s ; Replace initially occurring 0 with 1 ; Break out of loop if 1 occurs ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void flip ( string & s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == '0' ) { while ( s [ i ] == '0' ) { s [ i ] = '1' ; i ++ ; } break ; } } } int main ( ) { string s = \"100010001\" ; flip ( s ) ; cout << s ; return 0 ; }", "text_ms": "Memaksimumkan setara perpuluhan dengan membalikkan hanya satu set bersebelahan 0 S | C ++ pelaksanaan untuk memaksimumkan nilai setara perpuluhan yang diberikan dalam bentuk binari; Berfungsi untuk mencetak nombor binari; Semak sama ada nombor semasa ialah 0; Cari 0 s berterusan; Gantikan pada mulanya berlaku 0 dengan 1; Keluar dari gelung jika 1 berlaku; Kod pemacu"}
{"text": "Sentence Case of a given Camel cased string | C ++ implementation of the approach ; Function to return the original string after converting it back from camelCase ; Print the first character as it is ; Traverse the rest of the characters one by one ; If current character is uppercase print space followed by the current character in lowercase ; Else print the current character ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void getOrgString ( string s ) { cout << s [ 0 ] ; int i = 1 ; while ( i < s . length ( ) ) { if ( s [ i ] >= ' A ' && s [ i ] <= ' Z ' ) cout << \" ▁ \" << ( char ) tolower ( s [ i ] ) ; else cout << s [ i ] ; i ++ ; } } int main ( ) { string s = \" ILoveGeeksForGeeks \" ; getOrgString ( s ) ; return 0 ; }", "text_ms": "Kes Kalimat Rentetan Camel yang Diberikan | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan rentetan asal selepas menukarnya dari unta; Cetak watak pertama seperti itu; Melintasi seluruh watak satu demi satu; Jika watak semasa adalah ruang cetak huruf besar diikuti oleh watak semasa dalam huruf kecil; Lain mencetak watak semasa; Kod pemacu"}
{"text": "Count occurrences of a character in a repeated string | CPP program to find the occurrences of character x in the infinite repeated string upto length n ; Function to count the character ' a ' ; atleast k repetition are required ; if n is not the multiple of the string size check for the remaining repeating character . ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countChar ( string str , char x ) { int count = 0 , n = 10 ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) if ( str [ i ] == x ) count ++ ; int repetitions = n / str . size ( ) ; count = count * repetitions ; for ( int i = 0 ; i < n % str . size ( ) ; i ++ ) { if ( str [ i ] == x ) count ++ ; } return count ; } int main ( ) { string str = \" abcac \" ; cout << countChar ( str , ' a ' ) ; return 0 ; }", "text_ms": "Kira kejadian watak dalam rentetan berulang | Program CPP untuk mencari kejadian aksara x dalam rentetan berulang tak terhingga sehingga panjang n; Berfungsi untuk mengira watak 'A'; Atleast k pengulangan diperlukan; Jika n bukanlah pelbagai pemeriksaan saiz rentetan untuk watak berulang yang tersisa. ; Kod pemacu"}
{"text": "Frequency Measuring Techniques for Competitive Programming | C ++ program to count frequencies of array items having small values . ; Create an array to store counts . The size of array is limit + 1 and all values are initially 0 ; Traverse through array elements and count frequencies ( assuming that elements are limited by limit ) ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void countFreq ( int arr [ ] , int n , int limit ) { vector < int > count ( limit + 1 , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) count [ arr [ i ] ] ++ ; for ( int i = 0 ; i <= limit ; i ++ ) if ( count [ i ] > 0 ) cout << i << \" ▁ \" << count [ i ] << endl ; } int main ( ) { int arr [ ] = { 5 , 5 , 6 , 6 , 5 , 6 , 1 , 2 , 3 , 10 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int limit = 10 ; countFreq ( arr , n , limit ) ; return 0 ; }", "text_ms": "Teknik Pengukuran Kekerapan untuk Pengaturcaraan Kompetitif | Program C ++ untuk mengira frekuensi item array yang mempunyai nilai kecil. ; Buat array untuk menyimpan tuduhan. Saiz array adalah had + 1 dan semua nilai pada mulanya 0; Melintasi unsur -unsur array dan kekerapan kiraan (dengan mengandaikan bahawa unsur -unsur dibatasi oleh had); Kod pemacu"}
{"text": "Check if a string has m consecutive 1 ' s ▁ or ▁ 0' s | Program to check if the binary string contains m consecutive 1 ' s ▁ or ▁ 0' s ; Function that checks if the binary string contains m consecutive 1 ' s ▁ or ▁ 0' s ; length of binary string ; counts zeros ; counts 1 's ; count consecutive 0 's ; count consecutive 1 's ; Drivers Code ; function call", "code": "#include <bits/stdc++.h> NEW_LINE #include <stdio.h> NEW_LINE using namespace std ; bool check ( string s , int m ) { int l = s . length ( ) ; int c1 = 0 ; int c2 = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( s [ i ] == '0' ) { c2 = 0 ; c1 ++ ; } else { c1 = 0 ; c2 ++ ; } if ( c1 == m c2 == m ) return true ; } return false ; } int main ( ) { string s = \"001001\" ; int m = 2 ; if ( check ( s , m ) ) cout << \" YES \" ; else cout << \" NO \" ; return 0 ; }", "text_ms": "Semak jika rentetan mempunyai m berturut -turut 1 's atau ~ 0' s | Program untuk memeriksa sama ada rentetan binari mengandungi m berturut -turut 1 's atau' s; Fungsi yang memeriksa jika rentetan binari mengandungi m berturut -turut 1 's atau' s; panjang rentetan binari; Count Zeros; Count 1 's; Count berturut -turut 0 's; Count berturut -turut 1 's; Kod pemacu; panggilan fungsi"}
{"text": "Product of nodes at k | C ++ implementation to find product of digits of elements at k - th level ; Function to find product of digits of elements at k - th level ; int product = 1 ; Initialize result ; increasing level number ; decreasing level number ; check if current level is the desired level or not ; required product ; Driver program", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int productAtKthLevel ( string tree , int k ) { int level = -1 ; int n = tree . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( tree [ i ] == ' ( ' ) level ++ ; else if ( tree [ i ] == ' ) ' ) level -- ; else { if ( level == k ) product *= ( tree [ i ] - '0' ) ; } } return product ; } int main ( ) { string tree = \" ( 0(5(6 ( ) ( ) ) ( 4 ( ) (9 ( ) ( ) ) ) ) ( 7(1 ( ) ( ) ) ( 3 ( ) ( ) ) ) ) \" ; int k = 2 ; cout << productAtKthLevel ( tree , k ) ; return 0 ; }", "text_ms": "Produk nod di k | C ++ pelaksanaan untuk mencari produk digit elemen pada tahap k - th; Berfungsi untuk mencari produk digit elemen di peringkat k - th; int produk = 1; Memulakan hasil; peningkatan bilangan tahap; mengurangkan nombor tahap; Periksa sama ada tahap semasa adalah tahap yang dikehendaki atau tidak; produk yang diperlukan; Program Pemandu"}
{"text": "Removing row or column wise duplicates from matrix of characters | CPP code to form string after removing duplicates from rows and columns . ; Function to check duplicates in row and column ; Create an array isPresent and initialize all entries of it as false . The value of isPresent [ i ] [ j ] is going to be true if s [ i ] [ j ] is present in its row or column . ; Checking every row for duplicates of a [ i ] [ j ] ; Checking every column for duplicate characters ; If the character is unique in its row and column ; Driver code ; character array ; Calling function", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findDuplciates ( string a [ ] , int n , int m ) { bool isPresent [ n ] [ m ] ; memset ( isPresent , 0 , sizeof ( isPresent ) ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( a [ i ] [ j ] == a [ k ] [ j ] && i != k ) { isPresent [ i ] [ j ] = true ; isPresent [ k ] [ j ] = true ; } } for ( int k = 0 ; k < m ; k ++ ) { if ( a [ i ] [ j ] == a [ i ] [ k ] && j != k ) { isPresent [ i ] [ j ] = true ; isPresent [ i ] [ k ] = true ; } } } } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( ! isPresent [ i ] [ j ] ) printf ( \" % c \" , a [ i ] [ j ] ) ; } int main ( ) { int n = 2 , m = 5 ; string a [ ] = { \" zx \" , \" xz \" } ; findDuplciates ( a , n , m ) ; return 0 ; }", "text_ms": "Mengeluarkan baris atau lajur bijak pendua dari matriks aksara | Kod CPP untuk membentuk rentetan selepas mengeluarkan pendua dari baris dan lajur. ; Berfungsi untuk memeriksa pendua dalam baris dan lajur; Buat array ispresent dan mulakan semua penyertaannya sebagai palsu. Nilai ispresent [i] [j] akan benar jika s [i] [j] hadir dalam baris atau lajurnya. ; Memeriksa setiap baris untuk pendua [i] [j]; Memeriksa setiap lajur untuk aksara pendua; Jika watak itu unik dalam baris dan lajurnya; Kod pemacu; pelbagai watak; Fungsi panggilan"}
{"text": "Program to check for ISBN | CPP program to check if a given ISBN is valid or not ; length must be 10 ; Computing weighted sum of first 9 digits ; Checking last digit . ; If last digit is ' X ' , add 10 to sum , else add its value . ; Return true if weighted sum of digits is divisible by 11. ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isValidISBN ( string & isbn ) { int n = isbn . length ( ) ; if ( n != 10 ) return false ; int sum = 0 ; for ( int i = 0 ; i < 9 ; i ++ ) { int digit = isbn [ i ] - '0' ; if ( 0 > digit 9 < digit ) return false ; sum += ( digit * ( 10 - i ) ) ; } char last = isbn [ 9 ] ; if ( last != ' X ' && ( last < '0' last > '9' ) ) return false ; sum += ( ( last == ' X ' ) ? 10 : ( last - '0' ) ) ; return ( sum % 11 == 0 ) ; } int main ( ) { string isbn = \"007462542X \" ; if ( isValidISBN ( isbn ) ) cout << \" Valid \" ; else cout << \" Invalid \" ; return 0 ; }", "text_ms": "Program untuk memeriksa ISBN | Program CPP untuk memeriksa sama ada ISBN yang diberikan adalah sah atau tidak; panjang mestilah 10; Pengkomputeran berjumlah 9 digit pertama; Memeriksa digit terakhir. ; Jika digit terakhir adalah 'x', tambahkan 10 hingga jumlah, tambah nilainya. ; Kembali benar jika jumlah digit berwajaran boleh dibahagikan dengan 11 .; Kod pemacu"}
{"text": "Reverse vowels in a given string | C ++ program to reverse order of vowels ; utility function to check for vowel ; Function to reverse order of vowels ; Storing the vowels separately ; Placing the vowels in the reverse order in the string ; Driver function", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isVowel ( char c ) { return ( c == ' a ' c == ' A ' c == ' e ' c == ' E ' c == ' i ' c == ' I ' c == ' o ' c == ' O ' c == ' u ' c == ' U ' ) ; } string reverseVowel ( string str ) { int j = 0 ; string vowel ; for ( int i = 0 ; str [ i ] != ' \\0' ; i ++ ) if ( isVowel ( str [ i ] ) ) vowel [ j ++ ] = str [ i ] ; for ( int i = 0 ; str [ i ] != ' \\0' ; i ++ ) if ( isVowel ( str [ i ] ) ) str [ i ] = vowel [ -- j ] ; return str ; } int main ( ) { string str = \" hello ▁ world \" ; cout << reverseVowel ( str ) ; return 0 ; }", "text_ms": "Vokal terbalik dalam rentetan yang diberikan | Program C ++ untuk membalikkan urutan vokal; fungsi utiliti untuk memeriksa vokal; Berfungsi untuk membalikkan urutan vokal; Menyimpan vokal secara berasingan; Meletakkan vokal dalam urutan terbalik dalam rentetan; Fungsi pemacu"}
{"text": "String containing first letter of every word in a given string with spaces | C ++ program to find the string which contain the first character of each word of another string . ; Function to find string which has first character of each word . ; Traverse the string . ; If it is space , set v as true . ; Else check if v is true or not . If true , copy character in output string and set v as false . ; Driver cpde", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string firstLetterWord ( string str ) { string result = \" \" ; bool v = true ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == ' ▁ ' ) v = true ; else if ( str [ i ] != ' ▁ ' && v == true ) { result . push_back ( str [ i ] ) ; v = false ; } } return result ; } int main ( ) { string str = \" geeks ▁ for ▁ geeks \" ; cout << firstLetterWord ( str ) ; return 0 ; }", "text_ms": "String yang mengandungi huruf pertama setiap perkataan dalam rentetan yang diberikan dengan ruang | Program C ++ untuk mencari rentetan yang mengandungi watak pertama setiap perkataan rentetan lain. ; Fungsi untuk mencari rentetan yang mempunyai watak pertama setiap perkataan. ; Melintasi rentetan. ; Jika ia adalah ruang, tetapkan V sebagai benar. ; Lain semak jika v adalah benar atau tidak. Jika benar, salin watak dalam rentetan output dan tetapkan V sebagai palsu. ; Pemandu CPDE"}
{"text": "Unique paths covering every non | C ++ implementation of the approach ; Function for dfs . i , j == > Current cell indexes vis == > To mark visited cells ans == > Result z == > Current count 0 s visited z_count == > Total 0 s present ; Mark the block as visited ; update the count ; If end block reached ; If path covered all the non - obstacle blocks ; Up ; Down ; Left ; Right ; Unmark the block ( unvisited ) ; Function to return the count of the unique paths ; int z_count = 0 ; Total 0 s present ; Count non - obstacle blocks ; Starting position ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void dfs ( int i , int j , vector < vector < int > > & grid , vector < vector < bool > > & vis , int & ans , int z , int z_count ) { int n = grid . size ( ) , m = grid [ 0 ] . size ( ) ; vis [ i ] [ j ] = 1 ; if ( grid [ i ] [ j ] == 0 ) z ++ ; if ( grid [ i ] [ j ] == 2 ) { if ( z == z_count ) ans ++ ; vis [ i ] [ j ] = 0 ; return ; } if ( i >= 1 && ! vis [ i - 1 ] [ j ] && grid [ i - 1 ] [ j ] != -1 ) dfs ( i - 1 , j , grid , vis , ans , z , z_count ) ; if ( i < n - 1 && ! vis [ i + 1 ] [ j ] && grid [ i + 1 ] [ j ] != -1 ) dfs ( i + 1 , j , grid , vis , ans , z , z_count ) ; if ( j >= 1 && ! vis [ i ] [ j - 1 ] && grid [ i ] [ j - 1 ] != -1 ) dfs ( i , j - 1 , grid , vis , ans , z , z_count ) ; if ( j < m - 1 && ! vis [ i ] [ j + 1 ] && grid [ i ] [ j + 1 ] != -1 ) dfs ( i , j + 1 , grid , vis , ans , z , z_count ) ; vis [ i ] [ j ] = 0 ; } int uniquePaths ( vector < vector < int > > & grid ) { int n = grid . size ( ) , m = grid [ 0 ] . size ( ) ; int ans = 0 ; vector < vector < bool > > vis ( n , vector < bool > ( m , 0 ) ) ; int x , y ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { if ( grid [ i ] [ j ] == 0 ) z_count ++ ; else if ( grid [ i ] [ j ] == 1 ) { x = i , y = j ; } } } dfs ( x , y , grid , vis , ans , 0 , z_count ) ; return ans ; } int main ( ) { vector < vector < int > > grid { { 1 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 } , { 0 , 0 , 2 , -1 } } ; cout << uniquePaths ( grid ) ; return 0 ; }", "text_ms": "Laluan unik yang meliputi setiap bukan | C ++ pelaksanaan pendekatan; Fungsi untuk DFS. i, j ==> indeks sel semasa vis ==> untuk menandakan sel -sel yang dikunjungi ans ==> hasil z ==> kiraan semasa 0 s yang dikunjungi z_count ==> total 0 s hadir; Tandakan blok seperti yang dikunjungi; mengemas kini kiraan; Jika blok akhir dicapai; Jika jalan meliputi semua blok bukan halangan; Naik; Ke bawah; Kiri; Betul; Unmark blok (Unvisited); Berfungsi untuk mengembalikan kiraan laluan unik; int z_count = 0; Jumlah 0 s hadir; Menghitung blok penghalang; Kedudukan permulaan; Kod pemacu"}
{"text": "Count of unordered pairs ( x , y ) of Array which satisfy given equation | C ++ Program to find the number of unordered pairs ( x , y ) which satisfy the given equation for the array ; Return the number of unordered pairs satisfying the conditions ; ans stores the number of unordered pairs ; Making each value of array to positive ; Sort the array ; For each index calculating the right boundary for the unordered pairs ; Return the final result ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int numPairs ( int a [ ] , int n ) { int ans , i , index ; ans = 0 ; for ( i = 0 ; i < n ; i ++ ) a [ i ] = abs ( a [ i ] ) ; sort ( a , a + n ) ; for ( i = 0 ; i < n ; i ++ ) { index = upper_bound ( a , a + n , 2 * a [ i ] ) - a ; ans += index - i - 1 ; } return ans ; } int main ( ) { int a [ ] = { 3 , 6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << numPairs ( a , n ) << endl ; return 0 ; }", "text_ms": "Kira pasangan yang tidak teratur (x, y) array yang memenuhi persamaan yang diberikan | Program C ++ untuk mencari bilangan pasangan yang tidak teratur (x, y) yang memenuhi persamaan yang diberikan untuk array; Mengembalikan bilangan pasangan yang tidak teratur yang memenuhi syarat; Ans menyimpan bilangan pasangan yang tidak teratur; Menjadikan setiap nilai array menjadi positif; Susun array; Bagi setiap indeks mengira sempadan yang betul untuk pasangan yang tidak teratur; Mengembalikan hasil akhir; Kod pemacu"}
{"text": "Area of a Square | Using Side , Diagonal and Perimeter | C ++ program for the above approach ; Function to find the area of a square ; Use above formula ; Driver Code ; Given Side of square ; Function call", "code": "#include <iostream> NEW_LINE using namespace std ; int areaOfSquare ( int S ) { int area = S * S ; return area ; } int main ( ) { int S = 5 ; cout << areaOfSquare ( S ) ; return 0 ; }", "text_ms": "Kawasan persegi | Menggunakan sisi, pepenjuru dan perimeter | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari kawasan persegi; Gunakan formula di atas; Kod pemacu; Diberikan sisi persegi; Panggilan fungsi"}
{"text": "Maximum points of intersections possible among X circles and Y straight lines | C ++ program to implement the above approach ; Driver code ; Number of circles ; Number of straight lines ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxPointOfIntersection ( int x , int y ) { int k = y * ( y - 1 ) / 2 ; k = k + x * ( 2 * y + x - 1 ) ; return k ; } int main ( ) { int x = 3 ; int y = 4 ; cout << ( maxPointOfIntersection ( x , y ) ) ; }", "text_ms": "Titik maksimum persimpangan yang mungkin di kalangan x lingkaran dan garis lurus y | Program C ++ untuk melaksanakan pendekatan di atas; Kod pemacu; Bilangan bulatan; Bilangan garis lurus; Panggilan fungsi"}
{"text": "Icosihenagonal Number | C ++ program to find nth Icosihenagonal number ; Function to find Icosihenagonal number ; Formula to calculate nth Icosihenagonal number ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Icosihenagonal_num ( int n ) { return ( 19 * n * n - 17 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << Icosihenagonal_num ( n ) << endl ; n = 10 ; cout << Icosihenagonal_num ( n ) << endl ; return 0 ; }", "text_ms": "Nombor Icosihenagonal | Program C ++ untuk mencari nombor icosihenagon nth; Berfungsi untuk mencari nombor icosihenagon; Formula untuk mengira nombor icosihenagon nth; Kod pemacu"}
{"text": "Find the centroid of a non | C ++ program to implement the above approach ; For all vertices ; Calculate value of A using shoelace formula ; Calculating coordinates of centroid of polygon ; Driver code ; Coordinate of the vertices", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; pair < double , double > find_Centroid ( vector < pair < double , double > > & v ) { pair < double , double > ans = { 0 , 0 } ; int n = v . size ( ) ; double signedArea = 0 ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { double x0 = v [ i ] . first , y0 = v [ i ] . second ; double x1 = v [ ( i + 1 ) % n ] . first , y1 = v [ ( i + 1 ) % n ] . second ; double A = ( x0 * y1 ) - ( x1 * y0 ) ; signedArea += A ; ans . first += ( x0 + x1 ) * A ; ans . second += ( y0 + y1 ) * A ; } signedArea *= 0.5 ; ans . first = ( ans . first ) / ( 6 * signedArea ) ; ans . second = ( ans . second ) / ( 6 * signedArea ) ; return ans ; } int main ( ) { vector < pair < double , double > > vp = { { 1 , 2 } , { 3 , -4 } , { 6 , -7 } } ; pair < double , double > ans = find_Centroid ( vp ) ; cout << setprecision ( 12 ) << ans . first << \" ▁ \" << ans . second << ' ' ; return 0 ; }", "text_ms": "Cari centroid bukan | Program C ++ untuk melaksanakan pendekatan di atas; Untuk semua simpang; Hitung nilai menggunakan formula kasut; Mengira koordinat centroid poligon; Kod pemacu; Menyelaras simpul"}
{"text": "Program to find the angles of a quadrilateral | C ++ implementation of the approach ; Driver code ; according to formula derived above ; print all the angles", "code": "#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; int main ( ) { int d = 10 ; double a ; a = ( double ) ( 360 - ( 6 * d ) ) / 4 ; cout << a << \" , ▁ \" << a + d << \" , ▁ \" << a + ( 2 * d ) << \" , ▁ \" << a + ( 3 * d ) << endl ; return 0 ; }", "text_ms": "Program untuk mencari sudut segiempat | C ++ pelaksanaan pendekatan; Kod pemacu; Menurut formula yang diperolehi di atas; Cetak semua sudut"}
{"text": "Distance between two parallel Planes in 3 | C ++ program to find the Distance between two parallel Planes in 3 D . ; Function to find distance ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE #include <math.h> NEW_LINE using namespace std ; void distance ( float a1 , float b1 , float c1 , float d1 , float a2 , float b2 , float c2 , float d2 ) { float x1 , y1 , z1 , d ; if ( a1 / a2 == b1 / b2 && b1 / b2 == c1 / c2 ) { x1 = y1 = 0 ; z1 = - d1 / c1 ; d = fabs ( ( c2 * z1 + d2 ) ) / ( sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ) ; cout << \" Perpendicular ▁ distance ▁ is ▁ \" << d << endl ; } else cout << \" Planes ▁ are ▁ not ▁ parallel \" ; return ; } int main ( ) { float a1 = 1 ; float b1 = 2 ; float c1 = -1 ; float d1 = 1 ; float a2 = 3 ; float b2 = 6 ; float c2 = -3 ; float d2 = -4 ; distance ( a1 , b1 , c1 , d1 , a2 , b2 , c2 , d2 ) ; return 0 ; }", "text_ms": "Jarak antara dua pesawat selari dalam 3 | Program C ++ untuk mencari jarak antara dua pesawat selari dalam 3 d. ; Berfungsi untuk mencari jarak; Kod pemacu"}
{"text": "Count of ways to form 2 necklace from N beads containing N / 2 beads each | C ++ program for the above approach ; Function to calculate factorial ; Function to count number of ways to make 2 necklace having exactly N / 2 beads if each bead is considered different ; Number of ways to choose N / 2 beads from N beads ; Number of ways to permute N / 2 beads ; Divide ans by 2 to remove repetitions ; Return ans ; Driver Code ; Given Input ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int factorial ( int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; } long long numOfNecklace ( int N ) { long long ans = factorial ( N ) / ( factorial ( N / 2 ) * factorial ( N / 2 ) ) ; ans = ans * factorial ( N / 2 - 1 ) ; ans = ans * factorial ( N / 2 - 1 ) ; ans /= 2 ; return ans ; } int main ( ) { int N = 4 ; cout << numOfNecklace ( N ) << endl ; return 0 ; }", "text_ms": "Mengira cara untuk membentuk 2 kalung dari manik n yang mengandungi n / 2 manik masing -masing | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira faktorial; Fungsi untuk mengira bilangan cara untuk membuat 2 kalung yang mempunyai manik N / 2 jika setiap manik dianggap berbeza; Bilangan cara untuk memilih manik n / 2 dari manik N; Bilangan cara untuk membekalkan manik n / 2; Bahagikan Ans oleh 2 untuk menghapuskan pengulangan; Kembali Ans; Kod pemacu; Diberikan input; Panggilan fungsi"}
{"text": "Check if a number S can be made divisible by D by repeatedly adding the remainder to S | C ++ program for the above approach ; Function to check if S is divisible by D while changing S to ( S + S % D ) ; V ( 0 ) = S % D ; Stores the encountered values ; V ( i ) = ( V ( i - 1 ) + V ( i - 1 ) % D ) % D ; Check if the value has already been encountered ; Edge Case ; Otherwise , insert it into the hashmap ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string isDivisibleByDivisor ( int S , int D ) { S %= D ; unordered_set < int > hashMap ; hashMap . insert ( S ) ; for ( int i = 0 ; i <= D ; i ++ ) { S += ( S % D ) ; S %= D ; if ( hashMap . find ( S ) != hashMap . end ( ) ) { if ( S == 0 ) { return \" Yes \" ; } return \" No \" ; } else hashMap . insert ( S ) ; } return \" Yes \" ; } int main ( ) { int S = 3 , D = 6 ; cout << isDivisibleByDivisor ( S , D ) ; return 0 ; }", "text_ms": "Semak jika nombor s boleh dibuat dibahagikan dengan d dengan berulang kali menambahkan selebihnya kepada s | Program C ++ untuk pendekatan di atas; Fungsi untuk memeriksa sama ada S dibahagi dengan d semasa menukar s ke (s + s % d); V (0) = s % d; Menyimpan nilai yang ditemui; V (i) = (v (i - 1) + v (i - 1) % d) % d; Semak sama ada nilai telah ditemui; Kes tepi; Jika tidak, masukkannya ke dalam hashmap; Kod pemacu"}
{"text": "Minimum number of given moves required to reach ( 1 , 1 ) from ( X , Y ) | C ++ program for the above approach ; Function to count the number of steps required to convert ( x , y ) to ( 1 , 1 ) ; Store the required result ; Iterate while both x and y are not equal to 0 ; If x is greater than y ; Update count and value of x ; Otherwise ; Update count and value of y ; If both x and y > 1 ; Print the result ; Driver Code ; Given X and Y", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumSteps ( int x , int y ) { int cnt = 0 ; while ( x != 0 && y != 0 ) { if ( x > y ) { cnt += x / y ; x %= y ; } else { cnt += y / x ; y %= x ; } } cnt -- ; if ( x > 1 y > 1 ) cnt = -1 ; cout << cnt ; } int main ( ) { int x = 3 , y = 1 ; minimumSteps ( x , y ) ; return 0 ; }", "text_ms": "Bilangan minimum bergerak yang diperlukan untuk mencapai (1, 1) dari (x, y) | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira bilangan langkah yang diperlukan untuk menukar (x, y) hingga (1, 1); Simpan hasil yang diperlukan; Melangkah sementara kedua -dua x dan y tidak sama dengan 0; Jika x lebih besar daripada y; Kemas kini kiraan dan nilai x; Jika tidak; Kemas kini kiraan dan nilai y; Jika kedua -dua x dan y> 1; Cetak hasilnya; Kod pemacu; Diberikan x dan y"}
{"text": "Check if an array is stack sortable | C ++ implementation of above approach . ; Function to check if A [ ] is Stack Sortable or Not . ; Stack S ; Pointer to the end value of array B . ; Traversing each element of A [ ] from starting Checking if there is a valid operation that can be performed . ; If the stack is not empty ; Top of the Stack . ; If the top of the stack is Equal to B_end + 1 , we will pop it And increment B_end by 1. ; if current top is equal to B_end + 1 , we will increment B_end to B_end + 1 ; Pop the top element . ; If the stack is empty We cannot further perfom this operation . Therefore break ; Current Top ; If stack is empty Push the Current element ; If the Current element of the array A [ ] if smaller than the top of the stack We can push it in the Stack . ; Else We cannot sort the array Using any valid operations . ; Not Stack Sortable ; If the stack is empty push the current element in the stack . ; Stack Sortable ; Driver 's Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( int A [ ] , int N ) { stack < int > S ; int B_end = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! S . empty ( ) ) { int top = S . top ( ) ; while ( top == B_end + 1 ) { B_end = B_end + 1 ; S . pop ( ) ; if ( S . empty ( ) ) { break ; } top = S . top ( ) ; } if ( S . empty ( ) ) { S . push ( A [ i ] ) ; } else { top = S . top ( ) ; if ( A [ i ] < top ) { S . push ( A [ i ] ) ; } else { return false ; } } } else { S . push ( A [ i ] ) ; } } return true ; } int main ( ) { int A [ ] = { 4 , 1 , 2 , 3 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; check ( A , N ) ? cout << \" YES \" : cout << \" NO \" ; return 0 ; }", "text_ms": "Semak jika array adalah stack Sortable | C ++ pelaksanaan pendekatan di atas. ; Fungsi untuk memeriksa sama ada [] adalah stack sortable atau tidak. ; Stack s; Penunjuk ke nilai akhir array b. ; Melintasi setiap elemen [] dari memulakan pemeriksaan jika terdapat operasi yang sah yang boleh dilakukan. ; Jika timbunan tidak kosong; Bahagian atas timbunan. ; Jika bahagian atas timbunan adalah sama dengan B_end + 1, kami akan pop dan kenaikan b_end oleh 1 .; Jika bahagian atas semasa adalah sama dengan b_end + 1, kami akan meningkatkan b_end ke b_end + 1; Pop elemen teratas. ; Sekiranya timbunan kosong, kita tidak dapat terus berusaha operasi ini. Oleh itu pecah; Atas semasa; Jika timbunan kosong tolak elemen semasa; Jika elemen semasa array A [] jika lebih kecil daripada bahagian atas timbunan kita boleh menolaknya dalam timbunan. ; Lain -lain kita tidak dapat menyusun array menggunakan mana -mana operasi yang sah. ; Tidak boleh disusun; Jika timbunan kosong tolak elemen semasa dalam timbunan. ; Stack Sortable; Kod pemandu"}
{"text": "Minimum number of bracket reversals needed to make an expression balanced | C ++ program to find minimum number of reversals required to balance an expression ; Returns count of minimum reversals for making expr balanced . Returns - 1 if expr cannot be balanced . ; length of expression must be even to make it balanced by using reversals . ; After this loop , stack contains unbalanced part of expression , i . e . , expression of the form \" } } . . } { { . . { \" ; Length of the reduced expression red_len = ( m + n ) ; count opening brackets at the end of stack ; return ceil ( m / 2 ) + ceil ( n / 2 ) which is actually equal to ( m + n ) / 2 + n % 2 when m + n is even . ; Driver program to test above function", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countMinReversals ( string expr ) { int len = expr . length ( ) ; if ( len % 2 ) return -1 ; stack < char > s ; for ( int i = 0 ; i < len ; i ++ ) { if ( expr [ i ] == ' } ' && ! s . empty ( ) ) { if ( s . top ( ) == ' { ' ) s . pop ( ) ; else s . push ( expr [ i ] ) ; } else s . push ( expr [ i ] ) ; } int red_len = s . size ( ) ; int n = 0 ; while ( ! s . empty ( ) && s . top ( ) == ' { ' ) { s . pop ( ) ; n ++ ; } return ( red_len / 2 + n % 2 ) ; } int main ( ) { string expr = \" } } { { \" ; cout << countMinReversals ( expr ) ; return 0 ; }", "text_ms": "Bilangan minimum pembalikan kurungan yang diperlukan untuk membuat ekspresi seimbang | Program C ++ untuk mencari bilangan minimum pembalikan yang diperlukan untuk mengimbangi ungkapan; Mengembalikan kiraan pembalikan minimum untuk membuat expr seimbang. Pulangan - 1 Jika expr tidak boleh seimbang. ; Panjang ekspresi mestilah menjadikannya seimbang dengan menggunakan pembalikan. ; Selepas gelung ini, timbunan mengandungi bahagian ekspresi yang tidak seimbang, i. e. , ungkapan bentuk \"}}.} {{.. {\"; Panjang ekspresi yang dikurangkan red_len = (m + n); mengira kurungan pembukaan pada akhir timbunan; Kembali Ceil (m / 2) + Ceil (n / 2) yang sebenarnya sama dengan (m + n) / 2 + n % 2 apabila m + n juga. ; Program pemacu untuk menguji fungsi di atas"}
{"text": "Minimum number of bracket reversals needed to make an expression balanced | C ++ program to find minimum number of reversals required to balance an expression ; Returns count of minimum reversals for making expr balanced . Returns - 1 if expr cannot be balanced . ; Expressions of odd lengths cannot be balanced ; If we find a left bracket then we simply increment the left bracket ; Else if left bracket is 0 then we find unbalanced right bracket and increment right bracket or if the expression is balanced then we decrement left ; Driver program to test above function", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countMinReversals ( string expr ) { int len = expr . length ( ) ; if ( len % 2 != 0 ) { return -1 ; } int left_brace = 0 , right_brace = 0 ; int ans ; for ( int i = 0 ; i < len ; i ++ ) { if ( expr [ i ] == ' { ' ) { left_brace ++ ; } else { if ( left_brace == 0 ) { right_brace ++ ; } else { left_brace -- ; } } } ans = ceil ( left_brace / 2 ) + ceil ( right_brace / 2 ) ; return ans ; } int main ( ) { string expr = \" } } { { \" ; cout << countMinReversals ( expr ) ; return 0 ; }", "text_ms": "Bilangan minimum pembalikan kurungan yang diperlukan untuk membuat ekspresi seimbang | Program C ++ untuk mencari bilangan minimum pembalikan yang diperlukan untuk mengimbangi ungkapan; Mengembalikan kiraan pembalikan minimum untuk membuat expr seimbang. Pulangan - 1 Jika expr tidak boleh seimbang. ; Ekspresi panjang ganjil tidak boleh seimbang; Jika kita menemui pendakap kiri maka kita hanya menambah kurungan kiri; Lain jika pendakap kiri adalah 0 maka kita dapati pendakap kanan yang tidak seimbang dan pendakap kanan kenaikan atau jika ungkapan seimbang maka kita menurunkan kiri; Program pemacu untuk menguji fungsi di atas"}
{"text": "Form minimum number from given sequence | C ++ program to print minimum number that can be formed from a given sequence of Is and Ds ; Prints the minimum number that can be formed from input sequence of I ' s ▁ and ▁ D ' s ; Initialize current_max ( to make sure that we don 't use repeated character ; Initialize last_entry ( Keeps track for last printed digit ) ; Iterate over input array ; Initialize ' noOfNextD ' to get count of next D 's available ; If letter is ' I ' Calculate number of next consecutive D 's  available ; If ' I ' is first letter , print incremented sequence from 1 ; Set max digit reached ; If not first letter Get next digit to print ; Print digit for I ; For all next consecutive ' D ' print decremented sequence ; If letter is ' D ' ; If ' D ' is first letter in sequence Find number of Next D 's available ; Calculate first digit to print based on number of consecutive D 's ; Print twice for the first time ; Store last entry ; If current ' D ' is not first letter Decrement last_entry ; Driver program to test above", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void PrintMinNumberForPattern ( string arr ) { int curr_max = 0 ; int last_entry = 0 ; int j ; for ( int i = 0 ; i < arr . length ( ) ; i ++ ) { int noOfNextD = 0 ; switch ( arr [ i ] ) { case ' I ' : j = i + 1 ; while ( arr [ j ] == ' D ' && j < arr . length ( ) ) { noOfNextD ++ ; j ++ ; } if ( i == 0 ) { curr_max = noOfNextD + 2 ; cout << \" ▁ \" << ++ last_entry ; cout << \" ▁ \" << curr_max ; last_entry = curr_max ; } else { curr_max = curr_max + noOfNextD + 1 ; last_entry = curr_max ; cout << \" ▁ \" << last_entry ; } for ( int k = 0 ; k < noOfNextD ; k ++ ) { cout << \" ▁ \" << -- last_entry ; i ++ ; } break ; case ' D ' : if ( i == 0 ) { j = i + 1 ; while ( arr [ j ] == ' D ' && j < arr . length ( ) ) { noOfNextD ++ ; j ++ ; } curr_max = noOfNextD + 2 ; cout << \" ▁ \" << curr_max << \" ▁ \" << curr_max - 1 ; last_entry = curr_max - 1 ; } else { cout << \" ▁ \" << last_entry - 1 ; last_entry -- ; } break ; } } cout << endl ; } int main ( ) { PrintMinNumberForPattern ( \" IDID \" ) ; PrintMinNumberForPattern ( \" I \" ) ; PrintMinNumberForPattern ( \" DD \" ) ; PrintMinNumberForPattern ( \" II \" ) ; PrintMinNumberForPattern ( \" DIDI \" ) ; PrintMinNumberForPattern ( \" IIDDD \" ) ; PrintMinNumberForPattern ( \" DDIDDIID \" ) ; return 0 ; }", "text_ms": "Borang Nombor Minimum Dari Urutan yang Diberikan | Program C ++ untuk mencetak nombor minimum yang boleh dibentuk dari urutan tertentu IS dan DS; Mencetak nombor minimum yang boleh dibentuk dari urutan input i dan u; Inisialisasi Current_Max (untuk memastikan bahawa kita tidak menggunakan watak berulang; permulaan last_entry (menjejaki angka bercetak terakhir); beralih ke atas array input; memulakan 'noofnextd' untuk mendapatkan kiraan d berikut yang tersedia; Cetak angka untuk saya"}
{"text": "Form minimum number from given sequence | C ++ program to print minimum number that can be formed from a given sequence of Is and Ds ; min_avail represents the minimum number which is still available for inserting in the output vector . pos_of_I keeps track of the most recent index where ' I ' was encountered w . r . t the output vector ; vector to store the output ; cover the base cases ; Traverse rest of the input ; print the number ; Driver program to check the above function", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printLeast ( string arr ) { int min_avail = 1 , pos_of_I = 0 ; vector < int > v ; if ( arr [ 0 ] == ' I ' ) { v . push_back ( 1 ) ; v . push_back ( 2 ) ; min_avail = 3 ; pos_of_I = 1 ; } else { v . push_back ( 2 ) ; v . push_back ( 1 ) ; min_avail = 3 ; pos_of_I = 0 ; } for ( int i = 1 ; i < arr . length ( ) ; i ++ ) { if ( arr [ i ] == ' I ' ) { v . push_back ( min_avail ) ; min_avail ++ ; pos_of_I = i + 1 ; } else { v . push_back ( v [ i ] ) ; for ( int j = pos_of_I ; j <= i ; j ++ ) v [ j ] ++ ; min_avail ++ ; } } for ( int i = 0 ; i < v . size ( ) ; i ++ ) cout << v [ i ] << \" ▁ \" ; cout << endl ; } int main ( ) { printLeast ( \" IDID \" ) ; printLeast ( \" I \" ) ; printLeast ( \" DD \" ) ; printLeast ( \" II \" ) ; printLeast ( \" DIDI \" ) ; printLeast ( \" IIDDD \" ) ; printLeast ( \" DDIDDIID \" ) ; return 0 ; }", "text_ms": "Borang Nombor Minimum Dari Urutan yang Diberikan | Program C ++ untuk mencetak nombor minimum yang boleh dibentuk dari urutan tertentu IS dan DS; min_avail mewakili nombor minimum yang masih tersedia untuk memasukkan dalam vektor output. pos_of_i menjejaki indeks paling terkini di mana 'i' ditemui w. r. t vektor output; vektor untuk menyimpan output; meliputi kes asas; Melintasi sisa input; Cetak nombor; Program pemacu untuk memeriksa fungsi di atas"}
{"text": "Form minimum number from given sequence | C ++ program to print minimum number that can be formed from a given sequence of Is and Ds ; Function to decode the given sequence to construct minimum number without repeated digits ; result store output string ; create an empty stack of integers ; run n + 1 times where n is length of input sequence ; push number i + 1 into the stack ; if all characters of the input sequence are processed or current character is ' I ' ( increasing ) ; run till stack is empty ; remove top element from the stack and add it to solution ; main function", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void PrintMinNumberForPattern ( string seq ) { string result ; stack < int > stk ; for ( int i = 0 ; i <= seq . length ( ) ; i ++ ) { stk . push ( i + 1 ) ; if ( i == seq . length ( ) seq [ i ] == ' I ' ) { while ( ! stk . empty ( ) ) { result += to_string ( stk . top ( ) ) ; result += \" ▁ \" ; stk . pop ( ) ; } } } cout << result << endl ; } int main ( ) { PrintMinNumberForPattern ( \" IDID \" ) ; PrintMinNumberForPattern ( \" I \" ) ; PrintMinNumberForPattern ( \" DD \" ) ; PrintMinNumberForPattern ( \" II \" ) ; PrintMinNumberForPattern ( \" DIDI \" ) ; PrintMinNumberForPattern ( \" IIDDD \" ) ; PrintMinNumberForPattern ( \" DDIDDIID \" ) ; return 0 ; }", "text_ms": "Borang Nombor Minimum Dari Urutan yang Diberikan | Program C ++ untuk mencetak nombor minimum yang boleh dibentuk dari urutan tertentu IS dan DS; Fungsi untuk menyahkod urutan yang diberikan untuk membina nombor minimum tanpa digit berulang; Hasil Store Output String; Buat timbunan integer kosong; Jalankan n + 1 kali di mana n adalah panjang urutan input; Tekan nombor I + 1 ke dalam timbunan; Jika semua aksara urutan input diproses atau watak semasa adalah 'I' (meningkat); Jalankan sehingga timbunan kosong; Keluarkan elemen teratas dari timbunan dan tambahkannya ke penyelesaian; fungsi utama"}
{"text": "Form minimum number from given sequence | C ++ program of above approach ; Returns minimum number made from given sequence without repeating digits ; The loop runs for each input character as well as one additional time for assigning rank to remaining characters ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string getMinNumberForPattern ( string seq ) { int n = seq . length ( ) ; if ( n >= 9 ) return \" - 1\" ; string result ( n + 1 , ' ▁ ' ) ; int count = 1 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i == n seq [ i ] == ' I ' ) { for ( int j = i - 1 ; j >= -1 ; j -- ) { result [ j + 1 ] = '0' + count ++ ; if ( j >= 0 && seq [ j ] == ' I ' ) break ; } } } return result ; } int main ( ) { string inputs [ ] = { \" IDID \" , \" I \" , \" DD \" , \" II \" , \" DIDI \" , \" IIDDD \" , \" DDIDDIID \" } ; for ( string input : inputs ) { cout << getMinNumberForPattern ( input ) << \" STRNEWLINE \" ; } return 0 ; }", "text_ms": "Borang Nombor Minimum Dari Urutan yang Diberikan | C ++ program pendekatan di atas; Mengembalikan nombor minimum yang dibuat dari urutan yang diberikan tanpa mengulangi digit; Gelung berjalan untuk setiap aksara input serta satu masa tambahan untuk memberikan pangkat kepada watak yang tinggal; Kod pemacu"}
{"text": "Check if the first and last digit of the smallest number forms a prime | C ++ implementation of above approach ; function to check prime ; Function to generate smallest possible number with given digits ; Declare a hash array of size 10 and initialize all the elements to zero ; store the number of occurrences of the digits in the given array into the hash table ; Traverse the hash in ascending order to print the required number ; Print the number of times a digits occurs ; extracting the first digit ; extracting the last digit ; printing the prime combinations ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int isPrime ( int n ) { int i , c = 0 ; for ( i = 1 ; i < n / 2 ; i ++ ) { if ( n % i == 0 ) c ++ ; } if ( c == 1 ) return 1 ; else return 0 ; } void findMinNum ( int arr [ ] , int n ) { int first = 0 , last = 0 , num , rev , i ; int hash [ 10 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { hash [ arr [ i ] ] ++ ; } cout << \" Minimum ▁ number : ▁ \" ; for ( int i = 0 ; i <= 9 ; i ++ ) { for ( int j = 0 ; j < hash [ i ] ; j ++ ) cout << i ; } cout << endl ; for ( i = 0 ; i <= 9 ; i ++ ) { if ( hash [ i ] != 0 ) { first = i ; break ; } } for ( i = 9 ; i >= 0 ; i -- ) { if ( hash [ i ] != 0 ) { last = i ; break ; } } num = first * 10 + last ; rev = last * 10 + first ; cout << \" Prime ▁ combinations : ▁ \" ; if ( isPrime ( num ) && isPrime ( rev ) ) cout << num << \" ▁ \" << rev ; else if ( isPrime ( num ) ) cout << num ; else if ( isPrime ( rev ) ) cout << rev ; else cout << \" No ▁ combinations ▁ exist \" ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 7 , 8 } ; findMinNum ( arr , 5 ) ; return 0 ; }", "text_ms": "Semak jika digit pertama dan terakhir nombor terkecil membentuk Perdana | C ++ pelaksanaan pendekatan di atas; berfungsi untuk memeriksa perdana; Berfungsi untuk menghasilkan nombor yang paling kecil dengan digit yang diberikan; Mengisytiharkan pelbagai hash saiz 10 dan memulakan semua elemen kepada sifar; Simpan bilangan kejadian digit dalam array yang diberikan ke dalam jadual hash; Melintasi hash dalam urutan menaik untuk mencetak nombor yang diperlukan; Cetak bilangan kali digit berlaku; mengekstrak digit pertama; mengekstrak digit terakhir; mencetak kombinasi utama; Kod pemacu"}
{"text": "Finding a Non Transitive Co | C ++ program to find possible non transitive triplets btw L and R ; Function to return gcd of a and b ; function to check for gcd ; a and b are coprime if their gcd is 1. ; Checks if any possible triplet ( a , b , c ) satisfying the condition that ( a , b ) is coprime , ( b , c ) is coprime but ( a , c ) isnt ; Generate and check for all possible triplets between L and R ; if we find any such triplets set flag to true ; flag = True indicates that a pair exists between L and R ; Driver code ; finding possible Triplet between 2 and 10 ; finding possible Triplet between 23 and 46", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } bool coprime ( int a , int b ) { return ( gcd ( a , b ) == 1 ) ; } void possibleTripletInRange ( int L , int R ) { bool flag = false ; int possibleA , possibleB , possibleC ; for ( int a = L ; a <= R ; a ++ ) { for ( int b = a + 1 ; b <= R ; b ++ ) { for ( int c = b + 1 ; c <= R ; c ++ ) { if ( coprime ( a , b ) && coprime ( b , c ) && ! coprime ( a , c ) ) { flag = true ; possibleA = a ; possibleB = b ; possibleC = c ; break ; } } } } if ( flag == true ) { cout << \" ( \" << possibleA << \" , ▁ \" << possibleB << \" , ▁ \" << possibleC << \" ) \" << \" ▁ is ▁ one ▁ such ▁ possible ▁ triplet ▁ between ▁ \" << L << \" ▁ and ▁ \" << R << \" STRNEWLINE \" ; } else { cout << \" No ▁ Such ▁ Triplet ▁ exists ▁ between ▁ \" << L << \" ▁ and ▁ \" << R << \" STRNEWLINE \" ; } } int main ( ) { int L , R ; L = 2 ; R = 10 ; possibleTripletInRange ( L , R ) ; L = 23 ; R = 46 ; possibleTripletInRange ( L , R ) ; return 0 ; }", "text_ms": "Mencari Co Transitif | Program C ++ untuk mencari kemungkinan triplets bukan transitif btw l dan r; Berfungsi untuk mengembalikan GCD A dan B; berfungsi untuk memeriksa GCD; A dan B adalah coprime jika GCD mereka adalah 1; Memeriksa jika ada triplet yang mungkin (a, b, c) memenuhi syarat bahawa (a, b) adalah coprime, (b, c) adalah coprime tetapi (a, c) isnt; Menjana dan menyemak semua kemungkinan tiga kali ganda antara L dan R; Jika kita dapati apa -apa tiga kali ganda menetapkan bendera kepada benar; Bendera = benar menunjukkan bahawa pasangan wujud antara L dan R; Kod pemacu; mencari triplet yang mungkin antara 2 dan 10; Mencari mungkin triplet antara 23 dan 46"}
{"text": "Reach A and B by multiplying them with K and K ^ 2 at every step | CPP program to determine if A and B can be reached starting from 1 , 1 following the given steps . ; function to check is it is possible to reach A and B starting from 1 and 1 ; find the cuberoot of the number ; divide the number by cuberoot ; if it is a perfect cuberoot and divides a and b ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool possibleToReach ( int a , int b ) { int c = cbrt ( a * b ) ; int re1 = a / c ; int re2 = b / c ; if ( ( re1 * re1 * re2 == a ) && ( re2 * re2 * re1 == b ) ) return true ; else return false ; } int main ( ) { int A = 60 , B = 450 ; if ( possibleToReach ( A , B ) ) cout << \" yes \" ; else cout << \" no \" ; return 0 ; }", "text_ms": "Jangkau A dan B dengan mengalikannya dengan k dan k ^ 2 pada setiap langkah | Program CPP untuk menentukan sama ada A dan B boleh dicapai bermula dari 1, 1 berikutan langkah -langkah yang diberikan. ; Fungsi untuk memeriksa adalah mungkin untuk mencapai A dan B bermula dari 1 dan 1; Cari cuberoot nombor; Bahagikan nombor dengan Cuberoot; Jika ia adalah cuberoot yang sempurna dan membahagikan A dan B; Kod pemacu"}
{"text": "Undulating numbers | C ++ program to check whether a number is undulating or not ; Considering the definition with restriction that there should be at least 3 digits ; Check if all alternate digits are same or not . ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isUndulating ( string n ) { if ( n . length ( ) <= 2 ) return false ; for ( int i = 2 ; i < n . length ( ) ; i ++ ) if ( n [ i - 2 ] != n [ i ] ) false ; return true ; } int main ( ) { string n = \"1212121\" ; if ( isUndulating ( n ) ) cout << \" Yes \" ; else cout << \" No \" ; }", "text_ms": "Nombor bergelora | Program C ++ untuk memeriksa sama ada nombor beralun atau tidak; Memandangkan definisi dengan sekatan bahawa terdapat sekurang -kurangnya 3 digit; Semak sama ada semua digit alternatif adalah sama atau tidak. ; Kod pemacu"}
{"text": "Program to find the sum of a Series ( 1 * 1 ) + ( 2 * 2 ) + ( 3 * 3 ) + ( 4 * 4 ) + ( 5 * 5 ) + ... + ( n * n ) | CPP program to calculate the following series ; Function to calculate the following series ; Driver Code", "code": "#include <iostream> NEW_LINE using namespace std ; int Series ( int n ) { int i ; int sums = 0 ; for ( i = 1 ; i <= n ; i ++ ) sums += ( i * i ) ; return sums ; } int main ( ) { int n = 3 ; int res = Series ( n ) ; cout << res << endl ; }", "text_ms": "Program untuk mencari jumlah siri (1 * 1) + (2 * 2) + (3 * 3) + (4 * 4) + (5 * 5) + ... + (n * n) | Program CPP untuk mengira siri berikut; Fungsi untuk mengira siri berikut; Kod pemacu"}
{"text": "Count numbers with unit digit k in given range | Efficient CPP program to count numbers with last digit as k in given range . ; Returns count of numbers with k as last digit . ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countLastDigitK ( long long low , long long high , long long K ) { long long mlow = 10 * ceil ( low / 10.0 ) ; long long mhigh = 10 * floor ( high / 10.0 ) ; int count = ( mhigh - mlow ) / 10 ; if ( high % 10 >= K ) count ++ ; if ( low % 10 <= K && ( low % 10 ) ) count ++ ; return count ; } int main ( ) { int low = 3 , high = 35 , k = 3 ; cout << countLastDigitK ( low , high , k ) ; return 0 ; }", "text_ms": "Kira nombor dengan unit digit k dalam julat yang diberikan | Program CPP yang cekap untuk mengira nombor dengan digit terakhir sebagai k dalam julat yang diberikan. ; Mengembalikan kiraan nombor dengan k sebagai digit terakhir. ; Kod pemacu"}
{"text": "Sum of all numbers divisible by 6 in a given range | CPP program to find sum of numbers divisible by 6 in a given range . ; function to calculate the sum of all numbers divisible by 6 in range L - R . . ; no of multiples of 6 upto r ; no of multiples of 6 upto l - 1 ; summation of all multiples of 6 upto r ; summation of all multiples of 6 upto l - 1 ; returns the answer ; driver program to test the above function", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int sum ( int L , int R ) { int p = R / 6 ; int q = ( L - 1 ) / 6 ; int sumR = 3 * ( p * ( p + 1 ) ) ; int sumL = ( q * ( q + 1 ) ) * 3 ; return sumR - sumL ; } int main ( ) { int L = 1 , R = 20 ; cout << sum ( L , R ) ; return 0 ; }", "text_ms": "Jumlah semua nombor yang boleh dibahagikan dengan 6 dalam julat yang diberikan | Program CPP untuk mencari jumlah nombor yang boleh dibahagi dengan 6 dalam julat tertentu. ; fungsi untuk mengira jumlah semua nombor yang boleh dibahagi dengan 6 dalam julat l - r. . ; tidak ada gandaan 6 sehingga r; tiada gandaan 6 sehingga l - 1; penjumlahan semua gandaan 6 sehingga r; penjumlahan semua gandaan 6 sehingga l - 1; mengembalikan jawapannya; program pemacu untuk menguji fungsi di atas"}
{"text": "Largest smaller number possible using only one swap operation | C ++ program to find the largest smaller number by swapping one digit . ; Returns largest possible number with one swap such that the number is smaller than str . It is assumed that there are leading 0 s . ; Traverse from right until we find a digit which is greater than its next digit . For example , in 34125 , our index is 4. ; We can also use binary search here as digits after index are sorted in increasing order . Find the biggest digit in the right of arr [ index ] which is smaller than arr [ index ] ; If index is - 1 i . e . digits are in increasing order . ; Swap both values ; Drivers code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string prevNum ( string str ) { int len = str . length ( ) ; int index = -1 ; for ( int i = len - 2 ; i >= 0 ; i -- ) { if ( str [ i ] > str [ i + 1 ] ) { index = i ; break ; } } int smallGreatDgt = -1 ; for ( int i = len - 1 ; i > index ; i -- ) { if ( str [ i ] < str [ index ] ) { if ( smallGreatDgt == -1 ) smallGreatDgt = i ; else if ( str [ i ] >= str [ smallGreatDgt ] ) smallGreatDgt = i ; } } if ( index == -1 ) return \" - 1\" ; if ( smallGreatDgt != -1 ) { swap ( str [ index ] , str [ smallGreatDgt ] ) ; return str ; } return \" - 1\" ; } int main ( ) { string str = \"34125\" ; cout << prevNum ( str ) ; return 0 ; }", "text_ms": "Nombor yang lebih kecil yang terbesar mungkin menggunakan hanya satu operasi swap | Program C ++ untuk mencari nombor yang lebih kecil terbesar dengan menukar satu digit. ; Mengembalikan nombor yang mungkin terbesar dengan satu swap supaya nombor itu lebih kecil daripada STR. Dianggap bahawa terdapat 0 s. ; Traverse dari kanan sehingga kita dapati digit yang lebih besar daripada digit seterusnya. Sebagai contoh, dalam 34125, indeks kami ialah 4 .; Kami juga boleh menggunakan carian binari di sini sebagai digit selepas indeks disusun dalam peningkatan urutan. Cari digit terbesar di sebelah kanan ARR [indeks] yang lebih kecil daripada ARR [indeks]; Jika indeks adalah - 1 i. e. Digit adalah dalam urutan yang semakin meningkat. ; Menukar kedua -dua nilai; Kod pemandu"}
{"text": "Sgn value of a polynomial | CPP program to find sign value of a polynomial ; returns value of poly [ 0 ] x ( n - 1 ) + poly [ 1 ] x ( n - 2 ) + . . + poly [ n - 1 ] ; Evaluate value of polynomial using Horner 's method ; Returns sign value of polynomial ; Driver program to test above function . ; Let us evaluate value of 2 x3 - 6 x2 + 2 x - 1 for x = 3", "code": "#include <iostream> NEW_LINE using namespace std ; int horner ( int poly [ ] , int n , int x ) { for ( int i = 1 ; i < n ; i ++ ) result = result * x + poly [ i ] ; return result ; } int findSign ( int poly [ ] , int n , int x ) { int result = horner ( poly , n , x ) ; if ( result > 0 ) return 1 ; else if ( result < 0 ) return -1 ; return 0 ; } int main ( ) { int poly [ ] = { 2 , -6 , 2 , -1 } ; int x = 3 ; int n = sizeof ( poly ) / sizeof ( poly [ 0 ] ) ; cout << \" Sign ▁ of ▁ polynomial ▁ is ▁ \" << findSign ( poly , n , x ) ; return 0 ; }", "text_ms": "SGN Nilai polinomial | Program CPP untuk mencari nilai tanda polinomial; Pulangan nilai poli [0] x (n - 1) + poli [1] x (n - 2) +. . + poli [n - 1]; Menilai nilai polinomial menggunakan kaedah Horner; Mengembalikan nilai tanda polinomial; Program pemacu untuk menguji fungsi di atas. ; Marilah kita menilai nilai 2 x3 - 6 x2 + 2 x - 1 untuk x = 3"}
{"text": "Insert minimum number in array so that sum of array becomes prime | C ++ program to find minimum number to insert in array so their sum is prime ; Array to store primes ; function to calculate primes using sieve of eratosthenes ; Find prime number greater than a number ; To return prime number greater than n ; check if num is prime ; increment num ; To find number to be added so sum of array is prime ; call sieveOfEratostheneses to calculate primes ; To find sum of array elements ; To find prime number greater then sum ; Return difference of sum and num ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100005 NEW_LINE bool isPrime [ MAX ] ; void sieveOfEratostheneses ( ) { memset ( isPrime , true , sizeof ( isPrime ) ) ; isPrime [ 1 ] = false ; for ( int i = 2 ; i * i < MAX ; i ++ ) { if ( isPrime [ i ] ) { for ( int j = 2 * i ; j < MAX ; j += i ) isPrime [ j ] = false ; } } } int findPrime ( int n ) { int num = n + 1 ; while ( num ) { if ( isPrime [ num ] ) return num ; num = num + 1 ; } return 0 ; } int minNumber ( int arr [ ] , int n ) { sieveOfEratostheneses ( ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( isPrime [ sum ] ) return 0 ; int num = findPrime ( sum ) ; return num - sum ; } int main ( ) { int arr [ ] = { 2 , 4 , 6 , 8 , 12 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minNumber ( arr , n ) ; return 0 ; }", "text_ms": "Masukkan nombor minimum dalam array supaya jumlah array menjadi perdana | Program C ++ untuk mencari nombor minimum untuk memasukkan dalam array supaya jumlahnya adalah perdana; Array untuk menyimpan prima; berfungsi untuk mengira prima menggunakan ayak eratosthenes; Cari nombor perdana lebih besar daripada nombor; Untuk mengembalikan nombor perdana lebih besar daripada n; Semak jika Num adalah Perdana; kenaikan num; Untuk mencari nombor yang akan ditambah sehingga jumlah array adalah perdana; Panggil Sieveoferatostheneses untuk mengira prima; Untuk mencari jumlah elemen array; Untuk mencari nombor perdana yang lebih besar maka jumlahnya; Mengembalikan perbezaan jumlah dan num; Kod pemacu"}
{"text": "Sum of all Subarrays | Set 1 | Simple C ++ program to compute sum of subarray elements ; Computes sum all sub - array ; Pick starting point ; Pick ending point ; sum subarray between current starting and ending points ; driver program to test above function", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long int SubArraySum ( int arr [ ] , int n ) { long int result = 0 , temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { temp = 0 ; for ( int j = i ; j < n ; j ++ ) { temp += arr [ j ] ; result += temp ; } } return result ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << \" Sum ▁ of ▁ SubArray ▁ : ▁ \" << SubArraySum ( arr , n ) << endl ; return 0 ; }", "text_ms": "Jumlah semua subarray | Tetapkan 1 | Program C ++ mudah untuk mengira jumlah elemen subarray; Mengira jumlah semua sub - array; Pilih titik permulaan; Memilih titik akhir; jumlah subarray antara titik permulaan dan akhir semasa; program pemacu untuk menguji fungsi di atas"}
{"text": "Highest power of 2 less than or equal to given number | C ++ program to find highest power of 2 smaller than or equal to n . ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int highestPowerof2 ( int n ) { int p = ( int ) log2 ( n ) ; return ( int ) pow ( 2 , p ) ; } int main ( ) { int n = 10 ; cout << highestPowerof2 ( n ) ; return 0 ; }", "text_ms": "Kuasa tertinggi 2 kurang daripada atau sama dengan nombor yang diberikan | Program C ++ untuk mencari kuasa tertinggi 2 lebih kecil daripada atau sama dengan n. ; Kod pemacu"}
{"text": "Rearrange characters in a string such that no two adjacent are same | C ++ program to rearrange characters in a string so that no two adjacent characters are same . ; store frequency of character ; function for priority_queue to store Key according to freq ; Function to rearrange character of a string so that no char repeat twice ; Store frequencies of all characters in string ; Insert all characters with their frequencies into a priority_queue ; ' str ' that will store resultant value ; work as the previous visited element initial previous element be . ( ' # ' and it ' s ▁ frequency ▁ ' - 1 ' ) ; traverse queue ; pop top element from queue and add it to string . ; IF frequency of previous character is less than zero that means it is useless , we need not to push it ; make current character as the previous ' char ' decrease frequency by ' one ' ; If length of the resultant string and original string is not same then string is not valid ; valid string ; Driver program to test above function", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHAR = 26 ; struct Key { int freq ; char ch ; bool operator< ( const Key & k ) const { return freq < k . freq ; } } ; void rearrangeString ( string str ) { int n = str . length ( ) ; int count [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) count [ str [ i ] - ' a ' ] ++ ; priority_queue < Key > pq ; for ( char c = ' a ' ; c <= ' z ' ; c ++ ) { int val = c - ' a ' ; if ( count [ val ] ) { pq . push ( Key { count [ val ] , c } ) ; } } str = \" \" ; Key prev { -1 , ' # ' } ; while ( ! pq . empty ( ) ) { Key k = pq . top ( ) ; pq . pop ( ) ; str = str + k . ch ; if ( prev . freq > 0 ) pq . push ( prev ) ; ( k . freq ) -- ; prev = k ; } if ( n != str . length ( ) ) cout << \" ▁ Not ▁ valid ▁ String ▁ \" << endl ; else cout << str << endl ; } int main ( ) { string str = \" bbbaa \" ; rearrangeString ( str ) ; return 0 ; }", "text_ms": "Susun semula aksara dalam rentetan supaya tidak dua bersebelahan adalah sama | Program C ++ untuk menyusun semula aksara dalam rentetan supaya tidak ada dua aksara bersebelahan yang sama. ; frekuensi penyimpanan watak; fungsi untuk keutamaan_queue untuk menyimpan kunci mengikut freq; Berfungsi untuk menyusun semula watak rentetan supaya tiada char mengulangi dua kali; Simpan frekuensi semua aksara dalam rentetan; Masukkan semua aksara dengan frekuensi mereka ke Priority_Queue; 'str' yang akan menyimpan nilai yang dihasilkan; Bekerja sebagai elemen awal yang dilawati sebelum ini. (' #' dan frekuensi ' - 1'); Giliran Traverse; Pop atas elemen dari barisan dan tambahkannya ke rentetan. ; Jika kekerapan watak sebelumnya kurang daripada sifar yang bermaksud ia tidak berguna, kita tidak perlu menolaknya; Buat watak semasa sebagai kekerapan 'char' yang terdahulu oleh 'satu'; Jika panjang rentetan yang dihasilkan dan rentetan asal tidak sama maka rentetan tidak sah; rentetan sah; Program pemacu untuk menguji fungsi di atas"}
{"text": "Find ( a ^ b ) % m where ' a ' is very large | C ++ program to find ( a ^ b ) mod m for a large ' a ' ; utility function to calculate a % m ; ( s [ i ] - '0' ) gives the digit value and form the number ; Returns find ( a ^ b ) % m ; Find a % m ; now multiply ans by b - 1 times and take mod with m ; Driver program to run the case", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned int aModM ( string s , unsigned int mod ) { unsigned int number = 0 ; for ( unsigned int i = 0 ; i < s . length ( ) ; i ++ ) { number = ( number * 10 + ( s [ i ] - '0' ) ) ; number %= mod ; } return number ; } unsigned int ApowBmodM ( string & a , unsigned int b , unsigned int m ) { unsigned int ans = aModM ( a , m ) ; unsigned int mul = ans ; for ( unsigned int i = 1 ; i < b ; i ++ ) ans = ( ans * mul ) % m ; return ans ; } int main ( ) { string a = \"987584345091051645734583954832576\" ; unsigned int b = 3 , m = 11 ; cout << ApowBmodM ( a , b , m ) ; return 0 ; }", "text_ms": "Cari (a ^ b) % m di mana 'a' sangat besar | Program C ++ untuk mencari (a ^ b) mod m untuk 'a' yang besar; fungsi utiliti untuk mengira % m; (S [i] - '0') memberikan nilai digit dan membentuk nombor; Pulangan mencari (a ^ b) % m; Cari % m; Sekarang kalikan Ans dengan b - 1 kali dan ambil mod dengan m; Program pemacu untuk menjalankan kes itu"}
{"text": "Lagrange 's Interpolation | C ++ program for implementation of Lagrange 's Interpolation ; To represent a data point corresponding to x and y = f ( x ) ; function to interpolate the given data points using Lagrange 's formula xi corresponds to the new data point whose value is to be obtained n represents the number of known data points ; double result = 0 ; Initialize result ; Compute individual terms of above formula ; Add current term to result ; driver function to check the program ; creating an array of 4 known data points ; Using the interpolate function to obtain a data point corresponding to x = 3", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Data { int x , y ; } ; double interpolate ( Data f [ ] , int xi , int n ) { for ( int i = 0 ; i < n ; i ++ ) { double term = f [ i ] . y ; for ( int j = 0 ; j < n ; j ++ ) { if ( j != i ) term = term * ( xi - f [ j ] . x ) / double ( f [ i ] . x - f [ j ] . x ) ; } result += term ; } return result ; } int main ( ) { Data f [ ] = { { 0 , 2 } , { 1 , 3 } , { 2 , 12 } , { 5 , 147 } } ; cout << \" Value ▁ of ▁ f ( 3 ) ▁ is ▁ : ▁ \" << interpolate ( f , 3 , 5 ) ; return 0 ; }", "text_ms": "Interpolasi LaGrange | Program C ++ untuk pelaksanaan interpolasi LaGrange; Untuk mewakili titik data yang sepadan dengan x dan y = f (x); Fungsi untuk menginterpolasi titik data yang diberikan menggunakan Formula XI LaGrange sepadan dengan titik data baru yang nilainya diperoleh n mewakili bilangan titik data yang diketahui; hasil berganda = 0; Memulakan hasil; Mengira syarat individu di atas formula; Tambah istilah semasa untuk menghasilkan; fungsi pemacu untuk menyemak program; mewujudkan pelbagai 4 mata data yang diketahui; Menggunakan fungsi interpolasi untuk mendapatkan titik data yang sepadan dengan x = 3"}
{"text": "Sieve of Sundaram to print all primes smaller than n | C ++ program to print primes smaller than n using Sieve of Sundaram . ; Prints all prime numbers smaller ; In general Sieve of Sundaram , produces primes smaller than ( 2 * x + 2 ) for a number given number x . Since we want primes smaller than n , we reduce n to half ; This array is used to separate numbers of the form i + j + 2 ij from others where 1 <= i <= j ; Initialize all elements as not marked ; Main logic of Sundaram . Mark all numbers of the form i + j + 2 ij as true where 1 <= i <= j ; Since 2 is a prime number ; Print other primes . Remaining primes are of the form 2 * i + 1 such that marked [ i ] is false . ; Driver program to test above", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int SieveOfSundaram ( int n ) { int nNew = ( n - 1 ) / 2 ; bool marked [ nNew + 1 ] ; memset ( marked , false , sizeof ( marked ) ) ; for ( int i = 1 ; i <= nNew ; i ++ ) for ( int j = i ; ( i + j + 2 * i * j ) <= nNew ; j ++ ) marked [ i + j + 2 * i * j ] = true ; if ( n > 2 ) cout << 2 << \" ▁ \" ; for ( int i = 1 ; i <= nNew ; i ++ ) if ( marked [ i ] == false ) cout << 2 * i + 1 << \" ▁ \" ; } int main ( void ) { int n = 20 ; SieveOfSundaram ( n ) ; return 0 ; }", "text_ms": "Sieve of Sundaram untuk mencetak semua prima yang lebih kecil daripada n | Program C ++ untuk mencetak prima yang lebih kecil daripada N menggunakan ayak Sundaram. ; Mencetak semua nombor perdana yang lebih kecil; Secara umum Sundaram, menghasilkan prima yang lebih kecil daripada (2 * x + 2) untuk nombor yang diberikan nombor x. Oleh kerana kita mahu prima lebih kecil daripada N, kita mengurangkan N hingga separuh; Arahan ini digunakan untuk memisahkan nombor bentuk i + j + 2 ij dari orang lain di mana 1 <= i <= j; Memulakan semua elemen sebagai tidak ditandakan; Logik utama Sundaram. Tandakan semua nombor bentuk i + j + 2 ij sebagai benar di mana 1 <= i <= j; Oleh kerana 2 adalah nombor perdana; Cetak prima yang lain. Prima yang tersisa adalah bentuk 2 * i + 1 seperti yang ditandakan [i] adalah palsu. ; Program Pemandu untuk diuji di atas"}
{"text": "Construct original array starting with K from an array of XOR of all elements except elements at same index | C ++ program for the above approach ; Function to construct an array with each element equal to XOR of all array elements except the element at the same index ; Original array ; Stores Bitwise XOR of array ; Calculate XOR of all array elements ; Print the original array B [ ] ; Driver Code ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void constructArray ( int A [ ] , int N , int K ) { int B [ N ] ; int totalXOR = A [ 0 ] ^ K ; for ( int i = 0 ; i < N ; i ++ ) B [ i ] = totalXOR ^ A [ i ] ; for ( int i = 0 ; i < N ; i ++ ) { cout << B [ i ] << \" ▁ \" ; } } int main ( ) { int A [ ] = { 13 , 14 , 10 , 6 } , K = 2 ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; constructArray ( A , N , K ) ; return 0 ; }", "text_ms": "Bina Arahan Asal Bermula dengan K dari pelbagai xor semua elemen kecuali elemen pada indeks yang sama | Program C ++ untuk pendekatan di atas; Berfungsi untuk membina array dengan setiap elemen yang sama dengan XOR semua elemen array kecuali elemen pada indeks yang sama; Array asal; Kedai bitwise xor array; Hitung XOR semua elemen array; Cetak array asal B []; Kod pemacu; Panggilan fungsi"}
{"text": "Find extra element in the second array | C ++ implementation of the approach ; Function to return the extra element in B [ ] ; To store the result ; Find the XOR of all the element of array A [ ] and array B [ ] ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int extraElement ( int A [ ] , int B [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans ^= A [ i ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) ans ^= B [ i ] ; return ans ; } int main ( ) { int A [ ] = { 10 , 15 , 5 } ; int B [ ] = { 10 , 100 , 15 , 5 } ; int n = sizeof ( A ) / sizeof ( int ) ; cout << extraElement ( A , B , n ) ; return 0 ; }", "text_ms": "Cari elemen tambahan dalam array kedua | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan elemen tambahan dalam b []; Untuk menyimpan hasilnya; Cari xor semua elemen array a [] dan array b []; Kod pemacu"}
{"text": "Hamming distance between two Integers | C ++ implementation of above approach ; Function to calculate hamming distance ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int hammingDistance ( int n1 , int n2 ) { int x = n1 ^ n2 ; int setBits = 0 ; while ( x > 0 ) { setBits += x & 1 ; x >>= 1 ; } return setBits ; } int main ( ) { int n1 = 9 , n2 = 14 ; cout << hammingDistance ( 9 , 14 ) << endl ; return 0 ; }", "text_ms": "Hamming jarak antara dua bilangan bulat | C ++ pelaksanaan pendekatan di atas; Fungsi untuk mengira jarak Hamming; Kod pemacu"}
{"text": "Print bitwise AND set of a number N | CPP program to print all bitwise subsets of N ( Naive approach ) ; function to find bitwise subsets Naive approach ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printSubsets ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) if ( ( n & i ) == i ) cout << i << \" ▁ \" ; } int main ( ) { int n = 9 ; printSubsets ( n ) ; return 0 ; }", "text_ms": "Cetak bitwise dan set nombor n | Program CPP untuk mencetak semua subset bitwise N (pendekatan naif); berfungsi untuk mencari pendekatan naif subset bitwise; Kod pemacu"}
{"text": "Find most significant set bit of a number | CPP program to find MSB number for given n . ; To find the position of the most significant set bit ; To return the the value of the number with set bit at k - th position ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int setBitNumber ( int n ) { int k = ( int ) ( log2 ( n ) ) ; return 1 << k ; } int main ( ) { int n = 273 ; cout << setBitNumber ( n ) ; return 0 ; }", "text_ms": "Cari bit set yang paling ketara | Program CPP untuk mencari nombor MSB untuk diberikan n. ; Untuk mencari kedudukan bit set yang paling penting; Untuk mengembalikan nilai nombor dengan set bit pada kedudukan k - th; Kod pemacu"}
{"text": "Minimum number of subsets with distinct elements | A sorting based solution to find the minimum number of subsets of a set such that every subset contains distinct elements . ; Function to count subsets such that all subsets have distinct elements . ; Take input and initialize res = 0 ; Sort the array ; Traverse the input array and find maximum frequency ; For each number find its repetition / frequency ; Update res ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int subset ( int ar [ ] , int n ) { int res = 0 ; sort ( ar , ar + n ) ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; for ( ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) count ++ ; else break ; } res = max ( res , count ) ; } return res ; } int main ( ) { int arr [ ] = { 5 , 6 , 9 , 3 , 4 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << subset ( arr , n ) ; return 0 ; }", "text_ms": "Bilangan minimum subset dengan elemen yang berbeza | Penyelesaian berasaskan penyortiran untuk mencari bilangan minimum subset set supaya setiap subset mengandungi unsur -unsur yang berbeza. ; Fungsi untuk mengira subset sedemikian rupa sehingga semua subset mempunyai elemen yang berbeza. ; Ambil input dan mulakan res = 0; Susun array; Melintasi array input dan cari kekerapan maksimum; Untuk setiap nombor mencari pengulangan / kekerapannya; Kemas kini res; Kod pemacu"}
{"text": "Minimum number of subsets with distinct elements | A hashing based solution to find the minimum number of subsets of a set such that every subset contains distinct elements . ; Function to count subsets such that all subsets have distinct elements . ; Traverse the input array and store frequencies of elements ; Find the maximum value in map . ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int subset ( int arr [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ arr [ i ] ] ++ ; int res = 0 ; for ( auto x : mp ) res = max ( res , x . second ) ; return res ; } int main ( ) { int arr [ ] = { 5 , 6 , 9 , 3 , 4 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << subset ( arr , n ) ; return 0 ; }", "text_ms": "Bilangan minimum subset dengan elemen yang berbeza | Penyelesaian berasaskan hash untuk mencari bilangan minimum subset set supaya setiap subset mengandungi unsur -unsur yang berbeza. ; Fungsi untuk mengira subset sedemikian rupa sehingga semua subset mempunyai elemen yang berbeza. ; Melintasi array input dan frekuensi elemen; Cari nilai maksimum dalam peta. ; Kod pemacu"}
{"text": "Count ways to represent a number as sum of perfect squares | C ++ program for the above approach ; Store perfect squares less than or equal to N ; Utility function to calculate perfect squares less than or equal to N ; Function to find the number of ways to represent a number as sum of perfect squares ; Handle the base cases ; Include the i - th index element ; Exclude the i - th index element ; Return the result ; Driver Code ; Given Input ; Precalculate perfect squares <= N ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > psquare ; void calcPsquare ( int N ) { for ( int i = 1 ; i * i <= N ; i ++ ) psquare . push_back ( i * i ) ; } int countWays ( int index , int target ) { if ( target == 0 ) return 1 ; if ( index < 0 target < 0 ) return 0 ; int inc = countWays ( index , target - psquare [ index ] ) ; int exc = countWays ( index - 1 , target ) ; return inc + exc ; } int main ( ) { int N = 9 ; calcPsquare ( N ) ; cout << countWays ( psquare . size ( ) - 1 , N ) ; return 0 ; }", "text_ms": "Kira cara untuk mewakili nombor sebagai jumlah kotak yang sempurna | Program C ++ untuk pendekatan di atas; Simpan kotak sempurna kurang daripada atau sama dengan n; Fungsi utiliti untuk mengira dataran sempurna kurang daripada atau sama dengan n; Berfungsi untuk mencari bilangan cara untuk mewakili nombor sebagai jumlah kuadrat yang sempurna; Mengendalikan kes asas; Sertakan elemen indeks I - th; Tidak termasuk elemen indeks i - th; Mengembalikan hasilnya; Kod pemacu; Diberikan input; Precomment squares sempurna <= n; Panggilan fungsi"}
{"text": "Sum of distances of all nodes from a given node | C ++ program for the above approach ; Structure of a binary tree node ; Function that allocates a new node with the given data and NULL to its left and right pointers ; Return newly created node ; Function to count the number of nodes in the left and right subtrees ; Initialize a pair that stores the pair { number of nodes , depth } ; Finding the number of nodes in the left subtree ; Find the number of nodes in the right subtree ; Filling up size field ; Stores the sum of distances of all nodes from the given node ; Function to find the total distance ; If target node matches with the current node ; If root -> left is not null ; Update sum ; Recur for the left subtree ; If root -> right is not null ; Apply the formula given in the approach ; Recur for the right subtree ; Driver Code ; Input tree ; Total number of nodes ; Print the sum of distances", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; class TreeNode { public : int data , size ; TreeNode * left ; TreeNode * right ; } ; TreeNode * newNode ( int data ) { TreeNode * Node = new TreeNode ( ) ; Node -> data = data ; Node -> left = NULL ; Node -> right = NULL ; return ( Node ) ; } pair < int , int > sumofsubtree ( TreeNode * root ) { pair < int , int > p = make_pair ( 1 , 0 ) ; if ( root -> left ) { pair < int , int > ptemp = sumofsubtree ( root -> left ) ; p . second += ptemp . first + ptemp . second ; p . first += ptemp . first ; } if ( root -> right ) { pair < int , int > ptemp = sumofsubtree ( root -> right ) ; p . second += ptemp . first + ptemp . second ; p . first += ptemp . first ; } root -> size = p . first ; return p ; } int sum = 0 ; void distance ( TreeNode * root , int target , int distancesum , int n ) { if ( root -> data == target ) { sum = distancesum ; } if ( root -> left ) { int tempsum = distancesum - root -> left -> size + ( n - root -> left -> size ) ; distance ( root -> left , target , tempsum , n ) ; } if ( root -> right ) { int tempsum = distancesum - root -> right -> size + ( n - root -> right -> size ) ; distance ( root -> right , target , tempsum , n ) ; } } int main ( ) { TreeNode * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; root -> left -> left -> left = newNode ( 8 ) ; root -> left -> left -> right = newNode ( 9 ) ; int target = 3 ; pair < int , int > p = sumofsubtree ( root ) ; int totalnodes = p . first ; distance ( root , target , p . second , totalnodes ) ; cout << sum << endl ; return 0 ; }", "text_ms": "Jumlah jarak semua nod dari nod yang diberikan | Program C ++ untuk pendekatan di atas; Struktur nod pokok binari; Fungsi yang memperuntukkan nod baru dengan data yang diberikan dan batal ke petunjuk kiri dan kanannya; Kembali nod yang baru dibuat; Berfungsi untuk mengira bilangan nod di subtrees kiri dan kanan; Memulakan pasangan yang menyimpan pasangan {bilangan nod, kedalaman}; Mencari bilangan nod di subtree kiri; Cari bilangan nod di subtree yang betul; Mengisi medan saiz; Menyimpan jumlah jarak semua nod dari nod yang diberikan; Berfungsi untuk mencari jarak keseluruhan; Jika nod sasaran sepadan dengan nod semasa; Jika akar -> kiri tidak batal; Kemas kini Jumlah; Berulang untuk subtree kiri; Jika akar -> betul tidak batal; Memohon formula yang diberikan dalam pendekatan; Berulang untuk subtree yang betul; Kod pemacu; Pokok input; Jumlah nod; Cetak jumlah jarak"}
{"text": "Rearrange array such that sum of same indexed elements is atmost K | C ++ program for the above approach ; Function to rearrange array such that sum of similar indexed elements does not exceed K ; Sort the array B [ ] in descending order ; If condition fails ; Print the array ; Driver Code ; Given arrays", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void rearrangeArray ( int A [ ] , int B [ ] , int N , int K ) { sort ( B , B + N , greater < int > ( ) ) ; bool flag = true ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] + B [ i ] > K ) { flag = false ; break ; } } if ( ! flag ) { cout << \" - 1\" << endl ; } else { for ( int i = 0 ; i < N ; i ++ ) { cout << B [ i ] << \" ▁ \" ; } } } int main ( ) { int A [ ] = { 1 , 2 , 3 , 4 , 2 } ; int B [ ] = { 1 , 2 , 3 , 1 , 1 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int K = 5 ; rearrangeArray ( A , B , N , K ) ; return 0 ; }", "text_ms": "Menyusun semula array sedemikian rupa sehingga jumlah elemen yang diindeks yang sama adalah atmost k | Program C ++ untuk pendekatan di atas; Fungsi untuk menyusun semula array sedemikian rupa sehingga jumlah unsur -unsur yang diindeks yang sama tidak melebihi k; Susun array b [] dalam urutan menurun; Jika keadaan gagal; Cetak array; Kod pemacu; Diberikan susunan"}
{"text": "Count rows with sum exceeding sum of the remaining Matrix | C ++ program to implement the above approach ; Function to count the number of rows whose sum exceeds the sum of elements of the remaining matrix ; To store the result ; Stores the total sum of the matrix elements ; Calculate the total sum ; Traverse to check for each row ; Stores the sum of elements of the current row ; Calculate the sum of elements of the current row ; If sum of current row exceeds the sum of rest of the matrix ; Increase count ; Print the result ; Driver Code ; Given matrix ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  3 NEW_LINE #define M  3 NEW_LINE void countRows ( int mat [ M ] [ N ] ) { int count = 0 ; int totalSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { totalSum += mat [ i ] [ j ] ; } } for ( int i = 0 ; i < N ; i ++ ) { int currSum = 0 ; for ( int j = 0 ; j < M ; j ++ ) { currSum += mat [ i ] [ j ] ; } if ( currSum > totalSum - currSum ) count ++ ; } cout << count ; } int main ( ) { int mat [ N ] [ M ] = { { 2 , -1 , 5 } , { -3 , 0 , -2 } , { 5 , 1 , 2 } } ; countRows ( mat ) ; }", "text_ms": "Kira baris dengan jumlah melebihi jumlah matriks yang tinggal | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mengira bilangan baris yang jumlahnya melebihi jumlah unsur -unsur matriks yang tinggal; Untuk menyimpan hasilnya; Menyimpan jumlah keseluruhan unsur matriks; Kirakan jumlah keseluruhan; Melintasi untuk memeriksa setiap baris; Menyimpan jumlah elemen baris semasa; Kirakan jumlah elemen baris semasa; Jika jumlah baris semasa melebihi jumlah sisa matriks; Peningkatan kiraan; Cetak hasilnya; Kod pemacu; Diberikan matriks; Panggilan fungsi"}
{"text": "Check if array contains contiguous integers with duplicates allowed | C ++ implementation to check whether the array contains a set of contiguous integers ; function to check whether the array contains a set of contiguous integers ; Find maximum and minimum elements . ; There should be at least m elements in array to make them contiguous . ; Create a visited array and initialize false . ; Mark elements as true . ; If any element is not marked , all elements are not contiguous . ; Driver program", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool areElementsContiguous ( int arr [ ] , int n ) { int max = * max_element ( arr , arr + n ) ; int min = * min_element ( arr , arr + n ) ; int m = max - min + 1 ; if ( m > n ) return false ; bool visited [ m ] ; memset ( visited , false , sizeof ( visited ) ) ; for ( int i = 0 ; i < n ; i ++ ) visited [ arr [ i ] - min ] = true ; for ( int i = 0 ; i < m ; i ++ ) if ( visited [ i ] == false ) return false ; return true ; } int main ( ) { int arr [ ] = { 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( areElementsContiguous ( arr , n ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "text_ms": "Semak jika array mengandungi bilangan bulat bersebelahan dengan pendua yang dibenarkan | C ++ pelaksanaan untuk memeriksa sama ada array mengandungi satu set bilangan bulat bersebelahan; berfungsi untuk memeriksa sama ada array mengandungi satu set bilangan bulat bersebelahan; Cari elemen maksimum dan minimum. ; Harus ada sekurang -kurangnya elemen dalam pelbagai untuk menjadikannya bersebelahan. ; Buat array yang dikunjungi dan mulakan palsu. ; Tandakan elemen sebagai benar. ; Jika mana -mana elemen tidak ditandakan, semua elemen tidak bersebelahan. ; Program Pemandu"}
{"text": "Check if array contains contiguous integers with duplicates allowed | C ++ implementation to check whether the array contains a set of contiguous integers ; Function to check whether the array contains a set of contiguous integers ; Storing elements of ' arr [ ] ' in a hash table ' us ' ; as arr [ 0 ] is present in ' us ' ; starting with previous smaller element of arr [ 0 ] ; if ' curr _ ele ' is present in ' us ' ; increment count ; update 'curr_ele\" ; starting with next greater element of arr [ 0 ] ; if ' curr _ ele ' is present in ' us ' ; increment count ; update 'curr_ele\" ; returns true if array contains a set of contiguous integers else returns false ; Driver program to test above", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool areElementsContiguous ( int arr [ ] , int n ) { unordered_set < int > us ; for ( int i = 0 ; i < n ; i ++ ) us . insert ( arr [ i ] ) ; int count = 1 ; int curr_ele = arr [ 0 ] - 1 ; while ( us . find ( curr_ele ) != us . end ( ) ) { count ++ ; curr_ele -- ; } curr_ele = arr [ 0 ] + 1 ; while ( us . find ( curr_ele ) != us . end ( ) ) { count ++ ; curr_ele ++ ; } return ( count == ( int ) ( us . size ( ) ) ) ; } int main ( ) { int arr [ ] = { 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( areElementsContiguous ( arr , n ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "text_ms": "Semak jika array mengandungi bilangan bulat bersebelahan dengan pendua yang dibenarkan | C ++ pelaksanaan untuk memeriksa sama ada array mengandungi satu set bilangan bulat bersebelahan; Berfungsi untuk memeriksa sama ada array mengandungi satu set bilangan bulat bersebelahan; Menyimpan unsur -unsur 'arr []' dalam jadual hash 'kami'; sebagai Arr [0] hadir dalam 'kami'; Bermula dengan elemen yang lebih kecil sebelumnya ARR [0]; jika 'curr _ ele' hadir dalam 'kami'; kiraan kenaikan; mengemas kini 'curr_ele'; bermula dengan elemen yang lebih besar dari arr [0]; jika 'curr _ ele' hadir dalam 'us'; kiraan kenaikan; kemas kini 'curr_ele \"; pulangan benar jika array mengandungi satu set bilangan bulat bersebelahan lain kembali palsu; Program Pemandu untuk diuji di atas"}
{"text": "Longest subarray not having more than K distinct elements | CPP program to find longest subarray with k or less distinct elements . ; function to print the longest sub - array ; mark the element visited ; if its visited first time , then increase the counter of distinct elements by 1 ; When the counter of distinct elements increases from k , then reduce it to k ; from the left , reduce the number of time of visit ; if the reduced visited time element is not present in further segment then decrease the count of distinct elements ; increase the subsegment mark ; check length of longest sub - segment when greater then previous best then change it ; print the longest sub - segment ; driver program to test the above function", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void longest ( int a [ ] , int n , int k ) { unordered_map < int , int > freq ; int start = 0 , end = 0 , now = 0 , l = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ a [ i ] ] ++ ; if ( freq [ a [ i ] ] == 1 ) now ++ ; while ( now > k ) { freq [ a [ l ] ] -- ; if ( freq [ a [ l ] ] == 0 ) now -- ; l ++ ; } if ( i - l + 1 >= end - start + 1 ) end = i , start = l ; } for ( int i = start ; i <= end ; i ++ ) cout << a [ i ] << \" ▁ \" ; } int main ( ) { int a [ ] = { 6 , 5 , 1 , 2 , 3 , 2 , 1 , 4 , 5 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int k = 3 ; longest ( a , n , k ) ; return 0 ; }", "text_ms": "Subarray terpanjang tidak mempunyai lebih banyak daripada elemen yang berbeza | Program CPP untuk mencari subarray terpanjang dengan K atau kurang elemen yang berbeza. ; berfungsi untuk mencetak pelbagai sub - paling lama; Tandakan elemen yang dikunjungi; Jika ia dikunjungi kali pertama, maka tingkatkan kaunter unsur -unsur yang berbeza dengan 1; Apabila kaunter unsur -unsur yang berbeza meningkat dari k, kemudian mengurangkannya kepada k; Dari sebelah kiri, mengurangkan bilangan masa lawatan; Sekiranya elemen masa yang dikurangkan tidak terdapat dalam segmen selanjutnya maka mengurangkan kiraan unsur -unsur yang berbeza; meningkatkan tanda subsegment; Semak panjang sub -segmen terpanjang apabila lebih besar kemudian sebelum ini kemudian tukarnya; Cetak segmen sub - terpanjang; program pemacu untuk menguji fungsi di atas"}
{"text": "Check if any K ranges overlap at any point | C ++ implementation of the approach ; Comparator to sort the vector of pairs ; Function that returns true if any k segments overlap at any point ; Starting points are marked by - 1 and ending points by + 1 ; Sort the vector by first element ; Stack to store the overlaps ; Get the current element ; If it is the starting point ; Push it in the stack ; It is the ending point ; Pop an element from stack ; If more than k ranges overlap ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool sortby ( const pair < int , int > & a , const pair < int , int > & b ) { if ( a . first != b . first ) return a . first < b . first ; return ( a . second < b . second ) ; } bool kOverlap ( vector < pair < int , int > > pairs , int k ) { vector < pair < int , int > > vec ; for ( int i = 0 ; i < pairs . size ( ) ; i ++ ) { vec . push_back ( { pairs [ i ] . first , -1 } ) ; vec . push_back ( { pairs [ i ] . second , +1 } ) ; } sort ( vec . begin ( ) , vec . end ( ) ) ; stack < pair < int , int > > st ; for ( int i = 0 ; i < vec . size ( ) ; i ++ ) { pair < int , int > cur = vec [ i ] ; if ( cur . second == -1 ) { st . push ( cur ) ; } else { st . pop ( ) ; } if ( st . size ( ) >= k ) { return true ; } } return false ; } int main ( ) { vector < pair < int , int > > pairs ; pairs . push_back ( make_pair ( 1 , 3 ) ) ; pairs . push_back ( make_pair ( 2 , 4 ) ) ; pairs . push_back ( make_pair ( 3 , 5 ) ) ; pairs . push_back ( make_pair ( 7 , 10 ) ) ; int n = pairs . size ( ) , k = 3 ; if ( kOverlap ( pairs , k ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "text_ms": "Periksa sama ada Kira K dalam mana -mana Titik | C ++ pelaksanaan pendekatan; Komparator untuk menyusun vektor pasangan; Fungsi yang mengembalikan benar jika mana -mana segmen K bertindih pada bila -bila masa; Titik permulaan ditandakan dengan - 1 dan titik berakhir dengan + 1; Susun vektor dengan elemen pertama; Tumpukan untuk menyimpan tumpang tindih; Dapatkan elemen semasa; Jika ia adalah titik permulaan; Tolaknya dalam timbunan; Ia adalah titik akhir; Pop elemen dari timbunan; Jika lebih daripada K -ranges bertindih; Kod pemacu"}
{"text": "Find smallest range containing elements from k lists | C ++ program to finds out smallest range that includes elements from each of the given sorted lists . ; array for storing the current index of list i ; This function takes an k sorted lists in the form of 2D array as an argument . It finds out smallest range that includes elements from each of the k lists . ; initializing to 0 index ; ; for maintaining the index of list containing the minimum element ; iterating over all the list ; if every element of list [ i ] is traversed then break the loop ; find minimum value among all the list elements pointing by the ptr [ ] array ; update the index of the list ; find maximum value among all the list elements pointing by the ptr [ ] array ; if any list exhaust we will not get any better answer , so break the while loop ; updating the minrange ; Driver program to test above function", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  5 NEW_LINE int ptr [ 501 ] ; void findSmallestRange ( int arr [ ] [ N ] , int n , int k ) { int i , minval , maxval , minrange , minel , maxel , flag , minind ; for ( i = 0 ; i <= k ; i ++ ) ptr [ i ] = 0 ; minrange = INT_MAX ; while ( 1 ) { minind = -1 ; minval = INT_MAX ; maxval = INT_MIN ; flag = 0 ; for ( i = 0 ; i < k ; i ++ ) { if ( ptr [ i ] == n ) { flag = 1 ; break ; } if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] < minval ) { minind = i ; minval = arr [ i ] [ ptr [ i ] ] ; } if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] > maxval ) { maxval = arr [ i ] [ ptr [ i ] ] ; } } if ( flag ) break ; ptr [ minind ] ++ ; if ( ( maxval - minval ) < minrange ) { minel = minval ; maxel = maxval ; minrange = maxel - minel ; } } printf ( \" The ▁ smallest ▁ range ▁ is ▁ [ % d , ▁ % d ] STRNEWLINE \" , minel , maxel ) ; } int main ( ) { int arr [ ] [ N ] = { { 4 , 7 , 9 , 12 , 15 } , { 0 , 8 , 10 , 14 , 20 } , { 6 , 12 , 16 , 30 , 50 } } ; int k = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findSmallestRange ( arr , N , k ) ; return 0 ; }", "text_ms": "Cari julat terkecil yang mengandungi elemen dari senarai k | Program C ++ untuk mengetahui pelbagai terkecil yang merangkumi unsur -unsur dari setiap senarai disusun yang diberikan. ; array untuk menyimpan indeks semasa senarai i; Fungsi ini mengambil senarai yang disusun dalam bentuk array 2D sebagai hujah. Ia mendapati pelbagai terkecil yang merangkumi unsur -unsur dari setiap senarai K. ; memulakan ke 0 indeks; ; untuk mengekalkan indeks senarai yang mengandungi elemen minimum; melangkah ke atas semua senarai; Jika setiap elemen senarai [i] dilalui maka memecahkan gelung; Cari nilai minimum di antara semua elemen senarai yang menunjuk oleh array PTR []; mengemas kini indeks senarai; Cari nilai maksimum di antara semua elemen senarai yang menunjuk oleh array PTR []; Sekiranya ada senarai ekzos, kami tidak akan mendapat jawapan yang lebih baik, jadi pecahkan gelung sementara; mengemas kini Minrange; Program pemacu untuk menguji fungsi di atas"}
{"text": "Find largest d in array such that a + b + c = d | CPP Program to find the largest d such that d = a + b + c ; function to find largest d ; sort the array in ascending order ; iterating from backwards to find the required largest d ; since all four a , b , c , d should be distinct ; if the current combination of j , k , l in the set is equal to S [ i ] return this value as this would be the largest d since we are iterating in descending order ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findLargestd ( int S [ ] , int n ) { bool found = false ; sort ( S , S + n ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; for ( int k = j + 1 ; k < n ; k ++ ) { if ( i == k ) continue ; for ( int l = k + 1 ; l < n ; l ++ ) { if ( i == l ) continue ; if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) { found = true ; return S [ i ] ; } } } } } if ( found == false ) return INT_MIN ; } int main ( ) { int S [ ] = { 2 , 3 , 5 , 7 , 12 } ; int n = sizeof ( S ) / sizeof ( S [ 0 ] ) ; int ans = findLargestd ( S , n ) ; if ( ans == INT_MIN ) cout << \" No ▁ Solution \" << endl ; else cout << \" Largest ▁ d ▁ such ▁ that ▁ a ▁ + ▁ b ▁ + ▁ \" << \" c ▁ = ▁ d ▁ is ▁ \" << ans << endl ; return 0 ; }", "text_ms": "Cari D terbesar dalam array sedemikian rupa sehingga A + B + C = D | Program CPP untuk mencari yang terbesar D sedemikian rupa sehingga D = A + B + C; berfungsi untuk mencari d terbesar; Susun array dalam urutan menaik; melangkah dari belakang untuk mencari D terbesar yang diperlukan; Oleh kerana semua empat A, B, C, D harus berbeza; Jika kombinasi semasa J, K, L dalam set adalah sama dengan S [i] mengembalikan nilai ini kerana ini akan menjadi d terbesar kerana kita melelehkan dalam urutan menurun; Kod pemacu"}
{"text": "Find largest d in array such that a + b + c = d | A hashing based CPP program to find largest d such that a + b + c = d . ; The function finds four elements with given sum X ; Store sums ( a + b ) of all pairs ( a , b ) in a hash table ; Traverse through all pairs and find ( d - c ) is present in hash table ; If d - c is present in hash table , ; Making sure that all elements are distinct array elements and an element is not considered more than once . ; Driver program to test above function", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findFourElements ( int arr [ ] , int n ) { unordered_map < int , pair < int , int > > mp ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) mp [ arr [ i ] + arr [ j ] ] = { i , j } ; int d = INT_MIN ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int abs_diff = abs ( arr [ i ] - arr [ j ] ) ; if ( mp . find ( abs_diff ) != mp . end ( ) ) { pair < int , int > p = mp [ abs_diff ] ; if ( p . first != i && p . first != j && p . second != i && p . second != j ) d = max ( d , max ( arr [ i ] , arr [ j ] ) ) ; } } } return d ; } int main ( ) { int arr [ ] = { 2 , 3 , 5 , 7 , 12 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int res = findFourElements ( arr , n ) ; if ( res == INT_MIN ) cout << \" No ▁ Solution . \" ; else cout << res ; return 0 ; }", "text_ms": "Cari D terbesar dalam array sedemikian rupa sehingga A + B + C = D | Program CPP berasaskan hashing untuk mencari D terbesar sehingga A + B + C = D. ; Fungsi ini menemui empat elemen dengan jumlah x yang diberikan; Jumlah wang (a + b) semua pasangan (a, b) dalam jadual hash; Melintasi semua pasangan dan mencari (D - C) hadir dalam jadual hash; Jika d - c ada dalam jadual hash ,; Memastikan semua elemen adalah elemen array yang berbeza dan elemen tidak dianggap lebih dari sekali. ; Program pemacu untuk menguji fungsi di atas"}
{"text": "Maximize count of elements that can be selected having minimum difference between their sum and K | C ++ implementation of the above approach ; Function to count maximum number of elements that can be selected ; Sort the array ; Traverse the array ; Add current element to the sum ; IF sum exceeds k ; Increment count ; Return the count ; Driver Code ; Function call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int CountMaximum ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int sum = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum > k ) break ; count ++ ; } return count ; } int main ( ) { int arr [ ] = { 30 , 30 , 10 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 50 ; cout << CountMaximum ( arr , n , k ) ; return 0 ; }", "text_ms": "Memaksimumkan kiraan elemen yang boleh dipilih mempunyai perbezaan minimum antara jumlah dan k | C ++ pelaksanaan pendekatan di atas; Berfungsi untuk mengira bilangan maksimum elemen yang boleh dipilih; Susun array; Melintasi array; Tambah elemen semasa ke jumlah; Jika jumlah melebihi k; Kiraan kenaikan; Mengembalikan kiraan; Kod pemacu; Panggilan fungsi"}
{"text": "Program for array rotation | C ++ program to rotate an array by d elements ; Function to left Rotate arr [ ] of size n by 1 ; Function to left rotate arr [ ] of size n by d ; utility function to print an array ; Driver program to test above functions", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void leftRotatebyOne ( int arr [ ] , int n ) { int temp = arr [ 0 ] , i ; for ( i = 0 ; i < n - 1 ; i ++ ) arr [ i ] = arr [ i + 1 ] ; arr [ n - 1 ] = temp ; } void leftRotate ( int arr [ ] , int d , int n ) { for ( int i = 0 ; i < d ; i ++ ) leftRotatebyOne ( arr , n ) ; } void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << \" ▁ \" ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; leftRotate ( arr , 2 , n ) ; printArray ( arr , n ) ; return 0 ; }", "text_ms": "Program untuk Putaran Array | Program C ++ untuk memutar array oleh elemen D; Berfungsi ke kiri berputar arr [] saiz n oleh 1; Berfungsi ke kiri berputar arr [] saiz n oleh d; fungsi utiliti untuk mencetak array; Program pemacu untuk menguji fungsi di atas"}
{"text": "Sort the array in a given index range | C ++ program to sort the array in a given index range ; Function to sort the elements of the array from index a to index b ; Variables to store start and end of the index range ; Temporary array ; Sort the temporary array ; Modifying original array with temporary array elements ; Print the modified array ; Driver code ; length of the array", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void partSort ( int arr [ ] , int N , int a , int b ) { int l = min ( a , b ) ; int r = max ( a , b ) ; int temp [ r - l + 1 ] ; int j = 0 ; for ( int i = l ; i <= r ; i ++ ) { temp [ j ] = arr [ i ] ; j ++ ; } sort ( temp , temp + r - l + 1 ) ; j = 0 ; for ( int i = l ; i <= r ; i ++ ) { arr [ i ] = temp [ j ] ; j ++ ; } for ( int i = 0 ; i < N ; i ++ ) { cout << arr [ i ] << \" ▁ \" ; } } int main ( ) { int arr [ ] = { 7 , 8 , 4 , 5 , 2 } ; int a = 1 ; int b = 4 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; partSort ( arr , N , a , b ) ; return 0 ; }", "text_ms": "Susun array dalam julat indeks yang diberikan | Program C ++ untuk menyusun array dalam julat indeks yang diberikan; Berfungsi untuk menyusun unsur -unsur array dari indeks A ke indeks b; Pembolehubah untuk menyimpan permulaan dan akhir julat indeks; Arahan sementara; Susun array sementara; Mengubah suai array asal dengan elemen array sementara; Cetak array yang diubah suai; Kod pemacu; panjang array"}
{"text": "Sorting rows of matrix in descending order followed by columns in ascending order | C ++ implementation to sort the rows of matrix in descending order followed by sorting the columns in ascending order ; function to sort each row of the matrix according to the order specified by descending . ; function to find transpose of the matrix ; swapping element at index ( i , j ) by element at index ( j , i ) ; function to sort the matrix row - wise and column - wise ; sort rows of mat [ ] [ ] in descending order ; get transpose of mat [ ] [ ] ; again sort rows of mat [ ] [ ] in ascending order . ; again get transpose of mat [ ] [ ] ; function to print the matrix ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX_SIZE  10 NEW_LINE void sortByRow ( int mat [ ] [ MAX_SIZE ] , int n , bool descending ) { for ( int i = 0 ; i < n ; i ++ ) { if ( descending == true ) sort ( mat [ i ] , mat [ i ] + n , greater < int > ( ) ) ; else sort ( mat [ i ] , mat [ i ] + n ) ; } } void transpose ( int mat [ ] [ MAX_SIZE ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) swap ( mat [ i ] [ j ] , mat [ j ] [ i ] ) ; } void sortMatRowAndColWise ( int mat [ ] [ MAX_SIZE ] , int n ) { sortByRow ( mat , n , true ) ; transpose ( mat , n ) ; sortByRow ( mat , n , false ) ; transpose ( mat , n ) ; } void printMat ( int mat [ ] [ MAX_SIZE ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) cout << mat [ i ] [ j ] << \" ▁ \" ; cout << endl ; } } int main ( ) { int n = 3 ; int mat [ n ] [ MAX_SIZE ] = { { 3 , 2 , 1 } , { 9 , 8 , 7 } , { 6 , 5 , 4 } } ; cout << \" Original ▁ Matrix : STRNEWLINE \" ; printMat ( mat , n ) ; sortMatRowAndColWise ( mat , n ) ; cout << \" Matrix After Sorting : \" ; printMat ( mat , n ) ; return 0 ; }", "text_ms": "Penyusun baris matriks dalam urutan menurun diikuti oleh lajur dalam urutan menaik | C ++ pelaksanaan untuk menyusun baris matriks dalam urutan menurun diikuti dengan menyusun lajur dalam urutan menaik; Fungsi untuk menyusun setiap baris matriks mengikut perintah yang ditentukan oleh turun. ; berfungsi untuk mencari transpose matriks; elemen bertukar pada indeks (i, j) mengikut elemen pada indeks (j, i); berfungsi untuk menyusun baris matriks - bijak dan lajur - bijak; Susun baris tikar [] [] dalam urutan menurun; dapatkan transpose tikar [] []; Sekali lagi menyusun baris Mat [] [] dalam urutan menaik. ; Sekali lagi dapatkan transpose tikar [] []; berfungsi untuk mencetak matriks; Kod pemacu"}
{"text": "Move all zeroes to end of array | A C ++ program to move all zeroes at the end of array ; Function which pushes all zeros to end of an array . ; Count of non - zero elements ; Traverse the array . If element encountered is non - zero , then replace the element at index ' count ' with this element ; here count is ; incremented Now all non - zero elements have been shifted to front and ' count ' is set as index of first 0. Make all elements 0 from count to end . ; Driver program to test above function", "code": "#include <iostream> NEW_LINE using namespace std ; void pushZerosToEnd ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ; while ( count < n ) arr [ count ++ ] = 0 ; } int main ( ) { int arr [ ] = { 1 , 9 , 8 , 4 , 0 , 0 , 2 , 7 , 0 , 6 , 0 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; pushZerosToEnd ( arr , n ) ; cout << \" Array ▁ after ▁ pushing ▁ all ▁ zeros ▁ to ▁ end ▁ of ▁ array ▁ : STRNEWLINE \" ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << \" ▁ \" ; return 0 ; }", "text_ms": "Pindahkan semua sifar ke hujung array | Program C ++ untuk memindahkan semua sifar pada akhir array; Fungsi yang mendorong semua sifar ke akhir array. ; Kiraan unsur bukan sifar; Melintasi array. Jika elemen yang ditemui bukan sifar, kemudian gantikan elemen pada indeks 'kiraan' dengan elemen ini; Di sini kiraan adalah; Tambahan sekarang semua elemen bukan sifar telah beralih ke depan dan 'kiraan' ditetapkan sebagai indeks pertama 0. Buat semua elemen 0 dari kiraan hingga akhir. ; Program pemacu untuk menguji fungsi di atas"}
{"text": "Move all zeroes to end of array | Set | C ++ implementation to move all zeroes at the end of array ; function to move all zeroes at the end of array ; Count of non - zero elements ; Traverse the array . If arr [ i ] is non - zero , then swap the element at index ' count ' with the element at index ' i ' ; function to print the array elements ; Driver program to test above", "code": "#include <iostream> NEW_LINE using namespace std ; void moveZerosToEnd ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) swap ( arr [ count ++ ] , arr [ i ] ) ; } void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << \" ▁ \" ; } int main ( ) { int arr [ ] = { 0 , 1 , 9 , 8 , 4 , 0 , 0 , 2 , 7 , 0 , 6 , 0 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << \" Original ▁ array : ▁ \" ; printArray ( arr , n ) ; moveZerosToEnd ( arr , n ) ; cout << \" Modified array : \" printArray ( arr , n ) ; return 0 ; }", "text_ms": "Pindahkan semua sifar ke hujung array | Set | C ++ pelaksanaan untuk memindahkan semua sifar pada akhir array; berfungsi untuk memindahkan semua sifar pada akhir array; Kiraan unsur bukan sifar; Melintasi array. Jika arr [i] bukan sifar, maka swap elemen pada indeks 'kiraan' dengan elemen pada indeks 'i'; berfungsi untuk mencetak elemen array; Program Pemandu untuk diuji di atas"}
{"text": "Double the first element and move zero to end | C ++ implementation to rearrange the array elements after modification ; function which pushes all zeros to end of an array . ; Count of non - zero elements ; Traverse the array . If element encountered is non - zero , then replace the element at index ' count ' with this element ; here count is incremented ; Now all non - zero elements have been shifted to front and ' count ' is set as index of first 0. Make all elements 0 from count to end . ; function to rearrange the array elements after modification ; if ' arr [ ] ' contains a single element only ; traverse the array ; if true , perform the required modification ; double current index value ; put 0 in the next index ; increment by 1 so as to move two indexes ahead during loop iteration ; push all the zeros at the end of ' arr [ ] ' ; function to print the array elements ; Driver program to test above", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void pushZerosToEnd ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ; while ( count < n ) arr [ count ++ ] = 0 ; } void modifyAndRearrangeArr ( int arr [ ] , int n ) { if ( n == 1 ) return ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ( arr [ i ] != 0 ) && ( arr [ i ] == arr [ i + 1 ] ) ) { arr [ i ] = 2 * arr [ i ] ; arr [ i + 1 ] = 0 ; i ++ ; } } pushZerosToEnd ( arr , n ) ; } void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << \" ▁ \" ; } int main ( ) { int arr [ ] = { 0 , 2 , 2 , 2 , 0 , 6 , 6 , 0 , 0 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << \" Original ▁ array : ▁ \" ; printArray ( arr , n ) ; modifyAndRearrangeArr ( arr , n ) ; cout << \" Modified array : \" printArray ( arr , n ) ; return 0 ; }", "text_ms": "Gandakan elemen pertama dan gerakkan sifar ke akhir | C ++ pelaksanaan untuk menyusun semula elemen array selepas pengubahsuaian; fungsi yang mendorong semua sifar ke akhir array. ; Kiraan unsur bukan sifar; Melintasi array. Jika elemen yang ditemui bukan sifar, kemudian gantikan elemen pada indeks 'kiraan' dengan elemen ini; Di sini kiraan ditingkatkan; Sekarang semua elemen bukan sifar telah beralih ke depan dan 'kiraan' ditetapkan sebagai indeks pertama 0. Buat semua elemen 0 dari kiraan hingga akhir. ; berfungsi untuk menyusun semula elemen array selepas pengubahsuaian; jika 'arr []' mengandungi satu elemen sahaja; melintasi array; Jika benar, lakukan pengubahsuaian yang diperlukan; nilai indeks semasa dua kali; Letakkan 0 dalam indeks seterusnya; kenaikan sebanyak 1 untuk memindahkan dua indeks di hadapan semasa lelaran gelung; tolak semua sifar pada akhir 'arr []'; berfungsi untuk mencetak elemen array; Program Pemandu untuk diuji di atas"}
{"text": "Double the first element and move zero to end | Utility Function For Swaping Two Element Of An Array ; shift all zero to left side of an array ; Maintain last index with positive value ; If Element is non - zero ; swap current index , with lastSeen non - zero ; next element will be last seen non - zero", "code": "void swap ( int & a , int & b ) { a = b + a - ( b = a ) ; } void shiftAllZeroToLeft ( int array [ ] , int n ) { int lastSeenNonZero = 0 ; for ( index = 0 ; index < n ; index ++ ) { if ( array [ index ] != 0 ) { swap ( array [ index ] , array [ lastSeenNonZero ] ) ; lastSeenNonZero ++ ; } } }", "text_ms": "Gandakan elemen pertama dan gerakkan sifar ke akhir | Fungsi utiliti untuk menukar dua elemen array; beralih semua sifar ke sebelah kiri array; Mengekalkan indeks terakhir dengan nilai positif; Jika elemen bukan sifar; Swap Indeks Semasa, dengan LastSeen Non - Zero; Elemen seterusnya akan terakhir dilihat bukan - sifar"}
{"text": "Rearrange positive and negative numbers with constant extra space | C ++ program to Rearrange positive and negative numbers in a array ; A utility function to print an array of size n ; Function to Rearrange positive and negative numbers in a array ; if current element is positive do nothing ; if current element is negative , shift positive elements of arr [ 0. . i - 1 ] , to one position to their right ; Put negative element at its right position ; Driver program to test above functions", "code": "#include <stdio.h> NEW_LINE void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; printf ( \" STRNEWLINE \" ) ; } void RearrangePosNeg ( int arr [ ] , int n ) { int key , j ; for ( int i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; if ( key > 0 ) continue ; j = i - 1 ; while ( j >= 0 && arr [ j ] > 0 ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } arr [ j + 1 ] = key ; } } int main ( ) { int arr [ ] = { -12 , 11 , -13 , -5 , 6 , -7 , 5 , -3 , -6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; RearrangePosNeg ( arr , n ) ; printArray ( arr , n ) ; return 0 ; }", "text_ms": "Susun semula nombor positif dan negatif dengan ruang tambahan yang berterusan | Program C ++ untuk menyusun semula nombor positif dan negatif dalam array; Fungsi utiliti untuk mencetak pelbagai saiz n; Berfungsi untuk menyusun semula nombor positif dan negatif dalam array; Jika elemen semasa positif tidak melakukan apa -apa; Jika elemen semasa adalah negatif, pergeseran elemen positif ARR [0. i - 1], ke satu kedudukan di sebelah kanan mereka; Letakkan elemen negatif pada kedudukan yang betul; Program pemacu untuk menguji fungsi di atas"}
{"text": "Rearrange positive and negative numbers with constant extra space | C ++ program to Rearrange positive and negative numbers in a array ; Function to print an array ; Function to reverse an array . An array can be reversed in O ( n ) time and O ( 1 ) space . ; Merges two subarrays of arr [ ] . First subarray is arr [ l . . m ] Second subarray is arr [ m + 1. . r ] ; Initial index of 1 st subarray ; Initial index of IInd ; arr [ i . . m ] is positive ; arr [ j . . r ] is positive reverse positive part of left sub - array ( arr [ i . . m ] ) ; reverse negative part of right sub - array ( arr [ m + 1. . j - 1 ] ) ; reverse arr [ i . . j - 1 ] ; Function to Rearrange positive and negative numbers in a array ; Same as ( l + r ) / 2 , but avoids overflow for large l and h ; Sort first and second halves ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printArray ( int A [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) cout << A [ i ] << \" ▁ \" ; cout << endl ; } void reverse ( int arr [ ] , int l , int r ) { if ( l < r ) { swap ( arr [ l ] , arr [ r ] ) ; reverse ( arr , ++ l , -- r ) ; } } void merge ( int arr [ ] , int l , int m , int r ) { int i = l ; int j = m + 1 ; while ( i <= m && arr [ i ] < 0 ) i ++ ; while ( j <= r && arr [ j ] < 0 ) j ++ ; reverse ( arr , i , m ) ; reverse ( arr , m + 1 , j - 1 ) ; reverse ( arr , i , j - 1 ) ; } void RearrangePosNeg ( int arr [ ] , int l , int r ) { if ( l < r ) { int m = l + ( r - l ) / 2 ; RearrangePosNeg ( arr , l , m ) ; RearrangePosNeg ( arr , m + 1 , r ) ; merge ( arr , l , m , r ) ; } } int main ( ) { int arr [ ] = { -12 , 11 , -13 , -5 , 6 , -7 , 5 , -3 , -6 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; RearrangePosNeg ( arr , 0 , arr_size - 1 ) ; printArray ( arr , arr_size ) ; return 0 ; }", "text_ms": "Susun semula nombor positif dan negatif dengan ruang tambahan yang berterusan | Program C ++ untuk menyusun semula nombor positif dan negatif dalam array; Berfungsi untuk mencetak array; Fungsi untuk membalikkan array. Arahan boleh diterbalikkan dalam masa O (n) dan O (1) ruang. ; Menggabungkan dua subarray ARR []. Subarray pertama adalah arr [l. . m] subarray kedua adalah arr [m + 1. r]; Indeks awal Subarray 1 ST; Indeks awal IIND; arr [i. . M] adalah positif; arr [j. . r] adalah bahagian positif yang positif dari sub - array kiri (arr [i. m]); Bahagian negatif terbalik sub - array kanan (arr [m + 1 ... j - 1]); ARR terbalik [i. . J - 1]; Berfungsi untuk menyusun semula nombor positif dan negatif dalam array; Sama seperti (L + R) / 2, tetapi mengelakkan limpahan untuk L dan H yang besar; Menyusun bahagian pertama dan kedua; Kod pemacu"}
{"text": "Rearrange positive and negative numbers with constant extra space | C ++ implementation of the above approach ; Loop until arr [ i ] < 0 and still inside the array ; Loop until arr [ j ] > 0 and still inside the array ; if i is less than j ; Driver Code", "code": "#include <iostream> NEW_LINE using namespace std ; void RearrangePosNeg ( int arr [ ] , int n ) { int i = 0 ; int j = n - 1 ; while ( true ) { while ( arr [ i ] < 0 && i < n ) i ++ ; while ( arr [ j ] > 0 && j >= 0 ) j -- ; if ( i < j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } else break ; } } int main ( ) { int arr [ ] = { -12 , 11 , -13 , -5 , 6 , -7 , 5 , -3 , -6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; RearrangePosNeg ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << \" ▁ \" ; return 0 ; }", "text_ms": "Susun semula nombor positif dan negatif dengan ruang tambahan yang berterusan | C ++ pelaksanaan pendekatan di atas; Gelung sehingga arr [i] <0 dan masih di dalam array; Gelung sehingga arr [j]> 0 dan masih di dalam array; jika saya kurang daripada j; Kod pemacu"}
{"text": "Find the player to be able to replace the last element that can be replaced by its divisors | C ++ program for the above approach ; Function to find the winner of the game played based on given conditions ; A wins if size of array is odd ; Otherwise , B wins ; Driver Code ; Input array ; Size of the array", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void winner ( int arr [ ] , int N ) { if ( N % 2 == 1 ) { cout << \" A \" ; } else { cout << \" B \" ; } } int main ( ) { int arr [ ] = { 24 , 45 , 45 , 24 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; winner ( arr , N ) ; }", "text_ms": "Cari pemain untuk dapat menggantikan elemen terakhir yang boleh digantikan oleh pembahagi | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari pemenang permainan yang dimainkan berdasarkan keadaan yang diberikan; Kemenangan jika saiz array adalah ganjil; Jika tidak, B menang; Kod pemacu; Arahan input; Saiz array"}
{"text": "Queries to calculate sum of array elements present at every Yth index starting from the index X | C ++ program for the above approach ; Function to sum of arr [ x ] + arr [ x + y ] + arr [ x + 2 * y ] + ... for all possible values of X and Y , where Y is less than or equal to sqrt ( N ) . ; Iterate over all possible values of X ; Precompute for all possible values of an expression such that y <= sqrt ( N ) ; If i + j less than N ; Update dp [ i ] [ j ] ; Update dp [ i ] [ j ] ; Function to Find the sum of arr [ x ] + arr [ x + y ] + arr [ x + 2 * y ] + ... for all queries ; dp [ x ] [ y ] : Stores sum of arr [ x ] + arr [ x + y ] + arr [ x + 2 * y ] + ... ; Traverse the query array , Q [ ] [ ] ; If y is less than or equal to sqrt ( N ) ; Stores the sum of arr [ x ] + arr [ x + y ] + arr [ x + 2 * y ] + ... ; Traverse the array , arr [ ] ; Update sum ; Update x ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int sz = 20 ; const int sqr = int ( sqrt ( sz ) ) + 1 ; void precomputeExpressionForAllVal ( int arr [ ] , int N , int dp [ sz ] [ sqr ] ) { for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = 1 ; j <= sqrt ( N ) ; j ++ ) { if ( i + j < N ) { dp [ i ] [ j ] = arr [ i ] + dp [ i + j ] [ j ] ; } else { dp [ i ] [ j ] = arr [ i ] ; } } } } int querySum ( int arr [ ] , int N , int Q [ ] [ 2 ] , int M ) { int dp [ sz ] [ sqr ] ; precomputeExpressionForAllVal ( arr , N , dp ) ; for ( int i = 0 ; i < M ; i ++ ) { int x = Q [ i ] [ 0 ] ; int y = Q [ i ] [ 1 ] ; if ( y <= sqrt ( N ) ) { cout << dp [ x ] [ y ] << \" ▁ \" ; continue ; } int sum = 0 ; while ( x < N ) { sum += arr [ x ] ; x += y ; } cout << sum << \" ▁ \" ; } } int main ( ) { int arr [ ] = { 1 , 2 , 7 , 5 , 4 } ; int Q [ ] [ 2 ] = { { 2 , 1 } , { 3 , 2 } } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int M = sizeof ( Q ) / sizeof ( Q [ 0 ] ) ; querySum ( arr , N , Q , M ) ; return 0 ; }", "text_ms": "Pertanyaan untuk mengira jumlah elemen array yang hadir pada setiap indeks yth bermula dari indeks x | Program C ++ untuk pendekatan di atas; Fungsi kepada jumlah arr [x] + arr [x + y] + arr [x + 2 * y] + ... untuk semua nilai yang mungkin x dan y, di mana y kurang daripada atau sama dengan sqrt (n). ; Melangkah ke atas semua kemungkinan nilai x; Precompute untuk semua nilai yang mungkin dari ungkapan seperti y <= sqrt (n); Jika saya + j kurang daripada n; Kemas kini DP [i] [J]; Kemas kini DP [i] [J]; Fungsi untuk mencari jumlah arr [x] + arr [x + y] + arr [x + 2 * y] + ... untuk semua pertanyaan; dp [x] [y]: menyimpan jumlah arr [x] + arr [x + y] + arr [x + 2 * y] + ...; Melintasi array pertanyaan, q [] []; Jika y kurang daripada atau sama dengan sqrt (n); Menyimpan jumlah arr [x] + arr [x + y] + arr [x + 2 * y] + ...; Melintasi array, arr []; Kemas kini Jumlah; Kemas kini x; Kod pemacu"}
{"text": "Find all elements in array which have at | Simple C ++ program to find all elements in array which have at - least two greater elements itself . ; Pick elements one by one and count greater elements . If count is more than 2 , print that element . ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findElements ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ; if ( count >= 2 ) cout << arr [ i ] << \" ▁ \" ; } } int main ( ) { int arr [ ] = { 2 , -6 , 3 , 5 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findElements ( arr , n ) ; return 0 ; }", "text_ms": "Cari semua elemen dalam pelbagai yang ada di | Program C ++ mudah untuk mencari semua elemen dalam pelbagai yang mempunyai sekurang -kurangnya dua elemen yang lebih besar sendiri. ; Pilih elemen satu demi satu dan hitung elemen yang lebih besar. Jika kiraan lebih daripada 2, cetak elemen itu. ; Kod pemacu"}
{"text": "Find all elements in array which have at | Sorting based C ++ program to find all elements in array which have atleast two greater elements itself . ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findElements ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) cout << arr [ i ] << \" ▁ \" ; } int main ( ) { int arr [ ] = { 2 , -6 , 3 , 5 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findElements ( arr , n ) ; return 0 ; }", "text_ms": "Cari semua elemen dalam pelbagai yang ada di | Mengasingkan program C ++ untuk mencari semua elemen dalam array yang mempunyai dua elemen yang lebih besar sendiri. ; Kod pemacu"}
{"text": "Find all elements in array which have at | C ++ program to find all elements in array which have atleast two greater elements itself . ; If current element is smaller than first then update both first and second ; If arr [ i ] is in between first and second then update second ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findElements ( int arr [ ] , int n ) { int first = INT_MIN , second = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) second = arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < second ) cout << arr [ i ] << \" ▁ \" ; } int main ( ) { int arr [ ] = { 2 , -6 , 3 , 5 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findElements ( arr , n ) ; return 0 ; }", "text_ms": "Cari semua elemen dalam pelbagai yang ada di | Program C ++ untuk mencari semua elemen dalam array yang mempunyai dua elemen yang lebih besar sendiri. ; Jika elemen semasa lebih kecil daripada yang pertama kemudian kemas kini kedua -duanya dan kedua; Jika arr [i] berada di antara pertama dan kedua kemudian kemas kini kedua; Kod pemacu"}
{"text": "Minimize count of increments of each element of subarrays required to make Array non | C ++ Program to implement the above approach ; Function to find the minimum number of operations required to make the array non - increasing ; Stores the count of required operations ; If arr [ i ] > arr [ i + 1 ] , no increments required . Otherwise , add their difference to the answer ; Return the result res ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMinOps ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { res += max ( arr [ i + 1 ] - arr [ i ] , 0 ) ; } return res ; } int main ( ) { int arr [ ] = { 1 , 3 , 4 , 1 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << getMinOps ( arr , N ) ; }", "text_ms": "Kurangkan kiraan kenaikan setiap elemen subarray yang diperlukan untuk membuat array bukan | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari bilangan minimum operasi yang diperlukan untuk membuat array tidak meningkat; Menyimpan kiraan operasi yang diperlukan; Jika arr [i]> arr [i + 1], tiada kenaikan diperlukan. Jika tidak, tambahkan perbezaannya kepada jawapannya; Mengembalikan hasil res; Kod pemacu"}
{"text": "Find the smallest missing number | C ++ program to find the smallest elements missing in a sorted array . ; function that returns smallest elements missing in a sorted array . ; Left half has all elements from 0 to mid ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findFirstMissing ( int array [ ] , int start , int end ) { if ( start > end ) return end + 1 ; if ( start != array [ start ] ) return start ; int mid = ( start + end ) / 2 ; if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ; return findFirstMissing ( array , start , mid ) ; } int main ( ) { int arr [ ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << \" Smallest ▁ missing ▁ element ▁ is ▁ \" << findFirstMissing ( arr , 0 , n - 1 ) << endl ; }", "text_ms": "Cari nombor yang paling kecil | Program C ++ untuk mencari unsur -unsur terkecil yang hilang dalam array yang disusun. ; Fungsi yang mengembalikan unsur -unsur terkecil yang hilang dalam array yang disusun. ; Separuh kiri mempunyai semua elemen dari 0 hingga pertengahan; Kod pemacu"}
{"text": "Find the smallest missing number | C ++ program for the above approach ; Program to find Smallest Missing in Sorted Array ; Check if 0 is missing in the array ; Check is all numbers 0 to n - 1 are prsent in array ; Program to find missing element ; * Index matches with value at that index , means missing element cannot be upto that po ; Driver program to test the above function ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSmallestMissinginSortedArray ( vector < int > arr ) { if ( arr [ 0 ] != 0 ) return 0 ; if ( arr [ arr . size ( ) - 1 ] == arr . size ( ) - 1 ) return arr . size ( ) ; int first = arr [ 0 ] ; return findFirstMissing ( arr , 0 , arr . size ( ) - 1 , first ) ; } int findFirstMissing ( vector < int > arr , int start , int end , int first ) { if ( start < end ) { int mid = ( start + end ) / 2 ; if ( arr [ mid ] != mid + first ) return findFirstMissing ( arr , start , mid , first ) ; else return findFirstMissing ( arr , mid + 1 , end , first ) ; } return start + first ; } int main ( ) { vector < int > arr = { 0 , 1 , 2 , 3 , 4 , 5 , 7 } ; int n = arr . size ( ) ; cout << \" First ▁ Missing ▁ element ▁ is ▁ : ▁ \" << findSmallestMissinginSortedArray ( arr ) ; }", "text_ms": "Cari nombor yang paling kecil | Program C ++ untuk pendekatan di atas; Program untuk mencari yang paling kecil hilang dalam pelbagai disusun; Semak jika 0 hilang dalam array; Cek adalah semua nombor 0 hingga n - 1 adalah prsent dalam array; Program untuk mencari elemen yang hilang; * Perlawanan indeks dengan nilai pada indeks itu, bermakna elemen yang hilang tidak boleh sampai ke po; Program pemacu untuk menguji fungsi di atas; Panggilan fungsi"}
{"text": "Maximum sum such that no two elements are adjacent | c ++ program for the above approach ; Function to return max sum such that no two elements are adjacent ; current max excluding i ; current max including i ; return max of incl and excl ; Driver program to test above functions", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int FindMaxSum ( vector < int > arr , int n ) { int incl = arr [ 0 ] ; int excl = 0 ; int excl_new ; int i ; for ( i = 1 ; i < n ; i ++ ) { excl_new = ( incl > excl ) ? incl : excl ; incl = excl + arr [ i ] ; excl = excl_new ; } return ( ( incl > excl ) ? incl : excl ) ; } int main ( ) { vector < int > arr = { 5 , 5 , 10 , 100 , 10 , 5 } ; cout << FindMaxSum ( arr , arr . size ( ) ) ; }", "text_ms": "Jumlah maksimum supaya tidak ada dua elemen bersebelahan | program C ++ untuk pendekatan di atas; Berfungsi untuk mengembalikan jumlah maksimum supaya tidak ada dua elemen bersebelahan; Max semasa tidak termasuk i; Max semasa termasuk i; kembali max incl and excl; Program pemacu untuk menguji fungsi di atas"}
{"text": "Minimum steps to convert all top left to bottom right paths in Matrix as palindrome | Set 2 | C ++ program for the above approach ; Function for counting minimum number of changes ; Distance of elements from ( 0 , 0 ) will is i range [ 0 , n + m - 2 ] ; Store frequencies of [ 0 , 9 ] at distance i ; Initialize frequencies as 0 ; Count frequencies of [ 0 , 9 ] ; Increment frequency of value matrix [ i ] [ j ] at distance i + j ; Find value with max frequency and count total cells at distance i from front end and rear end ; Change all values to the value with max frequency ; Return the answer ; Driver Code ; Given Matrix ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  7 NEW_LINE int countChanges ( int matrix [ ] [ N ] , int n , int m ) { int dist = n + m - 1 ; int freq [ dist ] [ 10 ] ; for ( int i = 0 ; i < dist ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) freq [ i ] [ j ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { freq [ i + j ] [ matrix [ i ] [ j ] ] ++ ; } } int min_changes_sum = 0 ; for ( int i = 0 ; i < dist / 2 ; i ++ ) { int maximum = 0 ; int total_values = 0 ; for ( int j = 0 ; j < 10 ; j ++ ) { maximum = max ( maximum , freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) ; total_values += ( freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) ; } min_changes_sum += ( total_values - maximum ) ; } return min_changes_sum ; } int main ( ) { int mat [ ] [ N ] = { { 1 , 2 } , { 3 , 5 } } ; cout << countChanges ( mat , 2 , 2 ) ; return 0 ; }", "text_ms": "Langkah -langkah minimum untuk menukar semua laluan kiri ke bawah ke bawah dalam matriks sebagai palindrome | Tetapkan 2 | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira bilangan perubahan minimum; Jarak elemen dari (0, 0) akan saya julat [0, n + m - 2]; Frekuensi kedai [0, 9] pada jarak I; Memulakan frekuensi sebagai 0; Mengira frekuensi [0, 9]; Kekerapan Kekerapan Matriks nilai [i] [j] pada jarak i + j; Cari nilai dengan kekerapan maksimum dan hitung jumlah sel pada jarak i dari hujung depan dan belakang belakang; Tukar semua nilai ke nilai dengan kekerapan maksimum; Kembalikan jawapannya; Kod pemacu; Diberikan matriks; Panggilan fungsi"}
{"text": "Sparse Table | C ++ program to do range minimum query using sparse table ; lookup [ i ] [ j ] is going to store minimum value in arr [ i . . j ] . Ideally lookup table size should not be fixed and should be determined using n Log n . It is kept constant to keep code simple . ; Fills lookup array lookup [ ] [ ] in bottom up manner . ; Initialize M for the intervals with length 1 ; Compute values from smaller to bigger intervals ; Compute minimum value for all intervals with size 2 ^ j ; For arr [ 2 ] [ 10 ] , we compare arr [ lookup [ 0 ] [ 7 ] ] and arr [ lookup [ 3 ] [ 10 ] ] ; Returns minimum of arr [ L . . R ] ; Find highest power of 2 that is smaller than or equal to count of elements in given range . For [ 2 , 10 ] , j = 3 ; Compute minimum of last 2 ^ j elements with first 2 ^ j elements in range . For [ 2 , 10 ] , we compare arr [ lookup [ 0 ] [ 3 ] ] and arr [ lookup [ 3 ] [ 3 ] ] , ; Driver program", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  500 NEW_LINE int lookup [ MAX ] [ MAX ] ; void buildSparseTable ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) lookup [ i ] [ 0 ] = arr [ i ] ; for ( int j = 1 ; ( 1 << j ) <= n ; j ++ ) { for ( int i = 0 ; ( i + ( 1 << j ) - 1 ) < n ; i ++ ) { if ( lookup [ i ] [ j - 1 ] < lookup [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ) lookup [ i ] [ j ] = lookup [ i ] [ j - 1 ] ; else lookup [ i ] [ j ] = lookup [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ; } } } int query ( int L , int R ) { int j = ( int ) log2 ( R - L + 1 ) ; if ( lookup [ L ] [ j ] <= lookup [ R - ( 1 << j ) + 1 ] [ j ] ) return lookup [ L ] [ j ] ; else return lookup [ R - ( 1 << j ) + 1 ] [ j ] ; } int main ( ) { int a [ ] = { 7 , 2 , 3 , 0 , 5 , 10 , 3 , 12 , 18 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; buildSparseTable ( a , n ) ; cout << query ( 0 , 4 ) << endl ; cout << query ( 4 , 7 ) << endl ; cout << query ( 7 , 8 ) << endl ; return 0 ; }", "text_ms": "Jadual jarang | Program C ++ untuk melakukan pelbagai pertanyaan minimum menggunakan jadual jarang; Lookup [i] [j] akan menyimpan nilai minimum dalam arr [i. . j]. Saiz jadual cari yang ideal tidak boleh diperbaiki dan harus ditentukan menggunakan n log n. Ia tetap berterusan untuk memastikan kod mudah. ; Mengisi carian array carian [] [] dengan cara bawah. ; Memulakan m untuk selang dengan panjang 1; Mengira nilai dari selang yang lebih kecil hingga lebih besar; Kirakan nilai minimum untuk semua selang dengan saiz 2 ^ j; Untuk arr [2] [10], kami membandingkan arr [lookup [0] [7]] dan arr [lookup [3] [10]]; Mengembalikan minimum arr [l. . R]; Cari kuasa tertinggi 2 yang lebih kecil daripada atau sama dengan mengira unsur -unsur dalam julat yang diberikan. Untuk [2, 10], j = 3; Kirakan minimum unsur -unsur terakhir dengan unsur -unsur pertama dalam julat. Untuk [2, 10], kami membandingkan arr [lookup [0] [3]] dan arr [lookup [3] [3]] ,; Program Pemandu"}
{"text": "Sparse Table | C ++ program to do range minimum query using sparse table ; lookup [ i ] [ j ] is going to store GCD of arr [ i . . j ] . Ideally lookup table size should not be fixed and should be determined using n Log n . It is kept constant to keep code simple . ; it builds sparse table . ; GCD of single element is element itself ; Build sparse table ; Returns GCD of arr [ L . . R ] ; Find highest power of 2 that is smaller than or equal to count of elements in given range . For [ 2 , 10 ] , j = 3 ; Compute GCD of last 2 ^ j elements with first 2 ^ j elements in range . For [ 2 , 10 ] , we find GCD of arr [ lookup [ 0 ] [ 3 ] ] and arr [ lookup [ 3 ] [ 3 ] ] , ; Driver program", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  500 NEW_LINE int table [ MAX ] [ MAX ] ; void buildSparseTable ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) table [ i ] [ 0 ] = arr [ i ] ; for ( int j = 1 ; j <= n ; j ++ ) for ( int i = 0 ; i <= n - ( 1 << j ) ; i ++ ) table [ i ] [ j ] = __gcd ( table [ i ] [ j - 1 ] , table [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ) ; } int query ( int L , int R ) { int j = ( int ) log2 ( R - L + 1 ) ; return __gcd ( table [ L ] [ j ] , table [ R - ( 1 << j ) + 1 ] [ j ] ) ; } int main ( ) { int a [ ] = { 7 , 2 , 3 , 0 , 5 , 10 , 3 , 12 , 18 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; buildSparseTable ( a , n ) ; cout << query ( 0 , 2 ) << endl ; cout << query ( 1 , 3 ) << endl ; cout << query ( 4 , 5 ) << endl ; return 0 ; }", "text_ms": "Jadual jarang | Program C ++ untuk melakukan pelbagai pertanyaan minimum menggunakan jadual jarang; Lookup [i] [j] akan menyimpan GCD ARR [i. . j]. Saiz jadual cari yang ideal tidak boleh diperbaiki dan harus ditentukan menggunakan n log n. Ia tetap berterusan untuk memastikan kod mudah. ; Ia membina meja jarang. ; GCD elemen tunggal adalah elemen itu sendiri; Membina meja jarang; Mengembalikan GCD ARR [l. . R]; Cari kuasa tertinggi 2 yang lebih kecil daripada atau sama dengan mengira unsur -unsur dalam julat yang diberikan. Untuk [2, 10], j = 3; Kirakan GCD unsur -unsur terakhir dengan unsur -unsur pertama dalam julat. Untuk [2, 10], kita dapati GCD ARR [lookup [0] [3]] dan arr [lookup [3] [3]] ,; Program Pemandu"}
{"text": "Lexicographically smallest array after at | C ++ program to find lexicographically minimum value after k swaps . ; Modifies arr [ 0. . n - 1 ] to lexicographically smallest with k swaps . ; Set the position where we want to put the smallest integer ; If we exceed the Max swaps then terminate the loop ; Find the minimum value from i + 1 to max k or n ; Swap the elements from Minimum position we found till now to the i index ; Set the final value after swapping pos - i elements ; Driver code ; Function calling ; Print the final Array", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void minimizeWithKSwaps ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n - 1 && k > 0 ; ++ i ) { int pos = i ; for ( int j = i + 1 ; j < n ; ++ j ) { if ( j - i > k ) break ; if ( arr [ j ] < arr [ pos ] ) pos = j ; } for ( int j = pos ; j > i ; -- j ) swap ( arr [ j ] , arr [ j - 1 ] ) ; k -= pos - i ; } } int main ( ) { int arr [ ] = { 7 , 6 , 9 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; minimizeWithKSwaps ( arr , n , k ) ; for ( int i = 0 ; i < n ; ++ i ) cout << arr [ i ] << \" ▁ \" ; }", "text_ms": "Arahan terkecil lexicographically selepas di | Program C ++ untuk mencari nilai minimum lexicographically selepas k swap. ; Modifies arr [0 .. n - 1] kepada lexicographically terkecil dengan s swap. ; Tetapkan kedudukan di mana kita mahu meletakkan integer terkecil; Jika kita melebihi swap maksimum kemudian menamatkan gelung; Cari nilai minimum dari i + 1 hingga max k atau n; Tukar unsur -unsur dari kedudukan minimum yang kami dapati hingga sekarang ke indeks I; Tetapkan nilai akhir selepas menukar elemen POS - I; Kod pemacu; Fungsi panggilan; Cetak Array Akhir"}
{"text": "Find maximum average subarray of k length | C ++ program to find maximum average subarray of given length . ; Returns beginning index of maximum average subarray of length ' k ' ; Check if ' k ' is valid ; Create and fill array to store cumulative sum . csum [ i ] stores sum of arr [ 0 ] to arr [ i ] ; Initialize max_sm as sum of first subarray ; Find sum of other subarrays and update max_sum if required . ; To avoid memory leak ; Return starting index ; Driver program", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxAverage ( int arr [ ] , int n , int k ) { if ( k > n ) return -1 ; int * csum = new int [ n ] ; csum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) csum [ i ] = csum [ i - 1 ] + arr [ i ] ; int max_sum = csum [ k - 1 ] , max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { int curr_sum = csum [ i ] - csum [ i - k ] ; if ( curr_sum > max_sum ) { max_sum = curr_sum ; max_end = i ; } } delete [ ] csum ; return max_end - k + 1 ; } int main ( ) { int arr [ ] = { 1 , 12 , -5 , -6 , 50 , 3 } ; int k = 4 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << \" The ▁ maximum ▁ average ▁ subarray ▁ of ▁ \" \" length ▁ \" << k << \" ▁ begins ▁ at ▁ index ▁ \" << findMaxAverage ( arr , n , k ) ; return 0 ; }", "text_ms": "Cari subarray purata maksimum K panjang | Program C ++ untuk mencari subarray purata maksimum panjang yang diberikan. ; Pulangan permulaan indeks subarray purata maksimum panjang 'k'; Semak jika 'k' sah; Buat dan isi array untuk menyimpan jumlah kumulatif. csum [i] menyimpan jumlah arr [0] ke arr [i]; Memulakan max_sm sebagai jumlah subarray pertama; Cari jumlah subarray lain dan kemas kini max_sum jika diperlukan. ; Untuk mengelakkan kebocoran ingatan; Indeks permulaan kembali; Program Pemandu"}
{"text": "Find maximum average subarray of k length | C ++ program to find maximum average subarray of given length . ; Returns beginning index of maximum average subarray of length ' k ' ; Check if ' k ' is valid ; Compute sum of first ' k ' elements ; Compute sum of remaining subarrays ; Return starting index ; Driver program", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxAverage ( int arr [ ] , int n , int k ) { if ( k > n ) return -1 ; int sum = arr [ 0 ] ; for ( int i = 1 ; i < k ; i ++ ) sum += arr [ i ] ; int max_sum = sum , max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { int sum = sum + arr [ i ] - arr [ i - k ] ; if ( sum > max_sum ) { max_sum = sum ; max_end = i ; } } return max_end - k + 1 ; } int main ( ) { int arr [ ] = { 1 , 12 , -5 , -6 , 50 , 3 } ; int k = 4 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << \" The ▁ maximum ▁ average ▁ subarray ▁ of ▁ \" \" length ▁ \" << k << \" ▁ begins ▁ at ▁ index ▁ \" << findMaxAverage ( arr , n , k ) ; return 0 ; }", "text_ms": "Cari subarray purata maksimum K panjang | Program C ++ untuk mencari subarray purata maksimum panjang yang diberikan. ; Pulangan permulaan indeks subarray purata maksimum panjang 'k'; Semak jika 'k' sah; Mengira jumlah elemen 'k' pertama; Mengira jumlah subarray yang tinggal; Indeks permulaan kembali; Program Pemandu"}
{"text": "Minimum score possible for a player by selecting one or two consecutive array elements from given binary array | C ++ program for the above approach ; Stores the minimum score for each states as map < pair < pos , myturn > , ans > ; Function to find the minimum score after choosing element from array ; Return the stored state ; Base Case ; Player A 's turn ; Find the minimum score ; Store the current state ; Return the result ; Player B 's turn ; Find minimum score ; Store the current state ; Return the result ; Function that finds the minimum penality after choosing element from the given binary array ; Starting position of choosing element from array ; 0 denotes player A turn 1 denotes player B turn ; Function Call ; Print the answer for player A and B ; Minimum penalty ; Calculate sum of all arr elements ; Print the minimum score ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; map < pair < int , int > , int > m ; int findMinimum ( int a [ ] , int n , int pos , int myturn ) { if ( m . find ( { pos , myturn } ) != m . end ( ) ) { return m [ { pos , myturn } ] ; } if ( pos >= n ) { return 0 ; } if ( ! myturn ) { int ans = min ( findMinimum ( a , n , pos + 1 , ! myturn ) + a [ pos ] , findMinimum ( a , n , pos + 2 , ! myturn ) + a [ pos ] + a [ pos + 1 ] ) ; m [ { pos , myturn } ] = ans ; return ans ; } if ( myturn ) { int ans = min ( findMinimum ( a , n , pos + 1 , ! myturn ) , findMinimum ( a , n , pos + 2 , ! myturn ) ) ; m [ { pos , myturn } ] = ans ; return ans ; } return 0 ; } int countPenality ( int arr [ ] , int N ) { int pos = 0 ; int turn = 0 ; return findMinimum ( arr , N , pos , turn ) ; } void printAnswer ( int * arr , int N ) { int a = countPenality ( arr , N ) ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } cout << a ; } int main ( ) { int arr [ ] = { 1 , 0 , 1 , 1 , 0 , 1 , 1 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printAnswer ( arr , N ) ; return 0 ; }", "text_ms": "Skor minimum mungkin untuk pemain dengan memilih satu atau dua elemen array berturut -turut dari array binari yang diberikan | Program C ++ untuk pendekatan di atas; Menyimpan skor minimum untuk setiap negeri sebagai peta <pasangan <pos, myturn>, ans>; Berfungsi untuk mencari skor minimum selepas memilih elemen dari array; Mengembalikan keadaan yang disimpan; Kes asas; Pemain A 'S giliran; Cari skor minimum; Simpan keadaan semasa; Mengembalikan hasilnya; Pemain B 's giliran; Cari skor minimum; Simpan keadaan semasa; Mengembalikan hasilnya; Fungsi yang mendapati penalti minimum selepas memilih elemen dari array binari yang diberikan; Memulakan kedudukan memilih elemen dari array; 0 menandakan pemain A Turn 1 menandakan pemain B giliran; Panggilan fungsi; Cetak jawapan untuk Pemain A dan B; Penalti minimum; Hitung jumlah semua elemen ARR; Cetak skor minimum; Kod pemacu"}
{"text": "Sum of prime numbers in range [ L , R ] from given Array for Q queries | C ++ program for the above approach ; Function to find the prime numbers ; Create a boolean array prime [ ] and initialize all entries it as true A value in prime [ i ] will finally be false if i is Not a prime ; Check if prime [ p ] is not changed , then it is a prime ; Update all multiples of p greater than or equal to the square of it numbers which are multiple of p and are less than p ^ 2 are already been marked ; Function to get the middle index from corner indexes ; Function to get the sum of values in the given range of the array ; If segment of this node is a part of given range , then return the sum of the segment ; If segment of this node is outside the given range ; If a part of this segment overlaps with the given range ; Function to update the nodes which have the given index in their range ; If the input index lies outside the range of this segment ; If the input index is in range of this node , then update the value of the node and its children ; Function to update a value in input array and segment tree ; Check for erroneous input index ; Get the difference between new value and old value ; Update the value in array ; Update the values of nodes in segment tree only if either previous value or new value or both are prime ; If only new value is prime ; If only new value is prime ; If both are prime ; Return sum of elements in range from index qs ( query start ) to qe ( query end ) . It mainly uses getSumUtil ( ) ; Check for erroneous input values ; Function that constructs Segment Tree ; If there is one element in array , store it in current node of segment tree and return ; Only add those elements in segment tree which are prime ; If there are more than one elements , then recur for left and right subtrees and store the sum of values in this node ; Function to construct segment tree from given array ; Height of segment tree ; Maximum size of segment tree ; Allocate memory ; Fill the allocated memory st ; Return the constructed segment tree ; Driver code ; Function call ; Build segment tree from given array ; Print sum of values in array from index 1 to 3 ; Update : set arr [ 1 ] = 10 and update corresponding segment tree nodes ; Find sum after the value is updated", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int const MAX = 1000001 ; bool prime [ MAX ] ; void SieveOfEratosthenes ( ) { memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= MAX ; i += p ) prime [ i ] = false ; } } } int getMid ( int s , int e ) { return s + ( e - s ) / 2 ; } int getSumUtil ( int * st , int ss , int se , int qs , int qe , int si ) { if ( qs <= ss && qe >= se ) return st [ si ] ; if ( se < qs ss > qe ) return 0 ; int mid = getMid ( ss , se ) ; return getSumUtil ( st , ss , mid , qs , qe , 2 * si + 1 ) + getSumUtil ( st , mid + 1 , se , qs , qe , 2 * si + 2 ) ; } void updateValueUtil ( int * st , int ss , int se , int i , int diff , int si ) { if ( i < ss i > se ) return ; st [ si ] = st [ si ] + diff ; if ( se != ss ) { int mid = getMid ( ss , se ) ; updateValueUtil ( st , ss , mid , i , diff , 2 * si + 1 ) ; updateValueUtil ( st , mid + 1 , se , i , diff , 2 * si + 2 ) ; } } void updateValue ( int arr [ ] , int * st , int n , int i , int new_val ) { if ( i < 0 i > n - 1 ) { cout << \" - 1\" ; return ; } int diff = new_val - arr [ i ] ; int prev_val = arr [ i ] ; arr [ i ] = new_val ; if ( prime [ new_val ] prime [ prev_val ] ) { if ( ! prime [ prev_val ] ) updateValueUtil ( st , 0 , n - 1 , i , new_val , 0 ) ; else if ( ! prime [ new_val ] ) updateValueUtil ( st , 0 , n - 1 , i , - prev_val , 0 ) ; else updateValueUtil ( st , 0 , n - 1 , i , diff , 0 ) ; } } int getSum ( int * st , int n , int qs , int qe ) { if ( qs < 0 qe > n - 1 qs > qe ) { cout << \" - 1\" ; return -1 ; } return getSumUtil ( st , 0 , n - 1 , qs , qe , 0 ) ; } int constructSTUtil ( int arr [ ] , int ss , int se , int * st , int si ) { if ( ss == se ) { if ( prime [ arr [ ss ] ] ) st [ si ] = arr [ ss ] ; else st [ si ] = 0 ; return st [ si ] ; } int mid = getMid ( ss , se ) ; st [ si ] = constructSTUtil ( arr , ss , mid , st , si * 2 + 1 ) + constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 ) ; return st [ si ] ; } int * constructST ( int arr [ ] , int n ) { int x = ( int ) ( ceil ( log2 ( n ) ) ) ; int max_size = 2 * ( int ) pow ( 2 , x ) - 1 ; int * st = new int [ max_size ] ; constructSTUtil ( arr , 0 , n - 1 , st , 0 ) ; return st ; } int main ( ) { int arr [ ] = { 1 , 3 , 5 , 7 , 9 , 11 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int Q [ 3 ] [ 3 ] = { { 1 , 1 , 3 } , { 2 , 1 , 10 } , { 1 , 1 , 3 } } ; SieveOfEratosthenes ( ) ; int * st = constructST ( arr , n ) ; cout << getSum ( st , n , 1 , 3 ) << endl ; updateValue ( arr , st , n , 1 , 10 ) ; cout << getSum ( st , n , 1 , 3 ) << endl ; return 0 ; }", "text_ms": "Jumlah nombor utama dalam julat [l, r] dari array yang diberikan untuk pertanyaan q | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari nombor perdana; Buat Boolean Array Prime [] dan memulakan semua penyertaannya sebagai benar nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana; Semak jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan p lebih besar daripada atau sama dengan kuadrat nombor IT yang berganda p dan kurang daripada p ^ 2 telah ditandakan; Berfungsi untuk mendapatkan indeks pertengahan dari indeks sudut; Berfungsi untuk mendapatkan jumlah nilai dalam julat array yang diberikan; Jika segmen nod ini adalah sebahagian daripada julat yang diberikan, maka kembalikan jumlah segmen; Jika segmen nod ini berada di luar julat yang diberikan; Jika sebahagian daripada segmen ini bertindih dengan julat yang diberikan; Fungsi untuk mengemas kini nod yang mempunyai indeks yang diberikan dalam julatnya; Jika indeks input terletak di luar julat segmen ini; Jika indeks input berada dalam julat nod ini, maka kemas kini nilai nod dan anak -anaknya; Berfungsi untuk mengemas kini nilai dalam array input dan pokok segmen; Semak indeks input yang salah; Dapatkan perbezaan antara nilai baru dan nilai lama; Kemas kini nilai dalam array; Kemas kini nilai nod dalam pokok segmen hanya jika sama ada nilai sebelumnya atau nilai baru atau kedua -duanya adalah perdana; Jika hanya nilai baru adalah perdana; Jika hanya nilai baru adalah perdana; Jika kedua -duanya adalah perdana; Pulangan Jumlah Elemen dalam Julat dari Indeks QS (Permulaan Permintaan) ke QE (End Query). Ia terutamanya menggunakan getSumutil (); Semak nilai input yang salah; Fungsi yang membina pokok segmen; Jika terdapat satu elemen dalam array, simpannya dalam nod semasa pokok segmen dan kembali; Hanya tambah unsur -unsur dalam pokok segmen yang utama; Sekiranya terdapat lebih daripada satu elemen, maka berulang untuk subtrees kiri dan kanan dan simpan jumlah nilai dalam nod ini; Fungsi untuk membina pokok segmen dari array yang diberikan; Ketinggian pokok segmen; Saiz maksimum pokok segmen; Memperuntukkan ingatan; Isikan memori yang diperuntukkan ST; Mengembalikan pokok segmen yang dibina; Kod pemacu; Panggilan fungsi; Membina pokok segmen dari array yang diberikan; Cetak jumlah nilai dalam array dari indeks 1 hingga 3; Kemas kini: Tetapkan ARR [1] = 10 dan kemas kini nod pokok segmen yang sepadan; Cari jumlah selepas nilai dikemas kini"}
{"text": "Count the number of ways to construct the target string | C ++ Program to Count the number of ways to construct the target string ; base case ; If current subproblem has been solved , use the value ; current character ; search through all the indiced at which the current character occurs . For each index greater than prev , take the index and move to the next position , and add to the answer . ; Store and return the solution for this subproblem ; preprocess the strings by storing for each character of every string , the index of their occurrence we will use a common list for all because of only the index matter in the string from which the character was picked ; we are storing j + 1 because the initial picked index in the recursive step will ne 0. This is just for ease of implementation ; initialise dp table . - 1 represents that the subproblem hasn 't been solved ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int mod = 1000000007 ; int dp [ 1000 ] [ 1000 ] ; int calculate ( int pos , int prev , string s , vector < int > * index ) { if ( pos == s . length ( ) ) return 1 ; if ( dp [ pos ] [ prev ] != -1 ) return dp [ pos ] [ prev ] ; int c = s [ pos ] - ' a ' ; int answer = 0 ; for ( int i = 0 ; i < index . size ( ) ; i ++ ) { if ( index [ i ] > prev ) { answer = ( answer % mod + calculate ( pos + 1 , index [ i ] , s , index ) % mod ) % mod ; } } return dp [ pos ] [ prev ] = answer ; } int countWays ( vector < string > & a , string s ) { int n = a . size ( ) ; vector < int > index [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < a [ i ] . length ( ) ; j ++ ) { index [ a [ i ] [ j ] - ' a ' ] . push_back ( j + 1 ) ; } } memset ( dp , -1 , sizeof ( dp ) ) ; return calculate ( 0 , 0 , s , index ) ; } int main ( ) { vector < string > A ; A . push_back ( \" adc \" ) ; A . push_back ( \" aec \" ) ; A . push_back ( \" erg \" ) ; string S = \" ac \" ; cout << countWays ( A , S ) ; return 0 ; }", "text_ms": "Kira bilangan cara untuk membina rentetan sasaran | Program C ++ untuk mengira bilangan cara untuk membina rentetan sasaran; Kes asas; Jika subproblem semasa telah diselesaikan, gunakan nilai; watak semasa; Cari melalui semua yang ditunjukkan di mana watak semasa berlaku. Untuk setiap indeks yang lebih besar daripada sebelumnya, ambil indeks dan bergerak ke kedudukan seterusnya, dan tambahkan jawapannya. ; Simpan dan kembalikan penyelesaian untuk subproblem ini; PREPROCESS THE RINGS DENGAN MENYEDIAKAN UNTUK SETIAP KARAKTER SETIAP RENTING, INDEKS KELUARGA MEREKA KAMI AKAN MENGGUNAKAN SENARAI BERHUBUNGAN UNTUK SEMUA SETIAP HANYA SAHAJA INDEKS DALAM RENCEN DENGAN Watak dipilih; Kami menyimpan J + 1 kerana indeks yang dipilih awal dalam langkah rekursif akan NE 0. Ini hanya untuk kemudahan pelaksanaan; Inisiasi jadual DP. - 1 mewakili bahawa subproblem tidak diselesaikan; Kod pemacu"}
{"text": "Count of integers from the range [ 0 , N ] whose digit sum is a multiple of K | C ++ implementation of the approach ; To store the states of the dp ; Function to return the count of numbers from the range [ 0 , n ] whose digit sum is a multiple of k using bottom - up dp ; The digit in this index can only be from [ 0 , num [ idx ] ] ; The digit in this index can be anything from [ 0 , 9 ] ; new_tight is the flag value for the next position ; res can 't be negative ; Function to process the string to a vector of digits from MSD to LSD ; Driver code ; For large input number n ; Total number of digits in n ; Clean dp table ; Process the string to a vector of digits from MSD to LSD", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100005 NEW_LINE #define MOD  1000000007 NEW_LINE int dp [ MAX ] [ 101 ] [ 2 ] ; int countNum ( int idx , int sum , int tight , vector < int > num , int len , int k ) { if ( len == idx ) { if ( sum == 0 ) return 1 ; else return 0 ; } if ( dp [ idx ] [ sum ] [ tight ] != -1 ) return dp [ idx ] [ sum ] [ tight ] ; int res = 0 , limit ; if ( tight == 0 ) { limit = num [ idx ] ; } else { limit = 9 ; } for ( int i = 0 ; i <= limit ; i ++ ) { int new_tight = tight ; if ( tight == 0 && i < limit ) new_tight = 1 ; res += countNum ( idx + 1 , ( sum + i ) % k , new_tight , num , len , k ) ; res %= MOD ; } if ( res < 0 ) res += MOD ; return dp [ idx ] [ sum ] [ tight ] = res ; } vector < int > process ( string s ) { vector < int > num ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { num . push_back ( s [ i ] - '0' ) ; } return num ; } int main ( ) { string n = \"98765432109876543210\" ; int len = n . length ( ) ; int k = 58 ; memset ( dp , -1 , sizeof ( dp ) ) ; vector < int > num = process ( n ) ; cout << countNum ( 0 , 0 , 0 , num , len , k ) ; return 0 ; }", "text_ms": "Count of integer dari julat [0, n] yang jumlah digitnya adalah pelbagai k | C ++ pelaksanaan pendekatan; Untuk menyimpan negeri -negeri DP; Berfungsi untuk mengembalikan kiraan nombor dari julat [0, n] yang jumlah digitnya adalah pelbagai k menggunakan dp bawah; Digit dalam indeks ini hanya boleh dari [0, num [idx]]; Digit dalam indeks ini boleh menjadi apa -apa dari [0, 9]; new_tight adalah nilai bendera untuk kedudukan seterusnya; Res tidak boleh menjadi negatif; Berfungsi untuk memproses rentetan ke vektor digit dari MSD ke LSD; Kod pemacu; Untuk nombor input besar n; Jumlah bilangan digit dalam n; Jadual DP Bersih; Proses rentetan ke vektor digit dari MSD ke LSD"}
{"text": "Double Knapsack | Dynamic Programming | C ++ implementation of the above approach ; 3D array to store states of DP ; w1_r represents remaining capacity of 1 st knapsack w2_r represents remaining capacity of 2 nd knapsack i represents index of the array arr we are working on ; Base case ; Variables to store the result of three parts of recurrence relation ; Store the state in the 3D array ; Driver code ; Input array ; Initializing the array with - 1 ; Number of elements in the array ; Capacity of knapsacks ; Function to be called", "code": "#include <bits/stdc++.h> NEW_LINE #define maxN  31 NEW_LINE #define maxW  31 NEW_LINE using namespace std ; int dp [ maxN ] [ maxW ] [ maxW ] ; int maxWeight ( int * arr , int n , int w1_r , int w2_r , int i ) { if ( i == n ) return 0 ; if ( dp [ i ] [ w1_r ] [ w2_r ] != -1 ) return dp [ i ] [ w1_r ] [ w2_r ] ; int fill_w1 = 0 , fill_w2 = 0 , fill_none = 0 ; if ( w1_r >= arr [ i ] ) fill_w1 = arr [ i ] + maxWeight ( arr , n , w1_r - arr [ i ] , w2_r , i + 1 ) ; if ( w2_r >= arr [ i ] ) fill_w2 = arr [ i ] + maxWeight ( arr , n , w1_r , w2_r - arr [ i ] , i + 1 ) ; fill_none = maxWeight ( arr , n , w1_r , w2_r , i + 1 ) ; dp [ i ] [ w1_r ] [ w2_r ] = max ( fill_none , max ( fill_w1 , fill_w2 ) ) ; return dp [ i ] [ w1_r ] [ w2_r ] ; } int main ( ) { int arr [ ] = { 8 , 2 , 3 } ; memset ( dp , -1 , sizeof ( dp ) ) ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int w1 = 10 , w2 = 3 ; cout << maxWeight ( arr , n , w1 , w2 , 0 ) ; return 0 ; }", "text_ms": "Double Knapsack | Pengaturcaraan Dinamik | C ++ pelaksanaan pendekatan di atas; Arahan 3D untuk menyimpan negeri -negeri DP; W1_R mewakili kapasiti selebihnya 1 stnapsack w2_r mewakili kapasiti selebihnya 2 nd knapsack I mewakili indeks array arr yang kami sedang kerjakan; Kes asas; Pembolehubah untuk menyimpan hasil tiga bahagian hubungan berulang; Simpan negeri dalam array 3d; Kod pemacu; Arahan input; Memulakan array dengan - 1; Bilangan elemen dalam array; Kapasiti knapsacks; Berfungsi untuk dipanggil"}
{"text": "Sum of bitwise AND of all submatrices | C ++ program to find sum of Bit - wise AND of all submatrices ; Function to find prefix - count for each row from right to left ; Function to find the number of submatrices with all 1 s ; Array to store required prefix count of 1 s from right to left for boolean array ; Variable to store the final answer ; For each index of a column , determine the number of sub - matrices starting from that index and has all 1 s ; Stack to store elements and the count of the numbers they popped First part of pair is value of inserted element Second part is count of the number of elements pushed before with a greater value ; variable to store the number of submatrices with all 1 s ; Function to find the sum of Bitwise - AND of all submatrices ; matrix to store the status of ith bit of each element of matrix arr ; Driver Code", "code": "#include <iostream> NEW_LINE #include <stack> NEW_LINE using namespace std ; #define n  3 NEW_LINE void findPrefixCount ( int p_arr [ ] [ n ] , bool set_bit [ ] [ n ] ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = n - 1 ; j >= 0 ; j -- ) { if ( ! set_bit [ i ] [ j ] ) continue ; if ( j != n - 1 ) p_arr [ i ] [ j ] += p_arr [ i ] [ j + 1 ] ; p_arr [ i ] [ j ] += ( int ) set_bit [ i ] [ j ] ; } } } int matrixAllOne ( bool set_bit [ ] [ n ] ) { int p_arr [ n ] [ n ] = { 0 } ; findPrefixCount ( p_arr , set_bit ) ; int ans = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int i = n - 1 ; stack < pair < int , int > > q ; int to_sum = 0 ; while ( i >= 0 ) { int c = 0 ; while ( q . size ( ) != 0 and q . top ( ) . first > p_arr [ i ] [ j ] ) { to_sum -= ( q . top ( ) . second + 1 ) * ( q . top ( ) . first - p_arr [ i ] [ j ] ) ; c += q . top ( ) . second + 1 ; q . pop ( ) ; } to_sum += p_arr [ i ] [ j ] ; ans += to_sum ; q . push ( { p_arr [ i ] [ j ] , c } ) ; i -- ; } } return ans ; } int sumAndMatrix ( int arr [ ] [ n ] ) { int sum = 0 ; int mul = 1 ; for ( int i = 0 ; i < 30 ; i ++ ) { bool set_bit [ n ] [ n ] ; for ( int R = 0 ; R < n ; R ++ ) for ( int C = 0 ; C < n ; C ++ ) set_bit [ R ] [ C ] = ( ( arr [ R ] [ C ] & ( 1 << i ) ) != 0 ) ; sum += ( mul * matrixAllOne ( set_bit ) ) ; mul *= 2 ; } return sum ; } int main ( ) { int arr [ ] [ n ] = { { 9 , 7 , 4 } , { 8 , 9 , 2 } , { 11 , 11 , 5 } } ; cout << sumAndMatrix ( arr ) ; return 0 ; }", "text_ms": "Jumlah bitwise dan semua submatrices | Program C ++ untuk mencari jumlah bit - bijak dan semua submatrik; Berfungsi untuk mencari awalan - kiraan untuk setiap baris dari kanan ke kiri; Berfungsi untuk mencari bilangan submatrik dengan semua 1 s; Array untuk menyimpan kiraan awalan yang diperlukan 1 s dari kanan ke kiri untuk array boolean; Pembolehubah untuk menyimpan jawapan terakhir; Untuk setiap indeks lajur, tentukan bilangan sub -matriks bermula dari indeks itu dan mempunyai semua 1 s; Stack untuk menyimpan unsur -unsur dan kiraan nombor yang mereka muncul bahagian pertama pasangan adalah nilai elemen yang dimasukkan bahagian kedua adalah mengira bilangan elemen yang ditolak sebelum dengan nilai yang lebih besar; pembolehubah untuk menyimpan bilangan submatrik dengan semua 1 s; Berfungsi untuk mencari jumlah bitwise - dan semua submatrices; matriks untuk menyimpan status ith bit setiap elemen matriks arr; Kod pemacu"}
{"text": "Count ways to reach a score using 1 and 2 with no consecutive 2 s | Bottom up approach for counting ways to reach a score using 1 and 2 with consecutive 2 allowed ; noOfWays [ i ] will store count for last 3 values before i . ; Loop till \" n + 1\" to compute value for \" n \" ; number of ways if first run is 1 ; number of ways if first run is 2 and second run is 1 ; Remember last 3 values ; Driver code", "code": "#include <iostream> NEW_LINE using namespace std ; int CountWays ( int n ) { int noOfWays [ 3 ] ; noOfWays [ 0 ] = 1 ; noOfWays [ 1 ] = 1 ; noOfWays [ 2 ] = 1 + 1 ; for ( int i = 3 ; i < n + 1 ; i ++ ) { noOfWays [ i ] = noOfWays [ 3 - 1 ] + noOfWays [ 3 - 3 ] ; noOfWays [ 0 ] = noOfWays [ 1 ] ; noOfWays [ 1 ] = noOfWays [ 2 ] ; noOfWays [ 2 ] = noOfWays [ i ] ; } return noOfWays [ n ] ; } int main ( ) { int n = 5 ; cout << CountWays ( n ) ; return 0 ; }", "text_ms": "Kira cara untuk mencapai skor menggunakan 1 dan 2 tanpa berturut -turut 2 S | Pendekatan bawah untuk mengira cara untuk mencapai skor menggunakan 1 dan 2 dengan berturut -turut 2 dibenarkan; Noofways [i] akan menyimpan kiraan untuk 3 nilai terakhir sebelum i. ; Gelung hingga \"n + 1\" untuk mengira nilai untuk \"n\"; bilangan cara jika larian pertama adalah 1; Bilangan cara jika larian pertama adalah 2 dan larian kedua ialah 1; Ingat 3 nilai terakhir; Kod pemacu"}
{"text": "Lexicographically largest prime path from top | C ++ implementation of above approach ; Depth First Search ; Return if cell contain non prime number or obstacle , or going out of matrix or already visited the cell or already found the lexicographical largest path ; marking cell is already visited ; storing the lexicographical largest path index ; if reached the end of the matrix ; updating the final number of steps in lexicographical largest path ; moving diagonal ( trying lexicographical largest path ) ; moving cell right to current cell ; moving cell down to current cell . ; Print lexicographical largest prime path ; to count the number of step in lexicographical largest prime path ; to store the lexicographical largest prime path index ; to mark if the cell is already traversed or not ; traversing by DFS ; printing the lexicographical largest prime path ; Return the number of prime path in ther matrix . ; for each cell ; If on the top row or leftmost column , there is no path there . ; If non prime number ; Finding the matrix mapping by considering non prime number as obstacle and prime number be valid path . ; Sieve ; If prime ; if non prime ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  105 NEW_LINE void sieve ( int prime [ ] ) { for ( int i = 2 ; i * i <= MAX ; i ++ ) { if ( prime [ i ] == 0 ) { for ( int j = i * i ; j <= MAX ; j += i ) prime [ j ] = 1 ; } } } void dfs ( int i , int j , int k , int * q , int n , int m , int mappedMatrix [ ] [ MAX ] , int mark [ ] [ MAX ] , pair < int , int > ans [ ] ) { if ( mappedMatrix [ i ] [ j ] == 0 || i > n || j > m || mark [ i ] [ j ] || ( * q ) ) return ; mark [ i ] [ j ] = 1 ; ans [ k ] = make_pair ( i , j ) ; if ( i == n && j == m ) { ( * q ) = k ; return ; } dfs ( i + 1 , j + 1 , k + 1 , q , n , m , mappedMatrix , mark , ans ) ; dfs ( i + 1 , j , k + 1 , q , n , m , mappedMatrix , mark , ans ) ; dfs ( i , j + 1 , k + 1 , q , n , m , mappedMatrix , mark , ans ) ; } void lexicographicalPath ( int n , int m , int mappedMatrix [ ] [ MAX ] ) { int q = 0 ; pair < int , int > ans [ MAX ] ; int mark [ MAX ] [ MAX ] ; dfs ( 1 , 1 , 1 , & q , n , m , mappedMatrix , mark , ans ) ; for ( int i = 1 ; i <= q ; i ++ ) cout << ans [ i ] . first << \" ▁ \" << ans [ i ] . second << \" STRNEWLINE \" ; } void countPrimePath ( int mappedMatrix [ ] [ MAX ] , int n , int m ) { int dp [ MAX ] [ MAX ] = { 0 } ; dp [ 1 ] [ 1 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( i == 1 && j == 1 ) continue ; dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ) ; if ( mappedMatrix [ i ] [ j ] == 0 ) dp [ i ] [ j ] = 0 ; } } cout << dp [ n ] [ m ] << \" STRNEWLINE \" ; } void preprocessMatrix ( int mappedMatrix [ ] [ MAX ] , int a [ ] [ MAX ] , int n , int m ) { int prime [ MAX ] ; sieve ( prime ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( prime [ a [ i ] [ j ] ] == 0 ) mappedMatrix [ i + 1 ] [ j + 1 ] = 1 ; else mappedMatrix [ i + 1 ] [ j + 1 ] = 0 ; } } } int main ( ) { int n = 3 ; int m = 3 ; int a [ MAX ] [ MAX ] = { { 2 , 3 , 7 } , { 5 , 4 , 2 } , { 3 , 7 , 11 } } ; int mappedMatrix [ MAX ] [ MAX ] = { 0 } ; preprocessMatrix ( mappedMatrix , a , n , m ) ; countPrimePath ( mappedMatrix , n , m ) ; lexicographicalPath ( n , m , mappedMatrix ) ; return 0 ; }", "text_ms": "Laluan Perdana Lexicographically terbesar dari atas | C ++ pelaksanaan pendekatan di atas; Carian pertama kedalaman; Kembali jika sel mengandungi nombor bukan perdana atau halangan, atau keluar dari matriks atau sudah melawat sel atau sudah menemui jalan terbesar leksikografi; Penandaan sel sudah dikunjungi; menyimpan indeks laluan terbesar leksikografi; jika sampai ke akhir matriks; mengemas kini bilangan akhir langkah dalam laluan terbesar leksikografi; bergerak pepenjuru (mencuba laluan terbesar leksikografi); menggerakkan sel ke sel semasa; bergerak sel ke sel semasa. ; Cetak jalan utama lexicographical terbesar; untuk mengira bilangan langkah dalam laluan utama terbesar leksikografi; untuk menyimpan indeks jalan utama terbesar lexicographical; untuk menandakan jika sel sudah dilalui atau tidak; melintasi DFS; mencetak laluan utama terbesar lexicographical; Kembalikan bilangan jalan utama dalam matriks. ; untuk setiap sel; Jika di barisan atas atau lajur paling kiri, tidak ada jalan di sana. ; Jika nombor bukan perdana; Mencari pemetaan matriks dengan mempertimbangkan nombor bukan perdana sebagai halangan dan nombor utama menjadi laluan yang sah. ; Ayak; Jika Perdana; jika bukan Perdana; Kod pemacu"}
{"text": "Maximum size subset with given sum | A Dynamic Programming solution for subset sum problem + maximal subset value . ; Returns size of maximum sized subset if there is a subset of set [ ] with sun equal to given sum . It returns - 1 if there is no subset with given sum . ; The value of subset [ i ] [ j ] will be true if there is a subset of set [ 0. . j - 1 ] with sum equal to i ; If sum is 0 , then answer is true ; If sum is not 0 and set is empty , then answer is false ; Fill the subset table in bottom up manner ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int isSubsetSum ( int set [ ] , int n , int sum ) { bool subset [ sum + 1 ] [ n + 1 ] ; int count [ sum + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { subset [ 0 ] [ i ] = true ; count [ 0 ] [ i ] = 0 ; } for ( int i = 1 ; i <= sum ; i ++ ) { subset [ i ] [ 0 ] = false ; count [ i ] [ 0 ] = -1 ; } for ( int i = 1 ; i <= sum ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { subset [ i ] [ j ] = subset [ i ] [ j - 1 ] ; count [ i ] [ j ] = count [ i ] [ j - 1 ] ; if ( i >= set [ j - 1 ] ) { subset [ i ] [ j ] = subset [ i ] [ j ] || subset [ i - set [ j - 1 ] ] [ j - 1 ] ; if ( subset [ i ] [ j ] ) count [ i ] [ j ] = max ( count [ i ] [ j - 1 ] , count [ i - set [ j - 1 ] ] [ j - 1 ] + 1 ) ; } } } return count [ sum ] [ n ] ; } int main ( ) { int set [ ] = { 2 , 3 , 5 , 10 } ; int sum = 20 ; int n = 4 ; cout << isSubsetSum ( set , n , sum ) ; }", "text_ms": "Subset saiz maksimum dengan jumlah yang diberikan | Penyelesaian pengaturcaraan dinamik untuk masalah jumlah subset + nilai subset maksimal. ; Pulangan saiz subset bersaiz maksimum jika terdapat subset set [] dengan matahari sama dengan jumlah yang diberikan. Ia kembali - 1 jika tidak ada subset dengan jumlah yang diberikan. ; Nilai subset [i] [j] akan benar jika terdapat subset set [0 .. J - 1] dengan jumlah sama dengan i; Jika jumlah adalah 0, maka jawapannya benar; Jika jumlah tidak 0 dan ditetapkan kosong, maka jawapannya palsu; Isi jadual subset dengan cara bawah; Kod pemacu"}
{"text": "Print all longest common sub | C ++ program to find all LCS of two strings in sorted order . ; length of lcs ; dp matrix to store result of sub calls for lcs ; A memoization based function that returns LCS of str1 [ i . . len1 - 1 ] and str2 [ j . . len2 - 1 ] ; base condition ; if lcs has been computed ; if characters are same return previous + 1 else max of two sequences after removing i ' th ▁ and ▁ j ' th char one by one ; Function to print all routes common sub - sequences of length lcslen ; if currlcs is equal to lcslen then print it ; if we are done with all the characters of both string ; here we have to print all sub - sequences lexicographically , that ' s ▁ why ▁ we ▁ start ▁ from ▁ ' a ' to ' z ' if this character is  present in both of them then append it in data[] and same  remaining part ; done is a flag to tell that we have printed all the subsequences corresponding to current character ; if character ch is present in str1 then check if it is present in str2 ; if ch is present in both of them and remaining length is equal to remaining lcs length then add ch in sub - sequenece ; If we found LCS beginning with current character . ; This function prints all LCS of str1 and str2 in lexicographic order . ; Find lengths of both strings ; Find length of LCS ; Print all LCS using recursive backtracking data [ ] is used to store individual LCS . ; Driver program to run the case", "code": "#include <bits/stdc++.h> NEW_LINE #define MAX  100 NEW_LINE using namespace std ; int lcslen = 0 ; int dp [ MAX ] [ MAX ] ; int lcs ( string str1 , string str2 , int len1 , int len2 , int i , int j ) { int & ret = dp [ i ] [ j ] ; if ( i == len1 j == len2 ) return ret = 0 ; if ( ret != -1 ) return ret ; ret = 0 ; if ( str1 [ i ] == str2 [ j ] ) ret = 1 + lcs ( str1 , str2 , len1 , len2 , i + 1 , j + 1 ) ; else ret = max ( lcs ( str1 , str2 , len1 , len2 , i + 1 , j ) , lcs ( str1 , str2 , len1 , len2 , i , j + 1 ) ) ; return ret ; } void printAll ( string str1 , string str2 , int len1 , int len2 , char data [ ] , int indx1 , int indx2 , int currlcs ) { if ( currlcs == lcslen ) { data [ currlcs ] = ' \\0' ; puts ( data ) ; return ; } if ( indx1 == len1 indx2 == len2 ) return ; for ( char ch = ' a ' ; ch <= ' z ' ; ch ++ ) { bool done = false ; for ( int i = indx1 ; i < len1 ; i ++ ) { if ( ch == str1 [ i ] ) { for ( int j = indx2 ; j < len2 ; j ++ ) { if ( ch == str2 [ j ] && dp [ i ] [ j ] == lcslen - currlcs ) { data [ currlcs ] = ch ; printAll ( str1 , str2 , len1 , len2 , data , i + 1 , j + 1 , currlcs + 1 ) ; done = true ; break ; } } } if ( done ) break ; } } } void prinlAllLCSSorted ( string str1 , string str2 ) { int len1 = str1 . length ( ) , len2 = str2 . length ( ) ; memset ( dp , -1 , sizeof ( dp ) ) ; lcslen = lcs ( str1 , str2 , len1 , len2 , 0 , 0 ) ; char data [ MAX ] ; printAll ( str1 , str2 , len1 , len2 , data , 0 , 0 , 0 ) ; } int main ( ) { string str1 = \" abcabcaa \" , str2 = \" acbacba \" ; prinlAllLCSSorted ( str1 , str2 ) ; return 0 ; }", "text_ms": "Cetak semua sub biasa terpanjang | Program C ++ untuk mencari semua LCS dua rentetan dalam urutan yang disusun. ; panjang LCS; Matriks DP untuk menyimpan hasil sub panggilan untuk LCS; Fungsi berasaskan memoisasi yang mengembalikan LCS STR1 [i. . len1 - 1] dan str2 [j. . len2 - 1]; keadaan asas; Jika LCS telah dikira; Jika watak -watak yang sama pulangan sebelumnya + 1 lain max dua urutan selepas mengeluarkan i 'th »dan u' th char satu demi satu; Berfungsi untuk mencetak semua laluan sub - urutan panjang lcslen panjang; Jika currlcs sama dengan lcslen maka cetaknya; Jika kita selesai dengan semua watak kedua -dua rentetan; Di sini kita perlu mencetak semua sub -urutan secara lexicographically, bahawa mengapa kita mula dari 'a' ke 'z' jika watak ini hadir dalam kedua -dua mereka kemudian menambahnya dalam data [] dan bahagian yang sama; Selesai adalah bendera untuk memberitahu bahawa kami telah mencetak semua berikutnya yang sepadan dengan watak semasa; Jika watak CH hadir dalam STR1 maka periksa sama ada ia terdapat dalam STR2; Jika CH hadir dalam kedua -dua mereka dan baki panjang adalah sama dengan panjang LCS yang tinggal kemudian tambah CH dalam sub -sequenece; Jika kami mendapati LCS bermula dengan watak semasa. ; Fungsi ini mencetak semua LCS Str1 dan Str2 dalam urutan leksikografi. ; Cari panjang kedua -dua rentetan; Cari panjang LCS; Cetak semua LCS menggunakan data backtracking rekursif [] digunakan untuk menyimpan LCS individu. ; Program pemacu untuk menjalankan kes itu"}
{"text": "Check for Majority Element in a sorted array | C ++ Program to check for majority element in a sorted array ; get last index according to n ( even or odd ) ; search for first occurrence of x in arr [ ] ; check if x is present and is present more than n / 2 times ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isMajority ( int arr [ ] , int n , int x ) { int i ; int last_index = n % 2 ? ( n / 2 + 1 ) : ( n / 2 ) ; for ( i = 0 ; i < last_index ; i ++ ) { if ( arr [ i ] == x && arr [ i + n / 2 ] == x ) return 1 ; } return 0 ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 4 , 4 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 4 ; if ( isMajority ( arr , n , x ) ) cout << x << \" ▁ appears ▁ more ▁ than ▁ \" << n / 2 << \" ▁ times ▁ in ▁ arr [ ] \" << endl ; else cout << x << \" ▁ does ▁ not ▁ appear ▁ more ▁ than \" << n / 2 << \" ▁ times ▁ in ▁ arr [ ] \" << endl ; return 0 ; }", "text_ms": "Semak elemen majoriti dalam array yang disusun | Program C ++ untuk memeriksa elemen majoriti dalam array yang disusun; Dapatkan indeks terakhir mengikut N (walaupun atau ganjil); Cari kejadian pertama x dalam arr []; Semak jika X hadir dan hadir lebih daripada n / 2 kali; Kod pemacu"}
{"text": "Check for Majority Element in a sorted array | C ++ program to check for majority element in a sorted array ; If x is present in arr [ low ... high ] then returns the index of first occurrence of x , otherwise returns - 1 ; Check if arr [ mid ] is the first occurrence of x . arr [ mid ] is first occurrence if x is one of the following is true : ( i ) mid == 0 and arr [ mid ] = = x ( ii ) arr [ mid - 1 ] < x and arr [ mid ] == x ; This function returns true if the x is present more than n / 2 times in arr [ ] of size n ; Find the index of first occurrence of x in arr [ ] ; If element is not present at all , return false ; Check if the element is present more than n / 2 times ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int _binarySearch ( int arr [ ] , int low , int high , int x ) { if ( high >= low ) { int mid = ( low + high ) / 2 ; if ( ( mid == 0 x > arr [ mid - 1 ] ) && ( arr [ mid ] == x ) ) return mid ; else if ( x > arr [ mid ] ) return _binarySearch ( arr , ( mid + 1 ) , high , x ) ; else return _binarySearch ( arr , low , ( mid - 1 ) , x ) ; } return -1 ; } bool isMajority ( int arr [ ] , int n , int x ) { int i = _binarySearch ( arr , 0 , n - 1 , x ) ; if ( i == -1 ) return false ; if ( ( ( i + n / 2 ) <= ( n - 1 ) ) && arr [ i + n / 2 ] == x ) return true ; else return false ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 3 , 3 , 3 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 3 ; if ( isMajority ( arr , n , x ) ) cout << x << \" ▁ appears ▁ more ▁ than ▁ \" << n / 2 << \" ▁ times ▁ in ▁ arr [ ] \" << endl ; else cout << x << \" ▁ does ▁ not ▁ appear ▁ more ▁ than \" << n / 2 << \" ▁ times ▁ in ▁ arr [ ] \" << endl ; return 0 ; }", "text_ms": "Semak elemen majoriti dalam array yang disusun | Program C ++ untuk memeriksa elemen majoriti dalam array yang disusun; Jika x hadir dalam arr [rendah ... tinggi] maka mengembalikan indeks kejadian pertama x, jika tidak pulangan - 1; Semak jika ARR [MID] adalah kejadian pertama x. arr [pertengahan] adalah kejadian pertama jika x adalah salah satu daripada yang berikut adalah benar: (i) pertengahan == 0 dan arr [mid] = = x (ii) arr [pertengahan - 1] <x dan arr [mid] == x; Fungsi ini kembali benar jika x hadir lebih daripada n / 2 kali dalam arr [] saiz n; Cari indeks kejadian pertama x dalam arr []; Jika elemen tidak hadir sama sekali, kembali palsu; Semak jika elemen hadir lebih daripada n / 2 kali; Kod pemacu"}
{"text": "Check for Majority Element in a sorted array |  ;", "code": "#include <iostream> NEW_LINE using namespace std ; bool isMajorityElement ( int arr [ ] , int n , int key ) { if ( arr [ n / 2 ] == key ) return true ; else return false ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 3 , 3 , 3 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 3 ; if ( isMajorityElement ( arr , n , x ) ) cout << x << \" ▁ appears ▁ more ▁ than ▁ \" << n / 2 << \" ▁ times ▁ in ▁ arr [ ] \" << endl ; else cout << x << \" ▁ does ▁ not ▁ appear ▁ more ▁ than \" << n / 2 << \" ▁ times ▁ in ▁ arr [ ] \" << endl ; return 0 ; }", "text_ms": "Semak elemen majoriti dalam array yang disusun |  ;"}
{"text": "Cutting a Rod | DP | A Dynamic Programming solution for Rod cutting problem ; A utility function to get the maximum of two integers ; Returns the best obtainable price for a rod of length n and price [ ] as prices of different pieces ; Build the table val [ ] in bottom up manner and return the last entry from the table ; Driver program to test above functions", "code": "#include <iostream> NEW_LINE #include <bits/stdc++.h> NEW_LINE #include <math.h> NEW_LINE using namespace std ; int max ( int a , int b ) { return ( a > b ) ? a : b ; } int cutRod ( int price [ ] , int n ) { int val [ n + 1 ] ; val [ 0 ] = 0 ; int i , j ; for ( i = 1 ; i <= n ; i ++ ) { int max_val = INT_MIN ; for ( j = 0 ; j < i ; j ++ ) max_val = max ( max_val , price [ j ] + val [ i - j - 1 ] ) ; val [ i ] = max_val ; } return val [ n ] ; } int main ( ) { int arr [ ] = { 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << \" Maximum ▁ Obtainable ▁ Value ▁ is ▁ \" << cutRod ( arr , size ) ; getchar ( ) ; return 0 ; }", "text_ms": "Memotong batang | DP | Penyelesaian pengaturcaraan dinamik untuk masalah pemotongan rod; Fungsi utiliti untuk mendapatkan maksimum dua bilangan bulat; Mengembalikan harga terbaik yang boleh diperolehi untuk rod panjang n dan harga [] sebagai harga kepingan yang berbeza; Bina jadual Val [] dengan cara bawah dan kembalikan entri terakhir dari jadual; Program pemacu untuk menguji fungsi di atas"}
{"text": "Cutting a Rod | DP | CPP program for above approach ; Global Array for the purpose of memoization . ; A recursive program , using , memoization , to implement the rod cutting problem ( Top - Down ) . ; The maximum price will be zero , when either the length of the rod is zero or price is zero . ; If the length of the rod is less than the maximum length , Max_lene will consider it . Now depending upon the profit , either Max_lene we will take it or discard it . ; If the length of the rod is greater than the permitted size , Max_len we will not consider it . ; Max_lene Max_lenill return the maximum value obtained , Max_lenhich is present at the nth roMax_len and Max_lenth column . ; Driver program to test above functions ; Function Call", "code": "#include <iostream> NEW_LINE using namespace std ; int t [ 9 ] [ 9 ] ; int un_kp ( int price [ ] , int length [ ] , int Max_len , int n ) { if ( n == 0 Max_len == 0 ) { return 0 ; } if ( length [ n - 1 ] <= Max_len ) { t [ n ] [ Max_len ] = max ( price [ n - 1 ] + un_kp ( price , length , Max_len - length [ n - 1 ] , n ) , un_kp ( price , length , Max_len , n - 1 ) ) ; } else { t [ n ] [ Max_len ] = un_kp ( price , length , Max_len , n - 1 ) ; } return t [ n ] [ Max_len ] ; } int main ( ) { int price [ ] = { 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 } ; int n = sizeof ( price ) / sizeof ( price [ 0 ] ) ; int length [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { length [ i ] = i + 1 ; } int Max_len = n ; cout << \" Maximum ▁ obtained ▁ value ▁ is ▁ \" << un_kp ( price , length , n , Max_len ) << endl ; }", "text_ms": "Memotong batang | DP | Program CPP untuk pendekatan di atas; Arahan global untuk tujuan memoisasi. ; Program rekursif, menggunakan, memoisasi, untuk melaksanakan masalah pemotongan rod (atas - ke bawah). ; Harga maksimum akan menjadi sifar, apabila panjang rod adalah sifar atau harga adalah sifar. ; Jika panjang rod kurang daripada panjang maksimum, max_lene akan menganggapnya. Sekarang bergantung kepada keuntungan, sama ada max_lene kita akan mengambilnya atau membuangnya. ; Jika panjang rod lebih besar daripada saiz yang dibenarkan, max_len kita tidak akan menganggapnya. ; Max_lene max_lenill Kembalikan nilai maksimum yang diperoleh, max_lenhich hadir di lajur nth romax_len dan max_lenth. ; Program pemacu untuk menguji fungsi di atas; Panggilan fungsi"}
{"text": "Modify array to another given array by replacing array elements with the sum of the array | CPP program to implement the above approach ; Function to check if the arr [ ] can be converted to target [ ] by replacing any element in arr [ ] by the sum of arr [ ] ; Store the maximum element ; Store the index of the maximum element ; Traverse the array target [ ] ; If current element is greater than max ; If max element is 1 ; Traverse the array , target [ ] ; If current index is not equal to maximum element index ; Update max ; If max is less than or equal to 0 , ; Update the maximum element ; Recursively call the function ; Driver Code ; Size of the array", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPossible ( int target [ ] , int n ) { int max = 0 ; int index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( max < target [ i ] ) { max = target [ i ] ; index = i ; } } if ( max == 1 ) return true ; for ( int i = 0 ; i < n ; i ++ ) { if ( i != index ) { max -= target [ i ] ; if ( max <= 0 ) return false ; } } target [ index ] = max ; return isPossible ( target , n ) ; } int main ( ) { int target [ ] = { 9 , 3 , 5 } ; int n = sizeof ( target ) / sizeof ( target [ 0 ] ) ; bool res = isPossible ( target , n ) ; if ( res ) { cout << \" YES \" ; } else { cout << \" NO \" ; } return 0 ; }", "text_ms": "Ubah suai array ke array lain yang diberikan dengan menggantikan elemen array dengan jumlah array | Program CPP untuk melaksanakan pendekatan di atas; Fungsi untuk memeriksa sama ada arr [] boleh ditukar kepada sasaran [] dengan menggantikan mana -mana elemen dalam arr [] dengan jumlah arr []; Simpan elemen maksimum; Simpan indeks elemen maksimum; Melintasi sasaran array []; Jika elemen semasa lebih besar daripada maks; Jika elemen max adalah 1; Melintasi array, sasaran []; Jika indeks semasa tidak sama dengan indeks elemen maksimum; Kemas kini Max; Jika max kurang daripada atau sama dengan 0 ,; Mengemas kini elemen maksimum; Memanggil semula fungsi secara rekursif; Kod pemacu; Saiz array"}
{"text": "Sum of all products of the Binomial Coefficients of two numbers up to K | C ++ implementation of the above approach ; Function returns nCr i . e . Binomial Coefficient ; Initialize res with 1 ; Since C ( n , r ) = C ( n , n - r ) ; Evaluating expression ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int nCr ( int n , int r ) { int res = 1 ; if ( r > n - r ) r = n - r ; for ( int i = 0 ; i < r ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } int main ( ) { int n = 3 , m = 2 , k = 2 ; cout << nCr ( n + m , k ) ; return 0 ; }", "text_ms": "Jumlah semua produk koefisien binomial dua nombor sehingga k | C ++ pelaksanaan pendekatan di atas; Fungsi mengembalikan NCR i. e. Pekali binomial; Memulakan res dengan 1; Kerana c (n, r) = c (n, n - r); Menilai ungkapan; Kod pemacu"}
{"text": "Check if N can be obtained from 1 by repetitively multiplying by 10 or 20 | C ++ program to check if N can be obtained from 1 by repetitive multiplication by 10 or 20 ; Function to check if N can be obtained or not ; Count and remove trailing zeroes ; Check if remaining N is a power of 2 ; To check the condition to print YES or NO ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void Is_possible ( long long int N ) { int C = 0 ; int D = 0 ; while ( N % 10 == 0 ) { N = N / 10 ; C += 1 ; } if ( pow ( 2 , ( int ) log2 ( N ) ) == N ) { D = ( int ) log2 ( N ) ; if ( C >= D ) cout << \" YES \" ; else cout << \" NO \" ; } else cout << \" NO \" ; } int main ( ) { long long int N = 2000000000000 ; Is_possible ( N ) ; }", "text_ms": "Semak jika n boleh didapati dari 1 dengan mengulangi secara berulang dengan 10 atau 20 | Program C ++ untuk memeriksa sama ada n boleh diperolehi dari 1 dengan pendaraban berulang sebanyak 10 atau 20; Fungsi untuk memeriksa sama ada n boleh diperoleh atau tidak; Mengira dan mengeluarkan sifar trailing; Semak jika baki N adalah kuasa 2; Untuk memeriksa keadaan untuk mencetak ya atau tidak; Kod pemacu"}
{"text": "Central polygonal numbers | C ++ program to find N - th term in the series ; Function to find N - th term in the series ; Driver code", "code": "#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; void findNthTerm ( int n ) { cout << n * n - n + 1 << endl ; } int main ( ) { int N = 4 ; findNthTerm ( N ) ; return 0 ; }", "text_ms": "Nombor Poligonal Tengah | Program C ++ untuk mencari istilah N - Th dalam siri ini; Fungsi untuk mencari istilah n - th dalam siri ini; Kod pemacu"}
{"text": "Anti | C ++ program for the above approach ; Iterative function to reverse digits of num ; Return the reversed num ; Function to calculate sum of reverse all proper divisors ; Final result of summation of divisors ; Find all divisors of num ; If ' i ' is divisor of ' num ' ; If both divisors are same then add it only once else add both ; Add 1 to the result as 1 is also a divisor ; Function to check if N is anti - perfect or not ; Driver Code ; Given Number N ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int rev ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; } int divSum ( int num ) { int result = 0 ; for ( int i = 2 ; i <= sqrt ( num ) ; i ++ ) { if ( num % i == 0 ) { if ( i == ( num / i ) ) result += rev ( i ) ; else result += ( rev ( i ) + rev ( num / i ) ) ; } } return ( result + 1 ) ; } bool isAntiPerfect ( int n ) { return divSum ( n ) == n ; } int main ( ) { int N = 244 ; if ( isAntiPerfect ( N ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "text_ms": "Anti | Program C ++ untuk pendekatan di atas; Fungsi berulang untuk membalikkan digit NUM; Mengembalikan nombor terbalik; Fungsi untuk mengira jumlah pembalikan semua pembahagi yang betul; Hasil akhir penjumlahan pembahagi; Cari semua pembahagi Num; Jika 'saya' adalah pembahagi 'num'; Jika kedua -dua pembahagi adalah sama maka tambahkannya hanya sekali lagi, tambah kedua -duanya; Tambah 1 kepada keputusan sebagai 1 juga pembahagi; Fungsi untuk memeriksa sama ada n adalah anti - sempurna atau tidak; Kod pemacu; Diberi nombor n; Panggilan fungsi"}
{"text": "Program to print the series 1 , 3 , 4 , 8 , 15 , 27 , 50 â €¦ till N terms | C ++ implementation to print the N terms of the series whose three terms are given ; Function to print the series ; Generate the ith term and print it ; Driver Code ; Function Call", "code": "#include \" bits / stdc + + . h \" NEW_LINE using namespace std ; void printSeries ( int n , int a , int b , int c ) { int d ; if ( n == 1 ) { cout << a << \" ▁ \" ; return ; } if ( n == 2 ) { cout << a << \" ▁ \" << b << \" ▁ \" ; return ; } cout << a << \" ▁ \" << b << \" ▁ \" << c << \" ▁ \" ; for ( int i = 4 ; i <= n ; i ++ ) { d = a + b + c ; cout << d << \" ▁ \" ; a = b ; b = c ; c = d ; } } int main ( ) { int N = 7 , a = 1 , b = 3 ; int c = 4 ; printSeries ( N , a , b , c ) ; return 0 ; }", "text_ms": "Program untuk mencetak Siri 1, 3, 4, 8, 15, 27, 50 â € | Sehingga N Syarat | Pelaksanaan C ++ untuk mencetak istilah N siri yang tiga istilahnya diberikan; Berfungsi untuk mencetak siri; Menjana istilah ith dan mencetaknya; Kod pemacu; Panggilan fungsi"}
{"text": "Diameter of a Binary Indexed Tree with N nodes |  ; Function to find diameter of BIT with N + 1 nodes ; L is size of subtree just before subtree in which N lies ; H is the height of subtree just before subtree in which N lies ; Base Cases ; Size of subtree are power of 2 ; 3 Cases as explained in Approach ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int diameter ( int n ) { int L , H , templen ; L = 1 ; H = 0 ; if ( n == 1 ) { return 1 ; } if ( n == 2 ) { return 2 ; } if ( n == 3 ) { return 3 ; } while ( L * 2 <= n ) { L *= 2 ; H ++ ; } if ( n >= L * 2 - 1 ) return 2 * H + 1 ; else if ( n >= L + ( L / 2 ) - 1 ) return 2 * H ; return 2 * H - 1 ; } int main ( ) { int n = 15 ; cout << diameter ( n ) << endl ; }", "text_ms": "Diameter pokok terindeks binari dengan nod n |  ; Berfungsi untuk mencari diameter bit dengan n + 1 nod; L adalah saiz subtree sebelum subtree di mana n terletak; H ialah ketinggian subtree sebelum subtree di mana n terletak; Kes asas; Saiz subtree adalah kuasa 2; 3 kes seperti yang dijelaskan dalam pendekatan; Kod pemacu"}
{"text": "Find the larger exponential among two exponentials | C ++ implementation of the approach ; Function to find whether a ^ b is greater or c ^ d ; Find b * log ( a ) ; Find d * log ( c ) ; Compare both values ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void compareValues ( int a , int b , int c , int d ) { double log1 = log10 ( a ) ; double num1 = log1 * b ; double log2 = log10 ( c ) ; double num2 = log2 * d ; if ( num1 > num2 ) cout << a << \" ^ \" << b ; else cout << c << \" ^ \" << d ; } int main ( ) { int a = 8 , b = 29 , c = 60 , d = 59 ; compareValues ( a , b , c , d ) ; }", "text_ms": "Cari eksponen yang lebih besar di antara dua eksponen | C ++ pelaksanaan pendekatan; Fungsi untuk mencari sama ada A ^ B lebih besar atau c ^ d; Cari b * log (a); Cari d * log (c); Bandingkan kedua -dua nilai; Kod pemacu"}
{"text": "Sum of prime numbers without odd prime digits |  ; Find all prime numbers ; Store all prime numbers ; Function to check if a digit is odd prime or not ; Function to find sum ; To store required answer ; Get all prime numbers ; Traverse through all the prime numbers ; Flag stores 1 if a number does not contain any odd primes ; Find all digits of a number ; If number does not contain any odd primes ; Return the required answer ; Driver code ; Function call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100005 NEW_LINE vector < int > addPrimes ( ) { int n = MAX ; bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } vector < int > ans ; for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) ans . push_back ( p ) ; return ans ; } bool is_prime ( int n ) { return ( n == 3 n == 5 n == 7 ) ; } int find_Sum ( int n ) { int sum = 0 ; vector < int > v = addPrimes ( ) ; for ( int i = 0 ; i < v . size ( ) and n ; i ++ ) { int flag = 1 ; int a = v [ i ] ; while ( a != 0 ) { int d = a % 10 ; a = a / 10 ; if ( is_prime ( d ) ) { flag = 0 ; break ; } } if ( flag == 1 ) { n -- ; sum = sum + v [ i ] ; } } return sum ; } int main ( ) { int n = 7 ; cout << find_Sum ( n ) ; return 0 ; }", "text_ms": "Jumlah nombor perdana tanpa digit utama yang ganjil |  ; Cari semua nombor utama; Simpan semua nombor utama; Berfungsi untuk memeriksa sama ada digit adalah perdana ganjil atau tidak; Berfungsi untuk mencari jumlah; Untuk menyimpan jawapan yang diperlukan; Dapatkan semua nombor utama; Melintasi semua nombor perdana; Kedai bendera 1 Jika nombor tidak mengandungi sebarang prima yang ganjil; Cari semua digit nombor; Jika nombor tidak mengandungi sebarang prima yang ganjil; Mengembalikan jawapan yang diperlukan; Kod pemacu; Panggilan fungsi"}
{"text": "Count the number of primes in the prefix sum array of the given array | C ++ implementation of the approach ; Function to return the count of primes in the given array ; Find maximum value in the array ; USE SIEVE TO FIND ALL PRIME NUMBERS LESS THAN OR EQUAL TO max_val Create a boolean array \" prime [ 0 . . n ] \" . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; Remaining part of SIEVE ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Find all primes in arr [ ] ; Function to generate the prefix array ; Fill the prefix array ; Driver code ; Prefix array of arr [ ] ; Count of primes in the prefix array", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int primeCount ( int arr [ ] , int n ) { int max_val = * max_element ( arr , arr + n ) ; vector < bool > prime ( max_val + 1 , true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( prime [ arr [ i ] ] ) count ++ ; return count ; } void getPrefixArray ( int arr [ ] , int n , int pre [ ] ) { pre [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { pre [ i ] = pre [ i - 1 ] + arr [ i ] ; } } int main ( ) { int arr [ ] = { 1 , 4 , 8 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int pre [ n ] ; getPrefixArray ( arr , n , pre ) ; cout << primeCount ( pre , n ) ; return 0 ; }", "text_ms": "Kira bilangan prima dalam array jumlah awalan array yang diberikan | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan kiraan prima dalam array yang diberikan; Cari nilai maksimum dalam array; Gunakan ayak untuk mencari semua nombor perdana kurang daripada atau sama dengan max_val Buat array boolean \"Perdana [0 ... N]\". Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Baki bahagian Sieve; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Cari semua prima di arr []; Berfungsi untuk menghasilkan array awalan; Isi array awalan; Kod pemacu; Arahan awalan arr []; Count of Prima dalam Array Awalan"}
{"text": "Minimum value to be added to X such that it is at least Y percent of N | C ++ implementation of the approach ; Function to return the required value that must be added to x so that it is at least y percent of n ; Required value ; If x is already >= y percent of n ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minValue ( int n , int x , int y ) { float val = ( y * n ) / 100 ; if ( x >= val ) return 0 ; else return ( ceil ( val ) - x ) ; } int main ( ) { int n = 10 , x = 2 , y = 40 ; cout << minValue ( n , x , y ) ; }", "text_ms": "Nilai minimum yang akan ditambah kepada x supaya sekurang -kurangnya y peratus daripada n | C ++ pelaksanaan pendekatan; Fungsi untuk mengembalikan nilai yang diperlukan yang mesti ditambah kepada x supaya sekurang -kurangnya y peratus daripada n; Nilai yang diperlukan; Jika x sudah> = y peratus n; Kod pemacu"}
{"text": "Check if N is a Factorial Prime | C ++ program to check if given number is a factorial prime ; Utility function to check if a number is prime or not ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Function that returns true if n is a factorial prime ; If n is not prime then return false ; Calculate factorial ; If n is a factorial prime ; n is not a factorial prime ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } bool isFactorialPrime ( long n ) { if ( ! isPrime ( n ) ) return false ; long fact = 1 ; int i = 1 ; while ( fact <= n + 1 ) { fact = fact * i ; if ( n + 1 == fact n - 1 == fact ) return true ; i ++ ; } return false ; } int main ( ) { int n = 23 ; if ( isFactorialPrime ( n ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "text_ms": "Semak jika n adalah faktorial utama | Program C ++ untuk memeriksa sama ada nombor yang diberikan adalah faktorial utama; Fungsi utiliti untuk memeriksa sama ada nombor adalah perdana atau tidak; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; Fungsi yang kembali benar jika n adalah faktorial utama; Jika n tidak perdana maka kembali palsu; Hitung faktorial; Jika n adalah perdana faktorial; n bukanlah perdana faktorial; Kod pemacu"}
{"text": "Seating arrangement of n boys and girls alternatively around a round table | C ++ program to find number of ways in which n boys and n girls can sit alternatively sound a round table . ; Driver Code ; Get n ; find fac1 = ( n - 1 ) ! ; Find fac2 = n ! ; Find total number of ways ; Print the total number of ways", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long int NEW_LINE int main ( ) { ll n = 5 ; ll fac1 = 1 ; for ( int i = 2 ; i <= n - 1 ; i ++ ) fac1 = fac1 * i ; ll fac2 = fac1 * n ; ll totalWays = fac1 * fac2 ; cout << totalWays << endl ; return 0 ; }", "text_ms": "Susunan tempat duduk N Boys and Girls secara alternatif di sekitar meja bulat | Program C ++ untuk mencari bilangan cara di mana N Boys dan N Girls boleh duduk secara alternatif bunyi meja bulat. ; Kod pemacu; Dapatkan n; Cari FAC1 = (n - 1)! ; Cari FAC2 = N! ; Cari jumlah cara; Cetak jumlah cara"}
{"text": "Check whether the given number is Euclid Number or not | CPP program to check Euclid Number ; Function to generate prime numbers ; Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; store all prime numbers to vector ' arr ' ; Function to check the number for Euclid Number ; Multiply next prime number and check if product + 1 = n holds or not ; Driver code ; Get the prime numbers ; Get n ; Check if n is Euclid Number ; Get n ; Check if n is Euclid Number", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  10000 NEW_LINE vector < int > arr ; void SieveOfEratosthenes ( ) { bool prime [ MAX ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p < MAX ; p ++ ) if ( prime [ p ] ) arr . push_back ( p ) ; } bool isEuclid ( long n ) { long long product = 1 ; int i = 0 ; while ( product < n ) { product = product * arr [ i ] ; if ( product + 1 == n ) return true ; i ++ ; } return false ; } int main ( ) { SieveOfEratosthenes ( ) ; long n = 31 ; if ( isEuclid ( n ) ) cout << \" YES STRNEWLINE \" ; else cout << \" NO STRNEWLINE \" ; n = 42 ; if ( isEuclid ( n ) ) cout << \" YES STRNEWLINE \" ; else cout << \" NO STRNEWLINE \" ; return 0 ; }", "text_ms": "Semak sama ada nombor yang diberikan adalah nombor Euclid atau tidak | Program CPP untuk memeriksa nombor Euclid; Berfungsi untuk menjana nombor perdana; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Simpan semua nombor utama ke vektor 'arr'; Berfungsi untuk memeriksa nombor untuk nombor Euclid; Masukkan nombor perdana seterusnya dan periksa sama ada produk + 1 = n memegang atau tidak; Kod pemacu; Dapatkan nombor utama; Dapatkan n; Semak jika n adalah nombor euclid; Dapatkan n; Periksa sama ada n adalah nombor euclid"}
{"text": "Perfect cube greater than a given number | C ++ implementation of above approach ; Function to find the next perfect cube ; Driver Code", "code": "#include <cmath> NEW_LINE #include <iostream> NEW_LINE using namespace std ; int nextPerfectCube ( int N ) { int nextN = floor ( cbrt ( N ) ) + 1 ; return nextN * nextN * nextN ; } int main ( ) { int n = 35 ; cout << nextPerfectCube ( n ) ; return 0 ; }", "text_ms": "Cube sempurna lebih besar daripada nombor tertentu | C ++ pelaksanaan pendekatan di atas; Berfungsi untuk mencari kiub sempurna seterusnya; Kod pemacu"}
{"text": "Sum of all the prime divisors of a number | C ++ program to find sum of prime divisors of N ; Function to check if the number is prime or not . ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; function to find sum of prime divisors of N ; return type of sqrt function if float ; both factors are same ; both factors are not same ( i and n / i ) ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } int SumOfPrimeDivisors ( int n ) { int sum = 0 ; int root_n = ( int ) sqrt ( n ) ; for ( int i = 1 ; i <= root_n ; i ++ ) { if ( n % i == 0 ) { if ( i == n / i && isPrime ( i ) ) { sum += i ; } else { if ( isPrime ( i ) ) { sum += i ; } if ( isPrime ( n / i ) ) { sum += ( n / i ) ; } } } } return sum ; } int main ( ) { int n = 60 ; cout << \" Sum ▁ of ▁ prime ▁ divisors ▁ of ▁ 60 ▁ is ▁ \" << SumOfPrimeDivisors ( n ) << endl ; }", "text_ms": "Jumlah semua pembahagi utama nombor | Program C ++ untuk mencari jumlah pembahagi utama N; Fungsi untuk memeriksa sama ada nombor itu adalah perdana atau tidak. ; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; berfungsi untuk mencari jumlah pembahagi utama N; Kembali jenis fungsi SQRT jika terapung; Kedua -dua faktor adalah sama; Kedua -dua faktor tidak sama (i dan n / i); Kod pemacu"}
{"text": "Position of n among the numbers made of 2 , 3 , 5 & 7 |  ; If number is 2 then it is on the position pos * 2 + 1 ; If number is 3 then it is on the position pos * 2 + 2 ; If number is 5 then it is on the position pos * 2 + 3 ; If number is 7 then it is on the position pos * 2 + 4 ; Driver code", "code": "#include <algorithm> NEW_LINE #include <iostream> NEW_LINE using namespace std ; int findpos ( string n ) { int pos = 0 ; for ( int i = 0 ; n [ i ] != ' \\0' ; i ++ ) { switch ( n [ i ] ) { case '2' : pos = pos * 4 + 1 ; break ; case '3' : pos = pos * 4 + 2 ; break ; case '5' : pos = pos * 4 + 3 ; break ; case '7' : pos = pos * 4 + 4 ; break ; } } return pos ; } int main ( ) { string n = \"777\" ; cout << findpos ( n ) ; }", "text_ms": "Kedudukan N di antara nombor yang diperbuat daripada 2, 3, 5 & 7 |  ; Jika nombor adalah 2 maka ia berada di kedudukan pos * 2 + 1; Jika nombor adalah 3 maka ia berada di kedudukan pos * 2 + 2; Jika nombor adalah 5 maka ia berada di kedudukan pos * 2 + 3; Jika nombor adalah 7 maka ia berada di kedudukan pos * 2 + 4; Kod pemacu"}
{"text": "Finding a Non Transitive Co | C ++ program to find a non transitive co - prime triplets between L and R ; Checks if any possible triplet ( a , b , c ) satisfying the condition that ( a , b ) is coprime , ( b , c ) is coprime but ( a , c ) isnt ; Case 1 : Less than 3 numbers between L and R ; Case 2 : More than 3 numbers between L and R ; triplets should always be of form ( 2 k , 2 k + 1 , 2 k + 2 ) ; Case 3.1 : Exactly 3 numbers in range of form ( 2 k , 2 k + 1 , 2 k + 2 ) ; Case 3.2 : Exactly 3 numbers in range of form ( 2 k - 1 , 2 k , 2 k + 1 ) ; flag = True indicates that a pair exists between L and R ; Driver code ; finding possible Triplet between 2 and 10 ; finding possible Triplet between 23 and 46", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void possibleTripletInRange ( int L , int R ) { bool flag = false ; int possibleA , possibleB , possibleC ; int numbersInRange = ( R - L + 1 ) ; if ( numbersInRange < 3 ) { flag = false ; } else if ( numbersInRange > 3 ) { flag = true ; if ( L % 2 ) { L ++ ; } possibleA = L ; possibleB = L + 1 ; possibleC = L + 2 ; } else { if ( ! ( L % 2 ) ) { flag = true ; possibleA = L ; possibleB = L + 1 ; possibleC = L + 2 ; } else { flag = false ; } } if ( flag == true ) { cout << \" ( \" << possibleA << \" , ▁ \" << possibleB << \" , ▁ \" << possibleC << \" ) \" << \" ▁ is ▁ one ▁ such ▁ possible ▁ triplet ▁ between ▁ \" << L << \" ▁ and ▁ \" << R << \" STRNEWLINE \" ; } else { cout << \" No ▁ Such ▁ Triplet ▁ exists ▁ between ▁ \" << L << \" ▁ and ▁ \" << R << \" STRNEWLINE \" ; } } int main ( ) { int L , R ; L = 2 ; R = 10 ; possibleTripletInRange ( L , R ) ; L = 23 ; R = 46 ; possibleTripletInRange ( L , R ) ; return 0 ; }", "text_ms": "Mencari Co Transitif | Program C ++ untuk mencari Triplets Perdana yang tidak transitif di antara L dan R; Memeriksa jika ada triplet yang mungkin (a, b, c) memenuhi syarat bahawa (a, b) adalah coprime, (b, c) adalah coprime tetapi (a, c) isnt; Kes 1: Kurang daripada 3 nombor antara L dan R; Kes 2: Lebih daripada 3 nombor antara L dan R; Triplet harus selalu menjadi bentuk (2 k, 2 k + 1, 2 k + 2); Kes 3.1: Tepat 3 nombor dalam julat bentuk (2 k, 2 k + 1, 2 k + 2); Kes 3.2: Tepat 3 nombor dalam julat bentuk (2 k - 1, 2 k, 2 k + 1); Bendera = benar menunjukkan bahawa pasangan wujud antara L dan R; Kod pemacu; mencari triplet yang mungkin antara 2 dan 10; Mencari mungkin triplet antara 23 dan 46"}
{"text": "Count n digit numbers not having a particular digit | C ++ Implementation of above method ; Finding number of possible number with n digits excluding a particular digit ; Checking if number of digits is zero ; Checking if number of digits is one ; Checking if number of digits is odd ; Calling digitNumber function with ( digit - 1 ) / 2 digits ; Calling digitNumber function with n / 2 digits ; Calling digitNumber function Checking if excluding digit is zero or non - zero ; Driver function to run above program ; Initializing variables", "code": "#include <bits/stdc++.h> NEW_LINE #define mod  1000000007 NEW_LINE using namespace std ; long long digitNumber ( long long n ) { if ( n == 0 ) return 1 ; if ( n == 1 ) return 9 ; if ( n % 2 ) { long long temp = digitNumber ( ( n - 1 ) / 2 ) % mod ; return ( 9 * ( temp * temp ) % mod ) % mod ; } else { long long temp = digitNumber ( n / 2 ) % mod ; return ( temp * temp ) % mod ; } } int countExcluding ( int n , int d ) { if ( d == 0 ) return ( 9 * digitNumber ( n - 1 ) ) % mod ; else return ( 8 * digitNumber ( n - 1 ) ) % mod ; } int main ( ) { long long d = 9 ; int n = 3 ; cout << countExcluding ( n , d ) << endl ; return 0 ; }", "text_ms": "Count n digit nombor tidak mempunyai digit tertentu | C ++ pelaksanaan kaedah di atas; Mencari bilangan nombor yang mungkin dengan digit N tidak termasuk digit tertentu; Memeriksa jika bilangan digit adalah sifar; Memeriksa jika bilangan digit adalah satu; Memeriksa jika bilangan digit adalah ganjil; Memanggil fungsi digitNumber dengan (digit - 1) / 2 digit; Memanggil fungsi digitnumber dengan n / 2 digit; Memanggil fungsi DigitNumber Memeriksa jika tidak termasuk digit adalah sifar atau bukan sifar; Fungsi pemacu untuk menjalankan program di atas; Memulakan pembolehubah"}
{"text": "Check if given number is Emirp Number or not | C ++ program to check if given number is Emirp or not . ; Returns true if n is prime . Else false . ; Corner case ; Check from 2 to n - 1 ; Function will check whether number is Emirp or not ; Check if n is prime ; Find reverse of n ; If both Original and Reverse are Prime , then it is an Emirp number ; Driver code ; Input number", "code": "#include <iostream> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } bool isEmirp ( int n ) { if ( isPrime ( n ) == false ) return false ; int rev = 0 ; while ( n != 0 ) { int d = n % 10 ; rev = rev * 10 + d ; n /= 10 ; } return isPrime ( rev ) ; } int main ( ) { int n = 13 ; if ( isEmirp ( n ) == true ) cout << \" Yes \" ; else cout << \" No \" ; }", "text_ms": "Semak jika nombor yang diberikan adalah nombor emirp atau tidak | Program C ++ untuk memeriksa sama ada nombor yang diberikan adalah emirp atau tidak. ; Pulangan benar jika n adalah perdana. Lain palsu. ; Kes sudut; Semak dari 2 hingga n - 1; Fungsi akan memeriksa sama ada nombor adalah emirp atau tidak; Semak jika n adalah perdana; Cari terbalik n; Jika kedua -dua asal dan terbalik adalah perdana, maka ia adalah nombor emirp; Kod pemacu; Nombor input"}
{"text": "Program to Convert Radian to Degree | C ++ code to convert radian to degree ; Function for convertion ; Driver code", "code": "#include <iostream> NEW_LINE using namespace std ; double Convert ( double radian ) { double pi = 3.14159 ; return ( radian * ( 180 / pi ) ) ; } int main ( ) { double radian = 5.0 ; double degree = Convert ( radian ) ; cout << degree ; return 0 ; }", "text_ms": "Program untuk menukar radian ke ijazah | C ++ kod untuk menukar radian ke ijazah; Fungsi untuk penukaran; Kod pemacu"}
{"text": "Find trace of matrix formed by adding Row | C ++ program to find trace of matrix formed by adding Row - major and Column - major order of same matrix ; Return sum of first n integers of an AP ; Return the trace of sum of row - major matrix and column - major matrix ; Finding nth element in AP in case of Row major matrix . ; Finding sum of first n integers of AP in case of Row major matrix ; Finding nth element in AP in case of Row major matrix ; Finding sum of first n integers of AP in case of Column major matrix ; Driven Program", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int sn ( int n , int an ) { return ( n * ( 1 + an ) ) / 2 ; } int trace ( int n , int m ) { int an = 1 + ( n - 1 ) * ( m + 1 ) ; int rowmajorSum = sn ( n , an ) ; an = 1 + ( n - 1 ) * ( n + 1 ) ; int colmajorSum = sn ( n , an ) ; return rowmajorSum + colmajorSum ; } int main ( ) { int N = 3 , M = 3 ; cout << trace ( N , M ) << endl ; return 0 ; }", "text_ms": "Cari jejak matriks yang dibentuk dengan menambah baris | Program C ++ untuk mencari jejak matriks yang dibentuk dengan menambah baris - utama dan lajur - urutan utama matriks yang sama; Kembali jumlah integer pertama A AP; Kembalikan jejak jumlah baris - matriks utama dan lajur - matriks utama; Mencari elemen ke dalam AP sekiranya matriks utama baris. ; Mencari jumlah integer pertama AP dalam kes matriks utama baris; Mencari elemen ke dalam AP sekiranya matriks utama baris; Mencari jumlah integer pertama AP dalam kes matriks utama lajur; Program yang didorong"}
{"text": "Maximum of smallest possible area that can get with exactly k cut of given rectangular | C ++ code for Maximum of smallest possible area that can get with exactly k cut of given rectangular ; Utility Function ; for the 1 st case ; for the second case ; print final result ; driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void max_area ( int n , int m , int k ) { if ( k > ( n + m - 2 ) ) cout << \" Not ▁ possible \" << endl ; else { int result ; if ( k < max ( m , n ) - 1 ) { result = max ( m * ( n / ( k + 1 ) ) , n * ( m / ( k + 1 ) ) ) ; } else { result = max ( m / ( k - n + 2 ) , n / ( k - m + 2 ) ) ; } cout << result << endl ; } } int main ( ) { int n = 3 , m = 4 , k = 1 ; max_area ( n , m , k ) ; }", "text_ms": "Maksimum kawasan yang paling kecil yang boleh diperoleh dengan tepat K yang diberikan segi empat tepat | C ++ Kod untuk maksimum kawasan yang paling kecil yang boleh mendapatkan dengan tepat K Cut dari segi empat tepat yang diberikan; Fungsi utiliti; untuk kes 1 st; untuk kes kedua; Hasil akhir cetak; kod pemacu"}
{"text": "Program to find the area of a Square | CPP program to find the area of a square ; function to find the area ; Driver program", "code": "#include <iostream> NEW_LINE using namespace std ; int area_fun ( int side ) { int area = side * side ; return area ; } int main ( ) { int side = 4 ; int area = area_fun ( side ) ; cout << area ; return 0 ; }", "text_ms": "Program untuk mencari kawasan persegi | Program CPP untuk mencari kawasan persegi; berfungsi untuk mencari kawasan; Program Pemandu"}
{"text": "Count ways to express a number as sum of consecutive numbers | C ++ program to count number of ways to express N as sum of consecutive numbers . ; Utility method to compute number of ways in which N can be represented as sum of consecutive number ; constraint on values of L gives us the time Complexity as O ( N ^ 0.5 ) ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long int countConsecutive ( long int N ) { long int count = 0 ; for ( long int L = 1 ; L * ( L + 1 ) < 2 * N ; L ++ ) { double a = ( 1.0 * N - ( L * ( L + 1 ) ) / 2 ) / ( L + 1 ) ; if ( a - ( int ) a == 0.0 ) count ++ ; } return count ; } int main ( ) { long int N = 15 ; cout << countConsecutive ( N ) << endl ; N = 10 ; cout << countConsecutive ( N ) << endl ; return 0 ; }", "text_ms": "Kira cara untuk menyatakan nombor sebagai jumlah nombor berturut -turut | Program C ++ untuk mengira bilangan cara untuk menyatakan N sebagai jumlah nombor berturut -turut. ; Kaedah utiliti untuk mengira bilangan cara di mana n boleh diwakili sebagai jumlah nombor berturut -turut; Kekangan pada nilai L memberi kita kerumitan masa sebagai O (n ^ 0.5); Kod pemacu"}
{"text": "Automorphic Number | C ++ program to check if a number is Authomorphic ; Function to check Automorphic number ; Store the square ; Start Comparing digits ; Return false , if any digit of N doesn ' t ▁ ▁ match ▁ with ▁ its ▁ square ' s digits from last ; Reduce N and square ; Driver code", "code": "#include <iostream> NEW_LINE using namespace std ; bool isAutomorphic ( int N ) { int sq = N * N ; while ( N > 0 ) { if ( N % 10 != sq % 10 ) return false ; N /= 10 ; sq /= 10 ; } return true ; } int main ( ) { int N = 5 ; isAutomorphic ( N ) ? cout << \" Automorphic \" : cout << \" Not ▁ Automorphic \" ; return 0 ; }", "text_ms": "Nombor Automorphic | Program C ++ untuk memeriksa sama ada nombor adalah authomorphic; Berfungsi untuk memeriksa nombor automorphic; Simpan dataran; Mula membandingkan digit; Kembali palsu, jika mana -mana digit dari n tidak sesuai dengan angka -angka yang terakhir; Mengurangkan N dan persegi; Kod pemacu"}
{"text": "Number with maximum number of prime factors | C ++ program to find integer having maximum number of prime factor in first N natural numbers ; Return smallest number having maximum prime factors . ; default value of boolean is false ; Sieve of eratosthenes ; Storing prime numbers . ; Generating number having maximum prime factors . ; Driven Program", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxPrimefactorNum ( int N ) { bool arr [ N + 5 ] ; memset ( arr , true , sizeof ( arr ) ) ; for ( int i = 3 ; i * i <= N ; i += 2 ) { if ( arr [ i ] ) for ( int j = i * i ; j <= N ; j += i ) arr [ j ] = false ; } vector < int > prime ; prime . push_back ( 2 ) ; for ( int i = 3 ; i <= N ; i += 2 ) if ( arr [ i ] ) prime . push_back ( i ) ; int i = 0 , ans = 1 ; while ( ans * prime [ i ] <= N && i < prime . size ( ) ) { ans *= prime [ i ] ; i ++ ; } return ans ; } int main ( ) { int N = 40 ; cout << maxPrimefactorNum ( N ) << endl ; return 0 ; }", "text_ms": "Nombor dengan bilangan maksimum faktor utama | Program C ++ untuk mencari integer yang mempunyai bilangan maksimum faktor utama dalam nombor semulajadi n pertama; Kembalikan nombor terkecil yang mempunyai faktor utama maksimum. ; Nilai lalai boolean adalah palsu; Ayak eratosthenes; Menyimpan nombor perdana. ; Nombor penjanaan yang mempunyai faktor utama maksimum. ; Program yang didorong"}
{"text": "Highest power of 2 less than or equal to given number | C ++ program to find highest power of 2 smaller than or equal to n . ; check for the set bits ; Then we remove all but the top bit by xor ' ing ▁ the ▁ ▁ string ▁ of ▁ 1' s with that string of 1 ' s ▁ shifted ▁ one ▁ to ▁ ▁ the ▁ left , ▁ and ▁ we ▁ end ▁ up ▁ with ▁ just ▁ the ▁ one ▁ top ▁ bit ▁ ▁ followed ▁ by ▁ 0' s . ; Driver code", "code": "#include <iostream> NEW_LINE using namespace std ; unsigned highestPowerof2 ( unsigned x ) { x |= x >> 1 ; x |= x >> 2 ; x |= x >> 4 ; x |= x >> 8 ; x |= x >> 16 ; return x ^ ( x >> 1 ) ; } int main ( ) { int n = 10 ; cout << highestPowerof2 ( n ) << \" STRNEWLINE \" ; return 0 ; }", "text_ms": "Kuasa tertinggi 2 kurang daripada atau sama dengan nombor yang diberikan | Program C ++ untuk mencari kuasa tertinggi 2 lebih kecil daripada atau sama dengan n. ; Semak bit set; Kemudian kita mengeluarkan semua tetapi bit atas oleh xor 'ing u »'» s dengan rentetan 1 's' u u u u u u u u u u u u u u u u u u u u u u. ; Kod pemacu"}
{"text": "Sum of all proper divisors of a natural number | C ++ program to find sum of all divisors of a natural number ; Function to calculate sum of all proper divisors num -- > given natural number ; Final result of summation of divisors ; there will be no proper divisor ; find all divisors which divides ' num ' ; if ' i ' is divisor of ' num ' ; if both divisors are same then add it only once else add both ; Add 1 to the result as 1 is also a divisor ; Driver program to run the case", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int divSum ( int num ) { int result = 0 ; if ( num == 1 ) return result ; for ( int i = 2 ; i <= sqrt ( num ) ; i ++ ) { if ( num % i == 0 ) { if ( i == ( num / i ) ) result += i ; else result += ( i + num / i ) ; } } return ( result + 1 ) ; } int main ( ) { int num = 36 ; cout << divSum ( num ) ; return 0 ; }", "text_ms": "Jumlah semua pembahagi yang betul dari nombor semulajadi | Program C ++ untuk mencari jumlah semua pembahagi nombor semulajadi; Fungsi untuk mengira jumlah semua pembahagi yang betul Num -> diberi nombor semulajadi; Hasil akhir penjumlahan pembahagi; Tidak akan ada pembahagi yang betul; Cari semua pembahagi yang membahagikan 'num'; jika 'saya' adalah pembahagi 'num'; Jika kedua -dua pembahagi adalah sama maka tambahkannya hanya sekali lagi, tambah kedua -duanya; Tambah 1 kepada keputusan sebagai 1 juga pembahagi; Program pemacu untuk menjalankan kes itu"}
{"text": "Find Square Root under Modulo p | Set 1 ( When p is in form of 4 * i + 3 ) | An efficient C ++ program to find square root under modulo p when p is 7 , 11 , 19 , 23 , 31 , ... etc . ; Utility function to do modular exponentiation . It returns ( x ^ y ) % p . ; int res = 1 ; Initialize result x = x % p ; Update x if it is more than or equal to p ; If y is odd , multiply x with result ; y must be even now y = y >> 1 ; y = y / 2 ; Returns true if square root of n under modulo p exists Assumption : p is of the form 3 * i + 4 where i >= 1 ; Try \" + ( n ^ ( ( p ▁ + ▁ 1 ) / 4 ) ) \" ; Try \" - ( n ▁ ^ ▁ ( ( p ▁ + ▁ 1 ) / 4 ) ) \" ; If none of the above two work , then square root doesn 't exist ; Driver program to test", "code": "#include <iostream> NEW_LINE using namespace std ; int power ( int x , int y , int p ) { while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } void squareRoot ( int n , int p ) { if ( p % 4 != 3 ) { cout << \" Invalid ▁ Input \" ; return ; } n = n % p ; int x = power ( n , ( p + 1 ) / 4 , p ) ; if ( ( x * x ) % p == n ) { cout << \" Square ▁ root ▁ is ▁ \" << x ; return ; } x = p - x ; if ( ( x * x ) % p == n ) { cout << \" Square ▁ root ▁ is ▁ \" << x ; return ; } cout << \" Square ▁ root ▁ doesn ' t ▁ exist ▁ \" ; } int main ( ) { int p = 7 ; int n = 2 ; squareRoot ( n , p ) ; return 0 ; }", "text_ms": "Cari akar persegi di bawah modulo p | Tetapkan 1 (apabila p dalam bentuk 4 * i + 3) | Program C ++ yang cekap untuk mencari akar persegi di bawah modulo p apabila p ialah 7, 11, 19, 23, 31, ... dan lain -lain. ; Fungsi utiliti untuk melakukan eksponensi modular. Ia kembali (x ^ y) % p. ; int res = 1; Inisialisasi hasil x = x % p; Kemas kini X jika lebih daripada atau sama dengan P; Jika y adalah ganjil, kalikan x dengan hasil; y mestilah sekarang y = y >> 1; y = y / 2; Pulangan benar jika akar kuadrat n di bawah modulo p ada asumsi: p adalah bentuk 3 * i + 4 di mana i> = 1; Cuba \" + (n ^ ((p ~ ~ 1) / 4))\"; Cuba \" - (n '((p ~ ~ 1) / 4))\"; Sekiranya tiada dua kerja di atas, maka akar persegi tidak wujud; Program Pemandu untuk Menguji"}
{"text": "Primality Test | Set 3 ( Millerâ €“ Rabin ) | C ++ program Miller - Rabin primality test ; Utility function to do modular exponentiation . It returns ( x ^ y ) % p ; Initialize result ; Update x if it is more than or equal to p ; If y is odd , multiply x with result ; y must be even now y = y >> 1 ; y = y / 2 ; This function is called for all k trials . It returns false if n is composite and returns true if n is probably prime . d is an odd number such that d * 2 < sup > r < / sup > = n - 1 for some r >= 1 ; Pick a random number in [ 2. . n - 2 ] Corner cases make sure that n > 4 ; Compute a ^ d % n ; Keep squaring x while one of the following doesn 't  happen  (i) d does not reach n-1  (ii) (x^2) % n is not 1  (iii) (x^2) % n is not n-1 ; Return composite ; It returns false if n is composite and returns true if n is probably prime . k is an input parameter that determines accuracy level . Higher value of k indicates more accuracy . ; Corner cases ; Find r such that n = 2 ^ d * r + 1 for some r >= 1 ; Iterate given nber of ' k ' times ; Driver program", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int power ( int x , unsigned int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } bool miillerTest ( int d , int n ) { int a = 2 + rand ( ) % ( n - 4 ) ; int x = power ( a , d , n ) ; if ( x == 1 x == n - 1 ) return true ; while ( d != n - 1 ) { x = ( x * x ) % n ; d *= 2 ; if ( x == 1 ) return false ; if ( x == n - 1 ) return true ; } return false ; } bool isPrime ( int n , int k ) { if ( n <= 1 n == 4 ) return false ; if ( n <= 3 ) return true ; int d = n - 1 ; while ( d % 2 == 0 ) d /= 2 ; for ( int i = 0 ; i < k ; i ++ ) if ( ! miillerTest ( d , n ) ) return false ; return true ; } int main ( ) { int k = 4 ; cout << \" All ▁ primes ▁ smaller ▁ than ▁ 100 : ▁ STRNEWLINE \" ; for ( int n = 1 ; n < 100 ; n ++ ) if ( isPrime ( n , k ) ) cout << n << \" ▁ \" ; return 0 ; }", "text_ms": "Ujian Primal | Tetapkan 3 (Millerâ € \"Rabin) | C ++ Program Miller - Rabin Primality Test; Fungsi Utiliti untuk Melakukan Eksponen Modular. Benar jika n adalah perdana. N-1 Komposit;"}
{"text": "Length of the Longest Consecutive 1 s in Binary Representation | C ++ program to find length of the longest consecutive 1 s in binary representation of a number . ; Function to find length of the longest consecutive 1 s in binary representation of a number ; Initialize result ; Count the number of iterations to reach x = 0. ; This operation reduces length of every sequence of 1 s by one . ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxConsecutiveOnes ( int x ) { int count = 0 ; while ( x != 0 ) { x = ( x & ( x << 1 ) ) ; count ++ ; } return count ; } int main ( ) { cout << maxConsecutiveOnes ( 14 ) << endl ; cout << maxConsecutiveOnes ( 222 ) << endl ; return 0 ; }", "text_ms": "Panjang paling lama berturut -turut 1 s dalam perwakilan binari | Program C ++ untuk mencari panjang 1 s paling lama berturut -turut dalam perwakilan binari nombor. ; Berfungsi untuk mencari panjang 1 s paling lama berturut -turut dalam perwakilan binari nombor; Memulakan hasil; Kira bilangan lelaran untuk mencapai x = 0 .; Operasi ini mengurangkan panjang setiap urutan 1 s dengan satu. ; Kod pemacu"}
{"text": "Subtract two numbers without using arithmetic operators | C ++ program to Subtract two numbers without using arithmetic operators ; Iterate till there is no carry ; borrow contains common set bits of y and unset bits of x ; Subtraction of bits of x and y where at least one of the bits is not set ; Borrow is shifted by one so that subtracting it from x gives the required sum ; Driver Code", "code": "#include <iostream> NEW_LINE using namespace std ; int subtract ( int x , int y ) { while ( y != 0 ) { int borrow = ( ~ x ) & y ; x = x ^ y ; y = borrow << 1 ; } return x ; } int main ( ) { int x = 29 , y = 13 ; cout << \" x ▁ - ▁ y ▁ is ▁ \" << subtract ( x , y ) ; return 0 ; }", "text_ms": "Kurangkan dua nombor tanpa menggunakan pengendali aritmetik | Program C ++ untuk menolak dua nombor tanpa menggunakan pengendali aritmetik; Melangkah sehingga tidak ada bawa; Pinjam mengandungi bit set biasa Y dan bit yang tidak tersembunyi x; Penolakan bit x dan y di mana sekurang -kurangnya salah satu bit tidak ditetapkan; Meminjam dipindahkan oleh satu supaya menolaknya dari x memberikan jumlah yang diperlukan; Kod pemacu"}
{"text": "Subtract two numbers without using arithmetic operators | CPP Program to subtract two Number without using arithmetic operator Recursive implementation . ; Driver program", "code": "#include <iostream> NEW_LINE using namespace std ; int subtract ( int x , int y ) { if ( y == 0 ) return x ; return subtract ( x ^ y , ( ~ x & y ) << 1 ) ; } int main ( ) { int x = 29 , y = 13 ; cout << \" x ▁ - ▁ y ▁ is ▁ \" << subtract ( x , y ) ; return 0 ; }", "text_ms": "Kurangkan dua nombor tanpa menggunakan pengendali aritmetik | Program CPP untuk menolak dua nombor tanpa menggunakan pelaksanaan rekursif pengendali aritmetik. ; Program Pemandu"}
{"text": "Kth ancestor of all nodes in an N | C ++ implementation of the above approach ; Function to add an edge in the tree ; DFS to find the Kth ancestor of every node ; Pushing current node in the vector ; Traverse its neighbors ; If K ancestors are not found for current node ; Add the Kth ancestor for the node ; Function to find Kth ancestor of each node ; Building the tree ; Stores all parents of a node ; Store Kth ancestor of all nodes ; Print the ancestors ; Driver Code ; Given N and K ; Given edges of n - ary tree ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void addEdge ( vector < int > v [ ] , int x , int y ) { v [ x ] . push_back ( y ) ; v [ y ] . push_back ( x ) ; } void dfs ( vector < int > tree [ ] , vector < int > & temp , int ancestor [ ] , int u , int parent , int k ) { temp . push_back ( u ) ; for ( auto i : tree [ u ] ) { if ( i == parent ) continue ; dfs ( tree , temp , ancestor , i , u , k ) ; } temp . pop_back ( ) ; if ( temp . size ( ) < k ) { ancestor [ u ] = -1 ; } else { ancestor [ u ] = temp [ temp . size ( ) - k ] ; } } void KthAncestor ( int N , int K , int E , int edges [ ] [ 2 ] ) { vector < int > tree [ N + 1 ] ; for ( int i = 0 ; i < E ; i ++ ) { addEdge ( tree , edges [ i ] [ 0 ] , edges [ i ] [ 1 ] ) ; } vector < int > temp ; int ancestor [ N + 1 ] ; dfs ( tree , temp , ancestor , 1 , 0 , K ) ; for ( int i = 1 ; i <= N ; i ++ ) { cout << ancestor [ i ] << \" ▁ \" ; } } int main ( ) { int N = 9 ; int K = 2 ; int E = 8 ; int edges [ 8 ] [ 2 ] = { { 1 , 2 } , { 1 , 3 } , { 2 , 4 } , { 2 , 5 } , { 2 , 6 } , { 3 , 7 } , { 3 , 8 } , { 3 , 9 } } ; KthAncestor ( N , K , E , edges ) ; return 0 ; }", "text_ms": "Kth nenek moyang semua nod dalam n | C ++ pelaksanaan pendekatan di atas; Berfungsi untuk menambah kelebihan di dalam pokok; DFS untuk mencari nenek moyang Kth setiap nod; Menolak nod semasa dalam vektor; Melintasi jirannya; Jika n nenek moyang tidak dijumpai untuk nod semasa; Tambah nenek moyang KTH untuk nod; Berfungsi untuk mencari nenek moyang setiap nod; Membina pokok; Menyimpan semua ibu bapa nod; Simpan nenek moyang semua nod; Cetak nenek moyang; Kod pemacu; Diberikan n dan k; Diberi tepi pokok n - ary; Panggilan fungsi"}
{"text": "Queries to count array elements greater than or equal to a given number with updates | C ++ program for the above approach ; Function to build a segment tree ; Check for base case ; Find mid point ; Recursively build the segment tree ; Function for push down operation on the segment tree ; Function to update the segment tree ; Complete overlap ; Find mid ; Perform push down operation on segment tree ; Recursively update the segment tree ; Function to process the query ; Base case ; Find mid ; Perform push down operation on segment tree ; Recursively calculate the result of the query ; Return the result ; Function to count the numbers which are greater than the given query ; Sort the input array ; Create segment tree of size 4 * n ; Build the segment tree ; Iterate over the queries ; Store result in array ; Update the elements in the given range ; Print the result of queries ; Driver Code ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void build ( vector < int > & sum , vector < int > & a , int l , int r , int rt ) { if ( l == r ) { sum [ rt ] = a [ l - 1 ] ; return ; } int m = ( l + r ) >> 1 ; build ( sum , a , l , m , rt << 1 ) ; build ( sum , a , m + 1 , r , rt << 1 1 ) ; } void pushDown ( vector < int > & sum , vector < int > & add , int rt , int ln , int rn ) { if ( add [ rt ] ) { add [ rt << 1 ] += add [ rt ] ; add [ rt << 1 1 ] += add [ rt ] ; sum [ rt << 1 ] += add [ rt ] * ln ; sum [ rt << 1 1 ] += add [ rt ] * rn ; add [ rt ] = 0 ; } } void update ( vector < int > & sum , vector < int > & add , int L , int R , int C , int l , int r , int rt ) { if ( L <= l && r <= R ) { sum [ rt ] += C * ( r - l + 1 ) ; add [ rt ] += C ; return ; } int m = ( l + r ) >> 1 ; pushDown ( sum , add , rt , m - l + 1 , r - m ) ; if ( L <= m ) update ( sum , add , L , R , C , l , m , rt << 1 ) ; if ( R > m ) update ( sum , add , L , R , C , m + 1 , r , rt << 1 1 ) ; } int query ( vector < int > & sum , vector < int > & add , int L , int R , int l , int r , int rt ) { if ( L <= l && r <= R ) { return sum [ rt ] ; } int m = ( l + r ) >> 1 ; pushDown ( sum , add , rt , m - l + 1 , r - m ) ; int ans = 0 ; if ( L <= m ) ans += query ( sum , add , L , R , l , m , rt << 1 ) ; if ( R > m ) ans += query ( sum , add , L , R , m + 1 , r , rt << 1 1 ) ; return ans ; } void sequenceMaintenance ( int n , int q , vector < int > & a , vector < int > & b , int m ) { sort ( a . begin ( ) , a . end ( ) ) ; vector < int > sum , add , ans ; sum . assign ( n << 2 , 0 ) ; add . assign ( n << 2 , 0 ) ; build ( sum , a , 1 , n , 1 ) ; for ( int i = 0 ; i < q ; i ++ ) { int l = 1 , r = n , pos = -1 ; while ( l <= r ) { int m = ( l + r ) >> 1 ; if ( query ( sum , add , m , m , 1 , n , 1 ) >= b [ i ] ) { r = m - 1 ; pos = m ; } else { l = m + 1 ; } } if ( pos == -1 ) ans . push_back ( 0 ) ; else { ans . push_back ( n - pos + 1 ) ; update ( sum , add , pos , n , - m , 1 , n , 1 ) ; } } for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { cout << ans [ i ] << \" ▁ \" ; } } int main ( ) { int N = 4 ; int Q = 3 ; int M = 1 ; vector < int > arr = { 1 , 2 , 3 , 4 } ; vector < int > query = { 4 , 3 , 1 } ; sequenceMaintenance ( N , Q , arr , query , M ) ; return 0 ; }", "text_ms": "Pertanyaan untuk mengira elemen array lebih besar daripada atau sama dengan nombor tertentu dengan kemas kini | Program C ++ untuk pendekatan di atas; Berfungsi untuk membina pokok segmen; Semak kes asas; Cari titik pertengahan; Secara rekursif membina pokok segmen; Fungsi untuk menolak operasi pada pokok segmen; Berfungsi untuk mengemas kini pokok segmen; Tumpang tindih lengkap; Cari pertengahan; Melakukan operasi menolak pada pokok segmen; Mengemas kini pokok segmen secara rekursif; Berfungsi untuk memproses pertanyaan; Kes asas; Cari pertengahan; Melakukan operasi menolak pada pokok segmen; Secara rekursif mengira hasil pertanyaan; Mengembalikan hasilnya; Fungsi untuk mengira nombor yang lebih besar daripada pertanyaan yang diberikan; Susun array input; Buat pokok segmen saiz 4 * n; Membina pokok segmen; Melangkah ke atas pertanyaan; Kedai hasil dalam pelbagai; Mengemas kini unsur -unsur dalam julat yang diberikan; Cetak hasil pertanyaan; Kod pemacu; Panggilan fungsi"}
{"text": "Minimize Array length by repeatedly replacing co | C ++ Program for the above approach ; Function to find the final array length by replacing coprime pair with 1 ; Iterate over all pairs of element ; Check if gcd is 1 ; If no coprime pair found return false ; Driver code ; Check if atleast one coprime pair exists in the array ; If no such pair exists", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool hasCoprimePair ( vector < int > & arr , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( __gcd ( arr [ i ] , arr [ j ] ) == 1 ) { return true ; } } } return false ; } int main ( ) { int n = 3 ; vector < int > arr = { 6 , 9 , 15 } ; if ( hasCoprimePair ( arr , n ) ) { cout << 1 << endl ; } else { cout << n << endl ; } }", "text_ms": "Kurangkan panjang array dengan berulang kali menggantikan co | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari panjang array akhir dengan menggantikan pasangan coprime dengan 1; Melangkah ke atas semua pasang elemen; Semak jika GCD adalah 1; Sekiranya tiada pasangan Coprime mendapati kembali palsu; Kod pemacu; Semak sama ada satu pasangan coprime wujud dalam array; Sekiranya tidak ada pasangan seperti itu"}
{"text": "Count of ways to split N into Triplets forming a Triangle | C ++ Program to implement the above approach ; Function to return the required number of ways ; Check if a , b and c can form a triangle ; Return number of ways ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Numberofways ( int n ) { int count = 0 ; for ( int a = 1 ; a < n ; a ++ ) { for ( int b = 1 ; b < n ; b ++ ) { int c = n - ( a + b ) ; if ( a + b > c && a + c > b && b + c > a ) { count ++ ; } } } return count ; } int main ( ) { int n = 15 ; cout << Numberofways ( n ) << endl ; return 0 ; }", "text_ms": "Mengira cara untuk berpecah n ke dalam tiga kali ganda membentuk segitiga | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mengembalikan bilangan cara yang diperlukan; Semak jika A, B dan C boleh membentuk segitiga; Mengembalikan bilangan cara; Kod pemacu"}
{"text": "Count of pairs having each element equal to index of the other from an Array | C ++ program to implement the above approach ; Function to print the count of pair ; Iterate over all the elements of the array ; Increment the count ; Print the result ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void countPairs ( int N , int arr [ ] ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == arr [ arr [ i ] - 1 ] - 1 ) { count ++ ; } } cout << ( count / 2 ) << endl ; } int main ( ) { int arr [ ] = { 2 , 1 , 4 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countPairs ( N , arr ) ; }", "text_ms": "Kira pasangan yang mempunyai setiap elemen yang sama dengan indeks yang lain dari array | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mencetak kiraan pasangan; Melangkah ke atas semua elemen array; Kenaikan kiraan; Cetak hasilnya; Kod pemacu"}
{"text": "Find length of longest Fibonacci like subsequence | CPP implementation of above approach ; Function to return the max Length of Fibonacci subsequence ; Store all array elements in a hash table ; check until next fib element is found ; next element of fib subseq ; Driver program", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int LongestFibSubseq ( int A [ ] , int n ) { unordered_set < int > S ( A , A + n ) ; int maxLen = 0 , x , y ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { x = A [ j ] ; y = A [ i ] + A [ j ] ; int length = 2 ; while ( S . find ( y ) != S . end ( ) ) { int z = x + y ; x = y ; y = z ; maxLen = max ( maxLen , ++ length ) ; } } } return maxLen >= 3 ? maxLen : 0 ; } int main ( ) { int A [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << LongestFibSubseq ( A , n ) ; return 0 ; }", "text_ms": "Cari panjang fibonacci terpanjang seperti berikutnya | Pelaksanaan CPP pendekatan di atas; Berfungsi untuk mengembalikan panjang maksimum fibonacci seterusnya; Simpan semua elemen array dalam jadual hash; Semak sehingga elemen FIB seterusnya dijumpai; Elemen seterusnya FIB Subseq; Program Pemandu"}
{"text": "Maximize count of elements that can be selected having minimum difference between their sum and K | C ++ implementation of the above approach ; Function to count maximum number of elements that can be selected ; Sort he array ; Traverse the array ; Add current element to the sum ; IF sum exceeds k ; Increment count ; Return the count ; Driver Code ; Function call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int CountMaximum ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int sum = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum > k ) break ; count ++ ; } return count ; } int main ( ) { int arr [ ] = { 30 , 30 , 10 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 50 ; cout << CountMaximum ( arr , n , k ) ; return 0 ; }", "text_ms": "Memaksimumkan kiraan elemen yang boleh dipilih mempunyai perbezaan minimum antara jumlah dan k | C ++ pelaksanaan pendekatan di atas; Berfungsi untuk mengira bilangan maksimum elemen yang boleh dipilih; Sorakkan dia array; Melintasi array; Tambah elemen semasa ke jumlah; Jika jumlah melebihi k; Kiraan kenaikan; Mengembalikan kiraan; Kod pemacu; Panggilan fungsi"}
{"text": "Maximum types of candies a person can eat if only N / 2 of them can be eaten | C ++ program for the above approach ; Function to find number of candy types ; Declare a hashset to store candies ; Traverse the given array and inserts element into set ; Return the result ; Function to find maximum number of types of candies a person can eat ; Store the number of candies allowed to eat ; Store the number of candy types ; Return the result ; Driver Code ; Given Input ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int num_candyTypes ( vector < int > & candies ) { unordered_set < int > s ; for ( int i = 0 ; i < candies . size ( ) ; i ++ ) { s . insert ( candies [ i ] ) ; } return s . size ( ) ; } void distribute_candies ( vector < int > & candies ) { int allowed = candies . size ( ) / 2 ; int types = num_candyTypes ( candies ) ; if ( types < allowed ) cout << types ; else cout << allowed ; } int main ( ) { vector < int > candies = { 4 , 4 , 5 , 5 , 3 , 3 } ; distribute_candies ( candies ) ; return 0 ; }", "text_ms": "Jenis maksimum gula -gula seseorang boleh makan jika hanya n / 2 daripadanya boleh dimakan | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari bilangan jenis gula -gula; Mengisytiharkan hashset untuk menyimpan gula -gula; Melintasi array yang diberikan dan memasukkan elemen ke dalam set; Mengembalikan hasilnya; Berfungsi untuk mencari bilangan maksimum jenis gula -gula yang boleh dimakan seseorang; Simpan bilangan gula -gula yang dibenarkan makan; Simpan bilangan jenis gula -gula; Mengembalikan hasilnya; Kod pemacu; Diberikan input; Panggilan fungsi"}
{"text": "Length of diagonals of a Rhombus using length of Side and vertex Angle | C ++ program to implement the above approach ; Function to calculate the length of diagonals of a rhombus using length of sides and vertex angle ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; double Length_Diagonals ( int a , double theta ) { double p = a * sqrt ( 2 + ( 2 * cos ( theta * ( 3.141 / 180 ) ) ) ) ; double q = a * sqrt ( 2 - ( 2 * cos ( theta * ( 3.141 / 180 ) ) ) ) ; cout << fixed << setprecision ( 2 ) << p << \" ▁ \" << q ; } int main ( ) { int a = 6 ; int theta = 45 ; Length_Diagonals ( a , theta ) ; return 0 ; }", "text_ms": "Panjang pepenjuru rombus menggunakan panjang sisi dan sudut puncak | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mengira panjang pepenjuru rombus menggunakan panjang sisi dan sudut puncak; Kod pemacu"}
{"text": "Count of even and odd set bit with array element after XOR with K | C ++ program to count the set bits after taking XOR with a number K ; Function to store EVEN and odd variable ; Store the count of even and odd set bit ; Count the set bit using in built function ; Count of set - bit of K ; If y is odd then , count of even and odd set bit will be interchanged ; Else it will remain same as the original array ; Driver 's Code ; Function call to count even and odd", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void countEvenOdd ( int arr [ ] , int n , int K ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int x = __builtin_popcount ( arr [ i ] ) ; if ( x % 2 == 0 ) even ++ ; else odd ++ ; } int y ; y = __builtin_popcount ( K ) ; if ( y & 1 ) { cout << \" Even ▁ = ▁ \" << odd << \" , ▁ Odd ▁ = ▁ \" << even ; } else { cout << \" Even ▁ = ▁ \" << even << \" , ▁ Odd ▁ = ▁ \" << odd ; } } int main ( void ) { int arr [ ] = { 4 , 2 , 15 , 9 , 8 , 8 } ; int K = 3 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countEvenOdd ( arr , n , K ) ; return 0 ; }", "text_ms": "Kira bit set Even dan Odd dengan elemen array selepas xor dengan k | Program C ++ untuk mengira bit set selepas mengambil XOR dengan nombor k; Berfungsi untuk menyimpan pemboleh ubah yang walaupun dan ganjil; Simpan kiraan bit set walaupun dan ganjil; Kira set bit menggunakan dalam fungsi terbina; Count set - bit k; Jika y adalah ganjil, kiraan bit set walaupun dan ganjil akan ditukar; Lain ia akan tetap sama dengan array asal; Kod pemandu; Fungsi panggilan untuk mengira walaupun dan ganjil"}
{"text": "Number of ways to choose a pair containing an even and an odd number from 1 to N | C ++ implementation of the above approach ; Driver code", "code": "#include <iostream> NEW_LINE using namespace std ; int main ( ) { int N = 6 ; int Even = N / 2 ; int Odd = N - Even ; cout << Even * Odd ; return 0 ; }", "text_ms": "Bilangan cara untuk memilih pasangan yang mengandungi nombor yang lebih dan ganjil dari 1 hingga n | C ++ pelaksanaan pendekatan di atas; Kod pemacu"}
{"text": "Longest subsequence from an array of pairs having first element increasing and second element decreasing . | C ++ program for the above approach ; Recursive function to find the length of the longest subsequence of pairs whose first element is increasing and second is decreasing ; Base case ; Not include the current pair in the longest subsequence ; Including the current pair in the longest subsequence ; Driver Code ; Given Input ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int longestSubSequence ( pair < int , int > A [ ] , int N , int ind = 0 , int lastf = INT_MIN , int lasts = INT_MAX ) { if ( ind == N ) return 0 ; int ans = longestSubSequence ( A , N , ind + 1 , lastf , lasts ) ; if ( A [ ind ] . first > lastf && A [ ind ] . second < lasts ) ans = max ( ans , longestSubSequence ( A , N , ind + 1 , A [ ind ] . first , A [ ind ] . second ) + 1 ) ; return ans ; } int main ( ) { pair < int , int > A [ ] = { { 1 , 2 } , { 2 , 2 } , { 3 , 1 } } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << longestSubSequence ( A , N ) << \" STRNEWLINE \" ; return 0 ; }", "text_ms": "Paling terpanjang dari pelbagai pasangan yang mempunyai elemen pertama yang semakin meningkat dan elemen kedua berkurangan. | Program C ++ untuk pendekatan di atas; Fungsi rekursif untuk mencari panjang pasang pasang terpanjang yang elemen pertama yang semakin meningkat dan kedua berkurangan; Kes asas; Tidak termasuk pasangan semasa dalam masa yang paling lama; Termasuk pasangan semasa dalam masa yang paling lama; Kod pemacu; Diberikan input; Panggilan fungsi"}
{"text": "Count triples with Bitwise AND equal to Zero | C ++ program for the above approach ; Function to find the number of triplets whose Bitwise AND is 0. ; Stores the count of triplets having bitwise AND equal to 0 ; Stores frequencies of all possible A [ i ] & A [ j ] ; Traverse the array ; Update frequency of Bitwise AND of all array elements with a ; Traverse the array ; Iterate the map ; If bitwise AND of triplet is zero , increment cnt ; Return the number of triplets whose Bitwise AND is 0. ; Driver Code ; Input Array ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE #include <iostream> NEW_LINE using namespace std ; int countTriplets ( vector < int > & A ) { int cnt = 0 ; unordered_map < int , int > tuples ; for ( auto a : A ) for ( auto b : A ) ++ tuples [ a & b ] ; for ( auto a : A ) for ( auto t : tuples ) if ( ( t . first & a ) == 0 ) cnt += t . second ; return cnt ; } int main ( ) { vector < int > A = { 2 , 1 , 3 } ; cout << countTriplets ( A ) ; return 0 ; }", "text_ms": "Kira tiga dengan bitwise dan sama dengan sifar | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari bilangan tiga kali ganda yang bitwise dan 0.; Menyimpan kiraan triplet yang mempunyai bitwise dan sama dengan 0; Kedai frekuensi semua yang mungkin [i] & a [j]; Melintasi array; Kemas kini kekerapan bitwise dan semua elemen array dengan A; Melintasi array; Melelehkan peta; Jika bitwise dan triplet adalah sifar, kenaikan CNT; Kembalikan bilangan tiga kali ganda yang bitwise dan 0 .; Kod pemacu; Arahan input; Panggilan fungsi"}
{"text": "Count ways to reach a score using 1 and 2 with no consecutive 2 s | Bottom up approach for counting ways to reach a score using 1 and 2 with consecutive 2 allowed ; noOfWays [ i ] will store count for value i . 3 extra values are to take care of corner case n = 0 ; Loop till \" n + 1\" to compute value for \" n \" ; number of ways if first run is 1 ; Driver code", "code": "#include <iostream> NEW_LINE using namespace std ; int CountWays ( int n ) { int noOfWays [ n + 3 ] ; noOfWays [ 0 ] = 1 ; noOfWays [ 1 ] = 1 ; noOfWays [ 2 ] = 1 + 1 ; for ( int i = 3 ; i < n + 1 ; i ++ ) { noOfWays [ i ] = noOfWays [ i - 1 ] + noOfWays [ i - 3 ] ; } return noOfWays [ n ] ; } int main ( ) { int n = 0 ; cout << CountWays ( n ) ; return 0 ; }", "text_ms": "Kira cara untuk mencapai skor menggunakan 1 dan 2 tanpa berturut -turut 2 S | Pendekatan bawah untuk mengira cara untuk mencapai skor menggunakan 1 dan 2 dengan berturut -turut 2 dibenarkan; Noofways [i] akan menyimpan kiraan untuk nilai i. 3 nilai tambahan adalah untuk menjaga kes sudut n = 0; Gelung hingga \"n + 1\" untuk mengira nilai untuk \"n\"; bilangan cara jika larian pertama adalah 1; Kod pemacu"}
{"text": "Program to print Spiral Pattern |  ; Create row and col to traverse rows and columns ; Variable to determine the movement r = right , l = left , d = down , u = upper ; Array for matrix ; Assign the value ; switch - case to determine the next index ; If right , go right ; if left , go left ; if up , go up ; if down , go down ; Check if the matrix has reached array boundary ; Add the left size for the next boundary ; If 2 rotations has been made , decrease the size left by 1 ; switch - case to rotate the movement ; if right , rotate to down ; if down , rotate to left ; if left , rotate to up ; if up , rotate to right ; Print the matrix ; Driver Code ; Get the size of size ; Print the Spiral Pattern", "code": "#include <iostream> NEW_LINE using namespace std ; void printSpiral ( int size ) { int row = 0 , col = 0 ; int boundary = size - 1 ; int sizeLeft = size - 1 ; int flag = 1 ; char move = ' r ' ; int matrix [ size ] [ size ] = { 0 } ; for ( int i = 1 ; i < size * size + 1 ; i ++ ) { matrix [ row ] [ col ] = i ; switch ( move ) { case ' r ' : col += 1 ; break ; case ' l ' : col -= 1 ; break ; case ' u ' : row -= 1 ; break ; case ' d ' : row += 1 ; break ; } if ( i == boundary ) { boundary += sizeLeft ; if ( flag != 2 ) { flag = 2 ; } else { flag = 1 ; sizeLeft -= 1 ; } switch ( move ) { case ' r ' : move = ' d ' ; break ; case ' d ' : move = ' l ' ; break ; case ' l ' : move = ' u ' ; break ; case ' u ' : move = ' r ' ; break ; } } } for ( row = 0 ; row < size ; row ++ ) { for ( col = 0 ; col < size ; col ++ ) { int n = matrix [ row ] [ col ] ; if ( n < 10 ) cout << n << \" ▁ \" ; else cout << n << \" ▁ \" ; } cout << endl ; } } int main ( ) { int size = 5 ; printSpiral ( size ) ; return 0 ; }", "text_ms": "Program untuk mencetak corak lingkaran |  ; Buat baris dan col untuk melintasi baris dan lajur; Pembolehubah untuk menentukan pergerakan r = kanan, l = kiri, d = ke bawah, u = atas; Array untuk matriks; Berikan nilai; suis - kes untuk menentukan indeks seterusnya; Jika betul, pergi ke kanan; jika ditinggalkan, pergi ke kiri; jika naik, naik; jika turun, turun; Semak jika matriks telah mencapai sempadan array; Tambah saiz kiri untuk sempadan seterusnya; Jika 2 putaran telah dibuat, mengurangkan saiz yang ditinggalkan oleh 1; suis - kes untuk memutar pergerakan; jika betul, putar ke bawah; jika turun, putar ke kiri; jika dibiarkan, putar ke atas; jika naik, putar ke kanan; Cetak matriks; Kod pemacu; Dapatkan saiz saiz; Cetak corak lingkaran"}
{"text": "Find the last player to be able to flip a character in a Binary String | C ++ program for the above approach ; Function to check if player A wins the game or not ; Stores size of the groups of 0 s ; Stores size of the group of 0 s ; Traverse the array ; Increment c by 1 if a [ i ] is 0 ; Otherwise , push the size in array and reset c to 0 ; If there is no substring of odd length consisting only of 0 s ; If there is only 1 substring of odd length consisting only of 0 s ; Otherwise ; Stores the size of the largest and second largest substrings of 0 s ; Traverse the array v [ ] ; If current element is greater than first , then update both first and second ; If arr [ i ] is in between first and second , then update second ; If the condition is satisfied ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findWinner ( string a , int n ) { vector < int > v ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == '0' ) { c ++ ; } else { if ( c != 0 ) v . push_back ( c ) ; c = 0 ; } } if ( c != 0 ) v . push_back ( c ) ; if ( v . size ( ) == 0 ) { cout << \" Player ▁ B \" ; return ; } if ( v . size ( ) == 1 ) { if ( v [ 0 ] & 1 ) cout << \" Player ▁ A \" ; else cout << \" Player ▁ B \" ; return ; } int first = INT_MIN ; int second = INT_MIN ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( a [ i ] > first ) { second = first ; first = a [ i ] ; } else if ( a [ i ] > second && a [ i ] != first ) second = a [ i ] ; } if ( ( first & 1 ) && ( first + 1 ) / 2 > second ) cout << \" Player ▁ A \" ; else cout << \" Player ▁ B \" ; } int main ( ) { string S = \"1100011\" ; int N = S . length ( ) ; findWinner ( S , N ) ; return 0 ; }", "text_ms": "Cari pemain terakhir untuk dapat membalikkan watak dalam rentetan binari | Program C ++ untuk pendekatan di atas; Berfungsi untuk memeriksa sama ada pemain A memenangi permainan atau tidak; Kedai saiz kumpulan 0 s; Kedai saiz kumpulan 0 s; Melintasi array; Kenaikan c oleh 1 jika a [i] adalah 0; Jika tidak, tolak saiz dalam array dan tetapkan semula C ke 0; Sekiranya tidak ada substring panjang ganjil yang terdiri daripada 0 s; Sekiranya terdapat hanya 1 substring panjang ganjil yang terdiri hanya 0 s; Jika tidak; Menyimpan saiz substring terbesar dan kedua terbesar 0 s; Melintasi array v []; Jika elemen semasa lebih besar daripada yang pertama, maka kemas kini kedua -dua dan kedua; Jika arr [i] berada di antara pertama dan kedua, maka kemas kini kedua; Sekiranya keadaan itu berpuas hati; Kod pemacu"}
{"text": "Check if K palindromic strings can be formed from a given string | C ++ program to check whether the string is K palindrome or not ; function to check whether the string is K palindrome or not ; map to frequency of character ; Check when k is given as same as length of string ; iterator for map ; storing the frequency of every character in map ; if K is greater than size of string then return false ; check that number of character having the odd frequency ; if k is less than number of odd frequency character then it is again false other wise true ; Driver code", "code": "#include <iostream> NEW_LINE #include <map> NEW_LINE using namespace std ; bool can_Construct ( string S , int K ) { map < int , int > m ; int i = 0 , j = 0 , p = 0 ; if ( S . length ( ) == K ) { return true ; } map < int , int > :: iterator h ; for ( i = 0 ; i < S . length ( ) ; i ++ ) { m [ S [ i ] ] = m [ S [ i ] ] + 1 ; } if ( K > S . length ( ) ) { return false ; } else { for ( h = m . begin ( ) ; h != m . end ( ) ; h ++ ) { if ( m [ h -> first ] % 2 != 0 ) { p = p + 1 ; } } } if ( K < p ) { return false ; } return true ; } int main ( ) { string S = \" annabelle \" ; int K = 4 ; if ( can_Construct ( S , K ) ) { cout << \" Yes \" ; } else { cout << \" No \" ; } }", "text_ms": "Periksa sama ada rentetan kalindromik boleh dibentuk dari rentetan yang diberikan | Program C ++ untuk memeriksa sama ada rentetan adalah K palindrome atau tidak; berfungsi untuk memeriksa sama ada rentetan adalah k palindrome atau tidak; peta kepada kekerapan watak; Semak apabila k diberikan sama seperti panjang rentetan; Iterator untuk peta; menyimpan kekerapan setiap watak dalam peta; jika k lebih besar daripada saiz rentetan maka kembali palsu; Semak bilangan watak yang mempunyai kekerapan ganjil; Jika k kurang daripada bilangan watak frekuensi ganjil maka ia sekali lagi palsu yang lain bijak; Kod pemacu"}
{"text": "Check if two strings are same ignoring their cases |  ; Function to compare two strings ignoring their cases ; Convert to lowercase using transform ( ) function and :: tolower in STL ; Comparing both using inbuilt function ; if strings are equal , return true otherwise false ; Function to print the same or not same if strings are equal or not equal ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool equalIgnoreCase ( string str1 , string str2 ) { int i = 0 ; transform ( str1 . begin ( ) , str1 . end ( ) , str1 . begin ( ) , :: tolower ) ; transform ( str2 . begin ( ) , str2 . end ( ) , str2 . begin ( ) , :: tolower ) ; int x = str1 . compare ( str2 ) ; if ( x != 0 ) return false ; else return true ; } void equalIgnoreCaseUtil ( string str1 , string str2 ) { bool res = equalIgnoreCase ( str1 , str2 ) ; if ( res == true ) cout << \" Same \" << endl ; else cout << \" Not ▁ Same \" << endl ; } int main ( ) { string str1 , str2 ; str1 = \" Geeks \" ; str2 = \" geeks \" ; equalIgnoreCaseUtil ( str1 , str2 ) ; str1 = \" Geek \" ; str2 = \" geeksforgeeks \" ; equalIgnoreCaseUtil ( str1 , str2 ) ; return 0 ; }", "text_ms": "Semak jika dua rentetan sama mengabaikan kes mereka |  ; Fungsi untuk membandingkan dua rentetan mengabaikan kes mereka; Tukar ke huruf kecil menggunakan fungsi transform () dan :: Tolower di STL; Membandingkan kedua -dua menggunakan fungsi terbina; Jika rentetan adalah sama, kembali benar sebaliknya palsu; Berfungsi untuk mencetak sama atau tidak sama jika rentetan sama atau tidak sama; Kod pemacu"}
{"text": "Program to print Step Pattern | C ++ program to print Step Pattern ; function to print the steps ; declare a flag ; traverse through all the characters in the string ; if the x value is 0. . then we must increment till n ... set flag to true ; if the x value is n - 1 then we must decrement till 0 ... set flag as false ; print x * s ; checking whether to increment or decrement x ; Driver code ; Get the String and the number n ; calling the function", "code": "#include <iostream> NEW_LINE using namespace std ; void steps ( string str , int n ) { bool flag ; int x = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( x == 0 ) flag = true ; if ( x == n - 1 ) flag = false ; for ( int j = 0 ; j < x ; j ++ ) cout << \" * \" ; cout << str [ i ] << \" STRNEWLINE \" ; if ( flag == true ) x ++ ; else x -- ; } } int main ( ) { int n = 4 ; string str = \" GeeksForGeeks \" ; cout << \" String : ▁ \" << str << endl ; cout << \" Max ▁ Length ▁ of ▁ Steps : ▁ \" << n << endl ; steps ( str , n ) ; return 0 ; }", "text_ms": "Program untuk mencetak corak langkah | Program C ++ untuk mencetak corak langkah; berfungsi untuk mencetak langkah -langkah; mengisytiharkan bendera; melintasi semua watak dalam rentetan; Jika nilai x ialah 0 .. Kemudian kita mesti kenaikan sehingga n ... Tetapkan bendera kepada Benar; Jika nilai x adalah n - 1 maka kita mesti menurunkan sehingga 0 ... Tetapkan bendera sebagai palsu; cetak x * s; memeriksa sama ada untuk kenaikan atau penurunan x; Kod pemacu; Dapatkan rentetan dan nombor n; memanggil fungsi"}
{"text": "Frequency Measuring Techniques for Competitive Programming | C ++ program to count frequencies of array items ; Mark all array elements as not visited ; Traverse through array elements and count frequencies ; Skip this element if already processed ; Count frequency ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void countFreq ( int arr [ ] , int n ) { vector < int > visited ( n , false ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( visited [ i ] == true ) continue ; int count = 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { visited [ j ] = true ; count ++ ; } } cout << arr [ i ] << \" ▁ \" << count << endl ; } } int main ( ) { int arr [ ] = { 10 , 20 , 20 , 10 , 10 , 20 , 5 , 20 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countFreq ( arr , n ) ; return 0 ; }", "text_ms": "Teknik Pengukuran Kekerapan untuk Pengaturcaraan Kompetitif | Program C ++ untuk mengira frekuensi item array; Tandakan semua elemen array seperti yang tidak dikunjungi; Melintasi unsur -unsur array dan kekerapan kiraan; Langkau elemen ini jika sudah diproses; Kekerapan kiraan; Kod pemacu"}
{"text": "Check divisibility of binary string by 2 ^ k | C ++ implementation to check whether given binary number is evenly divisible by 2 ^ k or not ; function to check whether given binary number is evenly divisible by 2 ^ k or not ; count of number of 0 from last ; if count = k , number is evenly divisible , so returns true else false ; Driver program to test above ; first example ; Second example", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isDivisible ( char str [ ] , int k ) { int n = strlen ( str ) ; int c = 0 ; for ( int i = 0 ; i < k ; i ++ ) if ( str [ n - i - 1 ] == '0' ) c ++ ; return ( c == k ) ; } int main ( ) { char str1 [ ] = \"10101100\" ; int k = 2 ; if ( isDivisible ( str1 , k ) ) cout << \" Yes \" << endl ; else cout << \" No \" << \" STRNEWLINE \" ; char str2 [ ] = \"111010100\" ; k = 2 ; if ( isDivisible ( str2 , k ) ) cout << \" Yes \" << endl ; else cout << \" No \" << endl ; return 0 ; }", "text_ms": "Semak pembahagian rentetan binari dengan 2 ^ k | C ++ pelaksanaan untuk memeriksa sama ada nombor binari yang diberikan sama rata dengan 2 ^ k atau tidak; fungsi untuk memeriksa sama ada nombor binari yang diberikan sama rata dengan 2 ^ k atau tidak; kiraan bilangan 0 dari yang terakhir; Jika Count = k, nombor sama rata, jadi pulangan benar lain palsu; Program pemandu untuk menguji di atas; Contoh pertama; Contoh kedua"}
{"text": "Check if any anagram of a string is palindrome or not |  ; function to check whether characters of a string can form a palindrome ; Create a count array and initialize all values as 0 ; For each character in input strings , increment count in the corresponding count array ; Count odd occurring characters ; Return true if odd count is 0 or 1 , ; Driver program to test to print printDups", "code": "#include <iostream> NEW_LINE using namespace std ; #define NO_OF_CHARS  256 NEW_LINE bool canFormPalindrome ( string str ) { int count [ NO_OF_CHARS ] = { 0 } ; for ( int i = 0 ; str [ i ] ; i ++ ) count [ str [ i ] ] ++ ; int odd = 0 ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( count [ i ] & 1 ) odd ++ ; if ( odd > 1 ) return false ; } return true ; } int main ( ) { canFormPalindrome ( \" geeksforgeeks \" ) ? cout << \" Yes STRNEWLINE \" : cout << \" No STRNEWLINE \" ; canFormPalindrome ( \" geeksogeeks \" ) ? cout << \" Yes STRNEWLINE \" : cout << \" No STRNEWLINE \" ; return 0 ; }", "text_ms": "Semak jika ada anagram rentetan adalah palindrome atau tidak |  ; berfungsi untuk memeriksa sama ada watak rentetan boleh membentuk palindrome; Buat array kiraan dan mulakan semua nilai sebagai 0; Bagi setiap aksara dalam rentetan input, kiraan kenaikan dalam array kiraan yang sepadan; Mengira watak -watak yang ganjil; Kembali benar jika kiraan ganjil adalah 0 atau 1 ,; Program pemacu untuk diuji untuk mencetak cetakan"}
{"text": "Program to check if input is an integer or a string | CPP program to check if a given string is a valid integer ; Returns true if s is a number else false ; Driver code ; Saving the input in a string ; Function returns 1 if all elements are in range '0-9' ; Function returns 0 if the input is not an integer", "code": "#include <iostream> NEW_LINE using namespace std ; bool isNumber ( string s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( isdigit ( s [ i ] ) == false ) return false ; return true ; } int main ( ) { string str = \"6790\" ; if ( isNumber ( str ) ) cout << \" Integer \" ; else cout << \" String \" ; }", "text_ms": "Program untuk memeriksa sama ada input adalah integer atau rentetan | Program CPP untuk memeriksa sama ada rentetan yang diberikan adalah integer yang sah; Pulangan benar jika s adalah nombor lain palsu; Kod pemacu; Menyimpan input dalam rentetan; Fungsi pulangan 1 jika semua elemen berada dalam jarak '0-9'; Fungsi pulangan 0 jika input bukan integer"}
{"text": "Print reverse of a string using recursion | C ++ program to reverse a string using recursion ; Function to print reverse of the passed string ; Driver program to test above function", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void reverse ( string str ) { if ( str . size ( ) == 0 ) { return ; } reverse ( str . substr ( 1 ) ) ; cout << str [ 0 ] ; } int main ( ) { string a = \" Geeks ▁ for ▁ Geeks \" ; reverse ( a ) ; return 0 ; }", "text_ms": "Cetak terbalik rentetan menggunakan rekursi | Program C ++ untuk membalikkan rentetan menggunakan rekursi; Berfungsi untuk mencetak terbalik rentetan lulus; Program pemacu untuk menguji fungsi di atas"}
{"text": "Probability of distributing given balls into two halves having equal count of distinct colors | C ++ program for the above approach ; Stores the count of distinct colors in box1 ; Stores the count of distinct colors in box2 ; Function to calculate the required probability ; Calculate factorial from [ 1 , 10 ] ; Assign all distinct balls to second box ; Total number of balls ; Calculate total number of balls ; If K is an odd number ; Total ways of distributing the balls in two equal halves ; Required number of ways ; Return the required probability ; Function to calculate total number of possible distributions which satisfies the given conditions ; If used balls is equal to K / 2 ; If box1 is equal to box2 ; Base condition ; Stores the number of ways of distributing remaining balls without including the current balls in box1 ; Increment box1 by one ; Iterate over the range [ 1 , balls [ i ] ] ; If all the balls goes to box1 , then decrease box2 by one ; Total number of ways of selecting j balls ; Increment res by total number of valid ways of distributing the remaining balls ; Decrement box1 by one ; Increment box2 by 1 ; Function to calculate factorial of N ; Base Case ; Iterate over the range [ 1 , N ] ; Function to calculate NcR ; Driver Code ; Print the result", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; static int box1 = 0 ; static int box2 = 0 ; static int fact [ 11 ] ; double getProbability ( int balls [ ] , int M ) { factorial ( 10 ) ; box2 = M ; int K = 0 ; for ( int i = 0 ; i < M ; i ++ ) K += balls [ i ] ; if ( K % 2 == 1 ) return 0 ; long all = comb ( K , K / 2 ) ; long validPermutation = validPermutations ( K / 2 , balls , 0 , 0 , M ) ; return ( double ) validPermutation / all ; } long validPermutations ( int n , int balls [ ] , int usedBalls , int i , int M ) { if ( usedBalls == n ) { return box1 == box2 ? 1 : 0 ; } if ( i >= M ) return 0 ; long res = validPermutations ( n , balls , usedBalls , i + 1 , M ) ; box1 ++ ; for ( int j = 1 ; j <= balls [ i ] ; j ++ ) { if ( j == balls [ i ] ) box2 -- ; long combinations = comb ( balls [ i ] , j ) ; res += combinations * validPermutations ( n , balls , usedBalls + j , i + 1 , M ) ; } box1 -- ; box2 ++ ; return res ; } void factorial ( int N ) { fact [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; } long comb ( int n , int r ) { long res = fact [ n ] / fact [ r ] ; res /= fact [ n - r ] ; return res ; } int main ( ) { int arr [ ] = { 2 , 1 , 1 } ; int N = 4 ; int M = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ( getProbability ( arr , M ) ) ; return 0 ; }", "text_ms": "Kebarangkalian mengedarkan bola yang diberikan kepada dua bahagian yang mempunyai kiraan yang sama dengan warna yang berbeza | Program C ++ untuk pendekatan di atas; Menyimpan kiraan warna yang berbeza dalam Box1; Menyimpan kiraan warna yang berbeza dalam Box2; Fungsi untuk mengira kebarangkalian yang diperlukan; Hitung faktorial dari [1, 10]; Berikan semua bola yang berbeza ke kotak kedua; Jumlah bola; Hitung jumlah bola; Jika k adalah nombor ganjil; Jumlah cara mengedarkan bola dalam dua bahagian yang sama; Bilangan cara yang diperlukan; Mengembalikan kebarangkalian yang diperlukan; Fungsi untuk mengira jumlah bilangan pengagihan yang mungkin memenuhi syarat yang diberikan; Jika bola yang digunakan adalah sama dengan k / 2; Jika Box1 sama dengan Box2; Keadaan asas; Menyimpan bilangan cara mengedarkan bola yang tinggal tanpa termasuk bola semasa dalam Box1; Kotak kenaikan1 dengan satu; Melangkah ke atas julat [1, bola [i]]; Jika semua bola pergi ke Box1, kemudian menurunkan Box2 dengan satu; Jumlah cara memilih bola J; Kenaikan res dengan jumlah cara yang sah untuk mengedarkan bola yang tinggal; Box1 box1 oleh satu; Box2 Box2 oleh 1; Fungsi untuk mengira faktorial n; Kes asas; Melangkah ke atas julat [1, n]; Fungsi untuk mengira NCR; Kod pemacu; Cetak hasilnya"}
{"text": "Area of a n | C ++ Program to find the area of a regular polygon with given radius ; Function to find the area of a regular polygon ; Side and radius cannot be negative ; Area degree converted to radians ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float polyarea ( float n , float r ) { if ( r < 0 && n < 0 ) return -1 ; float A = ( ( r * r * n ) * sin ( ( 360 / n ) * 3.14159 / 180 ) ) / 2 ; return A ; } int main ( ) { float r = 9 , n = 6 ; cout << polyarea ( n , r ) << endl ; return 0 ; }", "text_ms": "Kawasan n | Program C ++ untuk mencari kawasan poligon biasa dengan radius yang diberikan; Berfungsi untuk mencari kawasan poligon biasa; Sampingan dan jejari tidak boleh negatif; Ijazah kawasan ditukar kepada radian; Kod pemacu"}
{"text": "Check if a line at 45 degree can divide the plane into two equal weight parts |  ; Checking if a plane can be divide by a line at 45 degrees such that weight sum is equal ; Rotating each point by 45 degrees and calculating prefix sum . Also , finding maximum and minimum x coordinates ; storing weight sum upto x - y point ; Finding prefix sum ; Line passes through i , so it neither falls left nor right . ; Driven Program", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void is_partition_possible ( int n , int x [ ] , int y [ ] , int w [ ] ) { map < int , int > weight_at_x ; int max_x = -2e3 , min_x = 2e3 ; for ( int i = 0 ; i < n ; i ++ ) { int new_x = x [ i ] - y [ i ] ; max_x = max ( max_x , new_x ) ; min_x = min ( min_x , new_x ) ; weight_at_x [ new_x ] += w [ i ] ; } vector < int > sum_till ; sum_till . push_back ( 0 ) ; for ( int x = min_x ; x <= max_x ; x ++ ) { sum_till . push_back ( sum_till . back ( ) + weight_at_x [ x ] ) ; } int total_sum = sum_till . back ( ) ; int partition_possible = false ; for ( int i = 1 ; i < sum_till . size ( ) ; i ++ ) { if ( sum_till [ i ] == total_sum - sum_till [ i ] ) partition_possible = true ; if ( sum_till [ i - 1 ] == total_sum - sum_till [ i ] ) partition_possible = true ; } printf ( partition_possible ? \" YES STRNEWLINE \" : \" NO STRNEWLINE \" ) ; } int main ( ) { int n = 3 ; int x [ ] = { -1 , -2 , 1 } ; int y [ ] = { 1 , 1 , -1 } ; int w [ ] = { 3 , 1 , 4 } ; is_partition_possible ( n , x , y , w ) ; return 0 ; }", "text_ms": "Semak jika garis pada 45 darjah boleh membahagikan pesawat ke dalam dua bahagian berat yang sama |  ; Memeriksa jika satah boleh dibahagikan dengan garis pada 45 darjah supaya jumlah berat adalah sama; Putar setiap titik sebanyak 45 darjah dan mengira jumlah awalan. Juga, mencari koordinat X maksimum dan minimum; menyimpan jumlah berat sehingga titik x - y; Mencari Jumlah awalan; Line melewati saya, jadi ia tidak jatuh ke kiri atau kanan. ; Program yang didorong"}
{"text": "Slope of perpendicular to line | C ++ program find slope of perpendicular line ; Function to find the Slope of other line ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; double findPCSlope ( double m ) { return -1.0 / m ; } int main ( ) { double m = 2.0 ; cout << findPCSlope ( m ) ; return 0 ; }", "text_ms": "Cerun tegak lurus ke garisan | Program C ++ Cari cerun garis tegak lurus; Berfungsi untuk mencari cerun garis lain; Kod pemacu"}
{"text": "Program to find area of a Circular Segment | C ++ Program to find area of segment of a circle ; Function to find area of segment ; Calculating area of sector ; Calculating area of triangle ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float pi = 3.14159 ; float area_of_segment ( float radius , float angle ) { float area_of_sector = pi * ( radius * radius ) * ( angle / 360 ) ; float area_of_triangle = ( float ) 1 / 2 * ( radius * radius ) * sin ( ( angle * pi ) / 180 ) ; return area_of_sector - area_of_triangle ; } int main ( ) { float radius = 10.0 , angle = 90.0 ; cout << \" Area ▁ of ▁ minor ▁ segment ▁ = ▁ \" << area_of_segment ( radius , angle ) << endl ; cout << \" Area ▁ of ▁ major ▁ segment ▁ = ▁ \" << area_of_segment ( radius , ( 360 - angle ) ) ; }", "text_ms": "Program untuk mencari kawasan segmen bulat | Program C ++ untuk mencari kawasan segmen bulatan; Fungsi untuk mencari kawasan segmen; Mengira kawasan sektor; Mengira kawasan segitiga; Kod pemacu"}
{"text": "Area of a Circular Sector | C ++ program to find Area of a Sector ; Calculating area of the sector ; Driver code", "code": "#include <iostream> NEW_LINE using namespace std ; void SectorArea ( double radius , double angle ) { if ( angle >= 360 ) cout << \" Angle ▁ not ▁ possible \" ; else { double sector = ( ( 22 * radius * radius ) / 7 ) * ( angle / 360 ) ; cout << sector ; } } int main ( ) { double radius = 9 ; double angle = 60 ; SectorArea ( radius , angle ) ; return 0 ; }", "text_ms": "Kawasan Sektor Pekeliling | Program C ++ untuk mencari kawasan sektor; Mengira kawasan sektor; Kod pemacu"}
{"text": "Make two numbers equal by multiplying with their prime factors minimum number of times | C ++ program for the above approach ; Function to calculate total number of prime factor with their prime factor ; Iterate while the number is even ; Reduce to half ; Iterate up to sqrt ( N ) ; Iterate while N has factors of i ; Removing one factor of i ; Function to count the number of factors ; Find the GCD ; Find multiples left in X and Y ; Find prime factor of multiple left in X and Y ; Initialize ans ; Check if it possible to obtain X or not ; Check if it possible to obtain Y or not ; return main ans ; Driver code ; Given Input ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; unordered_map < int , int > PrimeFactor ( int N ) { unordered_map < int , int > primef ; while ( N % 2 == 0 ) { if ( primef . count ( 2 ) ) { primef [ 2 ] += 1 ; } else { primef [ 2 ] = 1 ; } N /= 2 ; } for ( int i = 3 ; i <= sqrt ( N ) ; i ++ ) { while ( N % i == 0 ) { if ( primef . count ( i ) ) { primef [ i ] += 1 ; } else { primef [ i ] = 1 ; } N /= 2 ; } } if ( N > 2 ) { primef [ N ] = 1 ; } return primef ; } int CountToMakeEqual ( int X , int Y ) { int gcdofXY = __gcd ( X , Y ) ; int newX = Y / gcdofXY ; int newY = X / gcdofXY ; unordered_map < int , int > primeX ; unordered_map < int , int > primeY ; primeX = PrimeFactor ( newX ) ; primeY = PrimeFactor ( newY ) ; int ans = 0 ; for ( auto c : primeX ) { if ( X % c . first != 0 ) { return -1 ; } ans += primeX [ c . first ] ; } for ( auto c : primeY ) { if ( Y % c . first != 0 ) { return -1 ; } ans += primeY [ c . first ] ; } return ans ; } int main ( ) { int X = 36 ; int Y = 48 ; int ans = CountToMakeEqual ( X , Y ) ; cout << ans << endl ; return 0 ; }", "text_ms": "Buat dua nombor sama dengan mendarab dengan faktor utama mereka bilangan minimum kali | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira jumlah faktor utama dengan faktor utama mereka; Melangkah sementara nombornya juga; Mengurangkan separuh; Berulang sehingga sqrt (n); Melangkah sementara n mempunyai faktor i; Mengeluarkan satu faktor i; Berfungsi untuk mengira bilangan faktor; Cari GCD; Cari gandaan yang tersisa di x dan y; Cari faktor utama pelbagai kiri dalam x dan y; Memulakan ans; Semak sama ada mungkin untuk mendapatkan x atau tidak; Periksa sama ada mungkin untuk mendapatkan y atau tidak; kembali utama ans; Kod pemacu; Diberikan input; Panggilan fungsi"}
{"text": "Make given segments non | C ++ program for the above approach ; Stores the details of the Segment ; Function to check whether the graph is bipartite or not ; Mark source node as visited ; Push the source vertex in queue ; Get the front of the queue ; Assign the color to the popped node ; Traverse the adjacency list of the node u ; If any node is visited & a different colors has been assigned , then return false ; Set visited [ x ] ; Push the node x into the queue ; Update color of node ; If the graph is bipartite ; Function to add an edge between the nodes u and v ; Function to check if the assignment of direction can be possible to all the segments , such that they do not intersect after a long period of time ; Stores the adjacency list of the created graph ; Generate all possible pairs ; If segments do not overlap ; Otherwise , the segments overlap ; If both segments have same speed , then add an edge ; Keep the track of visited nodes ; Iterate for all possible nodes ; Check whether graph is bipartite or not ; If the graph is bipartite ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int L , R , V ; } ; bool check ( vector < int > Adj [ ] , int Src , int N , bool visited [ ] ) { int color [ N ] = { 0 } ; visited [ Src ] = true ; queue < int > q ; q . push ( Src ) ; while ( ! q . empty ( ) ) { int u = q . front ( ) ; q . pop ( ) ; int Col = color [ u ] ; for ( int x : Adj [ u ] ) { if ( visited [ x ] == true && color [ x ] == Col ) { return false ; } else if ( visited [ x ] == false ) { visited [ x ] = true ; q . push ( x ) ; color [ x ] = 1 - Col ; } } } return true ; } void addEdge ( vector < int > Adj [ ] , int u , int v ) { Adj [ u ] . push_back ( v ) ; Adj [ v ] . push_back ( u ) ; } void isPossible ( struct Node Arr [ ] , int N ) { vector < int > Adj [ N ] ; for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( Arr [ i ] . R < Arr [ j ] . L Arr [ i ] . L > Arr [ j ] . R ) { continue ; } else { if ( Arr [ i ] . V == Arr [ j ] . V ) { addEdge ( Adj , i , j ) ; } } } } bool visited [ N ] = { false } ; for ( int i = 0 ; i < N ; i ++ ) { if ( visited [ i ] == false && Adj [ i ] . size ( ) > 0 ) { if ( check ( Adj , i , N , visited ) == false ) { cout << \" No \" ; return ; } } } cout << \" Yes \" ; } int main ( ) { struct Node arr [ ] = { { 5 , 7 , 2 } , { 4 , 6 , 1 } , { 1 , 5 , 2 } , { 6 , 5 , 1 } } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; isPossible ( arr , N ) ; return 0 ; }", "text_ms": "Buat segmen yang diberikan bukan | Program C ++ untuk pendekatan di atas; Menyimpan butiran segmen; Berfungsi untuk memeriksa sama ada graf adalah bipartite atau tidak; Tanda nod sumber seperti yang dikunjungi; Tolak puncak sumber dalam barisan; Dapatkan bahagian depan barisan; Berikan warna kepada nod yang muncul; Melintasi senarai addacency nod u; Jika mana -mana nod dikunjungi & warna yang berbeza telah diberikan, maka kembali palsu; Tetapkan dikunjungi [x]; Tolak nod X ke dalam barisan; Kemas kini warna nod; Jika graf adalah bipartite; Berfungsi untuk menambah kelebihan antara nod U dan V; Berfungsi untuk memeriksa sama ada tugasan arah boleh dilakukan untuk semua segmen, supaya mereka tidak bersilang selepas jangka masa yang panjang; Menyimpan senarai adjacency graf yang dicipta; Menjana semua pasangan yang mungkin; Jika segmen tidak bertindih; Jika tidak, segmen bertindih; Jika kedua -dua segmen mempunyai kelajuan yang sama, maka tambahkan kelebihan; Pastikan jejak nod yang dikunjungi; Berulang untuk semua nod yang mungkin; Semak sama ada graf adalah bipartite atau tidak; Jika graf adalah bipartite; Kod pemacu"}
{"text": "Generate all numbers up to N in Lexicographical Order | C ++ program for the above approach ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void dfs ( int temp , int n , vector < int > & sol ) ; void lexNumbers ( int n ) { vector < int > sol ; dfs ( 1 , n , sol ) ; cout << \" [ \" << sol [ 0 ] ; for ( int i = 1 ; i < sol . size ( ) ; i ++ ) cout << \" , ▁ \" << sol [ i ] ; cout << \" ] \" ; } void dfs ( int temp , int n , vector < int > & sol ) { if ( temp > n ) return ; sol . push_back ( temp ) ; dfs ( temp * 10 , n , sol ) ; if ( temp % 10 != 9 ) dfs ( temp + 1 , n , sol ) ; } int main ( ) { int n = 15 ; lexNumbers ( n ) ; return 0 ; }", "text_ms": "Menjana semua nombor sehingga n dalam urutan leksikografi | Program C ++ untuk pendekatan di atas; Kod pemacu"}
{"text": "Minimum number of swaps required to sort an array of first N number | Function to find minimum swaps ; Initialise count variable ; If current element is not at the right position ; Swap current element with correct position of that element ; Increment for next index when current element is at correct position ; Driver code ; Function to find minimum swaps", "code": "#include <iostream> NEW_LINE using namespace std ; int minimumSwaps ( int arr [ ] , int n ) { int count = 0 ; int i = 0 ; while ( i < n ) { if ( arr [ i ] != i + 1 ) { while ( arr [ i ] != i + 1 ) { int temp = 0 ; temp = arr [ arr [ i ] - 1 ] ; arr [ arr [ i ] - 1 ] = arr [ i ] ; arr [ i ] = temp ; count ++ ; } } i ++ ; } return count ; } int main ( ) { int arr [ ] = { 2 , 3 , 4 , 1 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minimumSwaps ( arr , n ) ; }", "text_ms": "Bilangan swap minimum yang diperlukan untuk menyusun pelbagai nombor N pertama | Berfungsi untuk mencari swap minimum; Pembolehubah kiraan permulaan; Jika elemen semasa tidak berada di kedudukan yang betul; Swap elemen semasa dengan kedudukan yang betul dari elemen itu; Kenaikan untuk indeks seterusnya apabila elemen semasa berada pada kedudukan yang betul; Kod pemacu; Berfungsi untuk mencari swap minimum"}
{"text": "Merge K sorted Doubly Linked List in Sorted Order | C ++ program to merge K sorted doubly linked list in sorted order ; A linked list node ; Given a reference ( pointer to pointer ) to the head Of a DLL and an int , appends a new node at the end ; Allocate node ; Put in the data ; This new node is going to be the last node , so make next of it as NULL ; If the Linked List is empty , then make the new node as head ; Else traverse till the last node ; Change the next of last node ; Make last node as previous of new node ; Function to print the list ; Run while loop unless node becomes null ; Function to merge two sorted doubly linked lists ; If any of the list is empty ; Comparison the data of two linked list ; Store head pointer before merge the list ; Changing of pointer between Two list for merging ; Changing of pointer between Two list for merging ; Condition to check if any anyone list not end ; Return head pointer of merged list ; Function to merge all sorted linked list in sorted order ; Function call to merge two sorted doubly linked list at a time ; Return final sorted doubly linked list ; Driver code ; Loop to initialize all the lists to empty ; Create first doubly linked List List1 -> 1 <= > 5 <= > 9 ; Create second doubly linked List List2 -> 2 <= > 3 <= > 7 <= > 12 ; Create third doubly linked List List3 -> 8 <= > 11 <= > 13 <= > 18 ; Function call to merge all sorted doubly linked lists in sorted order ; Print final sorted list", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * next ; Node * prev ; } ; void append ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; struct Node * last = * head_ref ; new_node -> data = new_data ; new_node -> next = NULL ; if ( * head_ref == NULL ) { new_node -> prev = NULL ; * head_ref = new_node ; return ; } while ( last -> next != NULL ) last = last -> next ; last -> next = new_node ; new_node -> prev = last ; return ; } void printList ( Node * node ) { Node * last ; while ( node != NULL ) { cout << node -> data << \" ▁ \" ; last = node ; node = node -> next ; } } Node * mergeList ( Node * p , Node * q ) { Node * s = NULL ; if ( p == NULL q == NULL ) { return ( p == NULL ? q : p ) ; } if ( p -> data < q -> data ) { p -> prev = s ; s = p ; p = p -> next ; } else { q -> prev = s ; s = q ; q = q -> next ; } Node * head = s ; while ( p != NULL && q != NULL ) { if ( p -> data < q -> data ) { s -> next = p ; p -> prev = s ; s = s -> next ; p = p -> next ; } else { s -> next = q ; q -> prev = s ; s = s -> next ; q = q -> next ; } } if ( p == NULL ) { s -> next = q ; q -> prev = s ; } if ( q == NULL ) { s -> next = p ; p -> prev = s ; } return head ; } Node * mergeAllList ( Node * head [ ] , int k ) { Node * finalList = NULL ; for ( int i = 0 ; i < k ; i ++ ) { finalList = mergeList ( finalList , head [ i ] ) ; } return finalList ; } int main ( ) { int k = 3 ; Node * head [ k ] ; for ( int i = 0 ; i < k ; i ++ ) { head [ i ] = NULL ; } append ( & head [ 0 ] , 1 ) ; append ( & head [ 0 ] , 5 ) ; append ( & head [ 0 ] , 9 ) ; append ( & head [ 1 ] , 2 ) ; append ( & head [ 1 ] , 3 ) ; append ( & head [ 1 ] , 7 ) ; append ( & head [ 1 ] , 12 ) ; append ( & head [ 2 ] , 8 ) ; append ( & head [ 2 ] , 11 ) ; append ( & head [ 2 ] , 13 ) ; append ( & head [ 2 ] , 18 ) ; Node * finalList = mergeAllList ( head , k ) ; printList ( finalList ) ; return 0 ; }", "text_ms": "Gabungkan K -Sorted Doubly Linked List dalam Order Sorted | Program C ++ untuk menggabungkan senarai yang disusun dua kali ganda dalam urutan yang disusun; Nod senarai yang dipautkan; Memandangkan rujukan (penunjuk kepada penunjuk) ke kepala DLL dan int, tambah nod baru pada akhir; Memperuntukkan nod; Masukkan data; Nod baru ini akan menjadi nod terakhir, jadi buatlah seterusnya sebagai batal; Jika senarai yang dipautkan kosong, maka buat nod baru sebagai kepala; Lain melintasi sehingga nod terakhir; Tukar nod terakhir yang akan datang; Buat nod terakhir seperti sebelumnya dari nod baru; Berfungsi untuk mencetak senarai; Jalankan semasa gelung melainkan nod menjadi batal; Berfungsi untuk menggabungkan dua senarai dikaitkan dua kali ganda; Jika mana -mana senarai kosong; Perbandingan data dua senarai yang dipautkan; Simpan penunjuk kepala sebelum menggabungkan senarai; Menukar penunjuk antara dua senarai untuk penggabungan; Menukar penunjuk antara dua senarai untuk penggabungan; Syarat untuk memeriksa sama ada sesiapa yang menyenaraikan tidak berakhir; Kembali penunjuk kepala senarai yang digabungkan; Berfungsi untuk menggabungkan semua senarai yang disusun dalam susunan yang disusun; Panggilan fungsi untuk menggabungkan dua senarai dikaitkan berganda yang disusun pada satu masa; Kembali akhir disusun senarai dua kali ganda; Kod pemacu; Gelung untuk memulakan semua senarai untuk kosong; Buat senarai dikaitkan pertama List1 -> 1 <=> 5 <=> 9; Buat senarai dua kali ganda dikaitkan list2 -> 2 <=> 3 <=> 7 <=> 12; Buat senarai dikaitkan dua kali ganda senarai3 -> 8 <=> 11 <=> 13 <=> 18; Panggilan fungsi untuk menggabungkan semua senarai dikaitkan dua kali ganda dalam urutan yang disusun; Cetak senarai disusun akhir"}
{"text": "Recursive Selection Sort | Recursive C ++ program to sort an array using selection sort ; Return minimum index ; Find minimum of remaining elements ; Return minimum of current and remaining . ; Recursive selection sort . n is size of a [ ] and index is index of starting element . ; Return when starting and size are same ; calling minimum index function for minimum index ; Swapping when index nd minimum index are not same ; swap ; Recursively calling selection sort function ; Driver code ; Calling function ; printing sorted array", "code": "#include <iostream> NEW_LINE using namespace std ; int minIndex ( int a [ ] , int i , int j ) { if ( i == j ) return i ; int k = minIndex ( a , i + 1 , j ) ; return ( a [ i ] < a [ k ] ) ? i : k ; } void recurSelectionSort ( int a [ ] , int n , int index = 0 ) { if ( index == n ) return ; int k = minIndex ( a , index , n - 1 ) ; if ( k != index ) swap ( a [ k ] , a [ index ] ) ; recurSelectionSort ( a , n , index + 1 ) ; } int main ( ) { int arr [ ] = { 3 , 1 , 5 , 2 , 7 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; recurSelectionSort ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << \" ▁ \" ; cout << endl ; return 0 ; }", "text_ms": "Susun Pemilihan Rekursif | Program C ++ rekursif untuk menyusun pelbagai menggunakan pilihan pemilihan; Indeks minimum pulangan; Cari minimum elemen yang tinggal; Pulangan minimum semasa dan baki. ; Jenis pemilihan rekursif. N ialah saiz [] dan indeks adalah indeks elemen permulaan. ; Kembali apabila bermula dan saiznya sama; Memanggil fungsi indeks minimum untuk indeks minimum; Bertukar apabila indeks indeks minimum tidak sama; swap; Fungsi pemilihan pilihan rekursif; Kod pemacu; Fungsi panggilan; Percetakan Arahan yang disusun"}
{"text": "Recursive Insertion Sort | Recursive C ++ program for insertion sort ; Recursive function to sort an array using insertion sort ; Base case ; Sort first n - 1 elements ; Insert last element at its correct position in sorted array . ; Move elements of arr [ 0. . i - 1 ] , that are greater than key , to one position ahead of their current position ; A utility function to print an array of size n ; Driver program to test insertion sort", "code": "#include <iostream> NEW_LINE using namespace std ; void insertionSortRecursive ( int arr [ ] , int n ) { if ( n <= 1 ) return ; insertionSortRecursive ( arr , n - 1 ) ; int last = arr [ n - 1 ] ; int j = n - 2 ; while ( j >= 0 && arr [ j ] > last ) { arr [ j + 1 ] = arr [ j ] ; j -- ; } arr [ j + 1 ] = last ; } void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << \" ▁ \" ; } int main ( ) { int arr [ ] = { 12 , 11 , 13 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; insertionSortRecursive ( arr , n ) ; printArray ( arr , n ) ; return 0 ; }", "text_ms": "SENARAI SENSI RECURSIVE | Program C ++ rekursif untuk jenis penyisipan; Fungsi rekursif untuk menyusun array menggunakan jenis penyisipan; Kes asas; Susun pertama n - 1 elemen; Masukkan elemen terakhir pada kedudukan yang betul dalam array yang disusun. ; Gerakkan unsur -unsur ARR [0 .. i - 1], yang lebih besar daripada kunci, ke satu kedudukan di hadapan kedudukan semasa mereka; Fungsi utiliti untuk mencetak pelbagai saiz n; Program pemacu untuk menguji jenis penyisipan"}
{"text": "Recursive Bubble Sort | C / C ++ program for recursive implementation of Bubble sort ; A function to implement bubble sort ; Base case ; One pass of bubble sort . After this pass , the largest element is moved ( or bubbled ) to end . ; swap arr [ i ] , arr [ i + 1 ] ; Largest element is fixed , recur for remaining array ; Function to print an array ; Driver program to test above functions", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void bubbleSort ( int arr [ ] , int n ) { if ( n == 1 ) return ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) swap ( arr [ i ] , arr [ i + 1 ] ) ; bubbleSort ( arr , n - 1 ) ; } void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; printf ( \" STRNEWLINE \" ) ; } int main ( ) { int arr [ ] = { 64 , 34 , 25 , 12 , 22 , 11 , 90 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; bubbleSort ( arr , n ) ; printf ( \" Sorted ▁ array ▁ : ▁ STRNEWLINE \" ) ; printArray ( arr , n ) ; return 0 ; }", "text_ms": "Susun gelembung rekursif | C / C ++ Program untuk pelaksanaan rekursif jenis gelembung; Fungsi untuk melaksanakan jenis gelembung; Kes asas; Satu lulus jenis gelembung. Selepas lulus ini, elemen terbesar dipindahkan (atau bubbled) untuk berakhir. ; swap arr [i], arr [i + 1]; Unsur terbesar ditetapkan, berulang untuk array yang tinggal; Berfungsi untuk mencetak array; Program pemacu untuk menguji fungsi di atas"}
{"text": "Maximum possible difference of sum of two subsets of an array | Set 2 | C ++ Program for the above approach ; Stores the positive elements ; Stores the negative elements ; Stores the count of 0 s ; Sum of all positive numbers ; Sum of all negative numbers ; Iterate over the array ; Stores the difference ; Sort the positive numbers in ascending order ; Sort the negative numbers in decreasing order ; Case 1 : Include both positive and negative numbers ; Put all numbers in subset A and one 0 in subset B ; Put all numbers in subset A except the smallest positive number which is put in B ; Put all numbers in subset B and one 0 in subset A ; Place the largest negative number in subset A and remaining in B ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSumAfterPartition ( int arr [ ] , int n ) { vector < int > pos ; vector < int > neg ; int zero = 0 ; int pos_sum = 0 ; int neg_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) { pos . push_back ( arr [ i ] ) ; pos_sum += arr [ i ] ; } else if ( arr [ i ] < 0 ) { neg . push_back ( arr [ i ] ) ; neg_sum += arr [ i ] ; } else { zero ++ ; } } int ans = 0 ; sort ( pos . begin ( ) , pos . end ( ) ) ; sort ( neg . begin ( ) , neg . end ( ) , greater < int > ( ) ) ; if ( pos . size ( ) > 0 && neg . size ( ) > 0 ) { ans = ( pos_sum - neg_sum ) ; } else if ( pos . size ( ) > 0 ) { if ( zero > 0 ) { ans = ( pos_sum ) ; } else { ans = ( pos_sum - 2 * pos [ 0 ] ) ; } } else { if ( zero > 0 ) { ans = ( -1 * neg_sum ) ; } else { ans = ( neg [ 0 ] - ( neg_sum - neg [ 0 ] ) ) ; } } return ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , -5 , -7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxSumAfterPartition ( arr , n ) ; return 0 ; }", "text_ms": "Perbezaan maksimum jumlah dua subset dari array | Tetapkan 2 | Program C ++ untuk pendekatan di atas; Menyimpan unsur -unsur positif; Menyimpan unsur -unsur negatif; Menyimpan kiraan 0 s; Jumlah semua nombor positif; Jumlah semua nombor negatif; Melangkah ke atas array; Menyimpan perbezaan; Menyusun nombor positif dalam urutan menaik; Menyusun nombor negatif dalam penurunan urutan; Kes 1: Sertakan nombor positif dan negatif; Letakkan semua nombor dalam subset a dan satu 0 dalam subset b; Letakkan semua nombor dalam subset A kecuali nombor positif terkecil yang dimasukkan ke dalam B; Letakkan semua nombor dalam subset b dan satu 0 dalam subset A; Letakkan nombor negatif terbesar dalam subset A dan baki dalam B; Kod pemacu"}
{"text": "Split an array into subarrays with maximum Bitwise XOR of their respective Bitwise OR values | C ++ program for the above approach ; Function to find the bitwise OR of array elements ; Stores the resultant maximum value of Bitwise XOR ; Traverse the array arr [ ] ; Return the maximum value res ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int MaxXOR ( int arr [ ] , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { res |= arr [ i ] ; } return res ; } int main ( ) { int arr [ ] = { 1 , 5 , 7 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << MaxXOR ( arr , N ) ; return 0 ; }", "text_ms": "Pecahkan array ke subarrays dengan bitwise maksimum XOR masing -masing bitwise atau nilai masing -masing | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari elemen bitwise atau array; Menyimpan nilai maksimum yang dihasilkan dari bitwise XOR; Melintasi array arr []; Mengembalikan nilai maksimum RES; Kod pemacu"}
{"text": "Count number of common elements between a sorted array and a reverse sorted array | C ++ program for the above approach ; Function to count the number of elements common in both the arrays ; Used to traverse array A [ ] and B [ ] from the front and the back ; Stores the count of numbers common in both array ; If A [ first ] is less than B [ second ] ; Increment the value of first ; IF B [ second ] is less than A [ first ] ; Decrement the value of second ; A [ first ] is equal to B [ second ] ; Increment the value of count ; Increment the value of first ; Decrement the value of second ; Return the value of count ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countEqual ( int A [ ] , int B [ ] , int N ) { int first = 0 ; int second = N - 1 ; int count = 0 ; while ( first < N && second >= 0 ) { if ( A [ first ] < B [ second ] ) { first ++ ; } else if ( B [ second ] < A [ first ] ) { second -- ; } else { count ++ ; first ++ ; second -- ; } } return count ; } int main ( ) { int A [ ] = { 2 , 4 , 5 , 8 , 12 , 13 , 17 , 18 , 20 , 22 , 309 , 999 } ; int B [ ] = { 109 , 99 , 68 , 54 , 22 , 19 , 17 , 13 , 11 , 5 , 3 , 1 } ; int N = sizeof ( A ) / sizeof ( int ) ; cout << countEqual ( A , B , N ) ; return 0 ; }", "text_ms": "Kira bilangan unsur biasa antara array yang disusun dan array yang disusun terbalik | Program C ++ untuk pendekatan di atas; Berfungsi untuk mengira bilangan elemen yang biasa dalam kedua -dua tatasusunan; Digunakan untuk melintasi array A [] dan B [] dari depan dan belakang; Menyimpan kiraan nombor yang biasa dalam kedua -dua array; Jika A [pertama] kurang daripada b [kedua]; Meningkatkan nilai pertama; Jika B [kedua] kurang daripada [pertama]; Menurunkan nilai kedua; A [pertama] adalah sama dengan b [kedua]; Meningkatkan nilai kiraan; Meningkatkan nilai pertama; Menurunkan nilai kedua; Mengembalikan nilai kiraan; Kod pemacu"}
{"text": "Queries to count Palindrome Numbers from a range whose sum of digits is a Prime Number | C ++ program for the above approach ; Function to check if the number N is palindrome or not ; Store the value of N ; Store the reverse of number N ; Reverse temp and store in res ; If N is the same as res , then return true ; Function to find the sum of the digits of the number N ; Stores the sum of the digits ; Add the last digit of the number N to the sum ; Remove the last digit from N ; Return the resultant sum ; Function to check if N is prime or not ; If i is 1 or 0 , then return false ; Check if i is divisible by any number in the range [ 2 , n / 2 ] ; If n is divisible by i ; Function to precompute all the numbers till 10 ^ 5 that are palindromic and whose sum of digits is prime numbers ; Iterate over the range 1 to 10 ^ 5 ; If i is a palindrome number ; Stores the sum of the digits in i ; If the sum of digits in i is a prime number ; Find the prefix sum of arr [ ] ; Function to count all the numbers in the given ranges that are palindromic and the sum of digits is prime numbers ; Function Call to precompute all the numbers till 10 ^ 5 ; Traverse the given queries Q [ ] ; Print the result for each query ; Driver Code ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int arr [ 100005 ] ; bool isPalindrome ( int N ) { int temp = N ; int res = 0 ; while ( temp != 0 ) { int rem = temp % 10 ; res = res * 10 + rem ; temp /= 10 ; } if ( res == N ) { return true ; } else { return false ; } } int sumOfDigits ( int N ) { int sum = 0 ; while ( N != 0 ) { sum += N % 10 ; N /= 10 ; } return sum ; } bool isPrime ( int n ) { if ( n <= 1 ) { return false ; } for ( int i = 2 ; i <= n / 2 ; ++ i ) { if ( n % i == 0 ) return false ; } return true ; } void precompute ( ) { for ( int i = 1 ; i <= 100000 ; i ++ ) { if ( isPalindrome ( i ) ) { int sum = sumOfDigits ( i ) ; if ( isPrime ( sum ) ) arr [ i ] = 1 ; else arr [ i ] = 0 ; } else arr [ i ] = 0 ; } for ( int i = 1 ; i <= 100000 ; i ++ ) { arr [ i ] = arr [ i ] + arr [ i - 1 ] ; } } void countNumbers ( int Q [ ] [ 2 ] , int N ) { precompute ( ) ; for ( int i = 0 ; i < N ; i ++ ) { cout << ( arr [ Q [ i ] [ 1 ] ] - arr [ Q [ i ] [ 0 ] - 1 ] ) ; cout << endl ; } } int main ( ) { int Q [ ] [ 2 ] = { { 5 , 9 } , { 1 , 101 } } ; int N = sizeof ( Q ) / sizeof ( Q [ 0 ] ) ; countNumbers ( Q , N ) ; }", "text_ms": "Pertanyaan untuk mengira nombor palindrome dari julat yang jumlah digitnya adalah nombor utama | Program C ++ untuk pendekatan di atas; Berfungsi untuk memeriksa sama ada nombor n adalah palindrome atau tidak; Simpan nilai n; Simpan sebaliknya nombor n; Tempatan terbalik dan simpan di res; Jika n adalah sama dengan res, maka kembali benar; Berfungsi untuk mencari jumlah digit nombor n; Menyimpan jumlah digit; Tambah digit terakhir nombor N ke jumlah; Keluarkan digit terakhir dari N; Mengembalikan jumlah yang dihasilkan; Fungsi untuk memeriksa sama ada n adalah perdana atau tidak; Jika saya adalah 1 atau 0, maka kembali palsu; Semak jika saya boleh dibahagikan dengan mana -mana nombor dalam julat [2, n / 2]; Jika n boleh dibahagikan dengan i; Berfungsi untuk mendahului semua nombor sehingga 10 ^ 5 yang palindromik dan jumlah digitnya adalah nombor utama; Melangkah ke atas julat 1 hingga 10 ^ 5; Jika saya adalah nombor palindrome; Menyimpan jumlah digit dalam i; Jika jumlah digit dalam saya adalah nombor utama; Cari jumlah awalan arr []; Fungsi untuk mengira semua nombor dalam julat yang diberikan adalah palindromik dan jumlah digit adalah nombor utama; Fungsi panggilan untuk precompute semua nombor hingga 10 ^ 5; Melintasi pertanyaan yang diberikan Q []; Cetak hasil untuk setiap pertanyaan; Kod pemacu; Panggilan fungsi"}
{"text": "Smallest number greater than or equal to N having sum of digits not exceeding S | C ++ program for the above approach ; Function to calculate sum digits of n ; Function to find the smallest possible integer satisfying the given condition ; If the sum of digits is already smaller than S ; Initialize variables ; Finding last kth digit ; Add remaining to make digit 0 ; If sum of digits does not exceed S ; Update k ; Driver Code ; Given N and S ; Function call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int sum ( int n ) { int res = 0 ; while ( n > 0 ) { res += n % 10 ; n /= 10 ; } return res ; } int smallestNumber ( int n , int s ) { if ( sum ( n ) <= s ) { return n ; } int ans = n , k = 1 ; for ( int i = 0 ; i < 9 ; ++ i ) { int digit = ( ans / k ) % 10 ; int add = k * ( ( 10 - digit ) % 10 ) ; ans += add ; if ( sum ( ans ) <= s ) { break ; } k *= 10 ; } return ans ; } int main ( ) { int N = 3 , S = 2 ; cout << smallestNumber ( N , S ) << endl ; return 0 ; }", "text_ms": "Nombor terkecil lebih besar daripada atau sama dengan N yang mempunyai jumlah digit tidak melebihi s | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira jumlah digit n; Berfungsi untuk mencari integer yang paling kecil yang memenuhi syarat yang diberikan; Jika jumlah digit sudah lebih kecil daripada S; Memulakan pembolehubah; Mencari digit kth terakhir; Tambah baki untuk membuat digit 0; Jika jumlah digit tidak melebihi s; Kemas kini k; Kod pemacu; Diberikan n dan s; Panggilan fungsi"}
{"text": "Maximize count of Decreasing Consecutive Subsequences from an Array | C ++ program to implement the above approach ; Function to find the maximum number number of required subsequences ; HashMap to store number of arrows available with height of arrow as key ; Stores the maximum count of possible subsequences ; Stores the count of possible subsequences ; Check if i - th element can be part of any of the previous subsequence ; Count of subsequences possible with arr [ i ] as the next element ; If more than one such subsequence exists ; Include arr [ i ] in a subsequence ; Otherwise ; Increase count of subsequence possible with arr [ i ] - 1 as the next element ; Start a new subsequence ; Increase count of subsequence possible with arr [ i ] - 1 as the next element ; Return the answer ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSubsequences ( int arr [ ] , int n ) { unordered_map < int , int > m ; int maxCount = 0 ; int count ; for ( int i = 0 ; i < n ; i ++ ) { if ( m . find ( arr [ i ] ) != m . end ( ) ) { count = m [ arr [ i ] ] ; if ( count > 1 ) { m [ arr [ i ] ] = count - 1 ; } else m . erase ( arr [ i ] ) ; if ( arr [ i ] - 1 > 0 ) m [ arr [ i ] - 1 ] += 1 ; } else { maxCount ++ ; if ( arr [ i ] - 1 > 0 ) m [ arr [ i ] - 1 ] += 1 ; } } return maxCount ; } int main ( ) { int n = 5 ; int arr [ ] = { 4 , 5 , 2 , 1 , 4 } ; cout << maxSubsequences ( arr , n ) << endl ; }", "text_ms": "Memaksimumkan kiraan penurunan seterusnya berturut -turut dari array | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari bilangan maksimum bilangan berikutnya yang diperlukan; HashMap untuk menyimpan bilangan anak panah yang tersedia dengan ketinggian anak panah sebagai kunci; Menyimpan kiraan maksimum kemungkinan berikutnya; Menyimpan kiraan kemungkinan seterusnya; Semak jika elemen saya boleh menjadi sebahagian daripada mana -mana berikutnya; Kiraan seterusnya mungkin dengan arr [i] sebagai elemen seterusnya; Jika lebih daripada satu berikutnya wujud; Termasuk arr [i] dalam berikutnya; Jika tidak; Meningkatkan kiraan seterusnya dengan ARR [i] - 1 sebagai elemen seterusnya; Mulakan berikutnya baru; Meningkatkan kiraan seterusnya dengan ARR [i] - 1 sebagai elemen seterusnya; Kembalikan jawapannya; Kod pemacu"}
{"text": "Remove the first and last occurrence of a given Character from a String | C ++ Program to implement the above approach ; Function to remove first and last occurrence of a given character from the given string ; Traverse the given string from the beginning ; If ch is found ; Traverse the given string from the end ; If ch is found ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string removeOcc ( string & s , char ch ) { for ( int i = 0 ; s [ i ] ; i ++ ) { if ( s [ i ] == ch ) { s . erase ( s . begin ( ) + i ) ; break ; } } for ( int i = s . length ( ) - 1 ; i > -1 ; i -- ) { if ( s [ i ] == ch ) { s . erase ( s . begin ( ) + i ) ; break ; } } return s ; } int main ( ) { string s = \" hello ▁ world \" ; char ch = ' l ' ; cout << removeOcc ( s , ch ) ; return 0 ; }", "text_ms": "Keluarkan kejadian pertama dan terakhir yang diberikan dari rentetan | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk menghapuskan kejadian pertama dan terakhir dari watak yang diberikan dari rentetan yang diberikan; Melintasi rentetan yang diberikan dari awal; Jika ch dijumpai; Melintasi rentetan yang diberikan dari hujungnya; Jika ch dijumpai; Kod pemacu"}
{"text": "Minimum steps for increasing and decreasing Array to reach either 0 or N | C ++ program for the above approach ; Function that finds the minimum steps to reach either 0 or N for given increasing and decreasing arrays ; Initialize variable to find the minimum element ; Find minimum element in increasing [ ] array ; Initialize variable to find the maximum element ; Find maximum element in decreasing [ ] array ; Find the minimum steps ; Print the minimum steps ; Driver code ; Given N ; Given increasing and decreasing array ; Find length of arrays increasing and decreasing ; Function call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void minSteps ( int N , int increasing [ ] , int decreasing [ ] , int m1 , int m2 ) { int mini = INT_MAX ; for ( int i = 0 ; i < m1 ; i ++ ) { if ( mini > increasing [ i ] ) mini = increasing [ i ] ; } int maxi = INT_MIN ; for ( int i = 0 ; i < m2 ; i ++ ) { if ( maxi < decreasing [ i ] ) maxi = decreasing [ i ] ; } int minSteps = max ( maxi , N - mini ) ; cout << minSteps << endl ; } int main ( ) { int N = 7 ; int increasing [ ] = { 3 , 5 } ; int decreasing [ ] = { 6 } ; int m1 = sizeof ( increasing ) / sizeof ( increasing [ 0 ] ) ; int m2 = sizeof ( decreasing ) / sizeof ( decreasing [ 0 ] ) ; minSteps ( N , increasing , decreasing , m1 , m2 ) ; }", "text_ms": "Langkah -langkah minimum untuk meningkatkan dan mengurangkan array untuk mencapai 0 atau n | Program C ++ untuk pendekatan di atas; Fungsi yang mendapati langkah -langkah minimum untuk mencapai 0 atau n untuk peningkatan array yang semakin meningkat dan menurun; Memulakan pemboleh ubah untuk mencari elemen minimum; Cari elemen minimum dalam peningkatan [] array; Memulakan pembolehubah untuk mencari elemen maksimum; Cari elemen maksimum dalam penurunan [] array; Cari langkah minimum; Cetak langkah minimum; Kod pemacu; Diberikan n; Memandangkan peningkatan dan penurunan array; Cari panjang tatasusunan yang semakin meningkat dan berkurangan; Panggilan fungsi"}
{"text": "Minimum number of adjacent swaps required to convert a permutation to another permutation by given condition | C ++ program for the above approach ; Function to find the minimum number of swaps ; New array to convert to 1 - based indexing ; Keeps count of swaps ; Check if it is an ' X ' position ; Corner Case ; Swap ; Print the minimum swaps ; Driver Code ; Given Number N ; Given Permutation of N numbers ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void solve ( vector < int > & P , int n ) { vector < int > arr ; arr . push_back ( 0 ) ; for ( auto x : P ) arr . push_back ( x ) ; int cnt = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == i ) { swap ( arr [ i ] , arr [ i + 1 ] ) ; cnt ++ ; } } if ( arr [ n ] == n ) { swap ( arr [ n - 1 ] , arr [ n ] ) ; cnt ++ ; } cout << cnt << endl ; } signed main ( ) { int N = 9 ; vector < int > P = { 1 , 2 , 4 , 9 , 5 , 8 , 7 , 3 , 6 } ; solve ( P , N ) ; return 0 ; }", "text_ms": "Bilangan minimum swap bersebelahan yang diperlukan untuk menukar permutasi kepada permutasi lain dengan keadaan yang diberikan | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari bilangan swap minimum; Array baru untuk menukar kepada pengindeksan berasaskan 1; Menyimpan swap; Semak sama ada kedudukan 'X'; Kes sudut; Swap; Cetak swap minimum; Kod pemacu; Diberi nombor n; Diberi permutasi nombor N; Panggilan fungsi"}
{"text": "Count of interesting primes upto N | C ++ program to find the number of interesting primes up to N . ; Function to find all prime numbers ; Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries as true . A value in prime [ i ] will finally be false if i is Not a prime . ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p greater than or equal to the square of it ; Store all prime numbers ; Function to check if a number is perfect square or not ; To store all primes ; To store all interseting primes ; Store all perfect squares ; Store all perfect quadruples ; Store all interseting primes ; Return count of interseting primes ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void SieveOfEratosthenes ( int n , unordered_set < int > & allPrimes ) { bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) allPrimes . insert ( p ) ; } int countInterestingPrimes ( int n ) { unordered_set < int > allPrimes ; SieveOfEratosthenes ( n , allPrimes ) ; unordered_set < int > intersetingPrimes ; vector < int > squares , quadruples ; for ( int i = 1 ; i * i <= n ; i ++ ) { squares . push_back ( i * i ) ; } for ( int i = 1 ; i * i * i * i <= n ; i ++ ) { quadruples . push_back ( i * i * i * i ) ; } for ( auto a : squares ) { for ( auto b : quadruples ) { if ( allPrimes . count ( a + b ) ) intersetingPrimes . insert ( a + b ) ; } } return intersetingPrimes . size ( ) ; } int main ( ) { int N = 10 ; cout << countInterestingPrimes ( N ) ; return 0 ; }", "text_ms": "Count of Prima yang menarik sehingga n | Program C ++ untuk mencari bilangan prima yang menarik sehingga n. ; Berfungsi untuk mencari semua nombor utama; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaan sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana. ; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Mengemas kini semua gandaan p lebih besar daripada atau sama dengan kuadrat itu; Simpan semua nombor utama; Berfungsi untuk memeriksa sama ada nombor adalah persegi sempurna atau tidak; Untuk menyimpan semua prima; Untuk menyimpan semua prima interset; Simpan semua dataran yang sempurna; Simpan semua quadruples yang sempurna; Simpan semua prima interset; Kembali kiraan prima interset; Kod pemacu"}
{"text": "Check if an array is Wave Array | CPP code to check if the array is wave array ; Function to check if array is wave array arr : input array n : size of array ; Check the wave form * If arr [ 1 ] is greater than left and right * Same pattern will be followed by whole * elements , else reverse pattern * will be followed by array elements ; Check for last element ; Check for last element ; Driver Code ; Array", "code": "#include <iostream> NEW_LINE using namespace std ; bool isWaveArray ( int arr [ ] , int n ) { bool result = true ; if ( arr [ 1 ] > arr [ 0 ] && arr [ 1 ] > arr [ 2 ] ) { for ( int i = 1 ; i < n - 1 ; i += 2 ) { if ( arr [ i ] > arr [ i - 1 ] && arr [ i ] > arr [ i + 1 ] ) { result = true ; } else { result = false ; break ; } } if ( result == true && n % 2 == 0 ) { if ( arr [ n - 1 ] <= arr [ n - 2 ] ) { result = false ; } } } else if ( arr [ 1 ] < arr [ 0 ] && arr [ 1 ] < arr [ 2 ] ) { for ( int i = 1 ; i < n - 1 ; i += 2 ) { if ( arr [ i ] < arr [ i - 1 ] && arr [ i ] < arr [ i + 1 ] ) { result = true ; } else { result = false ; break ; } } if ( result == true && n % 2 == 0 ) { if ( arr [ n - 1 ] >= arr [ n - 2 ] ) { result = false ; } } } return result ; } int main ( ) { int arr [ ] = { 1 , 3 , 2 , 4 } ; int n = sizeof ( arr ) / sizeof ( int ) ; if ( isWaveArray ( arr , n ) ) { cout << \" YES \" << endl ; } else { cout << \" NO \" << endl ; } return 0 ; }", "text_ms": "Semak jika array adalah array gelombang | Kod CPP untuk memeriksa sama ada array adalah pelbagai gelombang; Fungsi untuk memeriksa sama ada array adalah array gelombang arr: array input n: saiz array; Semak borang gelombang * jika arr [1] lebih besar daripada corak kiri dan kanan * yang sama akan diikuti oleh seluruh elemen *, corak terbalik lain * akan diikuti oleh unsur -unsur array; Semak elemen terakhir; Semak elemen terakhir; Kod pemacu; Array"}
{"text": "Count distinct sequences obtained by replacing all elements of subarrays having equal first and last elements with the first element any number of times | C ++ program for the above approach ; Function to count number of sequences satisfying the given criteria ; Stores the index of the last occurrence of the element ; Initialize an array to store the number of different sequences that are possible of length i ; Base Case ; If no operation is applied on ith element ; If operation is applied on ith element ; Update the last occurrence of curEle ; Finally , print the answer ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void countPossiblities ( int arr [ ] , int n ) { int lastOccur [ 100000 ] ; for ( int i = 0 ; i < n ; i ++ ) { lastOccur [ i ] = -1 ; } int dp [ n + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { int curEle = arr [ i - 1 ] ; dp [ i ] = dp [ i - 1 ] ; if ( lastOccur [ curEle ] != -1 & lastOccur [ curEle ] < i - 1 ) { dp [ i ] += dp [ lastOccur [ curEle ] ] ; } lastOccur [ curEle ] = i ; } cout << dp [ n ] << endl ; } int main ( ) { int arr [ ] = { 1 , 2 , 1 , 2 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countPossiblities ( arr , N ) ; return 0 ; }", "text_ms": "Mengira urutan yang berbeza yang diperoleh dengan menggantikan semua elemen subarray yang mempunyai unsur pertama dan terakhir yang sama dengan elemen pertama sebilangan kali | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira bilangan urutan yang memenuhi kriteria yang diberikan; Menyimpan indeks kejadian terakhir elemen; Memulakan array untuk menyimpan bilangan urutan yang berbeza yang mungkin panjang i; Kes asas; Sekiranya tiada operasi digunakan pada elemen ITH; Jika operasi digunakan pada elemen ITH; Mengemas kini kejadian terakhir Curele; Akhirnya, cetak jawapannya; Kod pemacu"}
{"text": "Maximum sum possible from given Matrix by performing given operations | C ++ program for the above approach ; Function to print the maximum sum ; Dp table ; Initializing dp array with 0 s ; Base case ; Traverse each column ; Update answer for both rows ; Print the maximum sum ; Driver Code ; Given array ; Number of Columns ; Function calls", "code": "#include <iostream> NEW_LINE #include <vector> NEW_LINE using namespace std ; void maxSum ( vector < vector < int > > arr , int n , int m ) { vector < vector < int > > dp ( n ) ; for ( int i = 0 ; i < 2 ; i ++ ) { dp [ i ] = vector < int > ( m ) ; for ( int j = 0 ; j < m ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ m - 1 ] = arr [ 0 ] [ m - 1 ] ; dp [ 1 ] [ m - 1 ] = arr [ 1 ] [ m - 1 ] ; for ( int j = m - 2 ; j >= 0 ; j -- ) { for ( int i = 0 ; i < 2 ; i ++ ) { if ( i == 1 ) { dp [ i ] [ j ] = max ( arr [ i ] [ j ] + dp [ 0 ] [ j + 1 ] , arr [ i ] [ j ] + dp [ 0 ] [ j + 2 ] ) ; } else { dp [ i ] [ j ] = max ( arr [ i ] [ j ] + dp [ 1 ] [ j + 1 ] , arr [ i ] [ j ] + dp [ 1 ] [ j + 2 ] ) ; } } } cout << max ( dp [ 0 ] [ 0 ] , dp [ 1 ] [ 0 ] ) ; } int main ( ) { vector < vector < int > > arr = { { 1 , 50 , 21 , 5 } , { 2 , 10 , 10 , 5 } } ; int N = arr [ 0 ] . size ( ) ; maxSum ( arr , 2 , N ) ; return 0 ; }", "text_ms": "Jumlah maksimum yang mungkin dari matriks yang diberikan dengan melaksanakan operasi yang diberikan | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencetak jumlah maksimum; Jadual DP; Memulakan array DP dengan 0 s; Kes asas; Melintasi setiap lajur; Kemas kini jawapan untuk kedua -dua baris; Cetak jumlah maksimum; Kod pemacu; Diberikan array; Bilangan lajur; Panggilan fungsi"}
{"text": "Maximum sum possible from given Matrix by performing given operations | C ++ code for the above approach ; Function to print the maximum sum possible by selecting at most one element from each column such that no consecutive pairs are selected from a single row ; Initialize variables ; Traverse each column ; Print answer ; Driver Code ; Numberof columns", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxSum ( vector < vector < int > > arr , int n ) { int r1 = 0 , r2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int temp = r1 ; r1 = max ( r1 , r2 + arr [ 0 ] [ i ] ) ; r2 = max ( r2 , temp + arr [ 1 ] [ i ] ) ; } cout << max ( r1 , r2 ) ; } int main ( ) { vector < vector < int > > arr = { { 1 , 50 , 21 , 5 } , { 2 , 10 , 10 , 5 } } ; int n = arr [ 0 ] . size ( ) ; maxSum ( arr , n ) ; return 0 ; }", "text_ms": "Jumlah maksimum yang mungkin dari matriks yang diberikan dengan melaksanakan operasi yang diberikan | C ++ kod untuk pendekatan di atas; Fungsi untuk mencetak jumlah maksimum yang mungkin dengan memilih kebanyakan elemen dari setiap lajur sehingga tiada pasangan berturut -turut dipilih dari satu baris; Memulakan pembolehubah; Melintasi setiap lajur; Jawapan cetak; Kod pemacu; Lajur nombor"}
{"text": "Count unimodal and non | C ++ program for the above approach ; Function to calculate the factorials up to a number ; Calculate the factorial ; Function to find power ( a , b ) ; Iterate until b exists ; If b is divisible by 2 ; Decrease the value of b ; Return the answer ; Function that counts the unimodal and non - unimodal permutations of a given integer N ; Function Call for finding factorials up to N ; Function to count unimodal permutations ; Non - unimodal permutation is N ! - unimodal permutations ; Driver Code ; Given Number N ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int mod = 1e9 + 7 ; const int mx = 1e6 ; int fact [ mx + 1 ] ; void Calculate_factorial ( ) { fact [ 0 ] = 1 ; for ( int i = 1 ; i <= mx ; i ++ ) { fact [ i ] = i * fact [ i - 1 ] ; fact [ i ] %= mod ; } } int UniModal_per ( int a , int b ) { long long int res = 1 ; while ( b ) { if ( b % 2 ) res = res * a ; res %= mod ; a = a * a ; a %= mod ; b /= 2 ; } return res ; } void countPermutations ( int n ) { Calculate_factorial ( ) ; int uni_modal = UniModal_per ( 2 , n - 1 ) ; int nonuni_modal = fact [ n ] - uni_modal ; cout << uni_modal << \" ▁ \" << nonuni_modal ; return ; } int main ( ) { int N = 4 ; countPermutations ( N ) ; return 0 ; }", "text_ms": "Kira unimodal dan bukan | Program C ++ untuk pendekatan di atas; Berfungsi untuk mengira faktorial sehingga nombor; Kirakan faktorial; Berfungsi untuk mencari kuasa (a, b); Melangkah sehingga B wujud; Jika B boleh dibahagikan dengan 2; Mengurangkan nilai b; Kembalikan jawapannya; Fungsi yang mengira permutasi unimodal dan bukan unimodal dari integer yang diberikan; Fungsi panggilan untuk mencari faktorial sehingga n; Berfungsi untuk mengira permutasi unimodal; Permutasi bukan unimodal adalah N! - permutasi unimodal; Kod pemacu; Diberi nombor n; Panggilan fungsi"}
{"text": "Longest subsequence possible that starts and ends with 1 and filled with 0 in the middle | C ++ Program to find the longest subsequence possible that starts and ends with 1 and filled with 0 in the middle ; Prefix array to store the occurences of '1' and '0' ; Initialise prefix arrays with 0 ; Iterate over the length of the string ; If current character is '1' ; If current character is '0' ; Add '1' available for the first string ; Add '0' available for the second string ; Add '1' available for the third string ; Update answer ; Print the final result ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int longestSubseq ( string s , int length ) { int ones [ length + 1 ] , zeroes [ length + 1 ] ; memset ( ones , 0 , sizeof ( ones ) ) ; memset ( zeroes , 0 , sizeof ( zeroes ) ) ; for ( int i = 0 ; i < length ; i ++ ) { if ( s [ i ] == '1' ) { ones [ i + 1 ] = ones [ i ] + 1 ; zeroes [ i + 1 ] = zeroes [ i ] ; } else { zeroes [ i + 1 ] = zeroes [ i ] + 1 ; ones [ i + 1 ] = ones [ i ] ; } } int answer = INT_MIN ; int x = 0 ; for ( int i = 0 ; i <= length ; i ++ ) { for ( int j = i ; j <= length ; j ++ ) { x += ones [ i ] ; x += ( zeroes [ j ] - zeroes [ i ] ) ; x += ( ones [ length ] - ones [ j ] ) ; answer = max ( answer , x ) ; x = 0 ; } } cout << answer << endl ; } int main ( ) { string s = \"10010010111100101\" ; int length = s . length ( ) ; longestSubseq ( s , length ) ; return 0 ; }", "text_ms": "Susunan terpanjang mungkin yang bermula dan berakhir dengan 1 dan diisi dengan 0 di tengah | Program C ++ untuk mencari kemungkinan seterusnya yang paling lama yang bermula dan berakhir dengan 1 dan diisi dengan 0 di tengah; Arahan awalan untuk menyimpan kejadian '1' dan '0'; Arahan awalan permulaan dengan 0; Melangkah ke atas panjang rentetan; Jika watak semasa adalah '1'; Jika watak semasa adalah '0'; Tambah '1' yang tersedia untuk rentetan pertama; Tambah '0' tersedia untuk rentetan kedua; Tambah '1' yang tersedia untuk rentetan ketiga; Jawapan kemas kini; Cetak hasil akhir; Kod pemacu"}
{"text": "Largest Square in a Binary Matrix with at most K 1 s for multiple Queries | C ++ implementation to find the largest square in the matrix such that it contains atmost K 1 's ; Function to calculate the largest square with atmost K 1 s for Q queries ; Loop to solve for each query ; Traversing the each sub square and counting total ; Breaks when exceeds the maximum count ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; void largestSquare ( int matrix [ ] [ MAX ] , int R , int C , int q_i [ ] , int q_j [ ] , int K , int Q ) { for ( int q = 0 ; q < Q ; q ++ ) { int i = q_i [ q ] ; int j = q_j [ q ] ; int min_dist = min ( min ( i , j ) , min ( R - i - 1 , C - j - 1 ) ) ; int ans = -1 ; for ( int k = 0 ; k <= min_dist ; k ++ ) { int count = 0 ; for ( int row = i - k ; row <= i + k ; row ++ ) for ( int col = j - k ; col <= j + k ; col ++ ) count += matrix [ row ] [ col ] ; if ( count > K ) break ; ans = 2 * k + 1 ; } cout << ans << \" STRNEWLINE \" ; } } int main ( ) { int matrix [ ] [ MAX ] = { { 1 , 0 , 1 , 0 , 0 } , { 1 , 0 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 } , { 1 , 0 , 0 , 1 , 0 } } ; int K = 9 , Q = 1 ; int q_i [ ] = { 1 } ; int q_j [ ] = { 2 } ; largestSquare ( matrix , 4 , 5 , q_i , q_j , K , Q ) ; return 0 ; }", "text_ms": "Dataran terbesar dalam matriks binari dengan paling banyak k 1 s untuk pelbagai pertanyaan | C ++ pelaksanaan untuk mencari dataran terbesar dalam matriks supaya ia mengandungi atmost k 1 's; Berfungsi untuk mengira dataran terbesar dengan atmost k 1 s untuk pertanyaan Q; Gelung untuk menyelesaikan setiap pertanyaan; Melintasi setiap sub persegi dan mengira jumlah; Pecah apabila melebihi kiraan maksimum; Kod pemacu"}
{"text": "Largest Square in a Binary Matrix with at most K 1 s for multiple Queries | C ++ implementation to find the largest square in the matrix such that it contains atmost K 1 's ; Function to find the largest square in the matrix such that it contains atmost K 1 's ; Precomputing the countDP prefix sum of the matrix ; Loop to solve Queries ; Calculating the maximum possible distance of the centre from edge ; Calculating the number of 1 s in the submatrix ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; void largestSquare ( int matrix [ ] [ MAX ] , int R , int C , int q_i [ ] , int q_j [ ] , int K , int Q ) { int countDP [ R ] [ C ] ; memset ( countDP , 0 , sizeof ( countDP ) ) ; countDP [ 0 ] [ 0 ] = matrix [ 0 ] [ 0 ] ; for ( int i = 1 ; i < R ; i ++ ) countDP [ i ] [ 0 ] = countDP [ i - 1 ] [ 0 ] + matrix [ i ] [ 0 ] ; for ( int j = 1 ; j < C ; j ++ ) countDP [ 0 ] [ j ] = countDP [ 0 ] [ j - 1 ] + matrix [ 0 ] [ j ] ; for ( int i = 1 ; i < R ; i ++ ) for ( int j = 1 ; j < C ; j ++ ) countDP [ i ] [ j ] = matrix [ i ] [ j ] + countDP [ i - 1 ] [ j ] + countDP [ i ] [ j - 1 ] - countDP [ i - 1 ] [ j - 1 ] ; for ( int q = 0 ; q < Q ; q ++ ) { int i = q_i [ q ] ; int j = q_j [ q ] ; int min_dist = min ( min ( i , j ) , min ( R - i - 1 , C - j - 1 ) ) ; int ans = -1 ; for ( int k = 0 ; k <= min_dist ; k ++ ) { int x1 = i - k , x2 = i + k ; int y1 = j - k , y2 = j + k ; int count = countDP [ x2 ] [ y2 ] ; if ( x1 > 0 ) count -= countDP [ x1 - 1 ] [ y2 ] ; if ( y1 > 0 ) count -= countDP [ x2 ] [ y1 - 1 ] ; if ( x1 > 0 && y1 > 0 ) count += countDP [ x1 - 1 ] [ y1 - 1 ] ; if ( count > K ) break ; ans = 2 * k + 1 ; } cout << ans << \" STRNEWLINE \" ; } } int main ( ) { int matrix [ ] [ MAX ] = { { 1 , 0 , 1 , 0 , 0 } , { 1 , 0 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 } , { 1 , 0 , 0 , 1 , 0 } } ; int K = 9 , Q = 1 ; int q_i [ ] = { 1 } ; int q_j [ ] = { 2 } ; largestSquare ( matrix , 4 , 5 , q_i , q_j , K , Q ) ; return 0 ; }", "text_ms": "Dataran terbesar dalam matriks binari dengan paling banyak k 1 s untuk pelbagai pertanyaan | C ++ pelaksanaan untuk mencari dataran terbesar dalam matriks supaya ia mengandungi atmost k 1 's; Berfungsi untuk mencari dataran terbesar dalam matriks supaya ia mengandungi atmost k 1 's; Precomputing jumlah awalan countdp matriks; Gelung untuk menyelesaikan pertanyaan; Mengira jarak maksimum yang mungkin dari pusat dari tepi; Mengira bilangan 1 s dalam submatrix; Kod pemacu"}
{"text": "N consecutive ropes problem | C ++ implementation of the approach ; Function to return the minimum cost to connect the given ropes ; dp [ i ] [ j ] = minimum cost in range ( i , j ) sum [ i ] [ j ] = sum of range ( i , j ) ; Initializing the sum table ; Computing minimum cost for all the possible interval ( i , j ) Left range ; Right range ; No cost for a single rope ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int MinCost ( int arr [ ] , int n ) { int dp [ n + 5 ] [ n + 5 ] , sum [ n + 5 ] [ n + 5 ] ; memset ( sum , 0 , sizeof ( 0 ) ) ; for ( int i = 0 ; i < n ; i ++ ) { int k = arr [ i ] ; for ( int j = i ; j < n ; j ++ ) { if ( i == j ) sum [ i ] [ j ] = k ; else { k += arr [ j ] ; sum [ i ] [ j ] = k ; } } } for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = i ; j < n ; j ++ ) { dp [ i ] [ j ] = INT_MAX ; if ( i == j ) dp [ i ] [ j ] = 0 ; else { for ( int k = i ; k < j ; k ++ ) { dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] + sum [ i ] [ j ] ) ; } } } } return dp [ 0 ] [ n - 1 ] ; } int main ( ) { int arr [ ] = { 7 , 6 , 8 , 6 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << MinCost ( arr , n ) ; return 0 ; }", "text_ms": "N Masalah Tali berturut -turut | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan kos minimum untuk menyambungkan tali yang diberikan; dp [i] [j] = kos minimum dalam julat (i, j) jumlah [i] [j] = jumlah julat (i, j); Memulakan jadual jumlah; Pengkomputeran kos minimum untuk semua selang waktu yang mungkin (i, j) julat kiri; Julat kanan; Tiada kos untuk tali tunggal; Kod pemacu"}
{"text": "Length of the longest subsegment which is UpDown after inserting atmost one integer | C ++ implementation of the approach ; Function to recursively fill the dp array ; If f ( i , state ) is already calculated then return the value ; Calculate f ( i , state ) according to the recurrence relation and store in dp [ ] [ ] ; Function that calls the resucrsive function to fill the dp array and then returns the result ; dp [ ] [ ] array for storing result of f ( i , 1 ) and f ( 1 , 2 ) ; Populating the array dp [ ] with - 1 ; Make sure that longest UD and DU sequence starting at each index is calculated ; Assume the answer to be - 1 This value will only increase ; y is the length of the longest UD sequence starting at i ; If length is even then add an integer and then a DU sequence starting at i + y ; If length is odd then add an integer and then a UD sequence starting at i + y ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int f ( int i , int state , int A [ ] , int dp [ ] [ 3 ] , int N ) { if ( i >= N ) return 0 ; else if ( dp [ i ] [ state ] != -1 ) { return dp [ i ] [ state ] ; } else { if ( i == N - 1 ) dp [ i ] [ state ] = 1 ; else if ( state == 1 && A [ i ] > A [ i + 1 ] ) dp [ i ] [ state ] = 1 ; else if ( state == 2 && A [ i ] < A [ i + 1 ] ) dp [ i ] [ state ] = 1 ; else if ( state == 1 && A [ i ] <= A [ i + 1 ] ) dp [ i ] [ state ] = 1 + f ( i + 1 , 2 , A , dp , N ) ; else if ( state == 2 && A [ i ] >= A [ i + 1 ] ) dp [ i ] [ state ] = 1 + f ( i + 1 , 1 , A , dp , N ) ; return dp [ i ] [ state ] ; } } int maxLenSeq ( int A [ ] , int N ) { int i , tmp , y , ans ; int dp [ 1000 ] [ 3 ] ; memset ( dp , -1 , sizeof dp ) ; for ( i = 0 ; i < N ; i ++ ) { tmp = f ( i , 1 , A , dp , N ) ; tmp = f ( i , 2 , A , dp , N ) ; } ans = -1 ; for ( i = 0 ; i < N ; i ++ ) { y = dp [ i ] [ 1 ] ; if ( i + y >= N ) ans = max ( ans , dp [ i ] [ 1 ] + 1 ) ; else if ( y % 2 == 0 ) { ans = max ( ans , dp [ i ] [ 1 ] + 1 + dp [ i + y ] [ 2 ] ) ; } else if ( y % 2 == 1 ) { ans = max ( ans , dp [ i ] [ 1 ] + 1 + dp [ i + y ] [ 1 ] ) ; } } return ans ; } int main ( ) { int A [ ] = { 1 , 10 , 3 , 20 , 25 , 24 } ; int n = sizeof ( A ) / sizeof ( int ) ; cout << maxLenSeq ( A , n ) ; return 0 ; }", "text_ms": "Panjang subsegment terpanjang yang dikemas kini selepas memasukkan atmost satu integer | C ++ pelaksanaan pendekatan; Berfungsi untuk mengisi semula array DP; Jika f (i, state) sudah dikira maka kembalikan nilai; Hitung f (i, state) mengikut hubungan berulang dan simpan dalam dp [] []; Fungsi yang memanggil fungsi resucrsive untuk mengisi array DP dan kemudian mengembalikan hasilnya; dp [] [] array untuk menyimpan hasil f (i, 1) dan f (1, 2); Memaparkan array dp [] dengan - 1; Pastikan urutan UD dan DU terpanjang bermula pada setiap indeks dikira; Anggapkan jawapannya - 1 Nilai ini hanya akan meningkat; y ialah panjang urutan UD terpanjang bermula pada i; Jika panjangnya, tambah integer dan kemudian urutan du bermula pada i + y; Jika panjang ganjil maka tambah integer dan kemudian urutan ud bermula pada i + y; Kod pemacu"}
{"text": "Remove an element to maximize the GCD of the given array | C ++ implementation of the above approach ; Function to return the maximized gcd after removing a single element from the given array ; Prefix and Suffix arrays ; Single state dynamic programming relation for storing gcd of first i elements from the left in Prefix [ i ] ; Initializing Suffix array ; Single state dynamic programming relation for storing gcd of all the elements having greater than or equal to i in Suffix [ i ] ; If first or last element of the array has to be removed ; If any other element is replaced ; Return the maximized gcd ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int MaxGCD ( int a [ ] , int n ) { int Prefix [ n + 2 ] ; int Suffix [ n + 2 ] ; Prefix [ 1 ] = a [ 0 ] ; for ( int i = 2 ; i <= n ; i += 1 ) { Prefix [ i ] = __gcd ( Prefix [ i - 1 ] , a [ i - 1 ] ) ; } Suffix [ n ] = a [ n - 1 ] ; for ( int i = n - 1 ; i >= 1 ; i -= 1 ) { Suffix [ i ] = __gcd ( Suffix [ i + 1 ] , a [ i - 1 ] ) ; } int ans = max ( Suffix [ 2 ] , Prefix [ n - 1 ] ) ; for ( int i = 2 ; i < n ; i += 1 ) { ans = max ( ans , __gcd ( Prefix [ i - 1 ] , Suffix [ i + 1 ] ) ) ; } return ans ; } int main ( ) { int a [ ] = { 14 , 17 , 28 , 70 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << MaxGCD ( a , n ) ; return 0 ; }", "text_ms": "Keluarkan elemen untuk memaksimumkan GCD array yang diberikan | C ++ pelaksanaan pendekatan di atas; Berfungsi untuk mengembalikan GCD yang dimaksimumkan selepas mengeluarkan satu elemen dari array yang diberikan; Awalan dan akhiran tatasusunan; Hubungan pengaturcaraan dinamik tunggal untuk menyimpan GCD unsur -unsur pertama saya dari kiri dalam awalan [i]; Memulakan array akhiran; Hubungan pengaturcaraan dinamik tunggal untuk menyimpan GCD dari semua elemen yang mempunyai lebih besar daripada atau sama dengan saya dalam akhiran [i]; Jika elemen pertama atau terakhir array perlu dikeluarkan; Jika elemen lain diganti; Mengembalikan GCD yang dimaksimumkan; Kod pemacu"}
{"text": "Maximum subarray sum by flipping signs of at most K array elements | C ++ implementation of the approach ; Function to find the maximum subarray sum with flips starting from index i ; If the number of flips have exceeded ; Complete traversal ; If the state has previously been visited ; Initially ; Use Kadane 's algorithm and call two states ; Memoize the answer and return it ; Utility function to call flips from index and return the answer ; Create DP array int dp [ n ] [ k + 1 ] ; ; Iterate and call recursive function from every index to get the maximum subarray sum ; corner case ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define right  2 NEW_LINE #define left  4 NEW_LINE int dp [ left ] [ right ] ; int findSubarraySum ( int ind , int flips , int n , int a [ ] , int k ) { if ( flips > k ) return -1e9 ; if ( ind == n ) return 0 ; if ( dp [ ind ] [ flips ] != -1 ) return dp [ ind ] [ flips ] ; int ans = 0 ; ans = max ( 0 , a [ ind ] + findSubarraySum ( ind + 1 , flips , n , a , k ) ) ; ans = max ( ans , - a [ ind ] + findSubarraySum ( ind + 1 , flips + 1 , n , a , k ) ) ; return dp [ ind ] [ flips ] = ans ; } int findMaxSubarraySum ( int a [ ] , int n , int k ) { memset ( dp , -1 , sizeof ( dp ) ) ; int ans = -1e9 ; for ( int i = 0 ; i < n ; i ++ ) ans = max ( ans , findSubarraySum ( i , 0 , n , a , k ) ) ; if ( ans == 0 && k == 0 ) return * max_element ( a , a + n ) ; return ans ; } int main ( ) { int a [ ] = { -1 , -2 , -100 , -10 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int k = 1 ; cout << findMaxSubarraySum ( a , n , k ) ; return 0 ; }", "text_ms": "SUM MAXIMUM SUMBER DENGAN MENGURANGKAN TANDA PALING PADA ELEMENT ARAY KEDUA | C ++ pelaksanaan pendekatan; Berfungsi untuk mencari jumlah subarray maksimum dengan flip bermula dari indeks I; Jika bilangan flip telah melebihi; Traversal lengkap; Sekiranya negara sebelum ini telah dikunjungi; Pada mulanya; Gunakan algoritma Kadane dan hubungi dua negeri; Memoize jawapan dan mengembalikannya; Fungsi utiliti untuk memanggil flips dari indeks dan mengembalikan jawapannya; Buat array dp int dp [n] [k + 1]; ; ITERATE dan CALL FUNGSI RECURSIF DARI SETIAP INDEX UNTUK MEMBERI JUMLAH SUBARRAY MAXIMUM; kes sudut; Kod pemacu"}
{"text": "Find the sum of first N odd Fibonacci numbers | CPP program to Find the sum of first N odd Fibonacci numbers ; Function to calculate sum of first N odd Fibonacci numbers ; base values ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define mod  1000000007 NEW_LINE long long sumOddFibonacci ( int n ) { long long Sum [ n + 1 ] ; Sum [ 0 ] = 0 ; Sum [ 1 ] = 1 ; Sum [ 2 ] = 2 ; Sum [ 3 ] = 5 ; Sum [ 4 ] = 10 ; Sum [ 5 ] = 23 ; for ( int i = 6 ; i <= n ; i ++ ) { Sum [ i ] = ( ( Sum [ i - 1 ] + ( 4 * Sum [ i - 2 ] ) % mod - ( 4 * Sum [ i - 3 ] ) % mod + mod ) % mod + ( Sum [ i - 4 ] - Sum [ i - 5 ] + mod ) % mod ) % mod ; } return Sum [ n ] ; } int main ( ) { long long n = 6 ; cout << sumOddFibonacci ( n ) ; return 0 ; }", "text_ms": "Cari Jumlah Nombor Fibonacci Pertama N yang pertama | Program CPP untuk mencari jumlah nombor Fibonacci yang pertama; Fungsi untuk mengira jumlah nombor Fibonacci yang pertama; nilai asas; Kod pemacu"}
{"text": "Minimize the total number of teddies to be distributed | C ++ implementation of the above approach ; Initializing one tablet for each student ; if left adjacent is having higher marks review and change all the dp values assigned before until assigned dp values are found wrong according to given constrains ; if right adjacent is having higher marks add one in dp of left adjacent and assign to right one ; Driver Code ; n number of students ; marks of students ; solution of problem", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long long fun ( int marks [ ] , int n ) { long long dp [ n ] , temp ; fill ( dp , dp + n , 1 ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( marks [ i ] > marks [ i + 1 ] ) { temp = i ; while ( true ) { if ( ( marks [ temp ] > marks [ temp + 1 ] ) && temp >= 0 ) { if ( dp [ temp ] > dp [ temp + 1 ] ) { temp -= 1 ; continue ; } else { dp [ temp ] = dp [ temp + 1 ] + 1 ; temp -= 1 ; } } else break ; } } else if ( marks [ i ] < marks [ i + 1 ] ) dp [ i + 1 ] = dp [ i ] + 1 ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += dp [ i ] ; return sum ; } int main ( ) { int n = 6 ; int marks [ 6 ] = { 1 , 4 , 5 , 2 , 2 , 1 } ; cout << fun ( marks , n ) ; return 0 ; }", "text_ms": "Kurangkan jumlah teddies untuk diedarkan | C ++ pelaksanaan pendekatan di atas; Memulakan satu tablet untuk setiap pelajar; Jika dibiarkan bersebelahan mempunyai kajian markah yang lebih tinggi dan mengubah semua nilai DP yang diberikan sebelum sehingga nilai DP yang diberikan didapati salah mengikut kekangan yang diberikan; Jika betul bersebelahan mempunyai markah yang lebih tinggi, tambahkan satu di dp kiri bersebelahan dan berikan ke kanan; Kod pemacu; n bilangan pelajar; tanda pelajar; penyelesaian masalah"}
{"text": "Number of ways to reach Nth floor by taking at | C ++ program to reach N - th stair by taking a maximum of K leap ; elements of combo [ ] stores the no of possible ways to reach it by all combinations of k leaps or less ; assuming leap 0 exist and assigning its value to 1 for calculation ; loop to iterate over all possible leaps upto k ; ; in this loop we count all possible leaps to reach the jth stair with the help of ith leap or less ; if the leap is not more than the i - j ; calculate the value and store in combo [ j ] to reuse it for next leap calculation for the jth stair ; returns the no of possible number of leaps to reach the top of building of n stairs ; Driver Code ; N i the no of total stairs K is the value of the greatest leap", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int solve ( int N , int K ) { int combo [ N + 1 ] = { 0 } ; combo [ 0 ] = 1 ; for ( int i = 1 ; i <= K ; i ++ ) { for ( int j = 0 ; j <= N ; j ++ ) { if ( j >= i ) { combo [ j ] += combo [ j - i ] ; } } } return combo [ N ] ; } int main ( ) { int N = 29 ; int K = 5 ; cout << solve ( N , K ) ; solve ( N , K ) ; return 0 ; }", "text_ms": "Bilangan cara untuk mencapai lantai nth dengan mengambil di | Program C ++ untuk mencapai tangga N - dengan mengambil maksimum l leap; unsur -unsur kombo [] menyimpan cara yang tidak mungkin untuk mencapainya dengan semua kombinasi K Leaps atau kurang; Dengan mengandaikan lompatan 0 wujud dan memberikan nilainya kepada 1 untuk pengiraan; gelung untuk melangkah ke atas semua kemungkinan melompat sehingga K; ; Dalam gelung ini kita mengira semua kemungkinan lompatan untuk mencapai tangga jth dengan bantuan lompatan atau kurang; Jika lompatan itu tidak lebih daripada i - j; Kirakan nilai dan simpan dalam combo [j] untuk menggunakannya semula untuk pengiraan lompatan seterusnya untuk tangga jth; Mengembalikan tidak ada kemungkinan lompatan untuk mencapai bahagian atas bangunan n tangga; Kod pemacu; N i tangga total k adalah nilai lompatan terbesar"}
{"text": "Find the Longest Increasing Subsequence in Circular manner | C ++ implementation to find LIS in circular way ; Utility function to find LIS using Dynamic programming ; Initialize LIS values for all indexes ; Compute optimized LIS values in bottom up manner ; Set j on the basis of current window i . e . first element of the current window ; Pick maximum of all LIS values ; Function to find Longest Increasing subsequence in Circular manner ; Make a copy of given array by appending same array elements to itself ; Perform LIS for each window of size n ; Driver program to test above function", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int computeLIS ( int circBuff [ ] , int start , int end , int n ) { int LIS [ end - start ] ; for ( int i = start ; i < end ; i ++ ) LIS [ i ] = 1 ; for ( int i = start + 1 ; i < end ; i ++ ) for ( int j = start ; j < i ; j ++ ) if ( circBuff [ i ] > circBuff [ j ] && LIS [ i ] < LIS [ j ] + 1 ) LIS [ i ] = LIS [ j ] + 1 ; int res = INT_MIN ; for ( int i = start ; i < end ; i ++ ) res = max ( res , LIS [ i ] ) ; return res ; } int LICS ( int arr [ ] , int n ) { int circBuff [ 2 * n ] ; for ( int i = 0 ; i < n ; i ++ ) circBuff [ i ] = arr [ i ] ; for ( int i = n ; i < 2 * n ; i ++ ) circBuff [ i ] = arr [ i - n ] ; int res = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) res = max ( computeLIS ( circBuff , i , i + n , n ) , res ) ; return res ; } int main ( ) { int arr [ ] = { 1 , 4 , 6 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << \" Length ▁ of ▁ LICS ▁ is ▁ \" << LICS ( arr , n ) ; return 0 ; }", "text_ms": "Cari yang paling lama meningkat seterusnya secara bulat | C ++ pelaksanaan untuk mencari LIS dengan cara bulat; Fungsi utiliti untuk mencari LIS menggunakan pengaturcaraan dinamik; Memulakan nilai LIS untuk semua indeks; Kirakan nilai LIS yang dioptimumkan dengan cara bawah; Tetapkan j berdasarkan tetingkap semasa i. e. elemen pertama tetingkap semasa; Pilih maksimum semua nilai LIS; Berfungsi untuk mencari peningkatan yang paling lama dalam cara bulat; Buat salinan Array yang diberikan dengan memasuki elemen array yang sama kepada dirinya sendiri; Lakukan lis untuk setiap tetingkap saiz n; Program pemacu untuk menguji fungsi di atas"}
{"text": "Counts paths from a point to reach Origin | C ++ Program for above approach ; Function to find binomial Coefficient ; Constructing Pascal 's Triangle ; Driver Code", "code": "#include <iostream> NEW_LINE #include <bits/stdc++.h> NEW_LINE using namespace std ; int binomialCoeff ( int n , int k ) { int C [ k + 1 ] ; memset ( C , 0 , sizeof ( C ) ) ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; } int main ( ) { int n = 3 , m = 2 ; cout << \" Number ▁ of ▁ Paths : ▁ \" << binomialCoeff ( n + m , n ) << endl ; return 0 ; }", "text_ms": "Mengira laluan dari titik untuk mencapai asal | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari pekali binomial; Membina segitiga Pascal; Kod pemacu"}
{"text": "Longest Common Increasing Subsequence ( LCS + LIS ) | A C ++ Program to find length of the Longest Common Increasing Subsequence ( LCIS ) ; Returns the length and the LCIS of two arrays arr1 [ 0. . n - 1 ] and arr2 [ 0. . m - 1 ] ; table [ j ] is going to store length of LCIS ending with arr2 [ j ] . We initialize it as 0 , ; Traverse all elements of arr1 [ ] ; Initialize current length of LCIS ; For each element of arr1 [ ] , traverse all elements of arr2 [ ] . ; If both the array have same elements . Note that we don 't break the loop here. ; Now seek for previous smaller common element for current element of arr1 ; The maximum value in table [ ] is out result ; Driver program to test above function", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int LCIS ( int arr1 [ ] , int n , int arr2 [ ] , int m ) { int table [ m ] ; for ( int j = 0 ; j < m ; j ++ ) table [ j ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int current = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( arr1 [ i ] == arr2 [ j ] ) if ( current + 1 > table [ j ] ) table [ j ] = current + 1 ; if ( arr1 [ i ] > arr2 [ j ] ) if ( table [ j ] > current ) current = table [ j ] ; } } int result = 0 ; for ( int i = 0 ; i < m ; i ++ ) if ( table [ i ] > result ) result = table [ i ] ; return result ; } int main ( ) { int arr1 [ ] = { 3 , 4 , 9 , 1 } ; int arr2 [ ] = { 5 , 3 , 8 , 9 , 10 , 2 , 1 } ; int n = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int m = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; cout << \" Length ▁ of ▁ LCIS ▁ is ▁ \" << LCIS ( arr1 , n , arr2 , m ) ; return ( 0 ) ; }", "text_ms": "Susunan peningkatan yang paling lama (LCS + LIS) | Program C ++ untuk mencari panjang peningkatan yang paling lama (LCI); Mengembalikan panjang dan LCIS dua array ARR1 [0. n - 1] dan arr2 [0 .. m - 1]; Jadual [J] akan menyimpan panjang LCI yang berakhir dengan ARR2 [J]. Kami memulakannya sebagai 0 ,; Melintasi semua elemen ARR1 []; Memulakan panjang semasa LCI; Untuk setiap elemen arr1 [], melintasi semua elemen ARR2 []. ; Jika kedua -dua array mempunyai elemen yang sama. Perhatikan bahawa kami tidak memecahkan gelung di sini. ; Sekarang cari elemen umum yang lebih kecil sebelumnya untuk elemen semasa ARR1; Nilai maksimum dalam Jadual [] adalah hasil; Program pemacu untuk menguji fungsi di atas"}
{"text": "Length of longest common prefix possible by rearranging strings in a given array | C ++ program to implement the above approach ; Function to get the length of the longest common prefix by rearranging the strings ; freq [ i ] [ j ] : stores the frequency of a character ( = j ) in a string arr [ i ] ; Traverse the given array ; Stores length of current string ; Traverse current string of the given array ; Update the value of freq [ i ] [ arr [ i ] [ j ] ] ; Stores the length of longest common prefix ; Count the minimum frequency of each character in in all the strings of arr [ ] ; Stores minimum value in each row of freq [ ] [ ] ; Calculate minimum frequency of current character in all the strings . ; Update minRowVal ; Update maxLen ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int longComPre ( string arr [ ] , int N ) { int freq [ N ] [ 256 ] ; for ( let String of DistString ) { for ( int i = 0 ; i < N ; i ++ ) { int M = arr [ i ] . length ( ) ; for ( int j = 0 ; j < M ; j ++ ) { freq [ i ] [ arr [ i ] [ j ] ] ++ ; } } int maxLen = 0 ; for ( int j = 0 ; j < 256 ; j ++ ) { int minRowVal = INT_MAX ; for ( int i = 0 ; i < N ; i ++ ) { minRowVal = min ( minRowVal , freq [ i ] [ j ] ) ; } maxLen += minRowVal ; } return maxLen ; } int main ( ) { string arr [ ] = { \" aabdc \" , \" abcd \" , \" aacd \" } ; int N = 3 ; cout << longComPre ( arr , N ) ; }", "text_ms": "Panjang awalan biasa terpanjang mungkin dengan menyusun semula rentetan dalam array yang diberikan | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mendapatkan panjang awalan biasa terpanjang dengan menyusun semula rentetan; freq [i] [j]: Menyimpan kekerapan aksara (= j) dalam rentetan arr [i]; Melintasi array yang diberikan; Kedai panjang rentetan semasa; Melintasi rentetan arus array yang diberikan; Kemas kini nilai freq [i] [arr [i] [j]]; Menyimpan panjang awalan biasa terpanjang; Kira kekerapan minimum setiap aksara dalam semua rentetan arr []; Kedai nilai minimum dalam setiap baris freq [] []; Kirakan kekerapan minimum aksara semasa dalam semua rentetan. ; Kemas kini Minrowval; Kemas kini Maxlen; Kod pemacu"}
{"text": "Remove characters from a String that appears exactly K times | C ++ program to remove characters from a String that appears exactly K times ; Function to reduce the string by removing the characters which appears exactly k times ; Hash table initialised to 0 ; Increment the frequency of the character ; To store answer ; Next index in reduced string ; Append the characters which appears exactly k times ; Driver code ; Function call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHAR = 26 ; string removeChars ( char arr [ ] , int k ) { int hash [ MAX_CHAR ] = { 0 } ; int n = strlen ( arr ) ; for ( int i = 0 ; i < n ; ++ i ) hash [ arr [ i ] - ' a ' ] ++ ; string ans = \" \" ; int index = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( hash [ arr [ i ] - ' a ' ] != k ) { ans += arr [ i ] ; } } return ans ; } int main ( ) { char str [ ] = \" geeksforgeeks \" ; int k = 2 ; cout << removeChars ( str , k ) ; return 0 ; }", "text_ms": "Keluarkan aksara dari rentetan yang kelihatan tepat k kali | Program C ++ untuk menghapuskan aksara dari rentetan yang muncul tepat kali K; Berfungsi untuk mengurangkan rentetan dengan mengeluarkan aksara yang kelihatan tepat K kali; Jadual Hash diasaskan kepada 0; Meningkatkan kekerapan watak; Untuk menyimpan jawapan; Indeks seterusnya dalam rentetan yang dikurangkan; Tambah watak -watak yang kelihatan tepat K kali; Kod pemacu; Panggilan fungsi"}
{"text": "Contiguous subsegments of a string having distinct subsequent characters | C ++ implementation of the approach ; Function that prints the segments ; New array for every iteration ; Check if iterator points to end or not ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void sub_segments ( string str , int n ) { int l = str . length ( ) ; for ( int x = 0 ; x < l ; x += n ) { string newlist = str . substr ( x , n ) ; list < char > arr ; list < char > :: iterator it ; for ( auto y : newlist ) { it = find ( arr . begin ( ) , arr . end ( ) , y ) ; if ( it == arr . end ( ) ) arr . push_back ( y ) ; } for ( auto y : arr ) cout << y ; cout << endl ; } } int main ( ) { string str = \" geeksforgeeksgfg \" ; int n = 4 ; sub_segments ( str , n ) ; }", "text_ms": "Subsegments bersebelahan rentetan yang mempunyai aksara berikutnya yang berbeza | C ++ pelaksanaan pendekatan; Fungsi yang mencetak segmen; Arahan baru untuk setiap lelaran; Semak sama ada titik pengalihan berakhir atau tidak; Kod pemacu"}
{"text": "Program to find the Encrypted word | C ++ program to implement the above approach ; Function to find the encrypted string ; to store the encrypted string ; after ' z ' , it should go to a . ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findWord ( string c , int n ) { int co = 0 , i ; string s ( n , ' ▁ ' ) ; for ( i = 0 ; i < n ; i ++ ) { if ( i < n / 2 ) co ++ ; else co = n - i ; if ( c [ i ] + co <= 122 ) s [ i ] = ( char ) ( ( int ) c [ i ] + co ) ; else s [ i ] = ( char ) ( ( int ) c [ i ] + co - 26 ) ; } cout << s ; } int main ( ) { string s = \" abcd \" ; findWord ( s , s . length ( ) ) ; return 0 ; }", "text_ms": "Program untuk mencari perkataan yang disulitkan | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari rentetan yang disulitkan; untuk menyimpan rentetan yang disulitkan; Selepas 'Z', ia harus pergi ke a. ; Kod pemacu"}
{"text": "Check if two strings are same ignoring their cases | Function to compare two strings ignoring their cases ; length of first string ; length of second string ; if length is not same simply return false since both string can not be same if length is not equal ; loop to match one by one all characters of both string ; if current characters of both string are same , increase value of i to compare next character ; if any character of first string is some special character or numeric character and not same as corresponding character of second string then return false ; do the same for second string ; this block of code will be executed if characters of both strings are of different cases ; compare characters by ASCII value ; if characters matched , increase the value of i to compare next char ; if all characters of the first string are matched with corresponding characters of the second string , then return true ; Function to print the same or not same if strings are equal or not equal ; Driver Code", "code": "#include <iostream> NEW_LINE using namespace std ; bool equalIgnoreCase ( string str1 , string str2 ) { int i = 0 ; int len1 = str1 . size ( ) ; int len2 = str2 . size ( ) ; if ( len1 != len2 ) return false ; while ( i < len1 ) { if ( str1 [ i ] == str2 [ i ] ) { i ++ ; } else if ( ! ( ( str1 [ i ] >= ' a ' && str1 [ i ] <= ' z ' ) || ( str1 [ i ] >= ' A ' && str1 [ i ] <= ' Z ' ) ) ) { return false ; } else if ( ! ( ( str2 [ i ] >= ' a ' && str2 [ i ] <= ' z ' ) || ( str2 [ i ] >= ' A ' && str2 [ i ] <= ' Z ' ) ) ) { return false ; } else { if ( str1 [ i ] >= ' a ' && str1 [ i ] <= ' z ' ) { if ( str1 [ i ] - 32 != str2 [ i ] ) return false ; } else if ( str1 [ i ] >= ' A ' && str1 [ i ] <= ' Z ' ) { if ( str1 [ i ] + 32 != str2 [ i ] ) return false ; } i ++ ; return true ; void equalIgnoreCaseUtil ( string str1 , string str2 ) { bool res = equalIgnoreCase ( str1 , str2 ) ; if ( res == true ) cout << \" Same \" << endl ; else cout << \" Not ▁ Same \" << endl ; } int main ( ) { string str1 , str2 ; str1 = \" Geeks \" ; str2 = \" geeks \" ; equalIgnoreCaseUtil ( str1 , str2 ) ; str1 = \" Geek \" ; str2 = \" geeksforgeeks \" ; equalIgnoreCaseUtil ( str1 , str2 ) ; return 0 ; }", "text_ms": "Semak jika dua rentetan sama mengabaikan kes mereka | Fungsi untuk membandingkan dua rentetan mengabaikan kes mereka; panjang rentetan pertama; panjang rentetan kedua; Jika panjang tidak sama hanya kembali palsu kerana kedua -dua rentetan tidak boleh sama jika panjang tidak sama; gelung untuk memadankan satu demi satu semua watak kedua -dua rentetan; Jika aksara semasa kedua -dua rentetan adalah sama, tambah nilai saya untuk membandingkan watak seterusnya; Jika mana -mana watak rentetan pertama adalah beberapa watak khas atau aksara angka dan tidak sama dengan watak yang sama rentetan kedua kemudian kembali palsu; Lakukan perkara yang sama untuk rentetan kedua; Blok kod ini akan dilaksanakan jika watak -watak kedua -dua rentetan adalah kes yang berbeza; Bandingkan watak dengan nilai ASCII; Jika watak dipadankan, tingkatkan nilai saya untuk membandingkan char seterusnya; Jika semua aksara rentetan pertama dipadankan dengan aksara yang sepadan dengan rentetan kedua, maka kembali benar; Berfungsi untuk mencetak sama atau tidak sama jika rentetan sama atau tidak sama; Kod pemacu"}
{"text": "Maximize the value of A by replacing some of its digits with digits of B | C ++ implementation of the approach ; Function to return the maximized value of A ; Sort digits in ascending order ; j points to largest digit in B ; If all the digits of b have been used ; Current digit has been used ; Return the maximized value ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string maxValue ( string a , string b ) { sort ( b . begin ( ) , b . end ( ) ) ; int n = a . length ( ) ; int m = b . length ( ) ; int j = m - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( j < 0 ) break ; if ( b [ j ] > a [ i ] ) { a [ i ] = b [ j ] ; j -- ; } } return a ; } int main ( ) { string a = \"1234\" ; string b = \"4321\" ; cout << maxValue ( a , b ) ; return 0 ; }", "text_ms": "Memaksimumkan nilai A dengan menggantikan beberapa digitnya dengan digit B | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan nilai yang dimaksimumkan A; Jenis digit dalam urutan menaik; J menunjuk kepada digit terbesar di B; Jika semua digit B telah digunakan; Digit semasa telah digunakan; Mengembalikan nilai yang dimaksimumkan; Kod pemacu"}
{"text": "Count numbers in range such that digits in it and it 's product with q are unequal | C ++ program for above approach ; Function to check if all of the digits in a number and it 's product with q are unequal or not ; convert first number into string ; Insert elements from 1 st number to hash ; Calculate corresponding product ; Convert the product to string ; Using the hash check if any digit of product matches with the digits of input number ; If yes , return false ; Return true ; Function to count numbers in the range [ l , r ] such that all of the digits of the number and it 's product with q are unequal ; check for every number between l and r ; Driver Code ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkIfUnequal ( int n , int q ) { string s1 = to_string ( n ) ; int a [ 26 ] = { 0 } ; for ( int i = 0 ; i < s1 . size ( ) ; i ++ ) a [ s1 [ i ] - '0' ] ++ ; int prod = n * q ; string s2 = to_string ( prod ) ; for ( int i = 0 ; i < s2 . size ( ) ; i ++ ) { if ( a [ s2 [ i ] - '0' ] ) return false ; } return true ; } int countInRange ( int l , int r , int q ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( checkIfUnequal ( i , q ) ) count ++ ; } return count ; } int main ( ) { int l = 10 , r = 12 , q = 2 ; cout << countInRange ( l , r , q ) ; return 0 ; }", "text_ms": "Mengira nombor dalam julat supaya digit di dalamnya dan produknya dengan Q tidak sama rata | Program C ++ untuk pendekatan di atas; Berfungsi untuk memeriksa sama ada semua digit dalam nombor dan produknya dengan Q tidak sama atau tidak; Tukar nombor pertama ke dalam rentetan; Masukkan elemen dari nombor 1 ke hash; Hitung produk yang sepadan; Tukar produk ke rentetan; Menggunakan Hash Check jika mana -mana digit padanan produk dengan digit nombor input; Jika ya, kembali palsu; Kembali benar; Berfungsi untuk mengira nombor dalam julat [l, r] supaya semua digit nombor dan produknya dengan Q tidak sama rata; Semak setiap nombor antara L dan R; Kod pemacu; Panggilan fungsi"}
{"text": "Check if it is possible to rearrange a binary string with alternate 0 s and 1 s | CPP program to check if we can rearrange a string such that it has alternate 0 s and 1 s . ; function to check the binary string ; length of string ; count zero 's ; count one 's ; if length is even ; if length is odd ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool is_possible ( string s ) { int l = s . length ( ) ; int one = 0 , zero = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( s [ i ] == '0' ) zero ++ ; else one ++ ; } if ( l % 2 == 0 ) return ( one == zero ) ; else return ( abs ( one - zero ) == 1 ) ; } int main ( ) { string s = \"100110\" ; if ( is_possible ( s ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "text_ms": "Semak sama ada mungkin untuk menyusun semula rentetan binari dengan alternatif 0 s dan 1 s | Program CPP untuk memeriksa sama ada kita boleh menyusun semula rentetan supaya ia mempunyai alternatif 0 s dan 1 s. ; berfungsi untuk memeriksa rentetan binari; panjang rentetan; Count Zero; Kira satu 's; jika panjangnya; jika panjang ganjil; Kod pemacu"}
{"text": "Frequency Measuring Techniques for Competitive Programming | C ++ program to count frequencies of array items ; Create an array to store counts . The size of array is limit + 1 and all values are initially 0 ; Traverse through string characters and count frequencies ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int limit = 255 ; void countFreq ( string str ) { vector < int > count ( limit + 1 , 0 ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) count [ str [ i ] ] ++ ; for ( int i = 0 ; i <= limit ; i ++ ) if ( count [ i ] > 0 ) cout << ( char ) i << \" ▁ \" << count [ i ] << endl ; } int main ( ) { string str = \" GeeksforGeeks \" ; countFreq ( str ) ; return 0 ; }", "text_ms": "Teknik Pengukuran Kekerapan untuk Pengaturcaraan Kompetitif | Program C ++ untuk mengira frekuensi item array; Buat array untuk menyimpan tuduhan. Saiz array adalah had + 1 dan semua nilai pada mulanya 0; Melintasi aksara rentetan dan mengira frekuensi; Kod pemacu"}
{"text": "Count of even and odd set bit with array element after XOR with K | C ++ program to count the set bits after taking XOR with a number K ; Function to store EVEN and odd variable ; Store the count of even and odd set bit ; Count the set bit using in built function ; Count of set - bit of K ; If y is odd then , count of even and odd set bit will be interchanged ; Else it will remain same as the original array ; Driver 's Code ; Function call to count even and odd", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void countEvenOdd ( int arr [ ] , int n , int K ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int x = __builtin_popcount ( arr [ i ] ) ; if ( x % 2 == 0 ) even ++ ; else odd ++ ; } int y ; y = __builtin_popcount ( K ) ; if ( y & 1 ) { cout << \" Even ▁ = ▁ \" << odd << \" , ▁ Odd ▁ = ▁ \" << even ; } else { cout << \" Even ▁ = ▁ \" << even << \" , ▁ Odd ▁ = ▁ \" << odd ; } } int main ( void ) { int arr [ ] = { 4 , 2 , 15 , 9 , 8 , 8 } ; int K = 3 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countEvenOdd ( arr , n , K ) ; return 0 ; }", "text_ms": "Kira bit set Even dan Odd dengan elemen array selepas xor dengan k | Program C ++ untuk mengira bit set selepas mengambil XOR dengan nombor k; Berfungsi untuk menyimpan pemboleh ubah yang walaupun dan ganjil; Simpan kiraan bit set walaupun dan ganjil; Kira set bit menggunakan dalam fungsi terbina; Count set - bit k; Jika y adalah ganjil, kiraan bit set walaupun dan ganjil akan ditukar; Lain ia akan tetap sama dengan array asal; Kod pemandu; Fungsi panggilan untuk mengira walaupun dan ganjil"}
{"text": "gOOGLE cASE of a given sentence | CPP program to convert given sentence to camel case . ; Function to remove spaces and convert into camel case ; check for spaces in the sentence ; conversion into upper case ; If not space , copy character ; return string to main ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string convert ( string s ) { int n = s . length ( ) ; s [ 0 ] = tolower ( s [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == ' ▁ ' && i < n ) { s [ i + 1 ] = tolower ( s [ i + 1 ] ) ; i ++ ; } else s [ i ] = toupper ( s [ i ] ) ; } return s ; } int main ( ) { string str = \" I ▁ get ▁ intern ▁ at ▁ geeksforgeeks \" ; cout << convert ( str ) ; return 0 ; }", "text_ms": "Google Case Of A Sentyen tertentu | Program CPP untuk menukar ayat yang diberikan kepada kes unta. ; Berfungsi untuk mengeluarkan ruang dan menukar ke dalam kes unta; Semak ruang dalam ayat; penukaran ke atas kes; Jika tidak ruang, salin watak; kembali rentetan ke Main; Kod pemacu"}
{"text": "Transform the string | CPP code to transform string ; Function to change character 's case ; If character is lowercase change to uppercase ; If character is uppercase change to lowercase ; Function to delete vowels ; If character is consonant ; Function to insert \" # \" ; If character is not special ; Function to transform string ; Driver function ; Calling function", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string change_case ( string a ) { int l = a . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( a [ i ] >= ' a ' && a [ i ] <= ' z ' ) a [ i ] = ( char ) ( 65 + ( int ) ( a [ i ] - ' a ' ) ) ; else if ( a [ i ] >= ' A ' && a [ i ] <= ' Z ' ) a [ i ] = ( char ) ( 97 + ( int ) ( a [ i ] - ' A ' ) ) ; } return a ; } string delete_vowels ( string a ) { string temp = \" \" ; int l = a . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( a [ i ] != ' a ' && a [ i ] != ' e ' && a [ i ] != ' i ' && a [ i ] != ' o ' && a [ i ] != ' u ' && a [ i ] != ' A ' && a [ i ] != ' E ' && a [ i ] != ' O ' && a [ i ] != ' U ' && a [ i ] != ' I ' ) temp += a [ i ] ; } return temp ; } string insert_hash ( string a ) { string temp = \" \" ; int l = a . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( ( a [ i ] >= ' a ' && a [ i ] <= ' z ' ) || ( a [ i ] >= ' A ' && a [ i ] <= ' Z ' ) ) temp = temp + ' # ' + a [ i ] ; else temp = temp + a [ i ] ; } return temp ; } void transformSting ( string a ) { string b = delete_vowels ( a ) ; string c = change_case ( b ) ; string d = insert_hash ( c ) ; cout << d ; } int main ( ) { string a = \" SunshinE ! ! \" ; transformSting ( a ) ; return 0 ; }", "text_ms": "Ubah rentetan | Kod CPP untuk mengubah rentetan; Fungsi untuk mengubah kes watak; Jika watak adalah perubahan huruf kecil ke huruf besar; Jika watak adalah perubahan huruf besar kepada huruf kecil; Berfungsi untuk memadam vokal; Jika watak adalah konsonan; Fungsi untuk memasukkan \" #\"; Jika watak tidak istimewa; Berfungsi untuk mengubah rentetan; Fungsi pemacu; Fungsi panggilan"}
{"text": "Tcefrep Numbers | C ++ implementation to check if N is a Tcefrep number ; Iterative function to reverse digits of num ; Function to calculate sum of all proper divisors num -- > given natural number ; Final result of summation of divisors ; find all divisors which divides ' num ' ; if ' i ' is divisor of ' num ' ; if both divisors are same then add it only once else add both ; Add 1 to the result as 1 is also a divisor ; Driver Code ; Given Number N ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int reverse ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; } int properDivSum ( int num ) { int result = 0 ; for ( int i = 2 ; i <= sqrt ( num ) ; i ++ ) { if ( num % i == 0 ) { if ( i == ( num / i ) ) result += i ; else result += ( i + num / i ) ; } } return ( result + 1 ) ; } bool isTcefrep ( int n ) { return properDivSum ( n ) == reverse ( n ) ; } int main ( ) { int N = 6 ; if ( isTcefrep ( N ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "text_ms": "Nombor TCEFREP | C ++ pelaksanaan untuk memeriksa sama ada N adalah nombor TCEFREP; Fungsi berulang untuk membalikkan digit NUM; Fungsi untuk mengira jumlah semua pembahagi yang betul Num -> diberi nombor semulajadi; Hasil akhir penjumlahan pembahagi; Cari semua pembahagi yang membahagikan 'num'; jika 'saya' adalah pembahagi 'num'; Jika kedua -dua pembahagi adalah sama maka tambahkannya hanya sekali lagi, tambah kedua -duanya; Tambah 1 kepada keputusan sebagai 1 juga pembahagi; Kod pemacu; Diberi nombor n; Panggilan fungsi"}
{"text": "Program to find the N | C ++ program to find n - th number containing only 3 and 5. ; If n is odd , append 3 and move to parent ; If n is even , append 5 and move to parent ; Reverse res and return . ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string findNthNo ( int n ) { string res = \" \" ; while ( n >= 1 ) { if ( n & 1 ) { res = res + \"3\" ; n = ( n - 1 ) / 2 ; } else { res = res + \"5\" ; n = ( n - 2 ) / 2 ; } } reverse ( res . begin ( ) , res . end ( ) ) ; return res ; } int main ( ) { int n = 5 ; cout << findNthNo ( n ) ; return 0 ; }", "text_ms": "Program untuk mencari n | Program C ++ untuk mencari nombor N - TH yang mengandungi hanya 3 dan 5 .; Jika n adalah ganjil, tambah 3 dan pindah ke ibu bapa; Jika n adalah, tambah 5 dan pindah ke ibu bapa; Reverse Res dan kembali. ; Kod pemacu"}
{"text": "Nth non | CPP program to find n - th non - square number . ; function to find the nth Non - Square Number ; conversion from int to long double is necessary in order to preserve decimal places after square root . ; calculating the result ; Driver code ; initializing the term number ; Print the result", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findNthNonSquare ( int n ) { long double x = ( long double ) n ; long double ans = x + floor ( 0.5 + sqrt ( x ) ) ; return ( int ) ans ; } int main ( ) { int n = 16 ; cout << \" The ▁ \" << n << \" th ▁ Non - Square ▁ number ▁ is ▁ \" ; cout << findNthNonSquare ( n ) ; return 0 ; }", "text_ms": "Nth non | Program CPP untuk mencari nombor bukan persegi. ; berfungsi untuk mencari nombor non non - persegi; Penukaran dari Int ke Long Double diperlukan untuk memelihara tempat perpuluhan selepas akar persegi. ; mengira hasilnya; Kod pemacu; memulakan nombor jangka panjang; Cetak hasilnya"}
{"text": "Sum of series with alternate signed squares of AP | Efficient CPP program to find sum of series with alternate signed square AP sums . ; function to calculate series sum ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int seiresSum ( int n , int a [ ] ) { return n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) ; } int main ( ) { int n = 2 ; int a [ ] = { 1 , 2 , 3 , 4 } ; cout << seiresSum ( n , a ) ; return 0 ; }", "text_ms": "Jumlah siri dengan dataran yang ditandatangani alternatif AP | Program CPP yang cekap untuk mencari jumlah siri dengan jumlah AP persegi yang ditandatangani alternatif. ; fungsi untuk mengira jumlah siri; Kod pemacu"}
{"text": "Find nth number that contains the digit k or divisible by k . | C ++ program to find nth number that contains the digit k or divisible by k . ; Function for checking if digit k is in n or not ; finding remainder ; if digit found ; Function for finding nth number ; since k is the first which satisfy the criteria , so consider it in count making count = 1 and starting from i = k + 1 ; checking that the number contain k digit or divisible by k ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int checkdigit ( int n , int k ) { while ( n ) { int rem = n % 10 ; if ( rem == k ) return 1 ; n = n / 10 ; } return 0 ; } int findNthNumber ( int n , int k ) { for ( int i = k + 1 , count = 1 ; count < n ; i ++ ) { if ( checkdigit ( i , k ) || ( i % k == 0 ) ) count ++ ; if ( count == n ) return i ; } return -1 ; } int main ( ) { int n = 10 , k = 2 ; cout << findNthNumber ( n , k ) << endl ; return 0 ; }", "text_ms": "Cari nombor n yang mengandungi digit k atau dibahagikan dengan k. | Program C ++ untuk mencari nombor n yang mengandungi digit k atau dibahagikan oleh k. ; Fungsi untuk memeriksa jika digit k berada dalam n atau tidak; mencari selebihnya; jika digit dijumpai; Fungsi untuk mencari nombor nth; Oleh kerana k adalah yang pertama yang memenuhi kriteria, jadi pertimbangkannya dalam kiraan membuat kiraan = 1 dan bermula dari i = k + 1; Memeriksa bahawa nombor itu mengandungi k digit atau dibahagikan oleh k; Kod pemacu"}
{"text": "Count of subarrays of size K which is a permutation of numbers from 1 to K | C ++ program to implement the above approach ; Save index of numbers of the array ; Update min and max index with the current index and check if it 's a valid permutation ; Driver code", "code": "#include <iostream> NEW_LINE #include <unordered_map> NEW_LINE #include <vector> NEW_LINE using namespace std ; int find_permutations ( vector < int > & arr ) { int cnt = 0 ; int max_ind = -1 , min_ind = 10000000 ; int n = arr . size ( ) ; unordered_map < int , int > index_of ; for ( int i = 0 ; i < n ; i ++ ) { index_of [ arr [ i ] ] = i + 1 ; } for ( int i = 1 ; i <= n ; i ++ ) { max_ind = max ( max_ind , index_of [ i ] ) ; min_ind = min ( min_ind , index_of [ i ] ) ; if ( max_ind - min_ind + 1 == i ) cnt ++ ; } return cnt ; } int main ( ) { vector < int > nums ; nums . push_back ( 2 ) ; nums . push_back ( 3 ) ; nums . push_back ( 1 ) ; nums . push_back ( 5 ) ; nums . push_back ( 4 ) ; cout << find_permutations ( nums ) ; return 0 ; }", "text_ms": "Count subarrays saiz K yang merupakan permutasi nombor dari 1 hingga k | Program C ++ untuk melaksanakan pendekatan di atas; Simpan indeks nombor array; Kemas kini indeks min dan max dengan indeks semasa dan periksa sama ada ia adalah permutasi yang sah; Kod pemacu"}
{"text": "Count of integers that divide all the elements of the given array | C ++ implementation of the approach ; Function to return the count of the required integers ; To store the gcd of the array elements ; To store the count of factors of the found gcd ; If g is a perfect square ; Factors appear in pairs ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int getCount ( int a [ ] , int n ) { int gcd = 0 ; for ( int i = 0 ; i < n ; i ++ ) gcd = __gcd ( gcd , a [ i ] ) ; int cnt = 0 ; for ( int i = 1 ; i * i <= gcd ; i ++ ) { if ( gcd % i == 0 ) { if ( i * i == gcd ) cnt ++ ; else cnt += 2 ; } } return cnt ; } int main ( ) { int a [ ] = { 4 , 16 , 1024 , 48 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << getCount ( a , n ) ; return 0 ; }", "text_ms": "Count of integer yang membahagikan semua elemen array yang diberikan | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan kiraan bilangan bulat yang diperlukan; Untuk menyimpan GCD unsur -unsur array; Untuk menyimpan kiraan faktor GCD yang dijumpai; Jika G adalah persegi yang sempurna; Faktor muncul berpasangan; Kod pemacu"}
{"text": "Minimize cost of removals required to make all remaining characters of the string unique | C ++ program to implement the above approach ; Function to find the minimum cost of removing characters to make the String unique ; stores the visited character ; stores the answer ; traverse the String ; if already visited ; Stores the maximum cost of removing a particular character ; Store the total deletion cost of a particular character ; Mark the current character visited ; Traverse the indices of the String [ i , N - 1 ] ; If any duplicate is found ; Update the maximum cost and total cost ; Mark the current character visited ; Keep the character with maximum cost and delete the rest ; return the minimum cost ; Driver code ; input String ; input array ; function call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int delCost ( string s , int cost [ ] , int l1 , int l2 ) { bool visited [ l1 ] ; memset ( visited , 0 , sizeof ( visited ) ) ; int ans = 0 ; for ( int i = 0 ; i < l1 ; i ++ ) { if ( visited [ i ] ) { continue ; } int maxDel = 0 ; int totalCost = 0 ; visited [ i ] = 1 ; for ( int j = i ; j < l1 ; j ++ ) { if ( s [ i ] == s [ j ] ) { maxDel = max ( maxDel , cost [ j ] ) ; totalCost += cost [ j ] ; visited [ j ] = 1 ; } } ans += totalCost - maxDel ; } return ans ; } int main ( ) { string s = \" AAABBB \" ; int l1 = s . size ( ) ; int cost [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int l2 = sizeof ( cost ) / sizeof ( cost [ 0 ] ) ; cout << delCost ( s , cost , l1 , l2 ) ; return 0 ; }", "text_ms": "Kurangkan kos penyingkiran yang diperlukan untuk menjadikan semua watak yang tersisa dari rentetan unik | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari kos minimum untuk mengeluarkan aksara untuk membuat rentetan unik; menyimpan watak yang dikunjungi; menyimpan jawapannya; melintasi rentetan; jika sudah dikunjungi; Menyimpan kos maksimum untuk mengeluarkan watak tertentu; Simpan jumlah kos penghapusan watak tertentu; Tandakan watak semasa yang dikunjungi; Melintasi indeks rentetan [i, n - 1]; Jika ada pendua yang dijumpai; Mengemas kini kos maksimum dan jumlah kos; Tandakan watak semasa yang dikunjungi; Simpan watak dengan kos maksimum dan padamkan yang lain; mengembalikan kos minimum; Kod pemacu; rentetan input; Arahan input; panggilan fungsi"}
{"text": "Make all array elements equal by replacing triplets with their Bitwise XOR | C ++ program to implement the above approach ; Function to find triplets such that replacing them with their XOR make all array elements equal ; If N is even ; Calculate xor of array elements ; Traverse the array ; Update xor ; If xor is not equal to 0 ; Selecting the triplets such that elements of the pairs ( arr [ 0 ] , arr [ 1 ] ) , ( arr [ 2 ] , arr [ 3 ] ) . . . can be made equal ; Selecting the triplets such that all array elements can be made equal to arr [ N - 1 ] ; Selecting the triplets such that elements of the pairs ( arr [ 0 ] , arr [ 1 ] ) , ( arr [ 2 ] , arr [ 3 ] ) . . . can be made equal ; Selecting the triplets such that all array elements can be made equal to arr [ N - 1 ] ; Driver Code ; Given array ; Size of array ; Function call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkXOR ( int arr [ ] , int N ) { if ( N % 2 == 0 ) { int xro = 0 ; for ( int i = 0 ; i < N ; i ++ ) { xro ^= arr [ i ] ; } if ( xro != 0 ) { cout << -1 << endl ; return ; } for ( int i = 0 ; i < N - 3 ; i += 2 ) { cout << i << \" ▁ \" << i + 1 << \" ▁ \" << i + 2 << endl ; } for ( int i = 0 ; i < N - 3 ; i += 2 ) { cout << i << \" ▁ \" << i + 1 << \" ▁ \" << N - 1 << endl ; } } else { for ( int i = 0 ; i < N - 2 ; i += 2 ) { cout << i << \" ▁ \" << i + 1 << \" ▁ \" << i + 2 << endl ; } for ( int i = 0 ; i < N - 2 ; i += 2 ) { cout << i << \" ▁ \" << i + 1 << \" ▁ \" << N - 1 << endl ; } } } int main ( ) { int arr [ ] = { 4 , 2 , 1 , 7 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; checkXOR ( arr , N ) ; }", "text_ms": "Buat semua elemen array sama dengan menggantikan tiga kali ganda dengan bitwise xor mereka | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk mencari tiga kali ganda yang menggantikannya dengan XOR mereka membuat semua elemen array sama; Jika n juga; Hitung XOR unsur array; Melintasi array; Kemas kini XOR; Jika XOR tidak sama dengan 0; Memilih triplet seperti unsur -unsur pasangan (arr [0], arr [1]), (arr [2], arr [3]). . . boleh dibuat sama; Memilih tiga kali ganda supaya semua elemen array boleh dibuat sama dengan arr [n - 1]; Memilih triplet seperti unsur -unsur pasangan (arr [0], arr [1]), (arr [2], arr [3]). . . boleh dibuat sama; Memilih tiga kali ganda supaya semua elemen array boleh dibuat sama dengan arr [n - 1]; Kod pemacu; Diberikan array; Saiz array; Panggilan fungsi"}
{"text": "Make all array elements even by replacing adjacent pair of array elements with their sum | C ++ program to implement the above approach ; Function to find minimum count of operations required to make all array elements even ; Stores minimum count of replacements to make all array elements even ; Stores the count of odd continuous numbers ; Traverse the array ; If arr [ i ] is an odd number ; Update odd_cont_seg ; If odd_cont_seg is even ; Update res ; Update res ; Reset odd_cont_seg = 0 ; If odd_cont_seg exceeds 0 ; If odd_cont_seg is even ; Update res ; Update res ; Print the result ; Drivers Code", "code": "#include <iostream> NEW_LINE using namespace std ; int make_array_element_even ( int arr [ ] , int N ) { int res = 0 ; int odd_cont_seg = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 1 ) { odd_cont_seg ++ ; } else { if ( odd_cont_seg > 0 ) { if ( odd_cont_seg % 2 == 0 ) { res += odd_cont_seg / 2 ; } else { res += ( odd_cont_seg / 2 ) + 2 ; } odd_cont_seg = 0 ; } } } if ( odd_cont_seg > 0 ) { if ( odd_cont_seg % 2 == 0 ) { res += odd_cont_seg / 2 ; } else { res += odd_cont_seg / 2 + 2 ; } } return res ; } int main ( ) { int arr [ ] = { 2 , 4 , 5 , 11 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << make_array_element_even ( arr , N ) ; return 0 ; }", "text_ms": "Buat semua elemen array walaupun dengan menggantikan sepasang elemen array bersebelahan dengan jumlah mereka | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk mencari kiraan minimum operasi yang diperlukan untuk membuat semua elemen array walaupun; Kedai minimum penggantian minimum untuk membuat semua elemen array walaupun; Menyimpan kiraan nombor berterusan ganjil; Melintasi array; Jika arr [i] adalah nombor ganjil; Kemas kini ODD_CONT_SEG; Jika odd_cont_seg adalah walaupun; Kemas kini res; Kemas kini res; Tetapkan semula ODD_CONT_SEG = 0; Jika odd_cont_seg melebihi 0; Jika odd_cont_seg adalah walaupun; Kemas kini res; Kemas kini res; Cetak hasilnya; Kod pemandu"}
{"text": "Find a number K such that exactly K array elements are greater than or equal to K | C ++ program for the above approach ; Function to find K for which there are exactly K array elements greater than or equal to K ; Finding the largest array element ; Possible values of K ; Traverse the array ; If current array element is greater than or equal to i ; If i array elements are greater than or equal to i ; Otherwise ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int zvalue ( vector < int > & nums ) { int m = * max_element ( nums . begin ( ) , nums . end ( ) ) ; int cnt = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { cnt = 0 ; for ( int j = 0 ; j < nums . size ( ) ; j ++ ) { if ( nums [ j ] >= i ) cnt ++ ; } if ( cnt == i ) return i ; } return -1 ; } int main ( ) { vector < int > nums = { 7 , 8 , 9 , 0 , 0 , 1 } ; cout << zvalue ( nums ) << endl ; }", "text_ms": "Cari nombor k sedemikian rupa sehingga betul -betul elemen array lebih besar daripada atau sama dengan k | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari k yang mana terdapat unsur -unsur array yang lebih besar daripada atau sama dengan k; Mencari elemen array terbesar; Nilai kemungkinan k; Melintasi array; Jika elemen array semasa lebih besar daripada atau sama dengan i; Jika saya pelbagai elemen adalah lebih besar daripada atau sama dengan i; Jika tidak; Kod pemacu"}
{"text": "Lexicographically smallest and largest anagrams of a string containing another string as its substring | C ++ program for the above approach ; Function to find the lexicographically smallest anagram of string which contains another string ; Initializing the map and set ; Iterating over s1 ; Storing the frequency of characters present in s1 ; Storing the distinct characters present in s1 ; Decreasing the frequency of characters from M that are already present in s2 ; Traversing alphabets in sorted order ; If current character of set is not equal to current character of s2 ; If element is equal to current character of s2 ; Checking for second distinct character in s2 ; s2 [ j ] will store second distinct character ; Return the answer ; Function to find the lexicographically largest anagram of string which contains another string ; Getting the lexicographically smallest anagram ; d1 stores the prefix ; d2 stores the suffix ; Return the result ; Driver Code ; Given two strings ; Function Calls", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; pair < string , int > lexico_smallest ( string s1 , string s2 ) { map < char , int > M ; set < char > S ; pair < string , int > pr ; for ( int i = 0 ; i <= s1 . size ( ) - 1 ; ++ i ) { M [ s1 [ i ] ] ++ ; S . insert ( s1 [ i ] ) ; } for ( int i = 0 ; i <= s2 . size ( ) - 1 ; ++ i ) { M [ s2 [ i ] ] -- ; } char c = s2 [ 0 ] ; int index = 0 ; string res = \" \" ; for ( auto x : S ) { if ( x != c ) { for ( int i = 1 ; i <= M [ x ] ; ++ i ) { res += x ; } } else { int j = 0 ; index = res . size ( ) ; while ( s2 [ j ] == x ) { j ++ ; } if ( s2 [ j ] < c ) { res += s2 ; for ( int i = 1 ; i <= M [ x ] ; ++ i ) { res += x ; } } else { for ( int i = 1 ; i <= M [ x ] ; ++ i ) { res += x ; } index += M [ x ] ; res += s2 ; } } } pr . first = res ; pr . second = index ; return pr ; } string lexico_largest ( string s1 , string s2 ) { pair < string , int > pr = lexico_smallest ( s1 , s2 ) ; string d1 = \" \" ; for ( int i = pr . second - 1 ; i >= 0 ; i -- ) { d1 += pr . first [ i ] ; } string d2 = \" \" ; for ( int i = pr . first . size ( ) - 1 ; i >= pr . second + s2 . size ( ) ; -- i ) { d2 += pr . first [ i ] ; } string res = d2 + s2 + d1 ; return res ; } int main ( ) { string s1 = \" ethgakagmenpgs \" ; string s2 = \" geeks \" ; cout << lexico_smallest ( s1 , s2 ) . first << \" STRNEWLINE \" ; cout << lexico_largest ( s1 , s2 ) ; return ( 0 ) ; }", "text_ms": "Anagrams lexicographically terkecil dan terbesar rentetan yang mengandungi rentetan lain sebagai substringnya | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari anagram terkecil rentetan yang mengandungi rentetan lain; Memulakan peta dan set; Melangkah ke atas S1; Menyimpan kekerapan aksara yang ada di S1; Menyimpan watak -watak yang berbeza dalam S1; Mengurangkan kekerapan aksara dari m yang sudah ada di S2; Melintasi abjad dalam urutan yang disusun; Jika watak semasa set tidak sama dengan watak semasa S2; Jika elemen sama dengan watak semasa S2; Memeriksa watak kedua yang berbeza dalam S2; S2 [J] akan menyimpan watak kedua yang berbeza; Kembalikan jawapannya; Berfungsi untuk mencari anagram leksikografi terbesar rentetan yang mengandungi rentetan lain; Mendapatkan anagram terkecil secara lexicographically; D1 menyimpan awalan; D2 menyimpan akhiran; Mengembalikan hasilnya; Kod pemacu; Diberikan dua rentetan; Panggilan fungsi"}
{"text": "Queries to find the count of shortest paths in a Tree that contains a given edge | C ++ implementation for the above approach ; Adjacency list to represent the tree ; Number of vertices ; Mark visited / unvisited vertices ; Stores the subtree size of the corresponding nodes ; Function to create an edge between two vertices ; Add a to b 's list ; Add b to a 's list ; Function to perform DFS ; Mark the vertex visited ; Include the node in the subtree ; Traverse all its children ; Function to print the required number of paths ; Driver Code ; Number of vertices ; Calling modified dfs function ; Count pairs of vertices in the tree", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int sz = 1e5 ; vector < int > tree [ sz ] ; int n ; bool vis [ sz ] ; int subtreeSize [ sz ] ; void addEdge ( int a , int b ) { tree [ a ] . push_back ( b ) ; tree [ b ] . push_back ( a ) ; } void dfs ( int x ) { vis [ x ] = true ; subtreeSize [ x ] = 1 ; for ( auto i : tree [ x ] ) { if ( ! vis [ i ] ) { dfs ( i ) ; subtreeSize [ x ] += subtreeSize [ i ] ; } } } void countPairs ( int a , int b ) { int sub = min ( subtreeSize [ a ] , subtreeSize [ b ] ) ; cout << sub * ( n - sub ) << endl ; } int main ( ) { n = 6 ; addEdge ( 0 , 1 ) ; addEdge ( 0 , 2 ) ; addEdge ( 1 , 3 ) ; addEdge ( 3 , 4 ) ; addEdge ( 3 , 5 ) ; dfs ( 0 ) ; countPairs ( 1 , 3 ) ; countPairs ( 0 , 2 ) ; return 0 ; }", "text_ms": "Pertanyaan untuk mencari kiraan laluan terpendek di dalam pokok yang mengandungi kelebihan yang diberikan | C ++ pelaksanaan untuk pendekatan di atas; Senarai Adjacency untuk mewakili pokok; Bilangan simpang; Mark yang melawat / tidak dapat Vertices; Menyimpan saiz subtree nod yang sepadan; Berfungsi untuk mewujudkan kelebihan antara dua simpul; Tambah senarai A ke B; Tambah B ke senarai A; Berfungsi untuk melaksanakan DFS; Tandakan puncak yang dikunjungi; Termasuk nod dalam subtree; Melintasi semua anaknya; Berfungsi untuk mencetak bilangan laluan yang diperlukan; Kod pemacu; Bilangan simpang; Memanggil fungsi DFS yang diubah suai; Kira pasangan simpang di pokok"}
{"text": "Count of permutations of an Array having each element as a multiple or a factor of its index | C ++ Program to implement the above approach ; Function to find the count of desired permutations ; Base case ; If i has not been inserted ; Backtrack ; Insert i ; Recur to find valid permutations ; Remove i ; Return the final count ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findPermutation ( unordered_set < int > & arr , int N ) { int pos = arr . size ( ) + 1 ; if ( pos > N ) return 1 ; int res = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( arr . find ( i ) == arr . end ( ) ) { if ( i % pos == 0 or pos % i == 0 ) { arr . insert ( i ) ; res += findPermutation ( arr , N ) ; arr . erase ( arr . find ( i ) ) ; } } } return res ; } int main ( ) { int N = 5 ; unordered_set < int > arr ; cout << findPermutation ( arr , N ) ; return 0 ; }", "text_ms": "Kira permutasi array yang mempunyai setiap elemen sebagai pelbagai atau faktor indeksnya | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari kiraan permutasi yang dikehendaki; Kes asas; Jika saya belum dimasukkan; Backtrack; Masukkan i; Berulang untuk mencari permutasi yang sah; Keluarkan i; Mengembalikan kiraan akhir; Kod pemacu"}
{"text": "Check if sum Y can be obtained from the Array by the given operations | C ++ Program to implement the above approach ; Function to check if it is possible to obtain sum Y from a sequence of sum X from the array arr [ ] ; Store the difference ; Iterate over the array ; If diff reduced to 0 ; Driver Code", "code": "#include <iostream> NEW_LINE using namespace std ; void solve ( int arr [ ] , int n , int X , int Y ) { int diff = Y - X ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != 1 ) { diff = diff % ( arr [ i ] - 1 ) ; } } if ( diff == 0 ) cout << \" Yes \" ; else cout << \" No \" ; } int main ( ) { int arr [ ] = { 1 , 2 , 7 , 9 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int X = 11 , Y = 13 ; solve ( arr , n , X , Y ) ; return 0 ; }", "text_ms": "Semak jika jumlah y boleh didapati dari array oleh operasi yang diberikan | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk memeriksa sama ada mungkin untuk mendapatkan jumlah y dari urutan jumlah x dari array arr []; Simpan perbezaan; Melangkah ke atas array; Jika diff dikurangkan kepada 0; Kod pemacu"}
{"text": "Farthest distance of a Node from each Node of a Tree | C ++ Program to implement the above approach ; Adjacency List to store the graph ; Stores the height of each node ; Stores the maximum distance of a node from its ancestors ; Function to add edge between two vertices ; Insert edge from u to v ; Insert edge from v to u ; Function to calculate height of each Node ; Iterate in the adjacency list of the current node ; Dfs for child node ; Calculate height of nodes ; Increase height ; Function to calculate the maximum distance of a node from its ancestor ; Iterate in the adjacency list of the current node ; Find two children with maximum heights ; Calculate the maximum distance with ancestor for every node ; Calculating for children ; Driver Code ; Calculate height of nodes of the tree ; Calculate the maximum distance with ancestors ; Print the maximum of the two distances from each node", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define maxN  100001 NEW_LINE vector < int > adj [ maxN ] ; int height [ maxN ] ; int dist [ maxN ] ; void addEdge ( int u , int v ) { adj [ u ] . push_back ( v ) ; adj [ v ] . push_back ( u ) ; } void dfs1 ( int cur , int par ) { for ( auto u : adj [ cur ] ) { if ( u != par ) { dfs1 ( u , cur ) ; height [ cur ] = max ( height [ cur ] , height [ u ] ) ; } } height [ cur ] += 1 ; } void dfs2 ( int cur , int par ) { int max1 = 0 ; int max2 = 0 ; for ( auto u : adj [ cur ] ) { if ( u != par ) { if ( height [ u ] >= max1 ) { max2 = max1 ; max1 = height [ u ] ; } else if ( height [ u ] > max2 ) { max2 = height [ u ] ; } } } int sum = 0 ; for ( auto u : adj [ cur ] ) { if ( u != par ) { sum = ( ( max1 == height [ u ] ) ? max2 : max1 ) ; if ( max1 == height [ u ] ) dist [ u ] = 1 + max ( 1 + max2 , dist [ cur ] ) ; else dist [ u ] = 1 + max ( 1 + max1 , dist [ cur ] ) ; dfs2 ( u , cur ) ; } } } int main ( ) { int n = 6 ; addEdge ( 1 , 2 ) ; addEdge ( 2 , 3 ) ; addEdge ( 2 , 4 ) ; addEdge ( 2 , 5 ) ; addEdge ( 5 , 6 ) ; dfs1 ( 1 , 0 ) ; dfs2 ( 1 , 0 ) ; for ( int i = 1 ; i <= n ; i ++ ) cout << ( max ( dist [ i ] , height [ i ] ) - 1 ) << \" ▁ \" ; return 0 ; }", "text_ms": "Jarak paling jauh dari nod dari setiap nod pokok | Program C ++ untuk melaksanakan pendekatan di atas; Senarai adjacency untuk menyimpan graf; Menyimpan ketinggian setiap nod; Menyimpan jarak maksimum nod dari nenek moyangnya; Berfungsi untuk menambah kelebihan antara dua simpang; Masukkan kelebihan dari u ke v; Masukkan tepi dari v ke u; Berfungsi untuk mengira ketinggian setiap nod; Melangkah dalam senarai addacency nod semasa; DFS untuk nod kanak -kanak; Hitung ketinggian nod; Meningkatkan ketinggian; Fungsi untuk mengira jarak maksimum nod dari nenek moyangnya; Melangkah dalam senarai addacency nod semasa; Cari dua kanak -kanak dengan ketinggian maksimum; Kirakan jarak maksimum dengan nenek moyang untuk setiap nod; Mengira untuk kanak -kanak; Kod pemacu; Hitung ketinggian nod pokok; Kirakan jarak maksimum dengan nenek moyang; Cetak maksimum dua jarak dari setiap nod"}
{"text": "Middle of three using minimum comparisons | CPP program to find middle of three distinct numbers ; Function to find the middle of three number ; Checking for b ; Checking for a ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int middleOfThree ( int a , int b , int c ) { int middleOfThree ( int a , int b , int c ) { if ( ( a < b && b < c ) || ( c < b && b < a ) ) return b ; else if ( ( b < a && a < c ) || ( c < a && a < b ) ) return a ; else return c ; } int main ( ) { int a = 20 , b = 30 , c = 40 ; cout << middleOfThree ( a , b , c ) ; return 0 ; }", "text_ms": "Pertengahan tiga menggunakan perbandingan minimum | Program CPP untuk mencari pertengahan tiga nombor yang berbeza; Berfungsi untuk mencari pertengahan tiga nombor; Memeriksa B; Memeriksa A; Kod pemacu"}
{"text": "Difference between Insertion sort and Selection sort | C ++ program for implementation of selection sort ; Function to implement the selection sort ; One by one move boundary of unsorted subarray ; Find the minimum element in unsorted array ; Swap the found minimum element with the first element ; Function to print an array ; Driver Code ; Function Call ; Print the array", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void swap ( int * xp , int * yp ) { int temp = * xp ; * xp = * yp ; * yp = temp ; } void selectionSort ( int arr [ ] , int n ) { int i , j , min_idx ; for ( i = 0 ; i < n - 1 ; i ++ ) { min_idx = i ; for ( j = i + 1 ; j < n ; j ++ ) if ( arr [ j ] < arr [ min_idx ] ) min_idx = j ; swap ( & arr [ min_idx ] , & arr [ i ] ) ; } } void printArray ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) { cout << arr [ i ] << \" ▁ \" ; } cout << endl ; } int main ( ) { int arr [ ] = { 64 , 25 , 12 , 22 , 11 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; selectionSort ( arr , n ) ; cout << \" Sorted ▁ array : ▁ STRNEWLINE \" ; printArray ( arr , n ) ; return 0 ; }", "text_ms": "Perbezaan antara jenis penyisipan dan pilihan pemilihan | Program C ++ untuk pelaksanaan pilihan pemilihan; Berfungsi untuk melaksanakan jenis pemilihan; Satu demi satu langkah sempadan subarray yang tidak disusun; Cari elemen minimum dalam array yang tidak disusun; Tukar elemen minimum yang dijumpai dengan elemen pertama; Berfungsi untuk mencetak array; Kod pemacu; Panggilan fungsi; Cetak array"}
{"text": "Check if a given string can be converted to another by given possible swaps | C ++ program to implement the above approach ; Stores length of str1 ; Stores length of str2 ; Stores distinct characters of str1 ; Stores distinct characters of str2 ; Stores frequency of each character of str1 ; Traverse the string str1 ; Update frequency of str1 [ i ] ; Traverse the string str1 ; Insert str1 [ i ] into st1 ; Traverse the string str2 ; Insert str1 [ i ] into st1 ; If distinct characters in str1 and str2 are not same ; Stores frequency of each character of str2 ; Traverse the string str2 ; Update frequency of str2 [ i ] ; Sort hash1 [ ] array ; Sort hash2 [ ] array ; Traverse hash1 [ ] and hash2 [ ] ; If hash1 [ i ] not equal to hash2 [ i ] ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkStr1CanConStr2 ( string & str1 , string & str2 ) { int N = str1 . length ( ) ; int M = str2 . length ( ) ; set < int > st1 ; set < int > st2 ; int hash1 [ 256 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { hash1 [ str1 [ i ] ] ++ ; } for ( int i = 0 ; i < N ; i ++ ) { st1 . insert ( str1 [ i ] ) ; } for ( int i = 0 ; i < M ; i ++ ) { st2 . insert ( str2 [ i ] ) ; } if ( st1 != st2 ) { return false ; } int hash2 [ 256 ] = { 0 } ; for ( int i = 0 ; i < M ; i ++ ) { hash2 [ str2 [ i ] ] ++ ; } sort ( hash1 , hash1 + 256 ) ; sort ( hash2 , hash2 + 256 ) ; for ( int i = 0 ; i < 256 ; i ++ ) { if ( hash1 [ i ] != hash2 [ i ] ) { return false ; } } return true ; } int main ( ) { string str1 = \" xyyzzlll \" ; string str2 = \" yllzzxxx \" ; if ( checkStr1CanConStr2 ( str1 , str2 ) ) { cout << \" True \" ; } else { cout << \" False \" ; } }", "text_ms": "Semak jika rentetan yang diberikan boleh ditukar kepada yang lain dengan diberikan swap yang mungkin | Program C ++ untuk melaksanakan pendekatan di atas; Kedai panjang str1; Kedai panjang str2; Kedai watak -watak yang berbeza dari STR1; Kedai watak -watak yang berbeza dari STR2; Kedai kekerapan setiap watak Str1; Traverse string str1; Kemas kini kekerapan str1 [i]; Traverse string str1; Masukkan str1 [i] ke st1; Traverse string str2; Masukkan str1 [i] ke st1; Jika watak yang berbeza dalam str1 dan str2 tidak sama; Kedai kekerapan setiap watak Str2; Traverse string str2; Kemas kini kekerapan STR2 [i]; Sort hash1 [] array; Susun Hash2 [] array; Traverse Hash1 [] dan Hash2 []; Jika Hash1 [i] tidak sama dengan Hash2 [i]; Kod pemacu"}
{"text": "Sort the array in a given index range | C ++ program to sort the array in a given index range ; Function to sort the elements of the array from index a to index b ; Variables to store start and end of the index range ; Sort the subarray from arr [ l ] to arr [ r ] ; Print the modified array ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void partSort ( int arr [ ] , int N , int a , int b ) { int l = min ( a , b ) ; int r = max ( a , b ) ; vector < int > v ( arr , arr + N ) ; sort ( v . begin ( ) + l , v . begin ( ) + r + 1 ) ; for ( int i = 0 ; i < N ; i ++ ) cout << v [ i ] << \" ▁ \" ; } int main ( ) { int arr [ ] = { 7 , 8 , 4 , 5 , 2 } ; int a = 1 , b = 4 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; partSort ( arr , N , a , b ) ; }", "text_ms": "Susun array dalam julat indeks yang diberikan | Program C ++ untuk menyusun array dalam julat indeks yang diberikan; Berfungsi untuk menyusun unsur -unsur array dari indeks A ke indeks b; Pembolehubah untuk menyimpan permulaan dan akhir julat indeks; Susun subarray dari arr [l] ke arr [r]; Cetak array yang diubah suai; Kod pemacu"}
{"text": "Find the minimum cost to reach destination using a train | A Dynamic Programming based solution to find min cost to reach station N - 1 from station 0. ; This function returns the smallest possible cost to reach station N - 1 from station 0. ; dist [ i ] stores minimum cost to reach station i from station 0. ; Go through every station and check if using it as an intermediate station gives better path ; Driver program to test above function", "code": "#include <iostream> NEW_LINE #include <climits> NEW_LINE using namespace std ; #define INF  INT_MAX NEW_LINE #define N  4 NEW_LINE int minCost ( int cost [ ] [ N ] ) { int dist [ N ] ; for ( int i = 0 ; i < N ; i ++ ) dist [ i ] = INF ; dist [ 0 ] = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) dist [ j ] = dist [ i ] + cost [ i ] [ j ] ; return dist [ N - 1 ] ; } int main ( ) { int cost [ N ] [ N ] = { { 0 , 15 , 80 , 90 } , { INF , 0 , 40 , 50 } , { INF , INF , 0 , 70 } , { INF , INF , INF , 0 } } ; cout << \" The ▁ Minimum ▁ cost ▁ to ▁ reach ▁ station ▁ \" << N << \" ▁ is ▁ \" << minCost ( cost ) ; return 0 ; }", "text_ms": "Cari kos minimum untuk mencapai destinasi menggunakan kereta api | Penyelesaian berasaskan pengaturcaraan dinamik untuk mencari kos min untuk mencapai stesen n - 1 dari stesen 0 .; Fungsi ini mengembalikan kos yang paling kecil untuk mencapai stesen n - 1 dari stesen 0 .; Dist [i] menyimpan kos minimum untuk mencapai stesen I dari stesen 0 .; Pergi melalui setiap stesen dan periksa jika menggunakannya sebagai stesen perantaraan memberikan jalan yang lebih baik; Program pemacu untuk menguji fungsi di atas"}
{"text": "Number of loops of size k starting from a specific node | C ++ Program to find number of cycles of length k in a graph with n nodes . ; Return the Number of ways from a node to make a loop of size K in undirected complete connected graph of N nodes ; Driven Program", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int numOfways ( int n , int k ) { int p = 1 ; if ( k % 2 ) p = -1 ; return ( pow ( n - 1 , k ) + p * ( n - 1 ) ) / n ; } int main ( ) { int n = 4 , k = 2 ; cout << numOfways ( n , k ) << endl ; return 0 ; }", "text_ms": "Bilangan gelung saiz k bermula dari nod tertentu | Program C ++ untuk mencari bilangan kitaran panjang K dalam graf dengan nod N. ; Kembalikan bilangan cara dari nod untuk membuat gelung saiz K dalam graf nod yang tidak disambungkan lengkap; Program yang didorong"}
{"text": "Program to find the largest and smallest ASCII valued characters in a string | C ++ program to find largest and smallest characters in a string . ; function that return the largest alphabet . ; initializing max alphabet to ' a ' ; find largest alphabet ; returning largest element ; function that return the smallest alphabet ; initializing smallest alphabet to ' z ' ; find smallest alphabet ; returning smallest alphabet ; Driver Code ; Character array ; Calculating size of the string ; calling functions and print returned value", "code": "#include <iostream> NEW_LINE using namespace std ; char largest_alphabet ( char a [ ] , int n ) { char max = ' A ' ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] > max ) max = a [ i ] ; return max ; } char smallest_alphabet ( char a [ ] , int n ) { char min = ' z ' ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( a [ i ] < min ) min = a [ i ] ; return min ; } int main ( ) { char a [ ] = \" GeEksforGeeks \" ; int size = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << \" Largest ▁ and ▁ smallest ▁ alphabet ▁ is ▁ : ▁ \" ; cout << largest_alphabet ( a , size ) << \" ▁ and ▁ \" ; cout << smallest_alphabet ( a , size ) << endl ; return 0 ; }", "text_ms": "Program untuk mencari watak bernilai ASCII terbesar dan terkecil dalam rentetan | Program C ++ untuk mencari aksara terbesar dan terkecil dalam rentetan. ; Fungsi yang mengembalikan abjad terbesar. ; memulakan abjad max ke 'a'; Cari abjad terbesar; kembali elemen terbesar; fungsi yang mengembalikan abjad terkecil; memulakan abjad terkecil kepada 'z'; Cari abjad terkecil; kembali abjad terkecil; Kod pemacu; Pelbagai watak; Mengira saiz rentetan; fungsi memanggil dan mencetak nilai yang dikembalikan"}
{"text": "Make largest palindrome by changing at most K | C ++ program to get largest palindrome changing atmost K digits ; Returns maximum possible palindrome using k changes ; Initialize l and r by leftmost and rightmost ends ; first try to make string palindrome ; Replace left and right character by maximum of both ; If k is negative then we can 't make  string palindrome ; At mid character , if K > 0 then change it to 9 ; If character at lth ( same as rth ) is less than 9 ; If none of them is changed in the previous loop then subtract 2 from K and convert both to 9 ; If one of them is changed in the previous loop then subtract 1 from K ( 1 more is subtracted already ) and make them 9 ; Driver code to test above methods", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string maximumPalinUsingKChanges ( string str , int k ) { string palin = str ; int l = 0 ; int r = str . length ( ) - 1 ; while ( l < r ) { if ( str [ l ] != str [ r ] ) { palin [ l ] = palin [ r ] = max ( str [ l ] , str [ r ] ) ; k -- ; } l ++ ; r -- ; } if ( k < 0 ) return \" Not ▁ possible \" ; l = 0 ; r = str . length ( ) - 1 ; while ( l <= r ) { if ( l == r ) { if ( k > 0 ) palin [ l ] = '9' ; } if ( palin [ l ] < '9' ) { if ( k >= 2 && palin [ l ] == str [ l ] && palin [ r ] == str [ r ] ) { k -= 2 ; palin [ l ] = palin [ r ] = '9' ; } else if ( k >= 1 && ( palin [ l ] != str [ l ] palin [ r ] != str [ r ] ) ) { k -- ; palin [ l ] = palin [ r ] = '9' ; } } l ++ ; r -- ; } return palin ; } int main ( ) { string str = \"43435\" ; int k = 3 ; cout << maximumPalinUsingKChanges ( str , k ) ; return 0 ; }", "text_ms": "Buat palindrome terbesar dengan menukar paling banyak k | Program C ++ untuk mendapatkan palindrome terbesar menukar digit at atmost; Mengembalikan maksimum palindrome menggunakan perubahan k; Memulakan l dan r oleh hujung kiri dan paling kanan; Pertama cuba membuat tali palindrome; Menggantikan watak kiri dan kanan dengan maksimum kedua -duanya; Jika k adalah negatif maka kita tidak boleh membuat palindrome rentetan; Pada watak pertengahan, jika k> 0 kemudian ubahnya menjadi 9; Jika watak di LTH (sama seperti RTH) kurang daripada 9; Jika tiada seorang pun daripada mereka diubah dalam gelung sebelumnya maka tolak 2 dari k dan tukar kedua -duanya ke 9; Jika salah satu daripada mereka diubah dalam gelung sebelumnya maka tolak 1 dari k (1 lagi telah dikurangkan) dan menjadikannya 9; Kod pemacu untuk menguji kaedah di atas"}
{"text": "Count triples with Bitwise AND equal to Zero | C ++ program for the above approach ; Function to find the number of triplets whose Bitwise AND is 0. ; Stores the count of triplets having bitwise AND equal to 0 ; Stores frequencies of all possible A [ i ] & A [ j ] ; Traverse the array ; Update frequency of Bitwise AND of all array elements with a ; Traverse the array ; Iterate the map ; If bitwise AND of triplet is zero , increment cnt ; Return the number of triplets whose Bitwise AND is 0. ; Driver Code ; Input Array ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE #include <iostream> NEW_LINE using namespace std ; int countTriplets ( vector < int > & A ) { int cnt = 0 ; unordered_map < int , int > tuples ; for ( auto a : A ) for ( auto b : A ) ++ tuples [ a & b ] ; for ( auto a : A ) for ( auto t : tuples ) if ( ( t . first & a ) == 0 ) cnt += t . second ; return cnt ; } int main ( ) { vector < int > A = { 2 , 1 , 3 } ; cout << countTriplets ( A ) ; return 0 ; }", "text_ms": "Kira tiga dengan bitwise dan sama dengan sifar | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari bilangan tiga kali ganda yang bitwise dan 0.; Menyimpan kiraan triplet yang mempunyai bitwise dan sama dengan 0; Kedai frekuensi semua yang mungkin [i] & a [j]; Melintasi array; Kemas kini kekerapan bitwise dan semua elemen array dengan A; Melintasi array; Melelehkan peta; Jika bitwise dan triplet adalah sifar, kenaikan CNT; Kembalikan bilangan tiga kali ganda yang bitwise dan 0 .; Kod pemacu; Arahan input; Panggilan fungsi"}
{"text": "Minimize the count of adjacent pairs with different parity | C ++ implementation of above approach ; Recursive function to calculate minimum adjacent pairs with different parity ; If all the numbers are placed ; If replacement is not required ; If replacement is required ; backtracking ; backtracking ; Function to display the minimum number of adjacent elements with different parity ; Store no of even numbers not present in the array ; Store no of odd numbers not present in the array ; Erase exisiting numbers ; Store non - exisiting even and odd numbers ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void parity ( vector < int > even , vector < int > odd , vector < int > v , int i , int & min ) { if ( i == v . size ( ) || even . size ( ) == 0 && odd . size ( ) == 0 ) { int count = 0 ; for ( int j = 0 ; j < v . size ( ) - 1 ; j ++ ) { if ( v [ j ] % 2 != v [ j + 1 ] % 2 ) count ++ ; } if ( count < min ) min = count ; return ; } if ( v [ i ] != -1 ) parity ( even , odd , v , i + 1 , min ) ; else { if ( even . size ( ) != 0 ) { int x = even . back ( ) ; even . pop_back ( ) ; v [ i ] = x ; parity ( even , odd , v , i + 1 , min ) ; even . push_back ( x ) ; } if ( odd . size ( ) != 0 ) { int x = odd . back ( ) ; odd . pop_back ( ) ; v [ i ] = x ; parity ( even , odd , v , i + 1 , min ) ; odd . push_back ( x ) ; } } } void minDiffParity ( vector < int > v , int n ) { vector < int > even ; vector < int > odd ; unordered_map < int , int > m ; for ( int i = 1 ; i <= n ; i ++ ) m [ i ] = 1 ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( v [ i ] != -1 ) m . erase ( v [ i ] ) ; } for ( auto i : m ) { if ( i . first % 2 == 0 ) even . push_back ( i . first ) ; else odd . push_back ( i . first ) ; } int min = 1000 ; parity ( even , odd , v , 0 , min ) ; cout << min << endl ; } int main ( ) { int n = 8 ; vector < int > v = { 2 , 1 , 4 , -1 , -1 , 6 , -1 , 8 } ; minDiffParity ( v , n ) ; return 0 ; }", "text_ms": "Kurangkan kiraan pasangan bersebelahan dengan pariti yang berbeza | C ++ pelaksanaan pendekatan di atas; Fungsi rekursif untuk mengira pasangan bersebelahan minimum dengan pariti yang berbeza; Jika semua nombor diletakkan; Jika penggantian tidak diperlukan; Jika penggantian diperlukan; mundur; mundur; Berfungsi untuk memaparkan bilangan minimum elemen bersebelahan dengan pariti yang berbeza; Simpan tidak ada nombor yang tidak ada dalam array; Simpan tiada nombor ganjil yang tidak terdapat dalam array; Memadam nombor exisiting; Simpan bukan nombor dan nombor ganjil; Kod pemacu"}
{"text": "Find triplet such that number of nodes connecting these triplets is maximum | C ++ implementation of the approach ; To store the required nodes ; Parent array to retrace the nodes ; Visited array to prevent DFS in direction on Diameter path ; DFS function to find the startnode ; DFS function to find the endnode of diameter and maintain the parent array ; DFS function to find the end node of the Longest Branch to Diameter ; Function to find the required nodes ; To find start node of diameter ; To find end node of diameter ; x is the end node of diameter ; Mark all the nodes on diameter using back tracking ; Find the end node of longest branch to diameter ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE #define MAX  100005 NEW_LINE using namespace std ; vector < int > adjacent [ MAX ] ; bool visited [ MAX ] ; int startnode , endnode , thirdnode ; int maxi = -1 , N ; int parent [ MAX ] ; bool vis [ MAX ] ; void dfs ( int u , int count ) { visited [ u ] = true ; int temp = 0 ; for ( int i = 0 ; i < adjacent [ u ] . size ( ) ; i ++ ) { if ( ! visited [ adjacent [ u ] [ i ] ] ) { temp ++ ; dfs ( adjacent [ u ] [ i ] , count + 1 ) ; } } if ( temp == 0 ) { if ( maxi < count ) { maxi = count ; startnode = u ; } } } void dfs1 ( int u , int count ) { visited [ u ] = true ; int temp = 0 ; for ( int i = 0 ; i < adjacent [ u ] . size ( ) ; i ++ ) { if ( ! visited [ adjacent [ u ] [ i ] ] ) { temp ++ ; parent [ adjacent [ u ] [ i ] ] = u ; dfs1 ( adjacent [ u ] [ i ] , count + 1 ) ; } } if ( temp == 0 ) { if ( maxi < count ) { maxi = count ; endnode = u ; } } } void dfs2 ( int u , int count ) { visited [ u ] = true ; int temp = 0 ; for ( int i = 0 ; i < adjacent [ u ] . size ( ) ; i ++ ) { if ( ! visited [ adjacent [ u ] [ i ] ] && ! vis [ adjacent [ u ] [ i ] ] ) { temp ++ ; dfs2 ( adjacent [ u ] [ i ] , count + 1 ) ; } } if ( temp == 0 ) { if ( maxi < count ) { maxi = count ; thirdnode = u ; } } } void findNodes ( ) { dfs ( 1 , 0 ) ; for ( int i = 0 ; i <= N ; i ++ ) visited [ i ] = false ; maxi = -1 ; dfs1 ( startnode , 0 ) ; for ( int i = 0 ; i <= N ; i ++ ) visited [ i ] = false ; int x = endnode ; vis [ startnode ] = true ; while ( x != startnode ) { vis [ x ] = true ; x = parent [ x ] ; } maxi = -1 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( vis [ i ] ) dfs2 ( i , 0 ) ; } } int main ( ) { N = 4 ; adjacent [ 1 ] . push_back ( 2 ) ; adjacent [ 2 ] . push_back ( 1 ) ; adjacent [ 1 ] . push_back ( 3 ) ; adjacent [ 3 ] . push_back ( 1 ) ; adjacent [ 1 ] . push_back ( 4 ) ; adjacent [ 4 ] . push_back ( 1 ) ; findNodes ( ) ; cout << \" ( \" << startnode << \" , ▁ \" << endnode << \" , ▁ \" << thirdnode << \" ) \" ; return 0 ; }", "text_ms": "Cari triplet sedemikian rupa sehingga bilangan nod yang menghubungkan triplet ini adalah maksimum | C ++ pelaksanaan pendekatan; Untuk menyimpan nod yang diperlukan; Array induk untuk menjejaki semula nod; Arahan yang dikunjungi untuk mengelakkan DFS ke arah di garis pusat; Fungsi DFS untuk mencari startnode; Fungsi DFS untuk mencari endnode diameter dan mengekalkan array induk; Fungsi DFS untuk mencari nod akhir cawangan terpanjang ke diameter; Fungsi untuk mencari nod yang diperlukan; Untuk mencari node diameter; Untuk mencari nod akhir diameter; x adalah nod akhir diameter; Tandakan semua nod diameter menggunakan penjejakan belakang; Cari nod akhir cawangan terpanjang ke diameter; Kod pemacu"}
{"text": "Percentage increase in volume of the sphere if radius is increased by a given percentage | C ++ program to find percentage increase in the volume of the sphere if radius is increased by a given percentage ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void newvol ( double x ) { cout << \" percentage ▁ increase ▁ in ▁ the \" << \" ▁ volume ▁ of ▁ the ▁ sphere ▁ is ▁ \" << pow ( x , 3 ) / 10000 + 3 * x + ( 3 * pow ( x , 2 ) ) / 100 << \" % \" << endl ; } int main ( ) { double x = 10 ; newvol ( x ) ; return 0 ; }", "text_ms": "Peratusan peningkatan jumlah sfera jika radius meningkat dengan peratusan tertentu | Program C ++ untuk mencari peningkatan peratusan dalam jumlah sfera jika radius meningkat dengan peratusan tertentu; Kod pemacu"}
{"text": "Length of the chord of the circle whose radius and the angle subtended at the center by the chord is given | C ++ program to find the length chord of the circle whose radius and the angle subtended at the centre is also given ; Function to find the length of the chord ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void length_of_chord ( double r , double x ) { cout << \" The ▁ length ▁ of ▁ the ▁ chord \" << \" ▁ of ▁ the ▁ circle ▁ is ▁ \" << 2 * r * sin ( x * ( 3.14 / 180 ) ) << endl ; } int main ( ) { double r = 4 , x = 63 ; length_of_chord ( r , x ) ; return 0 ; }", "text_ms": "Panjang kord bulatan yang jejari dan sudutnya diselipkan di pusat oleh kord diberikan | Program C ++ untuk mencari kord panjang bulatan yang radius dan sudut yang diselaraskan di pusat juga diberikan; Berfungsi untuk mencari panjang kord; Kod pemacu"}
{"text": "Area of a square inscribed in a circle which is inscribed in an equilateral triangle | C ++ Program to find the area of the square inscribed within the circle which in turn is inscribed in an equilateral triangle ; Function to find the area of the square ; a cannot be negative ; area of the square ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float area ( float a ) { if ( a < 0 ) return -1 ; float area = sqrt ( a ) / 6 ; return area ; } int main ( ) { float a = 10 ; cout << area ( a ) << endl ; return 0 ; }", "text_ms": "Kawasan persegi yang tertulis dalam bulatan yang tertulis dalam segitiga sama rata | Program C ++ untuk mencari kawasan persegi yang tertulis dalam bulatan yang seterusnya ditulis dalam segitiga sama rata; Berfungsi untuk mencari kawasan dataran; A tidak boleh negatif; kawasan dataran; Kod pemacu"}
{"text": "Length of longest rod that can fit into a cuboid | C ++ program to find the longest rod that can fit in a cuboid ; Function to find the length ; temporary variable to hold the intermediate result ; length of longest rod is calculated using square root function ; Driver code ; calling longestRodInCuboid ( ) function to get the length of longest rod", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; double longestRodInCuboid ( int length , int breadth , int height ) { double result ; int temp ; temp = length * length + breadth * breadth + height * height ; result = sqrt ( temp ) ; return result ; } int main ( ) { int length = 12 , breadth = 9 , height = 8 ; cout << longestRodInCuboid ( length , breadth , height ) ; return 0 ; }", "text_ms": "Panjang batang terpanjang yang boleh dimuatkan ke dalam cuboid | Program C ++ untuk mencari rod terpanjang yang boleh dimuatkan dalam cuboid; Berfungsi untuk mencari panjang; Pembolehubah sementara untuk memegang hasil pertengahan; Panjang rod terpanjang dikira menggunakan fungsi akar persegi; Kod pemacu; Memanggil LongeStroDincuboid () berfungsi untuk mendapatkan panjang rod terpanjang"}
{"text": "Check whether a given point lies on or inside the rectangle | Set 3 | C ++ program to Check whether a given point lies inside or on the rectangle or not ; function to Check whether a given point lies inside or on the rectangle or not ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool LiesInsieRectangle ( int a , int b , int x , int y ) { if ( x - y - b <= 0 && x - y + b >= 0 && x + y - 2 * a + b <= 0 && x + y - b >= 0 ) return true ; return false ; } int main ( ) { int a = 7 , b = 2 , x = 4 , y = 5 ; if ( LiesInsieRectangle ( a , b , x , y ) ) cout << \" Given ▁ point ▁ lies ▁ inside ▁ the ▁ rectangle \" ; else cout << \" Given ▁ point ▁ does ▁ not ▁ lie ▁ on ▁ the ▁ rectangle \" ; return 0 ; }", "text_ms": "Semak sama ada titik tertentu terletak pada atau di dalam segi empat tepat | Set 3 | Program C ++ untuk memeriksa sama ada titik tertentu terletak di dalam atau di segi empat tepat atau tidak; berfungsi untuk memeriksa sama ada titik tertentu terletak di dalam atau di segi empat tepat atau tidak; Kod pemacu"}
{"text": "Maximize volume of cuboid with given sum of sides | Return the maximum volume . ; Return the maximum volume . ; for length ; for breadth ; for height ; calculating maximum volume . ; Driven Program", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxvolume ( int s ) { int maxvalue = 0 ; for ( int i = 1 ; i <= s - 2 ; i ++ ) { for ( int j = 1 ; j <= s - 1 ; j ++ ) { int k = s - i - j ; maxvalue = max ( maxvalue , i * j * k ) ; } } return maxvalue ; } int main ( ) { int s = 8 ; cout << maxvolume ( s ) << endl ; return 0 ; }", "text_ms": "Memaksimumkan jumlah cuboid dengan jumlah sisi yang diberikan | Kembalikan jumlah maksimum. ; Kembalikan jumlah maksimum. ; untuk panjang; untuk keluasan; untuk ketinggian; Mengira isipadu maksimum. ; Program yang didorong"}
{"text": "Maximize volume of cuboid with given sum of sides | Return the maximum volume . ; Return the maximum volume . ; finding length ; finding breadth ; finding height ; Driven Program", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxvolume ( int s ) { int length = s / 3 ; s -= length ; int breadth = s / 2 ; int height = s - breadth ; return length * breadth * height ; } int main ( ) { int s = 8 ; cout << maxvolume ( s ) << endl ; return 0 ; }", "text_ms": "Memaksimumkan jumlah cuboid dengan jumlah sisi yang diberikan | Kembalikan jumlah maksimum. ; Kembalikan jumlah maksimum. ; mencari panjang; mencari keluasan; Mencari ketinggian; Program yang didorong"}
{"text": "Area of a Hexagon | CPP program to find area of a Hexagon ; function for calculating area of the hexagon . ; Driver Code ; Length of a side", "code": "#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; double hexagonArea ( double s ) { return ( ( 3 * sqrt ( 3 ) * ( s * s ) ) / 2 ) ; } int main ( ) { double s = 4 ; cout << \" Area ▁ : ▁ \" << hexagonArea ( s ) ; return 0 ; }", "text_ms": "Kawasan Hexagon | Program CPP untuk mencari kawasan segi enam; Fungsi untuk mengira kawasan segi enam. ; Kod pemacu; Panjang sisi"}
{"text": "Maximum number of squares that can fit in a right angle isosceles triangle | CPP program for finding maximum squares that can fit in right angle isosceles triangle ; function for finding max squares ; return in O ( 1 ) with derived formula ; driver program", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSquare ( int b , int m ) { return ( b / m - 1 ) * ( b / m ) / 2 ; } int main ( ) { int b = 10 , m = 2 ; cout << maxSquare ( b , m ) ; return 0 ; }", "text_ms": "Bilangan maksimum kuadrat yang boleh dimuatkan dalam segitiga isosceles sudut kanan | Program CPP untuk mencari dataran maksimum yang boleh dimuatkan dalam segi tiga sudut yang betul; fungsi untuk mencari dataran maksimum; kembali dalam O (1) dengan formula yang diperoleh; Program Pemandu"}
{"text": "Check if right triangle possible from given area and hypotenuse | C ++ program to check existence of right triangle . ; Prints three sides of a right triangle from given area and hypotenuse if triangle is possible , else prints - 1. ; Descriminant of the equation ; applying the linear equation formula to find both the roots ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findRightAngle ( int A , int H ) { long D = pow ( H , 4 ) - 16 * A * A ; if ( D >= 0 ) { long root1 = ( H * H + sqrt ( D ) ) / 2 ; long root2 = ( H * H - sqrt ( D ) ) / 2 ; long a = sqrt ( root1 ) ; long b = sqrt ( root2 ) ; if ( b >= a ) cout << a << \" ▁ \" << b << \" ▁ \" << H ; else cout << b << \" ▁ \" << a << \" ▁ \" << H ; } else cout << \" - 1\" ; } int main ( ) { findRightAngle ( 6 , 5 ) ; }", "text_ms": "Semak jika segitiga yang betul mungkin dari kawasan tertentu dan hipotenus | Program C ++ untuk memeriksa kewujudan segitiga kanan. ; Mencetak tiga sisi segitiga kanan dari kawasan tertentu dan hipotenus jika segitiga mungkin, cetakan lain - 1 .; Deskripsi persamaan; memohon formula persamaan linear untuk mencari kedua -dua akar; Kod pemacu"}
{"text": "Maximum number of 2 x2 squares that can be fit inside a right isosceles triangle | C ++ program to count number of 2 x 2 squares in a right isosceles triangle ; removing the extra part we would always need ; Since each square has base of length of 2 ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberOfSquares ( int base ) { base = ( base - 2 ) ; base = floor ( base / 2 ) ; return base * ( base + 1 ) / 2 ; } int main ( ) { int base = 8 ; cout << numberOfSquares ( base ) ; return 0 ; }", "text_ms": "Bilangan maksimum 2 x2 kotak yang boleh dimuatkan di dalam segitiga isosceles kanan | Program C ++ untuk mengira bilangan 2 x 2 kotak di segitiga isosceles yang betul; Mengeluarkan bahagian tambahan yang selalu kita perlukan; Kerana setiap persegi mempunyai asas panjang 2; Kod pemacu"}
{"text": "Bitwise OR of bitwise AND of all possible non | C ++ program for the above approach ; Function to find the Bitwise OR of Bitwise AND of all possible subarrays after performing the every query ; Traversing each pair of the query ; Stores the Bitwise OR ; Updating the array ; Find the Bitwise OR of new updated array ; Print the ans ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void performQuery ( vector < int > arr , vector < vector < int > > Q ) { for ( int i = 0 ; i < Q . size ( ) ; i ++ ) { int or1 = 0 ; int x = Q [ i ] [ 0 ] ; arr [ x - 1 ] = Q [ i ] [ 1 ] ; for ( int j = 0 ; j < arr . size ( ) ; j ++ ) { or1 = or1 | arr [ j ] ; } cout << or1 << \" ▁ \" ; } } int main ( ) { vector < int > arr ( { 1 , 2 , 3 } ) ; vector < int > v1 ( { 1 , 4 } ) ; vector < int > v2 ( { 3 , 0 } ) ; vector < vector < int > > Q ; Q . push_back ( v1 ) ; Q . push_back ( v2 ) ; performQuery ( arr , Q ) ; }", "text_ms": "Bitwise atau bitwise dan semua yang mungkin bukan | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari bitwise atau bitwise dan semua subarray yang mungkin selepas melakukan setiap pertanyaan; Melintasi setiap pasangan pertanyaan; Menyimpan bitwise atau; Mengemas kini array; Cari bitwise atau array baru yang dikemas kini; Cetak Ans; Kod pemacu"}
{"text": "Smallest length of number divisible by K formed by using D only | C ++ program for the above approach ; Function to form the smallest number possible ; Array to mark the remainders counted already ; Iterate over the range ; If that remainder is already found , return - 1 ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int smallest ( int k , int d ) { int cnt = 1 ; int m = d % k ; vector < int > v ( k , 0 ) ; v [ m ] = 1 ; while ( 1 ) { if ( m == 0 ) return cnt ; m = ( ( ( m * ( 10 % k ) ) % k ) + ( d % k ) ) % k ; if ( v [ m ] == 1 ) return -1 ; v [ m ] = 1 ; cnt ++ ; } return -1 ; } int main ( ) { int d = 1 ; int k = 41 ; cout << smallest ( k , d ) ; return 0 ; }", "text_ms": "Panjang terkecil nombor yang boleh dibahagi dengan k yang dibentuk dengan menggunakan d sahaja | Program C ++ untuk pendekatan di atas; Berfungsi untuk membentuk bilangan terkecil yang mungkin; Array untuk menandakan baki yang telah dikira sudah; Melangkah ke atas julat; Jika baki itu sudah dijumpai, kembali - 1; Kod pemacu"}
{"text": "Fibonacci Cube Graph | CPP code to find vertices in a fibonacci cube graph of order n ; function to find fibonacci number ; function for finding number of vertices in fibonacci cube graph ; return fibonacci number for f ( n + 2 ) ; driver program", "code": "#include <iostream> NEW_LINE using namespace std ; int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; } int findVertices ( int n ) { return fib ( n + 2 ) ; } int main ( ) { int n = 3 ; cout << findVertices ( n ) ; return 0 ; }", "text_ms": "Grafik Cube Fibonacci | Kod CPP untuk mencari simpul dalam graf kiub Fibonacci Order N; berfungsi untuk mencari nombor Fibonacci; fungsi untuk mencari bilangan simpang dalam graf kiub Fibonacci; kembali nombor fibonacci untuk f (n + 2); Program Pemandu"}
{"text": "Modify array such that the array does not contain any common divisors other than 1 | C ++ program for the above approach ; Function to check if it is possible to modify the array such that there is no common factor between array elements except 1 ; Stores GCD of the array ; Calculate GCD of the array ; If the current divisor is smaller than X ; Divide GCD by the current divisor ; If possible ; Print the modified array ; Otherwise ; Driver Code ; Given array ; Size of the array", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkCommonDivisor ( int arr [ ] , int N , int X ) { int G = 0 ; for ( int i = 0 ; i < N ; i ++ ) { G = __gcd ( G , arr [ i ] ) ; } int copy_G = G ; for ( int divisor = 2 ; divisor <= X ; divisor ++ ) { while ( G % divisor == 0 ) { G = G / divisor ; } } if ( G <= X ) { cout << \" Yes STRNEWLINE \" ; for ( int i = 0 ; i < N ; i ++ ) cout << arr [ i ] / copy_G << \" ▁ \" ; cout << endl ; } else cout << \" No \" ; } int main ( ) { int arr [ ] = { 6 , 15 , 6 } , X = 6 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; checkCommonDivisor ( arr , N , X ) ; }", "text_ms": "Ubah suai array supaya array tidak mengandungi mana -mana pembahagi biasa selain 1 | Program C ++ untuk pendekatan di atas; Fungsi untuk memeriksa sama ada mungkin untuk mengubah suai array supaya tidak ada faktor yang sama antara elemen array kecuali 1; Menyimpan GCD array; Hitung GCD array; Jika pembahagi semasa lebih kecil daripada x; Bahagikan GCD oleh pembahagi semasa; Jika boleh; Cetak array yang diubah suai; Jika tidak; Kod pemacu; Diberikan array; Saiz array"}
{"text": "Program to print Spiral Pattern | Create row and col to traverse rows and columns ; Variable to determine the movement r = right , l = left , d = down , u = upper ; Array for matrix ; Assign the value ; switch - case to determine the next index ; If right , go right ; if left , go left ; if up , go up ; if down , go down ; Check if the matrix has reached array boundary ; Add the left size for the next boundary ; If 2 rotations has been made , decrease the size left by 1 ; switch - case to rotate the movement ; if right , rotate to down ; if down , rotate to left ; if left , rotate to up ; if up , rotate to right ; Print the matrix ; Driver Code ; Get the size of size ; Print the Spiral Pattern", "code": "#include <iostream> NEW_LINE using namespace std ; void printSpiral ( int size ) { int row = 0 , col = 0 ; int boundary = size - 1 ; int sizeLeft = size - 1 ; int flag = 1 ; char move = ' r ' ; int matrix [ size ] [ size ] = { 0 } ; for ( int i = 1 ; i < size * size + 1 ; i ++ ) { matrix [ row ] [ col ] = i ; switch ( move ) { case ' r ' : col += 1 ; break ; case ' l ' : col -= 1 ; break ; case ' u ' : row -= 1 ; break ; case ' d ' : row += 1 ; break ; } if ( i == boundary ) { boundary += sizeLeft ; if ( flag != 2 ) { flag = 2 ; } else { flag = 1 ; sizeLeft -= 1 ; } switch ( move ) { case ' r ' : move = ' d ' ; break ; case ' d ' : move = ' l ' ; break ; case ' l ' : move = ' u ' ; break ; case ' u ' : move = ' r ' ; break ; } } } for ( row = 0 ; row < size ; row ++ ) { for ( col = 0 ; col < size ; col ++ ) { int n = matrix [ row ] [ col ] ; if ( n < 10 ) cout << n << \" ▁ \" ; else cout << n << \" ▁ \" ; } cout << endl ; } } int main ( ) { int size = 5 ; printSpiral ( size ) ; return 0 ; }", "text_ms": "Program untuk mencetak corak lingkaran | Buat baris dan col untuk melintasi baris dan lajur; Pembolehubah untuk menentukan pergerakan r = kanan, l = kiri, d = ke bawah, u = atas; Array untuk matriks; Berikan nilai; suis - kes untuk menentukan indeks seterusnya; Jika betul, pergi ke kanan; jika ditinggalkan, pergi ke kiri; jika naik, naik; jika turun, turun; Semak jika matriks telah mencapai sempadan array; Tambah saiz kiri untuk sempadan seterusnya; Jika 2 putaran telah dibuat, mengurangkan saiz yang ditinggalkan oleh 1; suis - kes untuk memutar pergerakan; jika betul, putar ke bawah; jika turun, putar ke kiri; jika dibiarkan, putar ke atas; jika naik, putar ke kanan; Cetak matriks; Kod pemacu; Dapatkan saiz saiz; Cetak corak lingkaran"}
{"text": "Sort the biotonic doubly linked list | C ++ implementation to sort the biotonic doubly linked list ; a node of the doubly linked list ; Function to reverse a Doubly Linked List ; swap next and prev for all nodes of doubly linked list ; Before changing head , check for the cases like empty list and list with only one node ; Function to merge two sorted doubly linked lists ; If first linked list is empty ; If second linked list is empty ; Pick the smaller value ; function to sort a biotonic doubly linked list ; if list is empty or if it contains a single node only ; if true , then ' current ' is the first node which is smaller than its previous node ; move to the next node ; if true , then list is already sorted ; spilt into two lists , one starting with ' head ' and other starting with ' current ' ; reverse the list starting with ' current ' ; merge the two lists and return the final merged doubly linked list ; Function to insert a node at the beginning of the Doubly Linked List ; allocate node ; put in the data ; since we are adding at the beginning , prev is always NULL ; link the old list off the new node ; change prev of head node to new node ; move the head to point to the new node ; Function to print nodes in a given doubly linked list ; if list is empty ; Driver program to test above ; Create the doubly linked list : 2 < -> 5 < -> 7 < -> 12 < -> 10 < -> 6 < -> 4 < -> 1 ; sort the biotonic DLL", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; struct Node * prev ; } ; void reverse ( struct Node * * head_ref ) { struct Node * temp = NULL ; struct Node * current = * head_ref ; while ( current != NULL ) { temp = current -> prev ; current -> prev = current -> next ; current -> next = temp ; current = current -> prev ; } if ( temp != NULL ) * head_ref = temp -> prev ; } struct Node * merge ( struct Node * first , struct Node * second ) { if ( ! first ) return second ; if ( ! second ) return first ; if ( first -> data < second -> data ) { first -> next = merge ( first -> next , second ) ; first -> next -> prev = first ; first -> prev = NULL ; return first ; } else { second -> next = merge ( first , second -> next ) ; second -> next -> prev = second ; second -> prev = NULL ; return second ; } } struct Node * sort ( struct Node * head ) { if ( head == NULL head -> next == NULL ) return head ; struct Node * current = head -> next ; while ( current != NULL ) { if ( current -> data < current -> prev -> data ) break ; current = current -> next ; } if ( current == NULL ) return head ; current -> prev -> next = NULL ; current -> prev = NULL ; reverse ( & current ) ; return merge ( head , current ) ; } void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> prev = NULL ; new_node -> next = ( * head_ref ) ; if ( ( * head_ref ) != NULL ) ( * head_ref ) -> prev = new_node ; ( * head_ref ) = new_node ; } void printList ( struct Node * head ) { if ( head == NULL ) cout << \" Doubly ▁ Linked ▁ list ▁ empty \" ; while ( head != NULL ) { cout << head -> data << \" ▁ \" ; head = head -> next ; } } int main ( ) { struct Node * head = NULL ; push ( & head , 1 ) ; push ( & head , 4 ) ; push ( & head , 6 ) ; push ( & head , 10 ) ; push ( & head , 12 ) ; push ( & head , 7 ) ; push ( & head , 5 ) ; push ( & head , 2 ) ; cout << \" Original ▁ Doubly ▁ linked ▁ list : n \" ; printList ( head ) ; head = sort ( head ) ; cout << \" Doubly linked list after sorting : n \" ; printList ( head ) ; return 0 ; }", "text_ms": "Sort Biotonic Doubly Linked List | C ++ pelaksanaan untuk menyusun senarai dikaitkan biotonik; nod senarai dikaitkan dua kali ganda; Berfungsi untuk membalikkan senarai dikaitkan dua kali ganda; swap seterusnya dan sebelumnya untuk semua nod senarai dikaitkan dua kali ganda; Sebelum menukar kepala, periksa kes -kes seperti senarai kosong dan senarai dengan hanya satu nod; Berfungsi untuk menggabungkan dua senarai dikaitkan dua kali ganda; Jika senarai yang dipautkan pertama kosong; Jika senarai dikaitkan kedua kosong; Pilih nilai yang lebih kecil; berfungsi untuk menyusun senarai dikaitkan dua kali ganda biotonik; Jika senarai kosong atau jika ia mengandungi satu nod tunggal; Jika benar, maka 'semasa' adalah nod pertama yang lebih kecil daripada nod sebelumnya; Pindah ke nod seterusnya; Jika benar, maka senarai sudah disusun; tumpah ke dalam dua senarai, satu bermula dengan 'kepala' dan yang lain bermula dengan 'semasa'; membalikkan senarai bermula dengan 'semasa'; Gabungkan kedua -dua senarai dan kembalikan senarai dikaitkan dua kali ganda; Berfungsi untuk memasukkan nod pada permulaan senarai dikaitkan dua kali ganda; memperuntukkan nod; masukkan data; Oleh kerana kita menambah pada mulanya, sebelum ini sentiasa batal; Pautan senarai lama dari nod baru; Tukar Node kepala ke nod baru; gerakkan kepala untuk menunjuk ke nod baru; Berfungsi untuk mencetak nod dalam senarai dikaitkan dua kali ganda; Jika senarai kosong; Program pemandu untuk menguji di atas; Buat senarai yang dipautkan dua kali: 2 <-> 5 <-> 7 <-> 10 <--> 6 <--> 4 <-> 1; Susun DLL Biotonik"}
{"text": "Arrange consonants and vowels nodes in a linked list | C ++ program to arrange consonants and vowels nodes in a linked list ; A linked list node ; Function to add new node to the List ; utility function to print linked list ; utility function for checking vowel ; function to arrange consonants and vowels nodes ; for keep track of vowel ; list is empty ; We need to discover the first vowel in the list . It is going to be the returned head , and also the initial latestVowel . ; first element is a vowel . It will also be the new head and the initial latestVowel ; ; First element is not a vowel . Iterate through the list until we find a vowel . Note that curr points to the element * before * the element with the vowel . ; This is an edge case where there are only consonants in the list . ; Set the initial latestVowel and the new head to the vowel item that we found . Relink the chain of consonants after that vowel item : old_head_consonant -> consonant1 -> consonant2 -> vowel -> rest_of_list becomes vowel -> old_head_consonant -> consonant1 -> consonant2 -> rest_of_list ; Now traverse the list . Curr is always the item * before * the one we are checking , so that we can use it to re - link . ; The next discovered item is a vowel ; If it comes directly after the previous vowel , we don 't need to  move items around, just mark the  new latestVowel and advance curr. ; But if it comes after an intervening chain of consonants , we need to chain the newly discovered vowel right after the old vowel . Curr is not changed as after the re - linking it will have a new next , that has not been checked yet , and we always keep curr at one before the next to check . ; Chain in new vowel ; Advance latestVowel ; Remove found vowel from previous place ; Re - link chain of consonants after latestVowel ; No vowel in the next element , advance curr . ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { char data ; struct Node * next ; } ; Node * newNode ( char key ) { Node * temp = new Node ; temp -> data = key ; temp -> next = NULL ; return temp ; } void printlist ( Node * head ) { if ( ! head ) { cout << \" Empty ▁ List STRNEWLINE \" ; return ; } while ( head != NULL ) { cout << head -> data << \" ▁ \" ; if ( head -> next ) cout << \" - > ▁ \" ; head = head -> next ; } cout << endl ; } bool isVowel ( char x ) { return ( x == ' a ' x == ' e ' x == ' i ' x == ' o ' x == ' u ' ) ; } Node * arrange ( Node * head ) { Node * newHead = head ; Node * latestVowel ; Node * curr = head ; if ( head == NULL ) return NULL ; if ( isVowel ( head -> data ) ) latestVowel = head ; else { while ( curr -> next != NULL && ! isVowel ( curr -> next -> data ) ) curr = curr -> next ; if ( curr -> next == NULL ) return head ; latestVowel = newHead = curr -> next ; curr -> next = curr -> next -> next ; latestVowel -> next = head ; } while ( curr != NULL && curr -> next != NULL ) { if ( isVowel ( curr -> next -> data ) ) { if ( curr == latestVowel ) { latestVowel = curr = curr -> next ; } else { Node * temp = latestVowel -> next ; latestVowel -> next = curr -> next ; latestVowel = latestVowel -> next ; curr -> next = curr -> next -> next ; latestVowel -> next = temp ; } } else { curr = curr -> next ; } } return newHead ; } int main ( ) { Node * head = newNode ( ' a ' ) ; head -> next = newNode ( ' b ' ) ; head -> next -> next = newNode ( ' c ' ) ; head -> next -> next -> next = newNode ( ' e ' ) ; head -> next -> next -> next -> next = newNode ( ' d ' ) ; head -> next -> next -> next -> next -> next = newNode ( ' o ' ) ; head -> next -> next -> next -> next -> next -> next = newNode ( ' x ' ) ; head -> next -> next -> next -> next -> next -> next -> next = newNode ( ' i ' ) ; printf ( \" Linked ▁ list ▁ before ▁ : STRNEWLINE \" ) ; printlist ( head ) ; head = arrange ( head ) ; printf ( \" Linked ▁ list ▁ after ▁ : STRNEWLINE \" ) ; printlist ( head ) ; return 0 ; }", "text_ms": "Susun konsonan dan vokal nod dalam senarai yang dipautkan | Program C ++ untuk mengatur konsonan dan nod vokal dalam senarai yang dipautkan; Nod senarai yang dipautkan; Berfungsi untuk menambah nod baru ke senarai; fungsi utiliti untuk mencetak senarai yang dipautkan; fungsi utiliti untuk memeriksa vokal; berfungsi untuk mengatur konsonan dan nod vokal; untuk menjejaki vokal; senarai kosong; Kita perlu menemui vokal pertama dalam senarai. Ia akan menjadi kepala yang dikembalikan, dan juga Latarvowel awal. ; Unsur pertama adalah vokal. Ia juga akan menjadi kepala baru dan Latarvowel awal; ; Unsur pertama bukan vokal. Keluarkan melalui senarai sehingga kita dapati vokal. Perhatikan bahawa Curr menunjuk kepada elemen * sebelum * elemen dengan vokal. ; Ini adalah kes kelebihan di mana terdapat hanya konsonan dalam senarai. ; Tetapkan Latihan Awal dan kepala baru ke item vokal yang kami dapati. Relink rantai konsonan selepas item vokal itu: old_head_consonant -> consonant1 -> consonant2 -> vokal -> rest_of_list menjadi vokal -> old_head_consonant -> consonant1 -> consonant2 -> rest_of_list; Sekarang melintasi senarai. Curr sentiasa item * sebelum * yang kita periksa, supaya kita boleh menggunakannya untuk menghubungkan semula. ; Item yang ditemui seterusnya adalah vokal; Sekiranya ia datang secara langsung selepas vokal sebelumnya, kami tidak perlu memindahkan item di sekitar, hanya tandakan LatarVowel baru dan Advance Curr. ; Tetapi jika ia datang selepas rantaian konsonan intervensi, kita perlu mengikat vokal yang baru ditemui selepas vokal lama. Curr tidak berubah kerana selepas menghubungkannya akan mempunyai yang baru, yang belum diperiksa, dan kami sentiasa menyimpan Curr pada satu sebelum pemeriksaan seterusnya. ; Rantai dalam vokal baru; Advance Latestvowel; Keluarkan vokal yang dijumpai dari tempat sebelumnya; Re - Rantaian Konsonan Pautan Selepas Latihan Latihan; Tiada vokal dalam elemen seterusnya, Advance Curr. ; Kod pemacu"}
{"text": "K 'th Largest element in BST using constant extra space | CPP code for finding K - th largest Node using O ( 1 ) extra memory and reverse Morris traversal . ; Node structure ; helper function to create a new Node ; count variable to keep count of visited Nodes ; if right child is NULL ; first increment count and check if count = k ; otherwise move to the left child ; find inorder successor of current Node ; set left child of successor to the current Node ; move current to its right ; restoring the tree back to original binary search tree removing threaded links ; move current to its left child ; Constructed binary tree is 4 / \\ 2 7 / \\ / \\ 1 3 6 10", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; Node * newNode ( int data ) { Node * temp = new Node ; temp -> data = data ; temp -> right = temp -> left = NULL ; return temp ; } Node * KthLargestUsingMorrisTraversal ( Node * root , int k ) { Node * curr = root ; Node * Klargest = NULL ; int count = 0 ; while ( curr != NULL ) { if ( curr -> right == NULL ) { if ( ++ count == k ) Klargest = curr ; curr = curr -> left ; } else { Node * succ = curr -> right ; while ( succ -> left != NULL && succ -> left != curr ) succ = succ -> left ; if ( succ -> left == NULL ) { succ -> left = curr ; curr = curr -> right ; } else { succ -> left = NULL ; if ( ++ count == k ) Klargest = curr ; curr = curr -> left ; } } } return Klargest ; } int main ( ) { Node * root = newNode ( 4 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 7 ) ; root -> left -> left = newNode ( 1 ) ; root -> left -> right = newNode ( 3 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 10 ) ; cout << \" Finding ▁ K - th ▁ largest ▁ Node ▁ in ▁ BST ▁ : ▁ \" << KthLargestUsingMorrisTraversal ( root , 2 ) -> data ; return 0 ; }", "text_ms": "Elemen terbesar di BST menggunakan ruang tambahan yang berterusan | Kod CPP untuk mencari nod terbesar k - menggunakan O (1) memori tambahan dan membalikkan Morris Traversal. ; Struktur nod; fungsi penolong untuk membuat nod baru; Mengira pembolehubah untuk menyimpan kiraan nod yang dikunjungi; Jika anak yang betul adalah batal; kiraan kenaikan pertama dan semak jika Count = k; Jika tidak berpindah ke anak kiri; Cari pengganti inorder nod semasa; Tetapkan anak kiri pengganti ke nod semasa; gerakkan arus ke kanannya; memulihkan pokok itu kembali ke pokok carian binari asal yang mengeluarkan pautan berulir; gerakkan arus ke anak kiri; Pokok binari yang dibina adalah 4 / \\ 2 7 / \\ / \\ 1 3 6 10"}
{"text": "Sorting rows of matrix in ascending order followed by columns in descending order | C ++ implementation to sort the rows of matrix in ascending order followed by sorting the columns in descending order ; function to sort each row of the matrix according to the order specified by ascending . ; function to find transpose of the matrix ; swapping element at index ( i , j ) by element at index ( j , i ) ; function to sort the matrix row - wise and column - wise ; sort rows of mat [ ] [ ] ; get transpose of mat [ ] [ ] ; again sort rows of mat [ ] [ ] in descending order . ; again get transpose of mat [ ] [ ] ; function to print the matrix ; Driver program to test above", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX_SIZE  10 NEW_LINE void sortByRow ( int mat [ ] [ MAX_SIZE ] , int n , bool ascending ) { for ( int i = 0 ; i < n ; i ++ ) { if ( ascending ) sort ( mat [ i ] , mat [ i ] + n ) ; else sort ( mat [ i ] , mat [ i ] + n , greater < int > ( ) ) ; } } void transpose ( int mat [ ] [ MAX_SIZE ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) swap ( mat [ i ] [ j ] , mat [ j ] [ i ] ) ; } void sortMatRowAndColWise ( int mat [ ] [ MAX_SIZE ] , int n ) { sortByRow ( mat , n , true ) ; transpose ( mat , n ) ; sortByRow ( mat , n , false ) ; transpose ( mat , n ) ; } void printMat ( int mat [ ] [ MAX_SIZE ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) cout << mat [ i ] [ j ] << \" ▁ \" ; cout << endl ; } } int main ( ) { int n = 3 ; int mat [ n ] [ MAX_SIZE ] = { { 3 , 2 , 1 } , { 9 , 8 , 7 } , { 6 , 5 , 4 } } ; cout << \" Original ▁ Matrix : STRNEWLINE \" ; printMat ( mat , n ) ; sortMatRowAndColWise ( mat , n ) ; cout << \" Matrix After Sorting : \" ; printMat ( mat , n ) ; return 0 ; }", "text_ms": "Penyusun baris matriks dalam urutan menaik diikuti oleh lajur dalam urutan menurun | C ++ pelaksanaan untuk menyusun baris matriks dalam urutan menaik diikuti dengan menyusun lajur dalam urutan menurun; Fungsi untuk menyusun setiap baris matriks mengikut perintah yang ditentukan oleh menaik. ; berfungsi untuk mencari transpose matriks; elemen bertukar pada indeks (i, j) mengikut elemen pada indeks (j, i); berfungsi untuk menyusun baris matriks - bijak dan lajur - bijak; Susun baris Mat [] []; dapatkan transpose tikar [] []; Sekali lagi menyusun baris Mat [] [] dalam urutan menurun. ; Sekali lagi dapatkan transpose tikar [] []; berfungsi untuk mencetak matriks; Program Pemandu untuk diuji di atas"}
{"text": "Sort the matrix row | C ++ implementation to sort the matrix row - wise and column - wise ; function to sort each row of the matrix ; sorting row number ' i ' ; function to find transpose of the matrix ; swapping element at index ( i , j ) by element at index ( j , i ) ; function to sort the matrix row - wise and column - wise ; sort rows of mat [ ] [ ] ; get transpose of mat [ ] [ ] ; again sort rows of mat [ ] [ ] ; again get transpose of mat [ ] [ ] ; function to print the matrix ; Driver program to test above", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX_SIZE  10 NEW_LINE void sortByRow ( int mat [ MAX_SIZE ] [ MAX_SIZE ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) sort ( mat [ i ] , mat [ i ] + n ) ; } void transpose ( int mat [ MAX_SIZE ] [ MAX_SIZE ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) swap ( mat [ i ] [ j ] , mat [ j ] [ i ] ) ; } void sortMatRowAndColWise ( int mat [ MAX_SIZE ] [ MAX_SIZE ] , int n ) { sortByRow ( mat , n ) ; transpose ( mat , n ) ; sortByRow ( mat , n ) ; transpose ( mat , n ) ; } void printMat ( int mat [ MAX_SIZE ] [ MAX_SIZE ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) cout << mat [ i ] [ j ] << \" ▁ \" ; cout << endl ; } } int main ( ) { int mat [ MAX_SIZE ] [ MAX_SIZE ] = { { 4 , 1 , 3 } , { 9 , 6 , 8 } , { 5 , 2 , 7 } } ; int n = 3 ; cout << \" Original ▁ Matrix : STRNEWLINE \" ; printMat ( mat , n ) ; sortMatRowAndColWise ( mat , n ) ; cout << \" Matrix After Sorting : \" ; printMat ( mat , n ) ; return 0 ; }", "text_ms": "Susun baris matriks | C ++ pelaksanaan untuk menyusun baris matriks - bijak dan lajur - bijak; berfungsi untuk menyusun setiap baris matriks; menyusun nombor baris 'i'; berfungsi untuk mencari transpose matriks; elemen bertukar pada indeks (i, j) mengikut elemen pada indeks (j, i); berfungsi untuk menyusun baris matriks - bijak dan lajur - bijak; Susun baris Mat [] []; dapatkan transpose tikar [] []; sekali lagi menyusun baris tikar [] []; Sekali lagi dapatkan transpose tikar [] []; berfungsi untuk mencetak matriks; Program Pemandu untuk diuji di atas"}
{"text": "Magic Square | Even Order | C ++ Program to print Magic square of Doubly even order ; Function for calculating Magic square ; filling matrix with its count value starting from 1 ; ; change value of Array elements at fix location as per rule ( n * n + 1 ) - arr [ i ] [ j ] Top Left corner of Matrix ( order ( n / 4 ) * ( n / 4 ) ) ; Top Right corner of Matrix ( order ( n / 4 ) * ( n / 4 ) ) ; Bottom Left corner of Matrix ( order ( n / 4 ) * ( n / 4 ) ) ; Bottom Right corner of Matrix ( order ( n / 4 ) * ( n / 4 ) ) ; Centre of Matrix ( order ( n / 2 ) * ( n / 2 ) ) ; Printing the magic - square ; driver program ; Function call", "code": "#include <iostream> NEW_LINE using namespace std ; void doublyEven ( int n ) { int arr [ n ] [ n ] , i , j ; for ( i = 0 ; i < n ; i ++ ) for ( j = 0 ; j < n ; j ++ ) arr [ i ] [ j ] = ( n * i ) + j + 1 ; for ( i = 0 ; i < n / 4 ; i ++ ) for ( j = 0 ; j < n / 4 ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; for ( i = 0 ; i < n / 4 ; i ++ ) for ( j = 3 * ( n / 4 ) ; j < n ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; for ( i = 3 * n / 4 ; i < n ; i ++ ) for ( j = 0 ; j < n / 4 ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; for ( i = 3 * n / 4 ; i < n ; i ++ ) for ( j = 3 * n / 4 ; j < n ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; for ( i = n / 4 ; i < 3 * n / 4 ; i ++ ) for ( j = n / 4 ; j < 3 * n / 4 ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) cout << arr [ i ] [ j ] << \" ▁ \" ; cout << \" STRNEWLINE \" ; } } int main ( ) { int n = 8 ; doublyEven ( n ) ; return 0 ; }", "text_ms": "Magic Square | Malah pesanan | Program C ++ untuk mencetak Magic Square dari urutan dua kali ganda; Fungsi untuk mengira Magic Square; Mengisi matriks dengan nilai kiraannya bermula dari 1; ; Tukar nilai elemen array di lokasi pembaikan seperti peraturan (n * n + 1) - arr [i] [j] sudut kiri atas matriks (perintah (n / 4) * (n / 4)); Sudut kanan atas matriks (perintah (n / 4) * (n / 4)); Sudut kiri bawah matriks (pesanan (n / 4) * (n / 4)); Sudut kanan bawah matriks (pesanan (n / 4) * (n / 4)); Pusat matriks (perintah (n / 2) * (n / 2)); Mencetak Magic - Square; program pemacu; Panggilan fungsi"}
{"text": "Kronecker Product of two matrices | C ++ code to find the Kronecker Product of two matrices and stores it as matrix C ; rowa and cola are no of rows and columns of matrix A rowb and colb are no of rows and columns of matrix B ; Function to computes the Kronecker Product of two matrices ; i loops till rowa ; k loops till rowb ; j loops till cola ; l loops till colb ; Each element of matrix A is multiplied by whole Matrix B resp and stored as Matrix C ; Driver Code", "code": "#include <iostream> NEW_LINE using namespace std ; const int cola = 2 , rowa = 3 , colb = 3 , rowb = 2 ; void Kroneckerproduct ( int A [ ] [ cola ] , int B [ ] [ colb ] ) { int C [ rowa * rowb ] [ cola * colb ] ; for ( int i = 0 ; i < rowa ; i ++ ) { for ( int k = 0 ; k < rowb ; k ++ ) { for ( int j = 0 ; j < cola ; j ++ ) { for ( int l = 0 ; l < colb ; l ++ ) { C [ i + l + 1 ] [ j + k + 1 ] = A [ i ] [ j ] * B [ k ] [ l ] ; cout << C [ i + l + 1 ] [ j + k + 1 ] << \" ▁ \" ; } } cout << endl ; } } } int main ( ) { int A [ 3 ] [ 2 ] = { { 1 , 2 } , { 3 , 4 } , { 1 , 0 } } , B [ 2 ] [ 3 ] = { { 0 , 5 , 2 } , { 6 , 7 , 3 } } ; Kroneckerproduct ( A , B ) ; return 0 ; }", "text_ms": "Produk Kronecker Dua Matriks | C ++ kod untuk mencari produk Kronecker dua matriks dan menyimpannya sebagai matriks C; Rowa dan Cola tidak ada baris dan lajur matriks A rowb dan colb tidak ada baris dan lajur matriks B; Berfungsi untuk mengira produk Kronecker dua matriks; Saya gelung sehingga Rowa; k gelung hingga rowb; J Loops hingga Cola; l Loops hingga Colb; Setiap elemen matriks A didarab dengan keseluruhan matriks B resp dan disimpan sebagai matriks c; Kod pemacu"}
{"text": "Program to check if matrix is lower triangular | Program to check lower triangular matrix . ; Function to check matrix is in lower triangular form or not . ; Driver function . ; Function call", "code": "#include <bits/stdc++.h> NEW_LINE #define N  4 NEW_LINE using namespace std ; bool isLowerTriangularMatrix ( int mat [ N ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != 0 ) return false ; return true ; } int main ( ) { int mat [ N ] [ N ] = { { 1 , 0 , 0 , 0 } , { 1 , 4 , 0 , 0 } , { 4 , 6 , 2 , 0 } , { 0 , 4 , 7 , 6 } } ; if ( isLowerTriangularMatrix ( mat ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "text_ms": "Program untuk memeriksa sama ada matriks adalah segitiga yang lebih rendah | Program untuk memeriksa matriks segi tiga yang lebih rendah. ; Fungsi untuk memeriksa matriks adalah dalam bentuk segi tiga yang lebih rendah atau tidak. ; Fungsi pemacu. ; Panggilan fungsi"}
{"text": "Program to check if matrix is upper triangular | Program to check upper triangular matrix . ; Function to check matrix is in upper triangular form or not . ; Driver function .", "code": "#include <bits/stdc++.h> NEW_LINE #define N  4 NEW_LINE using namespace std ; bool isUpperTriangularMatrix ( int mat [ N ] [ N ] ) { for ( int i = 1 ; i < N ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( mat [ i ] [ j ] != 0 ) return false ; return true ; } int main ( ) { int mat [ N ] [ N ] = { { 1 , 3 , 5 , 3 } , { 0 , 4 , 6 , 2 } , { 0 , 0 , 2 , 5 } , { 0 , 0 , 0 , 6 } } ; if ( isUpperTriangularMatrix ( mat ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "text_ms": "Program untuk memeriksa sama ada matriks adalah segitiga atas | Program untuk memeriksa matriks segi tiga atas. ; Fungsi untuk memeriksa matriks adalah dalam bentuk segi tiga atas atau tidak. ; Fungsi pemacu."}
{"text": "Counting sets of 1 s and 0 s in a binary matrix | CPP program to compute number of sets in a binary matrix . ; no of columns ; no of rows ; function to calculate the number of non empty sets of cell ; stores the final answer ; traverses row - wise ; traverses column wise ; at the end subtract n * m as no of single sets have been added twice . ; driver program to test the above function .", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int m = 3 ; const int n = 2 ; long long countSets ( int a [ n ] [ m ] ) { long long res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int u = 0 , v = 0 ; for ( int j = 0 ; j < m ; j ++ ) a [ i ] [ j ] ? u ++ : v ++ ; res += pow ( 2 , u ) - 1 + pow ( 2 , v ) - 1 ; } for ( int i = 0 ; i < m ; i ++ ) { int u = 0 , v = 0 ; for ( int j = 0 ; j < n ; j ++ ) a [ j ] [ i ] ? u ++ : v ++ ; res += pow ( 2 , u ) - 1 + pow ( 2 , v ) - 1 ; } return res - ( n * m ) ; } int main ( ) { int a [ ] [ 3 ] = { ( 1 , 0 , 1 ) , ( 0 , 1 , 0 ) } ; cout << countSets ( a ) ; return 0 ; }", "text_ms": "Mengira set 1 s dan 0 s dalam matriks binari | Program CPP untuk mengira bilangan set dalam matriks binari. ; tiada lajur; tiada baris; berfungsi untuk mengira bilangan set sel yang tidak kosong; menyimpan jawapan terakhir; Traverses Row - Bijaksana; Traverses Column Wise; Pada akhirnya tolak n * m kerana tiada set tunggal telah ditambah dua kali. ; Program Pemandu untuk menguji fungsi di atas."}
{"text": "Program to check if a matrix is symmetric | Simple c ++ code for check a matrix is symmetric or not . ; Fills transpose of mat [ N ] [ N ] in tr [ N ] [ N ] ; Returns true if mat [ N ] [ N ] is symmetric , else false ; Driver code", "code": "#include <iostream> NEW_LINE using namespace std ; const int MAX = 100 ; void transpose ( int mat [ ] [ MAX ] , int tr [ ] [ MAX ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) tr [ i ] [ j ] = mat [ j ] [ i ] ; } bool isSymmetric ( int mat [ ] [ MAX ] , int N ) { int tr [ N ] [ MAX ] ; transpose ( mat , tr , N ) ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != tr [ i ] [ j ] ) return false ; return true ; } int main ( ) { int mat [ ] [ MAX ] = { { 1 , 3 , 5 } , { 3 , 2 , 4 } , { 5 , 4 , 1 } } ; if ( isSymmetric ( mat , 3 ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "text_ms": "Program untuk memeriksa sama ada matriks adalah simetri | Kod C ++ mudah untuk memeriksa matriks adalah simetri atau tidak. ; Mengisi transpose mat [n] [n] dalam tr [n] [n]; Pulangan benar jika Mat [n] [n] adalah simetri, lain -lain palsu; Kod pemacu"}
{"text": "Program to check if a matrix is symmetric | Efficient c ++ code for check a matrix is symmetric or not . ; Returns true if mat [ N ] [ N ] is symmetric , else false ; Driver code", "code": "#include <iostream> NEW_LINE using namespace std ; const int MAX = 100 ; bool isSymmetric ( int mat [ ] [ MAX ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) return false ; return true ; } int main ( ) { int mat [ ] [ MAX ] = { { 1 , 3 , 5 } , { 3 , 2 , 4 } , { 5 , 4 , 1 } } ; if ( isSymmetric ( mat , 3 ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "text_ms": "Program untuk memeriksa sama ada matriks adalah simetri | Kod C ++ yang cekap untuk memeriksa matriks adalah simetri atau tidak. ; Pulangan benar jika Mat [n] [n] adalah simetri, lain -lain palsu; Kod pemacu"}
{"text": "Program to find Normal and Trace of a matrix | C ++ program to find trace and normal of given matrix ; Size of given matrix ; Returns Normal of a matrix of size n x n ; Returns trace of a matrix of size n x n ; Driven source", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; int findNormal ( int mat [ ] [ MAX ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) sum += mat [ i ] [ j ] * mat [ i ] [ j ] ; return sqrt ( sum ) ; } int findTrace ( int mat [ ] [ MAX ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += mat [ i ] [ i ] ; return sum ; } int main ( ) { int mat [ ] [ MAX ] = { { 1 , 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 , 4 } , { 5 , 5 , 5 , 5 , 5 } , } ; cout << \" Trace ▁ of ▁ Matrix ▁ = ▁ \" << findTrace ( mat , 5 ) << endl ; cout << \" Normal ▁ of ▁ Matrix ▁ = ▁ \" << findNormal ( mat , 5 ) << endl ; return 0 ; }", "text_ms": "Program untuk mencari normal dan jejak matriks | Program C ++ untuk mencari jejak dan normal matriks yang diberikan; Saiz matriks yang diberikan; Pulangan normal matriks saiz n x n; Mengembalikan jejak matriks saiz n x n; Sumber yang didorong"}
{"text": "Maximum determinant of a matrix with every values either 0 or n | C ++ program to find maximum possible determinant of 0 / n matrix . ; Function for maximum determinant ; Function to print resulatant matrix ; three position where 0 appears ; position where n appears ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxDet ( int n ) { return ( 2 * n * n * n ) ; } void resMatrix ( int n ) { for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { if ( i == 0 && j == 2 ) cout << \"0 ▁ \" ; else if ( i == 1 && j == 0 ) cout << \"0 ▁ \" ; else if ( i == 2 && j == 1 ) cout << \"0 ▁ \" ; else cout << n << \" ▁ \" ; } cout << \" STRNEWLINE \" ; } } int main ( ) { int n = 15 ; cout << \" Maximum ▁ Determinant ▁ = ▁ \" << maxDet ( n ) ; cout << \" Resultant Matrix : \" resMatrix ( n ) ; return 0 ; }", "text_ms": "Penentu maksimum matriks dengan setiap nilai sama ada 0 atau n | Program C ++ untuk mencari penentu maksimum mungkin 0 / N matriks. ; Fungsi untuk penentu maksimum; Berfungsi untuk mencetak matriks resulatant; tiga kedudukan di mana 0 muncul; kedudukan di mana n muncul; Kod pemacu"}
{"text": "Count Negative Numbers in a Column | CPP implementation of Naive method to count of negative numbers in M [ n ] [ m ] ; Follow the path shown using arrows above ; no more negative numbers in this row ; Driver program to test above functions", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countNegative ( int M [ ] [ 4 ] , int n , int m ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( M [ i ] [ j ] < 0 ) count += 1 ; else break ; } } return count ; } int main ( ) { int M [ 3 ] [ 4 ] = { { -3 , -2 , -1 , 1 } , { -2 , 2 , 3 , 4 } , { 4 , 5 , 7 , 8 } } ; cout << countNegative ( M , 3 , 4 ) ; return 0 ; }", "text_ms": "Kira nombor negatif dalam lajur | Pelaksanaan CPP kaedah naif untuk mengira nombor negatif dalam m [n] [m]; Ikuti jalan yang ditunjukkan menggunakan anak panah di atas; Tiada nombor negatif dalam baris ini; Program pemacu untuk menguji fungsi di atas"}
{"text": "Count Negative Numbers in a Column | CPP implementation of Efficient method to count of negative numbers in M [ n ] [ m ] ; Function to count negative number ; initialize result ; Start with top right corner ; Follow the path shown using arrows above ; j is the index of the last negative number in this row . So there must be ( j + 1 ) ; negative numbers in this row . ; move to the left and see if we can find a negative number there ; Driver program to test above functions", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countNegative ( int M [ ] [ 4 ] , int n , int m ) { int count = 0 ; int i = 0 ; int j = m - 1 ; while ( j >= 0 && i < n ) { if ( M [ i ] [ j ] < 0 ) { count += j + 1 ; i += 1 ; } else j -= 1 ; } return count ; } int main ( ) { int M [ 3 ] [ 4 ] = { { -3 , -2 , -1 , 1 } , { -2 , 2 , 3 , 4 } , { 4 , 5 , 7 , 8 } } ; cout << countNegative ( M , 3 , 4 ) ; return 0 ; }", "text_ms": "Kira nombor negatif dalam lajur | Pelaksanaan CPP kaedah yang cekap untuk mengira nombor negatif dalam m [n] [m]; Berfungsi untuk mengira nombor negatif; memulakan hasil; Mulakan dengan sudut kanan atas; Ikuti jalan yang ditunjukkan menggunakan anak panah di atas; J ialah indeks nombor negatif terakhir dalam baris ini. Jadi mesti ada (j + 1); Nombor negatif dalam baris ini. ; Pindah ke kiri dan lihat jika kita dapat mencari nombor negatif di sana; Program pemacu untuk menguji fungsi di atas"}
{"text": "Count Negative Numbers in a Column | C ++ implementation of More efficient method to count number of negative numbers in row - column sorted matrix M [ n ] [ m ] ; Recursive binary search to get last negative value in a row between a start and an end ; Base case ; Get the mid for binary search ; If current element is negative ; If it is the rightmost negative element in the current row ; Check in the right half of the array ; Check in the left half of the array ; Function to return the count of negative numbers in the given matrix ; Initialize result ; To store the index of the rightmost negative element in the row under consideration ; Iterate over all rows of the matrix ; If the first element of the current row is positive then there will be no negatives in the matrix below or after it ; Run binary search only until the index of last negative Integer in the above row ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int getLastNegativeIndex ( int array [ ] , int start , int end , int n ) { if ( start == end ) { return start ; } int mid = start + ( end - start ) / 2 ; if ( array [ mid ] < 0 ) { if ( mid + 1 < n && array [ mid + 1 ] >= 0 ) { return mid ; } return getLastNegativeIndex ( array , mid + 1 , end , n ) ; } else { return getLastNegativeIndex ( array , start , mid - 1 , n ) ; } } int countNegative ( int M [ ] [ 4 ] , int n , int m ) { int count = 0 ; int nextEnd = m - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( M [ i ] [ 0 ] >= 0 ) { break ; } nextEnd = getLastNegativeIndex ( M [ i ] , 0 , nextEnd , 4 ) ; count += nextEnd + 1 ; } return count ; } int main ( ) { int M [ ] [ 4 ] = { { -3 , -2 , -1 , 1 } , { -2 , 2 , 3 , 4 } , { 4 , 5 , 7 , 8 } } ; int r = 3 ; int c = 4 ; cout << ( countNegative ( M , r , c ) ) ; return 0 ; }", "text_ms": "Kira nombor negatif dalam lajur | C ++ pelaksanaan kaedah yang lebih efisien untuk mengira bilangan nombor negatif dalam baris - matriks disusun lajur m [n] [m]; Carian binari rekursif untuk mendapatkan nilai negatif terakhir berturut -turut antara permulaan dan akhir; Kes asas; Dapatkan pertengahan untuk carian binari; Jika elemen semasa adalah negatif; Jika ia adalah elemen negatif paling kanan dalam baris semasa; Semak separuh kanan array; Semak di separuh kiri array; Fungsi untuk mengembalikan kiraan nombor negatif dalam matriks yang diberikan; Memulakan hasil; Untuk menyimpan indeks elemen negatif paling kanan dalam baris yang dipertimbangkan; Melangkah ke atas semua baris matriks; Jika elemen pertama baris semasa adalah positif maka tidak akan ada negatif dalam matriks di bawah atau selepas itu; Jalankan carian binari hanya sehingga indeks integer negatif terakhir dalam baris di atas; Kod pemacu"}
{"text": "Find a specific pair in Matrix | A Naive method to find maximum value of mat [ d ] [ e ] - ma [ a ] [ b ] such that d > a and e > b ; The function returns maximum value A ( d , e ) - A ( a , b ) over all choices of indexes such that both d > a and e > b . ; stores maximum value ; Consider all possible pairs mat [ a ] [ b ] and mat [ d ] [ e ] ; Driver program to test above function", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  5 NEW_LINE int findMaxValue ( int mat [ ] [ N ] ) { int maxValue = INT_MIN ; for ( int a = 0 ; a < N - 1 ; a ++ ) for ( int b = 0 ; b < N - 1 ; b ++ ) for ( int d = a + 1 ; d < N ; d ++ ) for ( int e = b + 1 ; e < N ; e ++ ) if ( maxValue < ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ) maxValue = mat [ d ] [ e ] - mat [ a ] [ b ] ; return maxValue ; } int main ( ) { int mat [ N ] [ N ] = { { 1 , 2 , -1 , -4 , -20 } , { -8 , -3 , 4 , 2 , 1 } , { 3 , 8 , 6 , 1 , 3 } , { -4 , -1 , 1 , 7 , -6 } , { 0 , -4 , 10 , -5 , 1 } } ; cout << \" Maximum ▁ Value ▁ is ▁ \" << findMaxValue ( mat ) ; return 0 ; }", "text_ms": "Cari pasangan tertentu dalam Matrix | Kaedah naif untuk mencari nilai maksimum MAT [d] [e] - ma [a] [b] seperti d> a dan e> b; Fungsi ini mengembalikan nilai maksimum a (d, e) - a (a, b) atas semua pilihan indeks sedemikian rupa sehingga kedua -dua d> a dan e> b. ; Kedai nilai maksimum; Pertimbangkan semua kemungkinan pasangan tikar [a] [b] dan mat [d] [e]; Program pemacu untuk menguji fungsi di atas"}
{"text": "Find a specific pair in Matrix | An efficient method to find maximum value of mat [ d ] - ma [ a ] [ b ] such that c > a and d > b ; The function returns maximum value A ( c , d ) - A ( a , b ) over all choices of indexes such that both c > a and d > b . ; stores maximum value ; maxArr [ i ] [ j ] stores max of elements in matrix from ( i , j ) to ( N - 1 , N - 1 ) ; last element of maxArr will be same 's as of  the input matrix ; preprocess last row Initialize max ; preprocess last column Initialize max ; preprocess rest of the matrix from bottom ; Update maxValue ; set maxArr ( i , j ) ; Driver program to test above function", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  5 NEW_LINE int findMaxValue ( int mat [ ] [ N ] ) { int maxValue = INT_MIN ; int maxArr [ N ] [ N ] ; maxArr [ N - 1 ] [ N - 1 ] = mat [ N - 1 ] [ N - 1 ] ; int maxv = mat [ N - 1 ] [ N - 1 ] ; for ( int j = N - 2 ; j >= 0 ; j -- ) { if ( mat [ N - 1 ] [ j ] > maxv ) maxv = mat [ N - 1 ] [ j ] ; maxArr [ N - 1 ] [ j ] = maxv ; } maxv = mat [ N - 1 ] [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( mat [ i ] [ N - 1 ] > maxv ) maxv = mat [ i ] [ N - 1 ] ; maxArr [ i ] [ N - 1 ] = maxv ; } for ( int i = N - 2 ; i >= 0 ; i -- ) { for ( int j = N - 2 ; j >= 0 ; j -- ) { if ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > maxValue ) maxValue = maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] ; maxArr [ i ] [ j ] = max ( mat [ i ] [ j ] , max ( maxArr [ i ] [ j + 1 ] , maxArr [ i + 1 ] [ j ] ) ) ; } } return maxValue ; } int main ( ) { int mat [ N ] [ N ] = { { 1 , 2 , -1 , -4 , -20 } , { -8 , -3 , 4 , 2 , 1 } , { 3 , 8 , 6 , 1 , 3 } , { -4 , -1 , 1 , 7 , -6 } , { 0 , -4 , 10 , -5 , 1 } } ; cout << \" Maximum ▁ Value ▁ is ▁ \" << findMaxValue ( mat ) ; return 0 ; }", "text_ms": "Cari pasangan tertentu dalam Matrix | Kaedah yang cekap untuk mencari nilai maksimum MAT [d] - ma [a] [b] sedemikian rupa sehingga c> a dan d> b; Fungsi ini mengembalikan nilai maksimum a (c, d) - a (a, b) atas semua pilihan indeks sedemikian rupa sehingga kedua -dua c> a dan d> b. ; Kedai nilai maksimum; maxarr [i] [j] menyimpan max unsur -unsur dalam matriks dari (i, j) hingga (n - 1, n - 1); Elemen terakhir Maxarr akan menjadi sama seperti matriks input; Preprocess Last Row Inisialisasi Max; preprocess lajur terakhir memulakan max; PREPROCESS ROST OF MATRIX DARI BAWAH; Kemas kini MaxValue; Tetapkan Maxarr (i, j); Program pemacu untuk menguji fungsi di atas"}
{"text": "Print all elements in sorted order from row and column wise sorted matrix | A C ++ program to Print all elements in sorted order from row and column wise sorted matrix ; A utility function to youngify a Young Tableau . This is different from standard youngify . It assumes that the value at mat [ 0 ] [ 0 ] is infinite . ; Find the values at down and right sides of mat [ i ] [ j ] ; If mat [ i ] [ j ] is the down right corner element , return ; Move the smaller of two values ( downVal and rightVal ) to mat [ i ] [ j ] and recur for smaller value ; A utility function to extract minimum element from Young tableau ; This function uses extractMin ( ) to print elements in sorted order ; driver program to test above function", "code": "#include <iostream> NEW_LINE #include <climits> NEW_LINE using namespace std ; #define INF  INT_MAX NEW_LINE #define N  4 NEW_LINE void youngify ( int mat [ ] [ N ] , int i , int j ) { int downVal = ( i + 1 < N ) ? mat [ i + 1 ] [ j ] : INF ; int rightVal = ( j + 1 < N ) ? mat [ i ] [ j + 1 ] : INF ; if ( downVal == INF && rightVal == INF ) return ; if ( downVal < rightVal ) { mat [ i ] [ j ] = downVal ; mat [ i + 1 ] [ j ] = INF ; youngify ( mat , i + 1 , j ) ; } else { mat [ i ] [ j ] = rightVal ; mat [ i ] [ j + 1 ] = INF ; youngify ( mat , i , j + 1 ) ; } } int extractMin ( int mat [ ] [ N ] ) { int ret = mat [ 0 ] [ 0 ] ; mat [ 0 ] [ 0 ] = INF ; youngify ( mat , 0 , 0 ) ; return ret ; } void printSorted ( int mat [ ] [ N ] ) { cout << \" Elements ▁ of ▁ matrix ▁ in ▁ sorted ▁ order ▁ n \" ; for ( int i = 0 ; i < N * N ; i ++ ) cout << extractMin ( mat ) << \" ▁ \" ; } int main ( ) { int mat [ N ] [ N ] = { { 10 , 20 , 30 , 40 } , { 15 , 25 , 35 , 45 } , { 27 , 29 , 37 , 48 } , { 32 , 33 , 39 , 50 } , } ; printSorted ( mat ) ; return 0 ; }", "text_ms": "Cetak semua elemen dalam susunan yang disusun dari baris dan lajur yang bijak matriks disusun | Program C ++ untuk mencetak semua elemen dalam susunan yang disusun dari baris dan lajur yang disusun dengan bijak; Fungsi utiliti untuk Youngify meja muda. Ini berbeza dengan Standard Youngify. Ia mengandaikan bahawa nilai pada MAT [0] [0] adalah tak terhingga. ; Cari nilai -nilai di bawah dan kanan tikar [i] [j]; Jika tikar [i] [j] adalah elemen sudut kanan, kembali; Gerakkan lebih kecil daripada dua nilai (downval dan rightval) ke tikar [i] [j] dan berulang untuk nilai yang lebih kecil; Fungsi utiliti untuk mengekstrak elemen minimum dari Tableau muda; Fungsi ini menggunakan ExtractMin () untuk mencetak elemen dalam urutan yang disusun; program pemacu untuk menguji fungsi di atas"}
{"text": "Given an n x n square matrix , find sum of all sub | A simple C ++ program to find sum of all subsquares of size k x k ; Size of given matrix ; A simple function to find sum of all sub - squares of size k x k in a given square matrix of size n x n ; k must be smaller than or equal to n ; row number of first cell in current sub - square of size k x k ; column of first cell in current sub - square of size k x k ; Calculate and print sum of current sub - square ; Line separator for sub - squares starting with next row ; Driver program to test above function", "code": "#include <iostream> NEW_LINE using namespace std ; #define n  5 NEW_LINE void printSumSimple ( int mat [ ] [ n ] , int k ) { if ( k > n ) return ; for ( int i = 0 ; i < n - k + 1 ; i ++ ) { for ( int j = 0 ; j < n - k + 1 ; j ++ ) { int sum = 0 ; for ( int p = i ; p < k + i ; p ++ ) for ( int q = j ; q < k + j ; q ++ ) sum += mat [ p ] [ q ] ; cout << sum << \" ▁ \" ; } cout << endl ; } } int main ( ) { int mat [ n ] [ n ] = { { 1 , 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 , 4 } , { 5 , 5 , 5 , 5 , 5 } , } ; int k = 3 ; printSumSimple ( mat , k ) ; return 0 ; }", "text_ms": "Memandangkan matriks n x n persegi, cari jumlah semua sub | Program C ++ yang mudah untuk mencari jumlah semua subsquares saiz k x k; Saiz matriks yang diberikan; Fungsi mudah untuk mencari jumlah semua sub -dataran saiz k x k dalam matriks persegi saiz n x n; k mestilah lebih kecil daripada atau sama dengan n; Nombor baris sel pertama dalam sub -persegi semasa saiz k x k; Lajur sel pertama dalam sub -persegi semasa saiz k x k; Hitung dan cetak jumlah sub -persegi semasa; Pemisah garis untuk sub -dataran bermula dengan baris seterusnya; Program pemacu untuk menguji fungsi di atas"}
{"text": "Given an n x n square matrix , find sum of all sub | An efficient C ++ program to find sum of all subsquares of size k x k ; Size of given matrix ; A O ( n ^ 2 ) function to find sum of all sub - squares of size k x k in a given square matrix of size n x n ; k must be smaller than or equal to n ; 1 : PREPROCESSING To store sums of all strips of size k x 1 ; Go column by column ; Calculate sum of first k x 1 rectangle in this column ; Calculate sum of remaining rectangles ; 2 : CALCULATE SUM of Sub - Squares using stripSum [ ] [ ] ; Calculate and print sum of first subsquare in this row ; Calculate sum of remaining squares in current row by removing the leftmost strip of previous sub - square and adding a new strip ; Driver program to test above function", "code": "#include <iostream> NEW_LINE using namespace std ; #define n  5 NEW_LINE void printSumTricky ( int mat [ ] [ n ] , int k ) { if ( k > n ) return ; int stripSum [ n ] [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) sum += mat [ i ] [ j ] ; stripSum [ 0 ] [ j ] = sum ; for ( int i = 1 ; i < n - k + 1 ; i ++ ) { sum += ( mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] ) ; stripSum [ i ] [ j ] = sum ; } } for ( int i = 0 ; i < n - k + 1 ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < k ; j ++ ) sum += stripSum [ i ] [ j ] ; cout << sum << \" ▁ \" ; for ( int j = 1 ; j < n - k + 1 ; j ++ ) { sum += ( stripSum [ i ] [ j + k - 1 ] - stripSum [ i ] [ j - 1 ] ) ; cout << sum << \" ▁ \" ; } cout << endl ; } } int main ( ) { int mat [ n ] [ n ] = { { 1 , 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 , 4 } , { 5 , 5 , 5 , 5 , 5 } , } ; int k = 3 ; printSumTricky ( mat , k ) ; return 0 ; }", "text_ms": "Memandangkan matriks n x n persegi, cari jumlah semua sub | Program C ++ yang cekap untuk mencari jumlah semua subsquares saiz k x k; Saiz matriks yang diberikan; A o (n ^ 2) berfungsi untuk mencari jumlah semua sub -dataran saiz k x k dalam matriks persegi yang diberikan saiz n x n; k mestilah lebih kecil daripada atau sama dengan n; 1: Preprocessing untuk menyimpan jumlah semua jalur saiz k x 1; Pergi lajur mengikut lajur; Hitung jumlah pertama K x 1 segi empat tepat dalam lajur ini; Hitung jumlah segi empat tepat; 2: Kirakan jumlah sub - dataran menggunakan stripsum [] []; Hitung dan cetak jumlah Subsquare Pertama dalam baris ini; Kirakan jumlah kuadrat yang tinggal dalam baris semasa dengan mengeluarkan jalur paling kiri sub -persegi sebelumnya dan menambah jalur baru; Program pemacu untuk menguji fungsi di atas"}
{"text": "Program to find transpose of a matrix |  ; This function stores transpose of A [ ] [ ] in B [ ] [ ] ; Driver code", "code": "#include <stdio.h> NEW_LINE #define M  3 NEW_LINE #define N  4 NEW_LINE void transpose ( int A [ ] [ N ] , int B [ ] [ M ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < M ; j ++ ) B [ i ] [ j ] = A [ j ] [ i ] ; } int main ( ) { int A [ M ] [ N ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } } ; int B [ N ] [ M ] , i , j ; transpose ( A , B ) ; printf ( \" Result ▁ matrix ▁ is ▁ STRNEWLINE \" ) ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < M ; j ++ ) printf ( \" % d ▁ \" , B [ i ] [ j ] ) ; printf ( \" STRNEWLINE \" ) ; } return 0 ; }", "text_ms": "Program untuk mencari transpose matriks |  ; Fungsi ini menyimpan transpose a [] [] dalam b [] []; Kod pemacu"}
{"text": "Program to find transpose of a matrix |  ; Converts A [ ] [ ] to its transpose ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  4 NEW_LINE void transpose ( int A [ ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) swap ( A [ i ] [ j ] , A [ j ] [ i ] ) ; } int main ( ) { int A [ N ] [ N ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; transpose ( A ) ; printf ( \" Modified ▁ matrix ▁ is ▁ STRNEWLINE \" ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) printf ( \" % d ▁ \" , A [ i ] [ j ] ) ; printf ( \" STRNEWLINE \" ) ; } return 0 ; }", "text_ms": "Program untuk mencari transpose matriks |  ; Menukarkan [] [] ke transposinya; Kod pemacu"}
{"text": "Number of paths with exactly k coins | A Naive Recursive C ++ program to count paths with exactly ' k ' coins ; Recursive function to count paths with sum k from ( 0 , 0 ) to ( m , n ) ; Base cases ; ( m , n ) can be reached either through ( m - 1 , n ) or through ( m , n - 1 ) ; A wrapper over pathCountRec ( ) ; Driver program", "code": "#include <bits/stdc++.h> NEW_LINE #define R  3 NEW_LINE #define C  3 NEW_LINE using namespace std ; int pathCountRec ( int mat [ ] [ C ] , int m , int n , int k ) { if ( m < 0 n < 0 ) return 0 ; if ( m == 0 && n == 0 ) return ( k == mat [ m ] [ n ] ) ; return pathCountRec ( mat , m - 1 , n , k - mat [ m ] [ n ] ) + pathCountRec ( mat , m , n - 1 , k - mat [ m ] [ n ] ) ; } int pathCount ( int mat [ ] [ C ] , int k ) { return pathCountRec ( mat , R - 1 , C - 1 , k ) ; } int main ( ) { int k = 12 ; int mat [ R ] [ C ] = { { 1 , 2 , 3 } , { 4 , 6 , 5 } , { 3 , 2 , 1 } } ; cout << pathCount ( mat , k ) ; return 0 ; }", "text_ms": "Bilangan Jalan dengan Koin Kata Tepat | Program C ++ rekursif naif untuk mengira laluan dengan duit syiling 'k' yang tepat; Fungsi rekursif untuk mengira laluan dengan jumlah k dari (0, 0) hingga (m, n); Kes asas; (m, n) boleh dicapai sama ada melalui (m - 1, n) atau melalui (m, n - 1); Pembungkus ke atas PathCountrec (); Program Pemandu"}
{"text": "Number of paths with exactly k coins | A Dynamic Programming based C ++ program to count paths with exactly ' k ' coins ; Base cases ; If this subproblem is already solved ; ( m , n ) can be reached either through ( m - 1 , n ) or through ( m , n - 1 ) ; This function mainly initializes dp [ ] [ ] [ ] and calls pathCountDPRecDP ( ) ; Driver Program to test above functions", "code": "#include <bits/stdc++.h> NEW_LINE #define R  3 NEW_LINE #define C  3 NEW_LINE #define MAX_K  1000 NEW_LINE using namespace std ; int dp [ R ] [ C ] [ MAX_K ] ; int pathCountDPRecDP ( int mat [ ] [ C ] , int m , int n , int k ) { if ( m < 0 n < 0 ) return 0 ; if ( m == 0 && n == 0 ) return ( k == mat [ m ] [ n ] ) ; if ( dp [ m ] [ n ] [ k ] != -1 ) return dp [ m ] [ n ] [ k ] ; dp [ m ] [ n ] [ k ] = pathCountDPRecDP ( mat , m - 1 , n , k - mat [ m ] [ n ] ) + pathCountDPRecDP ( mat , m , n - 1 , k - mat [ m ] [ n ] ) ; return dp [ m ] [ n ] [ k ] ; } int pathCountDP ( int mat [ ] [ C ] , int k ) { memset ( dp , -1 , sizeof dp ) ; return pathCountDPRecDP ( mat , R - 1 , C - 1 , k ) ; } int main ( ) { int k = 12 ; int mat [ R ] [ C ] = { { 1 , 2 , 3 } , { 4 , 6 , 5 } , { 3 , 2 , 1 } } ; cout << pathCountDP ( mat , k ) ; return 0 ; }", "text_ms": "Bilangan Jalan dengan Koin Kata Tepat | Program C ++ berasaskan pengaturcaraan yang dinamik untuk mengira laluan dengan duit syiling 'k' yang tepat; Kes asas; Jika subproblem ini sudah diselesaikan; (m, n) boleh dicapai sama ada melalui (m - 1, n) atau melalui (m, n - 1); Fungsi ini terutamanya memulakan dp [] [] [] dan memanggil PathCountDPrecdp (); Program pemacu untuk menguji fungsi di atas"}
{"text": "Sort the given matrix | C ++ implementation to sort the given matrix ; function to sort the given matrix ; temporary matrix of size n ^ 2 ; copy the elements of matrix one by one into temp [ ] ; sort temp [ ] ; copy the elements of temp [ ] one by one in mat [ ] [ ] ; function to print the given matrix ; Driver program to test above", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define SIZE  10 NEW_LINE void sortMat ( int mat [ SIZE ] [ SIZE ] , int n ) { int temp [ n * n ] ; int k = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) temp [ k ++ ] = mat [ i ] [ j ] ; sort ( temp , temp + k ) ; k = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) mat [ i ] [ j ] = temp [ k ++ ] ; } void printMat ( int mat [ SIZE ] [ SIZE ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) cout << mat [ i ] [ j ] << \" ▁ \" ; cout << endl ; } } int main ( ) { int mat [ SIZE ] [ SIZE ] = { { 5 , 4 , 7 } , { 1 , 3 , 8 } , { 2 , 9 , 6 } } ; int n = 3 ; cout << \" Original ▁ Matrix : STRNEWLINE \" ; printMat ( mat , n ) ; sortMat ( mat , n ) ; cout << \" Matrix After Sorting : \" ; printMat ( mat , n ) ; return 0 ; }", "text_ms": "Susun Matriks yang Diberikan | C ++ pelaksanaan untuk menyusun matriks yang diberikan; berfungsi untuk menyusun matriks yang diberikan; matriks sementara saiz n ^ 2; Salin unsur -unsur matriks satu demi satu ke temp []; Susun temp []; Salin unsur -unsur temp [] satu demi satu dalam tikar [] []; berfungsi untuk mencetak matriks yang diberikan; Program Pemandu untuk diuji di atas"}
{"text": "Selection Sort | C ++ program for implementation of selection sort ; swap function ; sort function ; One by one move boundary of unsorted subarray ; Find the minimum element in unsorted array ; Swap the found minimum element with the first element ; Function to print an array ; Driver program to test above functions", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void swap ( int * xp , int * yp ) { int temp = * xp ; * xp = * yp ; * yp = temp ; } void selectionSort ( int arr [ ] , int n ) { int i , j , min_idx ; for ( i = 0 ; i < n - 1 ; i ++ ) { min_idx = i ; for ( j = i + 1 ; j < n ; j ++ ) if ( arr [ j ] < arr [ min_idx ] ) min_idx = j ; swap ( & arr [ min_idx ] , & arr [ i ] ) ; } } void printArray ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) cout << arr [ i ] << \" ▁ \" ; cout << endl ; } int main ( ) { int arr [ ] = { 64 , 25 , 12 , 22 , 11 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; selectionSort ( arr , n ) ; cout << \" Sorted ▁ array : ▁ STRNEWLINE \" ; printArray ( arr , n ) ; return 0 ; }", "text_ms": "Pemilihan jenis | Program C ++ untuk pelaksanaan pilihan pemilihan; fungsi swap; Susun fungsi; Satu demi satu langkah sempadan subarray yang tidak disusun; Cari elemen minimum dalam array yang tidak disusun; Tukar elemen minimum yang dijumpai dengan elemen pertama; Berfungsi untuk mencetak array; Program pemacu untuk menguji fungsi di atas"}
{"text": "Bubble Sort | Optimized implementation of Bubble sort ; An optimized version of Bubble Sort ; swap arr [ j ] and arr [ j + 1 ] ; IF no two elements were swapped by inner loop , then break ; Function to print an array ; Driver program to test above functions", "code": "#include <stdio.h> NEW_LINE void swap ( int * xp , int * yp ) { int temp = * xp ; * xp = * yp ; * yp = temp ; } void bubbleSort ( int arr [ ] , int n ) { int i , j ; bool swapped ; for ( i = 0 ; i < n - 1 ; i ++ ) { swapped = false ; for ( j = 0 ; j < n - i - 1 ; j ++ ) { if ( arr [ j ] > arr [ j + 1 ] ) { swap ( & arr [ j ] , & arr [ j + 1 ] ) ; swapped = true ; } } if ( swapped == false ) break ; } } void printArray ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) printf ( \" % d ▁ \" , arr [ i ] ) ; printf ( \" n \" ) ; } int main ( ) { int arr [ ] = { 64 , 34 , 25 , 12 , 22 , 11 , 90 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; bubbleSort ( arr , n ) ; printf ( \" Sorted ▁ array : ▁ STRNEWLINE \" ) ; printArray ( arr , n ) ; return 0 ; }", "text_ms": "Bubble sort | Pelaksanaan yang dioptimumkan dari Bubble Sort; Versi bubble yang dioptimumkan; swap arr [j] dan arr [j + 1]; Jika tidak ada dua elemen yang ditukar dengan gelung dalaman, kemudian pecah; Berfungsi untuk mencetak array; Program pemacu untuk menguji fungsi di atas"}
{"text": "Find k closest elements to a given value |  ; Function to find the cross over point ( the point beforewhich elements are smaller than or equal to x and afterwhich greater than x ) ; Base cases x is greater than all ; x is smaller than all ; Find the middle point ; If x is same as middle element , then return mid ; If x is greater than arr [ mid ] , then either arr [ mid + 1 ] is ceiling of x or ceiling lies in arr [ mid + 1. . . high ] ; This function prints k closest elements to x in arr [ ] . n is the number of elements in arr [ ] ; Find the crossover point ; Right index to search ; To keep track of count of elements already printed ; If x is present in arr [ ] , then reduce left index Assumption : all elements in arr [ ] are distinct ; Compare elements on left and right of crossover point to find the k closest elements ; If there are no more elements on right side , then print left elements ; If there are no more elements on left side , then print right elements ; Driver program to check above functions", "code": "#include <stdio.h> NEW_LINE int findCrossOver ( int arr [ ] , int low , int high , int x ) { if ( arr [ high ] <= x ) return high ; if ( arr [ low ] > x ) return low ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] <= x && arr [ mid + 1 ] > x ) return mid ; if ( arr [ mid ] < x ) return findCrossOver ( arr , mid + 1 , high , x ) ; return findCrossOver ( arr , low , mid - 1 , x ) ; } void printKclosest ( int arr [ ] , int x , int k , int n ) { int l = findCrossOver ( arr , 0 , n - 1 , x ) ; int r = l + 1 ; int count = 0 ; if ( arr [ l ] == x ) l -- ; while ( l >= 0 && r < n && count < k ) { if ( x - arr [ l ] < arr [ r ] - x ) printf ( \" % d ▁ \" , arr [ l -- ] ) ; else printf ( \" % d ▁ \" , arr [ r ++ ] ) ; count ++ ; } while ( count < k && l >= 0 ) printf ( \" % d ▁ \" , arr [ l -- ] ) , count ++ ; while ( count < k && r < n ) printf ( \" % d ▁ \" , arr [ r ++ ] ) , count ++ ; } int main ( ) { int arr [ ] = { 12 , 16 , 22 , 30 , 35 , 39 , 42 , 45 , 48 , 50 , 53 , 55 , 56 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 35 , k = 4 ; printKclosest ( arr , x , 4 , n ) ; return 0 ; }", "text_ms": "Cari K Elemen yang paling dekat dengan nilai yang diberikan |  ; Fungsi untuk mencari titik silang (titik sebelum ini adalah lebih kecil daripada atau sama dengan x dan selepas itu lebih besar daripada x); Kes asas X lebih besar daripada semua; X lebih kecil daripada semua; Cari titik tengah; Jika x sama dengan elemen tengah, maka kembali pertengahan; Jika x lebih besar daripada arr [pertengahan], maka sama ada arr [pertengahan + 1] adalah siling x atau siling terletak pada arr [pertengahan + 1. . tinggi]; Fungsi ini mencetak elemen yang paling dekat dengan x dalam arr []. n ialah bilangan elemen dalam arr []; Cari titik crossover; Indeks yang betul untuk mencari; Untuk menjejaki kiraan elemen yang telah dicetak; Jika x hadir dalam arr [], maka mengurangkan asumsi indeks kiri: semua elemen dalam arr [] adalah berbeza; Bandingkan unsur -unsur di kiri dan kanan titik crossover untuk mencari unsur -unsur yang paling dekat; Jika tidak ada lagi elemen di sebelah kanan, maka cetak elemen kiri; Sekiranya tidak ada lagi elemen di sebelah kiri, maka cetak elemen kanan; Program pemacu untuk menyemak fungsi di atas"}
{"text": "Coin Change | DP | Recursive C program for coin change problem . ; Returns the count of ways we can sum S [ 0. . . m - 1 ] coins to get sum n ; If n is 0 then there is 1 solution ( do not include any coin ) ; If n is less than 0 then no solution exists ; If there are no coins and n is greater than 0 , then no solution exist ; count is sum of solutions ( i ) including S [ m - 1 ] ( ii ) excluding S [ m - 1 ] ; Driver program to test above function", "code": "#include <stdio.h> NEW_LINE int count ( int S [ ] , int m , int n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 0 ; if ( m <= 0 && n >= 1 ) return 0 ; return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; } int main ( ) { int i , j ; int arr [ ] = { 1 , 2 , 3 } ; int m = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" % d ▁ \" , count ( arr , m , 4 ) ) ; getchar ( ) ; return 0 ; }", "text_ms": "Perubahan duit syiling | DP | Program C Rekursif untuk masalah perubahan duit syiling. ; Mengembalikan kiraan cara kita dapat jumlah s [0. . m - 1] syiling untuk mendapatkan jumlah n; Jika n adalah 0 maka terdapat 1 penyelesaian (jangan termasuk mana -mana duit syiling); Jika n kurang daripada 0 maka tiada penyelesaian wujud; Sekiranya tidak ada duit syiling dan N lebih besar daripada 0, maka tiada penyelesaian wujud; Count adalah jumlah penyelesaian (i) termasuk S [m - 1] (ii) tidak termasuk S [m - 1]; Program pemacu untuk menguji fungsi di atas"}
{"text": "Coin Change | DP | Dynamic Programming C ++ implementation of Coin Change problem ; table [ i ] will be storing the number of solutions for value i . We need n + 1 rows as the table is constructed in bottom up manner using the base case ( n = 0 ) ; Base case ( If given value is 0 ) ; Pick all coins one by one and update the table [ ] values after the index greater than or equal to the value of the picked coin", "code": "#include <bits/stdc++.h> NEW_LINE int count ( int S [ ] , int m , int n ) { int table [ n + 1 ] ; memset ( table , 0 , sizeof ( table ) ) ; table [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = S [ i ] ; j <= n ; j ++ ) table [ j ] += table [ j - S [ i ] ] ; return table [ n ] ; }", "text_ms": "Perubahan duit syiling | DP | Pengaturcaraan dinamik C ++ pelaksanaan masalah perubahan duit syiling; Jadual [i] akan menyimpan bilangan penyelesaian untuk nilai i. Kami memerlukan baris n + 1 kerana jadual dibina dengan cara bawah menggunakan kes asas (n = 0); Kes asas (jika diberi nilai adalah 0); Pilih semua duit syiling satu demi satu dan kemas kini nilai jadual [] selepas indeks lebih besar daripada atau sama dengan nilai duit syiling yang dipilih"}
{"text": "Matrix Chain Multiplication | DP | C ++ program using memoization ; Function for matrix chain multiplication ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int dp [ 100 ] [ 100 ] ; int matrixChainMemoised ( int * p , int i , int j ) { if ( i == j ) { return 0 ; } if ( dp [ i ] [ j ] != -1 ) { return dp [ i ] [ j ] ; } dp [ i ] [ j ] = INT_MAX ; for ( int k = i ; k < j ; k ++ ) { dp [ i ] [ j ] = min ( dp [ i ] [ j ] , matrixChainMemoised ( p , i , k ) + matrixChainMemoised ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) ; } return dp [ i ] [ j ] ; } int MatrixChainOrder ( int * p , int n ) { int i = 1 , j = n - 1 ; return matrixChainMemoised ( p , i , j ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; memset ( dp , -1 , sizeof dp ) ; cout << \" Minimum ▁ number ▁ of ▁ multiplications ▁ is ▁ \" << MatrixChainOrder ( arr , n ) ; }", "text_ms": "Pendaraban rantai matriks | DP | Program C ++ menggunakan memoisasi; Fungsi untuk pendaraban rantai matriks; Kod pemacu"}
{"text": "Matrix Chain Multiplication | DP | See the Cormen book for details of the following algorithm ; Matrix Ai has dimension p [ i - 1 ] x p [ i ] for i = 1. . n ; For simplicity of the program , one extra row and one extra column are allocated in m [ ] [ ] . 0 th row and 0 th column of m [ ] [ ] are not used ; cost is zero when multiplying one matrix . ; L is chain length . ; q = cost / scalar multiplications ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int MatrixChainOrder ( int p [ ] , int n ) { int m [ n ] [ n ] ; int i , j , k , L , q ; for ( i = 1 ; i < n ; i ++ ) m [ i ] [ i ] = 0 ; for ( L = 2 ; L < n ; L ++ ) { for ( i = 1 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; m [ i ] [ j ] = INT_MAX ; for ( k = i ; k <= j - 1 ; k ++ ) { q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( q < m [ i ] [ j ] ) m [ i ] [ j ] = q ; } } } return m [ 1 ] [ n - 1 ] ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << \" Minimum ▁ number ▁ of ▁ multiplications ▁ is ▁ \" << MatrixChainOrder ( arr , size ) ; getchar ( ) ; return 0 ; }", "text_ms": "Pendaraban rantai matriks | DP | Lihat buku Cormen untuk butiran algoritma berikut; Matrix AI mempunyai dimensi p [i - 1] x p [i] untuk i = 1. n; Untuk kesederhanaan program, satu baris tambahan dan satu lajur tambahan diperuntukkan dalam M [] []. 0 bar dan lajur 0 M [] [] tidak digunakan; Kos adalah sifar apabila mendarabkan satu matriks. ; L adalah panjang rantai. ; Q = Kos / skalar pendaraban; Kod pemacu"}
{"text": "Cutting a Rod | DP | A Naive recursive solution for Rod cutting problem ; A utility function to get the maximum of two integers ; Returns the best obtainable price for a rod of length n and price [ ] as prices of different pieces ; Recursively cut the rod in different pieces and compare different configurations ; Driver program to test above functions", "code": "#include <stdio.h> NEW_LINE #include <limits.h> NEW_LINE int max ( int a , int b ) { return ( a > b ) ? a : b ; } int cutRod ( int price [ ] , int n ) { if ( n <= 0 ) return 0 ; int max_val = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) max_val = max ( max_val , price [ i ] + cutRod ( price , n - i - 1 ) ) ; return max_val ; } int main ( ) { int arr [ ] = { 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Maximum ▁ Obtainable ▁ Value ▁ is ▁ % dn \" , cutRod ( arr , size ) ) ; getchar ( ) ; return 0 ; }", "text_ms": "Memotong batang | DP | Penyelesaian rekursif naif untuk masalah pemotongan rod; Fungsi utiliti untuk mendapatkan maksimum dua bilangan bulat; Mengembalikan harga terbaik yang boleh diperolehi untuk rod panjang n dan harga [] sebagai harga kepingan yang berbeza; Recursif memotong batang dalam kepingan yang berbeza dan membandingkan konfigurasi yang berbeza; Program pemacu untuk menguji fungsi di atas"}
{"text": "Cutting a Rod | DP | A Dynamic Programming solution for Rod cutting problem ; A utility function to get the maximum of two integers ; Returns the best obtainable price for a rod of length n and price [ ] as prices of different pieces ; Build the table val [ ] in bottom up manner and return the last entry from the table ; Driver program to test above functions", "code": "#include <stdio.h> NEW_LINE #include <limits.h> NEW_LINE int max ( int a , int b ) { return ( a > b ) ? a : b ; } int cutRod ( int price [ ] , int n ) { int val [ n + 1 ] ; val [ 0 ] = 0 ; int i , j ; for ( i = 1 ; i <= n ; i ++ ) { int max_val = INT_MIN ; for ( j = 0 ; j < i ; j ++ ) max_val = max ( max_val , price [ j ] + val [ i - j - 1 ] ) ; val [ i ] = max_val ; } return val [ n ] ; } int main ( ) { int arr [ ] = { 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( \" Maximum ▁ Obtainable ▁ Value ▁ is ▁ % dn \" , cutRod ( arr , size ) ) ; getchar ( ) ; return 0 ; }", "text_ms": "Memotong batang | DP | Penyelesaian pengaturcaraan dinamik untuk masalah pemotongan rod; Fungsi utiliti untuk mendapatkan maksimum dua bilangan bulat; Mengembalikan harga terbaik yang boleh diperolehi untuk rod panjang n dan harga [] sebagai harga kepingan yang berbeza; Bina jadual Val [] dengan cara bawah dan kembalikan entri terakhir dari jadual; Program pemacu untuk menguji fungsi di atas"}
{"text": "Cutting a Rod | DP | CPP program for above approach ; Global Array for the purpose of memoization . ; A recursive program , using , memoization , to implement the rod cutting problem ( Top - Down ) . ; The maximum price will be zero , when either the length of the rod is zero or price is zero . ; If the length of the rod is less than the maximum length , Max_lene will consider it . Now depending upon the profit , either Max_lene we will take it or discard it . ; If the length of the rod is greater than the permitted size , Max_len we will not consider it . ; Max_lene Max_lenill return the maximum value obtained , Max_lenhich is present at the nth roMax_len and Max_lenth column . ; Driver program to test above functions ; Function Call", "code": "#include <iostream> NEW_LINE using namespace std ; int t [ 9 ] [ 9 ] ; int un_kp ( int price [ ] , int length [ ] , int Max_len , int n ) { if ( n == 0 Max_len == 0 ) { return 0 ; } if ( length [ n - 1 ] <= Max_len ) { t [ n ] [ Max_len ] = max ( price [ n - 1 ] + un_kp ( price , length , Max_len - length [ n - 1 ] , n ) , un_kp ( price , length , Max_len , n - 1 ) ) ; } else { t [ n ] [ Max_len ] = un_kp ( price , length , Max_len , n - 1 ) ; } return t [ n ] [ Max_len ] ; } int main ( ) { int price [ ] = { 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 } ; int n = sizeof ( price ) / sizeof ( price [ 0 ] ) ; int length [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { length [ i ] = i + 1 ; } int Max_len = n ; cout << \" Maximum ▁ obtained ▁ value ▁ is ▁ \" << un_kp ( price , length , n , Max_len ) << endl ; }", "text_ms": "Memotong batang | DP | Program CPP untuk pendekatan di atas; Arahan global untuk tujuan memoisasi. ; Program rekursif, menggunakan, memoisasi, untuk melaksanakan masalah pemotongan rod (atas - ke bawah). ; Harga maksimum akan menjadi sifar, apabila panjang rod adalah sifar atau harga adalah sifar. ; Jika panjang rod kurang daripada panjang maksimum, max_lene akan menganggapnya. Sekarang bergantung kepada keuntungan, sama ada max_lene kita akan mengambilnya atau membuangnya. ; Jika panjang rod lebih besar daripada saiz yang dibenarkan, max_len kita tidak akan menganggapnya. ; Max_lene max_lenill Kembalikan nilai maksimum yang diperoleh, max_lenhich hadir di lajur nth romax_len dan max_lenth. ; Program pemacu untuk menguji fungsi di atas; Panggilan fungsi"}
{"text": "Multiply two integers without using multiplication , division and bitwise operators , and no loops | C ++ program to Multiply two integers without using multiplication , division and bitwise operators , and no loops ; function to multiply two numbers x and y ; 0 multiplied with anything gives 0 ; Add x one by one ; the case where y is negative ; Driver code", "code": "#include <iostream> NEW_LINE using namespace std ; class GFG { public : int multiply ( int x , int y ) { if ( y == 0 ) return 0 ; if ( y > 0 ) return ( x + multiply ( x , y - 1 ) ) ; if ( y < 0 ) return - multiply ( x , - y ) ; } } ; int main ( ) { GFG g ; cout << endl << g . multiply ( 5 , -11 ) ; getchar ( ) ; return 0 ; }", "text_ms": "Multiply dua bilangan bulat tanpa menggunakan pendaraban, pembahagian dan pengendali bitwise, dan tiada gelung | Program C ++ untuk membiak dua integer tanpa menggunakan pendaraban, pembahagian dan pengendali bitwise, dan tiada gelung; berfungsi untuk membiak dua nombor x dan y; 0 didarab dengan apa -apa memberi 0; Tambah x satu demi satu; kes di mana y adalah negatif; Kod pemacu"}
{"text": "Sieve of Eratosthenes | C ++ program to print all primes smaller than or equal to n using Sieve of Eratosthenes ; Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p greater than or equal to the square of it numbers which are multiple of p and are less than p ^ 2 are already been marked . ; Print all prime numbers ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void SieveOfEratosthenes ( int n ) { bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) cout << p << \" ▁ \" ; } int main ( ) { int n = 30 ; cout << \" Following ▁ are ▁ the ▁ prime ▁ numbers ▁ smaller ▁ \" << \" ▁ than ▁ or ▁ equal ▁ to ▁ \" << n << endl ; SieveOfEratosthenes ( n ) ; return 0 ; }", "text_ms": "Sieve of Eratosthenes | Program C ++ untuk mencetak semua prima yang lebih kecil daripada atau sama dengan N menggunakan penapis eratosthenes; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan p lebih besar daripada atau sama dengan kuadrat nombor IT yang berganda p dan kurang daripada p ^ 2 telah ditandakan. ; Cetak semua nombor utama; Kod pemacu"}
{"text": "Pascal 's Triangle | C ++ code for Pascal 's Triangle ; binomialCoeff ; Function to print first n lines of Pascal 's Triangle ; Iterate through every line and print entries in it ; Every line has number of integers equal to line number ; Driver program", "code": "#include <stdio.h> NEW_LINE int binomialCoeff ( int n , int k ) ; int binomialCoeff ( int n , int k ) { int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } void printPascal ( int n ) { for ( int line = 0 ; line < n ; line ++ ) { for ( int i = 0 ; i <= line ; i ++ ) printf ( \" % d ▁ \" , binomialCoeff ( line , i ) ) ; printf ( \" STRNEWLINE \" ) ; } } int main ( ) { int n = 7 ; printPascal ( n ) ; return 0 ; }", "text_ms": "Segitiga Pascal | C ++ kod untuk segitiga Pascal; BinomialCoeff; Berfungsi untuk mencetak garisan N pertama dari segitiga Pascal; Berulang melalui setiap baris dan cetak penyertaan di dalamnya; Setiap baris mempunyai bilangan integer yang sama dengan nombor baris; Program Pemandu"}
{"text": "Pascal 's Triangle | C ++ program for Pascals Triangle ; A O ( n ^ 2 ) time and O ( n ^ 2 ) extra space method for Pascal 's Triangle ; An auxiliary array to store generated pscal triangle values ; Iterate through every line and print integer ( s ) in it ; Every line has number of integers equal to line number ; First and last values in every row are 1 ; Other values are sum of values just above and left of above ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printPascal ( int n ) { int arr [ n ] [ n ] ; for ( int line = 0 ; line < n ; line ++ ) { for ( int i = 0 ; i <= line ; i ++ ) { if ( line == i i == 0 ) arr [ line ] [ i ] = 1 ; else arr [ line ] [ i ] = arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ; cout << arr [ line ] [ i ] << \" ▁ \" ; } cout << \" STRNEWLINE \" ; } } int main ( ) { int n = 5 ; printPascal ( n ) ; return 0 ; }", "text_ms": "Segitiga Pascal | Program C ++ untuk Pascals Triangle; A o (n ^ 2) masa dan o (n ^ 2) kaedah ruang tambahan untuk segitiga Pascal; Array tambahan untuk menyimpan nilai segitiga PSCAL yang dihasilkan; Melangkah melalui setiap baris dan cetak integer (s) di dalamnya; Setiap baris mempunyai bilangan integer yang sama dengan nombor baris; Nilai pertama dan terakhir dalam setiap baris adalah 1; Nilai -nilai lain adalah jumlah nilai di atas dan kiri di atas; Kod pemacu"}
{"text": "Pascal 's Triangle | C ++ program for Pascals Triangle A O ( n ^ 2 ) time and O ( 1 ) extra space function for Pascal 's Triangle ; used to represent C ( line , i ) ; The first value in a line is always 1 ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printPascal ( int n ) { for ( int line = 1 ; line <= n ; line ++ ) { int C = 1 ; for ( int i = 1 ; i <= line ; i ++ ) { cout << C << \" ▁ \" ; C = C * ( line - i ) / i ; } cout << \" STRNEWLINE \" ; } } int main ( ) { int n = 5 ; printPascal ( n ) ; return 0 ; }", "text_ms": "Segitiga Pascal | Program C ++ untuk Pascals Segitiga A O (N ^ 2) Masa dan O (1) Fungsi Ruang Tambahan untuk Segitiga Pascal; digunakan untuk mewakili C (garis, i); Nilai pertama dalam baris sentiasa 1; Kod pemacu"}
{"text": "Add two numbers without using arithmetic operators | C ++ Program to add two numbers without using arithmetic operator ; Iterate till there is no carry ; carry now contains common set bits of x and y ; Sum of bits of x and y where at least one of the bits is not set ; Carry is shifted by one so that adding it to x gives the required sum ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Add ( int x , int y ) { while ( y != 0 ) { int carry = x & y ; x = x ^ y ; y = carry << 1 ; } return x ; } int main ( ) { cout << Add ( 15 , 32 ) ; return 0 ; }", "text_ms": "Tambah dua nombor tanpa menggunakan pengendali aritmetik | Program C ++ untuk menambah dua nombor tanpa menggunakan pengendali aritmetik; Melangkah sehingga tidak ada bawa; Bawa sekarang mengandungi bit set biasa x dan y; Jumlah bit x dan y di mana sekurang -kurangnya salah satu bit tidak ditetapkan; Membawa beralih oleh satu supaya menambahnya kepada x memberikan jumlah yang diperlukan; Kod pemacu"}
{"text": "Compute modulus division by a power |  ; This function will return n % d . d must be one of : 1 , 2 , 4 , 8 , 16 , 32 , ... ; Driver Code ; d must be a power of 2", "code": "#include <stdio.h> NEW_LINE unsigned int getModulo ( unsigned int n , unsigned int d ) { return ( n & ( d - 1 ) ) ; } int main ( ) { unsigned int n = 6 ; unsigned int d = 4 ; printf ( \" % u ▁ moduo ▁ % u ▁ is ▁ % u \" , n , d , getModulo ( n , d ) ) ; getchar ( ) ; return 0 ; }", "text_ms": "Mengira Bahagian Modulus dengan Kuasa |  ; Fungsi ini akan kembali n % d. D mestilah salah satu: 1, 2, 4, 8, 16, 32, ...; Kod pemacu; D mesti menjadi kuasa 2"}
{"text": "Count set bits in an integer | C ++ program to Count set bits in an integer ; Function to get no of set bits in binary representation of positive integer n ; Program to test function countSetBits", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned int countSetBits ( unsigned int n ) { unsigned int count = 0 ; while ( n ) { count += n & 1 ; n >>= 1 ; } return count ; } int main ( ) { int i = 9 ; cout << countSetBits ( i ) ; return 0 ; }", "text_ms": "Count set bit dalam integer | Program C ++ untuk mengira set bit dalam integer; Berfungsi untuk mendapatkan bit yang ditetapkan dalam perwakilan binari integer positif n; Program untuk menguji fungsi countsetbits"}
{"text": "Count set bits in an integer | CPP implementation for recursive approach to find the number of set bits using Brian Kernighans Algorithm ; recursive function to count set bits ; base case ; driver code ; get value from user ; function calling", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSetBits ( int n ) { if ( n == 0 ) return 0 ; else return 1 + countSetBits ( n & ( n - 1 ) ) ; } int main ( ) { int n = 9 ; cout << countSetBits ( n ) ; return 0 ; }", "text_ms": "Count set bit dalam integer | Pelaksanaan CPP untuk pendekatan rekursif untuk mencari bilangan bit yang ditetapkan menggunakan algoritma Brian Kernighans; fungsi rekursif untuk mengira set bit; Kes asas; kod pemacu; Dapatkan nilai dari pengguna; fungsi panggilan"}
{"text": "Count set bits in an integer | C ++ implementation of the approach ; Lookup table ; Function to initialise the lookup table ; To initially generate the table algorithmically ; Function to return the count of set bits in n ; Driver code ; Initialise the lookup table", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int BitsSetTable256 [ 256 ] ; void initialize ( ) { BitsSetTable256 [ 0 ] = 0 ; for ( int i = 0 ; i < 256 ; i ++ ) { BitsSetTable256 [ i ] = ( i & 1 ) + BitsSetTable256 [ i / 2 ] ; } } int countSetBits ( int n ) { return ( BitsSetTable256 [ n & 0xff ] + BitsSetTable256 [ ( n >> 8 ) & 0xff ] + BitsSetTable256 [ ( n >> 16 ) & 0xff ] + BitsSetTable256 [ n >> 24 ] ) ; } int main ( ) { initialize ( ) ; int n = 9 ; cout << countSetBits ( n ) ; }", "text_ms": "Count set bit dalam integer | C ++ pelaksanaan pendekatan; Jadual carian; Berfungsi untuk memulakan jadual carian; Pada mulanya menjana jadual algoritma; Berfungsi untuk mengembalikan kiraan bit set dalam n; Kod pemacu; Memulakan jadual carian"}
{"text": "Count set bits in an integer | C ++ program to demonstrate __builtin_popcount ( ) ; Driver code", "code": "#include <iostream> NEW_LINE using namespace std ; int main ( ) { cout << __builtin_popcount ( 4 ) << endl ; cout << __builtin_popcount ( 15 ) ; return 0 ; }", "text_ms": "Count set bit dalam integer | Program C ++ untuk menunjukkan __builtin_popcount (); Kod pemacu"}
{"text": "Count set bits in an integer | C ++ program to count set bits by pre - storing count set bits in nibbles . ; Recursively get nibble of a given number and map them in the array ; Find last nibble ; Use pre - stored values to find count in last nibble plus recursively add remaining nibbles . ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int num_to_bits [ 16 ] = { 0 , 1 , 1 , 2 , 1 , 2 , 2 , 3 , 1 , 2 , 2 , 3 , 2 , 3 , 3 , 4 } ; unsigned int countSetBitsRec ( unsigned int num ) { int nibble = 0 ; if ( 0 == num ) return num_to_bits [ 0 ] ; nibble = num & 0xf ; return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) ; } int main ( ) { int num = 31 ; cout << countSetBitsRec ( num ) ; return 0 ; }", "text_ms": "Count set bit dalam integer | Program C ++ untuk mengira set bit dengan pra -menyimpan bit set bit dalam gumpalan. ; Recursif dapat menggigit nombor tertentu dan memetakannya dalam array; Cari nibble terakhir; Gunakan nilai pra -disimpan untuk mencari kiraan dalam nibble terakhir ditambah dengan rekursif menambah baki yang tersisa. ; Kod pemacu"}
{"text": "Count set bits in an integer |  ; Check each bit in a number is set or not and return the total count of the set bits . ; ( 1 << i ) = pow ( 2 , i ) ; Driver code", "code": "#include <iostream> NEW_LINE using namespace std ; int countSetBits ( int N ) { int count = 0 ; for ( int i = 0 ; i < sizeof ( int ) * 8 ; i ++ ) { if ( N & ( 1 << i ) ) count ++ ; } return count ; } int main ( ) { int N = 15 ; cout << countSetBits ( N ) << endl ; return 0 ; }", "text_ms": "Count set bit dalam integer |  ; Semak setiap bit dalam nombor ditetapkan atau tidak dan kembalikan jumlah kiraan bit yang ditetapkan. ; (1 << i) = pow (2, i); Kod pemacu"}
{"text": "Program to find parity | C ++ program to find parity of an integer ; Function to get parity of number n . It returns 1 if n has odd parity , and returns 0 if n has even parity ; Driver program to test getParity ( )", "code": "# include <bits/stdc++.h> NEW_LINE # define bool  int NEW_LINE using namespace std ; bool getParity ( unsigned int n ) { bool parity = 0 ; while ( n ) { parity = ! parity ; n = n & ( n - 1 ) ; } return parity ; } int main ( ) { unsigned int n = 7 ; cout << \" Parity ▁ of ▁ no ▁ \" << n << \" ▁ = ▁ \" << ( getParity ( n ) ? \" odd \" : \" even \" ) ; getchar ( ) ; return 0 ; }", "text_ms": "Program untuk mencari pariti | Program C ++ untuk mencari pariti integer; Berfungsi untuk mendapatkan pariti nombor n. Ia mengembalikan 1 jika n mempunyai pariti ganjil, dan pulangan 0 jika n mempunyai pariti; Program Pemandu untuk Menguji GetParity ()"}
{"text": "Program to find whether a no is power of two | C ++ Program to find whether a no is power of two ; Function to check if x is power of 2 ; Driver program", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPowerOfTwo ( int n ) { if ( n == 0 ) return false ; return ( ceil ( log2 ( n ) ) == floor ( log2 ( n ) ) ) ; } int main ( ) { isPowerOfTwo ( 31 ) ? cout << \" Yes \" << endl : cout << \" No \" << endl ; isPowerOfTwo ( 64 ) ? cout << \" Yes \" << endl : cout << \" No \" << endl ; return 0 ; }", "text_ms": "Program untuk mencari sama ada tidak ada kuasa dua | Program C ++ untuk mencari sama ada NO adalah kuasa dua; Fungsi untuk memeriksa sama ada x adalah kuasa 2; Program Pemandu"}
{"text": "Program to find whether a no is power of two |  ; Function to check if x is power of 2 ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPowerOfTwo ( int n ) { if ( n == 0 ) return 0 ; while ( n != 1 ) { if ( n % 2 != 0 ) return 0 ; n = n / 2 ; } return 1 ; } int main ( ) { isPowerOfTwo ( 31 ) ? cout << \" Yes STRNEWLINE \" : cout << \" No STRNEWLINE \" ; isPowerOfTwo ( 64 ) ? cout << \" Yes STRNEWLINE \" : cout << \" No STRNEWLINE \" ; return 0 ; }", "text_ms": "Program untuk mencari sama ada tidak ada kuasa dua |  ; Fungsi untuk memeriksa sama ada x adalah kuasa 2; Kod pemacu"}
{"text": "Program to find whether a no is power of two | C ++ program for above approach ; Function which checks whether a number is a power of 2 ; base cases '1' is the only odd number which is a power of 2 ( 2 ^ 0 ) ; all other odd numbers are not powers of 2 ; recursive function call ; Driver Code ; True ; False", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool powerOf2 ( int n ) { if ( n == 1 ) return true ; else if ( n % 2 != 0 n == 0 ) return false ; return powerOf2 ( n / 2 ) ; } int main ( ) { int n = 64 ; int m = 12 ; if ( powerOf2 ( n ) == 1 ) cout << \" True \" << endl ; else cout << \" False \" << endl ; if ( powerOf2 ( m ) == 1 ) cout << \" True \" << endl ; else cout << \" False \" << endl ; }", "text_ms": "Program untuk mencari sama ada tidak ada kuasa dua | Program C ++ untuk pendekatan di atas; Fungsi yang memeriksa sama ada nombor adalah kuasa 2; Kes asas '1' adalah satu -satunya nombor ganjil yang merupakan kuasa 2 (2 ^ 0); Semua nombor ganjil yang lain bukan kuasa 2; panggilan fungsi rekursif; Kod pemacu; Benar; Palsu"}
{"text": "Program to find whether a no is power of two |  ; Function to check if x is power of 2 ; First x in the below expression is for the case when x is 0 ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define bool  int NEW_LINE bool isPowerOfTwo ( int x ) { return x && ( ! ( x & ( x - 1 ) ) ) ; } int main ( ) { isPowerOfTwo ( 31 ) ? cout << \" Yes STRNEWLINE \" : cout << \" No STRNEWLINE \" ; isPowerOfTwo ( 64 ) ? cout << \" Yes STRNEWLINE \" : cout << \" No STRNEWLINE \" ; return 0 ; }", "text_ms": "Program untuk mencari sama ada tidak ada kuasa dua |  ; Fungsi untuk memeriksa sama ada x adalah kuasa 2; Pertama x dalam ungkapan di bawah adalah untuk kes apabila x adalah 0; Kod pemacu"}
{"text": "Find the maximum repeating number in O ( n ) time and O ( 1 ) extra space | C ++ program to find the maximum repeating number ; Returns maximum repeating element in arr [ 0. . n - 1 ] . The array elements are in range from 0 to k - 1 ; Iterate though input array , for every element arr [ i ] , increment arr [ arr [ i ] % k ] by k ; Find index of the maximum repeating element ; Return index of the maximum element ; Driver program to test above function", "code": "#include <iostream> NEW_LINE using namespace std ; int maxRepeating ( int * arr , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) arr [ arr [ i ] % k ] += k ; int max = arr [ 0 ] , result = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { max = arr [ i ] ; result = i ; } } return result ; } int main ( ) { int arr [ ] = { 2 , 3 , 3 , 5 , 3 , 4 , 1 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 8 ; cout << \" The ▁ maximum ▁ repeating ▁ number ▁ is ▁ \" << maxRepeating ( arr , n , k ) << endl ; return 0 ; }", "text_ms": "Cari nombor pengulangan maksimum dalam O (n) masa dan O (1) ruang tambahan | Program C ++ untuk mencari nombor pengulangan maksimum; Mengembalikan elemen berulang maksimum dalam ARR [0. n - 1]. Unsur -unsur array berada dalam jarak dari 0 hingga k - 1; Berulang walaupun array input, untuk setiap elemen arr [i], kenaikan arr [arr [i] % k] oleh k; Cari indeks elemen berulang maksimum; Indeks pulangan elemen maksimum; Program pemacu untuk menguji fungsi di atas"}
{"text": "Range Query on array whose each element is XOR of index value and previous element | CPP Program to solve range query on array whose each element is XOR of index value and previous element . ; function return derived formula value . ; finding xor value of range [ y ... x ] ; function to solve query for l and r . ; if l or r is 0. ; finding x is divisible by 2 or not . ; Driven Program", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int fun ( int x ) { int y = ( x / 4 ) * 4 ; int ans = 0 ; for ( int i = y ; i <= x ; i ++ ) ans ^= i ; return ans ; } int query ( int x ) { if ( x == 0 ) return 0 ; int k = ( x + 1 ) / 2 ; return ( x %= 2 ) ? 2 * fun ( k ) : ( ( fun ( k - 1 ) * 2 ) ^ ( k & 1 ) ) ; } void allQueries ( int q , int l [ ] , int r [ ] ) { for ( int i = 0 ; i < q ; i ++ ) cout << ( query ( r [ i ] ) ^ query ( l [ i ] - 1 ) ) << endl ; } int main ( ) { int q = 3 ; int l [ ] = { 2 , 2 , 5 } ; int r [ ] = { 4 , 8 , 9 } ; allQueries ( q , l , r ) ; return 0 ; }", "text_ms": "Pertanyaan pelbagai pada array yang setiap elemen adalah xor nilai indeks dan elemen sebelumnya | Program CPP untuk menyelesaikan pertanyaan pelbagai pada array yang setiap elemennya adalah XOR nilai indeks dan elemen sebelumnya. ; Fungsi pulangan nilai formula yang diperolehi. ; Mencari nilai XOR julat [y ... x]; Fungsi untuk menyelesaikan pertanyaan untuk l dan r. ; jika l atau r ialah 0 .; Mencari X boleh dibahagikan dengan 2 atau tidak. ; Program yang didorong"}
{"text": "Queries on XOR of greatest odd divisor of the range |  ; Precompute the prefix XOR of greatest odd divisor ; Finding the Greatest Odd divisor ; Finding prefix XOR ; Return XOR of the range ; Driven Program", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void prefixXOR ( int arr [ ] , int preXOR [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { while ( arr [ i ] % 2 != 1 ) arr [ i ] /= 2 ; preXOR [ i ] = arr [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) preXOR [ i ] = preXOR [ i - 1 ] ^ preXOR [ i ] ; } int query ( int preXOR [ ] , int l , int r ) { if ( l == 0 ) return preXOR [ r ] ; else return preXOR [ r ] ^ preXOR [ l - 1 ] ; } int main ( ) { int arr [ ] = { 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int preXOR [ n ] ; prefixXOR ( arr , preXOR , n ) ; cout << query ( preXOR , 0 , 2 ) << endl ; cout << query ( preXOR , 1 , 2 ) << endl ; return 0 ; }", "text_ms": "Pertanyaan pada Xor pembahagi ganjil yang paling hebat dari julat |  ; Precompute awalan xor pembahagi ganjil yang paling besar; Mencari pembahagi ganjil yang paling besar; Mencari awalan xor; Kembali xor julat; Program yang didorong"}
{"text": "Minimum adjacent swaps required to Sort Binary array | C ++ code to find minimum number of swaps to sort a binary array ; Function to find minimum swaps to sort an array of 0 s and 1 s . ; Array to store count of zeroes ; Count number of zeroes on right side of every one . ; Count total number of swaps by adding number of zeroes on right side of every one . ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinSwaps ( int arr [ ] , int n ) { int noOfZeroes [ n ] ; memset ( noOfZeroes , 0 , sizeof ( noOfZeroes ) ) ; int i , count = 0 ; noOfZeroes [ n - 1 ] = 1 - arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { noOfZeroes [ i ] = noOfZeroes [ i + 1 ] ; if ( arr [ i ] == 0 ) noOfZeroes [ i ] ++ ; } for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) count += noOfZeroes [ i ] ; } return count ; } int main ( ) { int arr [ ] = { 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMinSwaps ( arr , n ) ; return 0 ; }", "text_ms": "Swap bersebelahan minimum diperlukan untuk menyusun array binari | C ++ kod untuk mencari bilangan swap minimum untuk menyusun array binari; Fungsi untuk mencari swap minimum untuk menyusun pelbagai 0 s dan 1 s. ; Array untuk menyimpan kiraan sifar; Kira bilangan sifar di sebelah kanan setiap satu. ; Kira jumlah swap dengan menambahkan bilangan sifar di sebelah kanan setiap satu. ; Kod pemacu"}
{"text": "Minimum adjacent swaps required to Sort Binary array |  ; Driver Code", "code": "#include <iostream> NEW_LINE using namespace std ; int minswaps ( int arr [ ] , int n ) { int count = 0 ; int num_unplaced_zeros = 0 ; for ( int index = n - 1 ; index >= 0 ; index -- ) { if ( arr [ index ] == 0 ) num_unplaced_zeros += 1 ; else count += num_unplaced_zeros ; } return count ; } int main ( ) { int arr [ ] = { 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 } ; cout << minswaps ( arr , 9 ) ; return 0 ; }", "text_ms": "Swap bersebelahan minimum diperlukan untuk menyusun array binari |  ; Kod pemacu"}
{"text": "Program to check if an array is sorted or not ( Iterative and Recursive ) | C ++ program to check if an Array is sorted or not ; Function that returns true if array is sorted in non - decreasing order . ; Array has one or no element ; Unsorted pair found ; No unsorted pair found ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool arraySortedOrNot ( int arr [ ] , int n ) { if ( n == 0 n == 1 ) return true ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ; return true ; } int main ( ) { int arr [ ] = { 20 , 23 , 23 , 45 , 78 , 88 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( arraySortedOrNot ( arr , n ) ) cout << \" Yes STRNEWLINE \" ; else cout << \" No STRNEWLINE \" ; }", "text_ms": "Program untuk memeriksa sama ada array disusun atau tidak (berulang dan rekursif) | Program C ++ untuk memeriksa sama ada array disusun atau tidak; Fungsi yang pulih benar jika array disusun dalam perintah yang tidak menurun. ; Array mempunyai satu atau tiada elemen; Pasangan yang tidak disusun dijumpai; Tiada pasangan yang tidak disusun dijumpai; Kod pemacu"}
{"text": "Find the two numbers with odd occurrences in an unsorted array | C ++ Program to find the two odd occurring elements ; Prints two numbers that occur odd number of times . The function assumes that the array size is at least 2 and there are exactly two numbers occurring odd number of times . ; Will hold XOR of two odd occurring elements ; Will have only single set bit of xor2 ; Get the xor of all elements in arr [ ] . The xor will basically be xor of two odd occurring elements ; Get one set bit in the xor2 . We get rightmost set bit in the following line as it is easy to get ; Now divide elements in two sets : 1 ) The elements having the corresponding bit as 1. 2 ) The elements having the corresponding bit as 0. ; XOR of first set is finally going to hold one odd occurring number x ; XOR of second set is finally going to hold the other odd occurring number y ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printTwoOdd ( int arr [ ] , int size ) { int xor2 = arr [ 0 ] ; int set_bit_no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) xor2 = xor2 ^ arr [ i ] ; set_bit_no = xor2 & ~ ( xor2 - 1 ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] & set_bit_no ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } cout << \" The ▁ two ▁ ODD ▁ elements ▁ are ▁ \" << x << \" ▁ & ▁ \" << y ; } int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 3 , 1 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printTwoOdd ( arr , arr_size ) ; return 0 ; }", "text_ms": "Cari dua nombor dengan kejadian ganjil dalam array yang tidak disusun | Program C ++ untuk mencari dua elemen yang ganjil; Mencetak dua nombor yang berlaku bilangan kali ganjil. Fungsi ini mengandaikan bahawa saiz array sekurang -kurangnya 2 dan terdapat dua nombor yang berlaku pada masa yang ganjil. ; Akan memegang Xor dua elemen yang ganjil; Hanya akan mempunyai bit satu set XOR2; Dapatkan XOR semua elemen di arr []. XOR pada dasarnya akan menjadi XOR dari dua elemen yang ganjil; Dapatkan satu set bit di XOR2. Kami mendapat set paling kanan dalam baris berikut kerana mudah diperoleh; Sekarang bahagikan unsur -unsur dalam dua set: 1) unsur -unsur yang mempunyai bit yang sepadan sebagai 1.2) unsur -unsur yang mempunyai bit yang sepadan sebagai 0 .; XOR set pertama akhirnya akan memegang satu nombor X yang ganjil; XOR set kedua akhirnya akan memegang nombor yang lain yang berlaku y; Kod pemacu"}
{"text": "Find the two numbers with odd occurrences in an unsorted array | C ++ Program to find the two odd occurring elements ; Prints two numbers that occur odd number of times . The function assumes that the array size is at least 2 and there are exactly two numbers occurring odd number of times . ; Create map and calculate frequency of array of * elements using array . ; Traverse through the map and check if its second element that is the frequency is odd or not . Then this is the odd occurring element . Its is clearly mentioned in problem that there are only two odd occurring elements so this will print those two elements . ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printTwoOdd ( int arr [ ] , int size ) { map < int , int > m ; for ( int i = 0 ; i < size ; i ++ ) { m [ arr [ i ] ] ++ ; } cout << \" The ▁ two ▁ ODD ▁ elements ▁ are ▁ \" ; for ( auto & x : m ) { if ( x . second % 2 != 0 ) cout << x . first << \" , ▁ \" ; } } int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 3 , 1 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printTwoOdd ( arr , arr_size ) ; return 0 ; }", "text_ms": "Cari dua nombor dengan kejadian ganjil dalam array yang tidak disusun | Program C ++ untuk mencari dua elemen yang ganjil; Mencetak dua nombor yang berlaku bilangan kali ganjil. Fungsi ini mengandaikan bahawa saiz array sekurang -kurangnya 2 dan terdapat dua nombor yang berlaku pada masa yang ganjil. ; Buat peta dan hitung kekerapan array * elemen menggunakan array. ; Melintasi peta dan periksa jika elemen kedua yang kekerapannya ganjil atau tidak. Kemudian ini adalah elemen yang ganjil. Ia jelas disebut dalam masalah bahawa hanya terdapat dua elemen yang ganjil sehingga ini akan mencetak kedua -dua elemen tersebut. ; Kod pemacu"}
{"text": "Find a pair with the given difference | C ++ program to find a pair with the given difference ; The function assumes that the array is sorted ; Initialize positions of two elements ; Search for a pair ; Driver program to test above function", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool findPair ( int arr [ ] , int size , int n ) { int i = 0 ; int j = 1 ; while ( i < size && j < size ) { if ( i != j && arr [ j ] - arr [ i ] == n ) { cout << \" Pair ▁ Found : ▁ ( \" << arr [ i ] << \" , ▁ \" << arr [ j ] << \" ) \" ; return true ; } else if ( arr [ j ] - arr [ i ] < n ) j ++ ; else i ++ ; } cout << \" No ▁ such ▁ pair \" ; return false ; } int main ( ) { int arr [ ] = { 1 , 8 , 30 , 40 , 100 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int n = 60 ; findPair ( arr , size , n ) ; return 0 ; }", "text_ms": "Cari pasangan dengan perbezaan yang diberikan | Program C ++ untuk mencari pasangan dengan perbezaan yang diberikan; Fungsi ini mengandaikan bahawa array disusun; Memulakan kedudukan dua elemen; Cari pasangan; Program pemacu untuk menguji fungsi di atas"}
{"text": "Find k maximum elements of array in original order | C ++ program to find k maximum elements of array in original order ; Function to print m Maximum elements ; vector to store the copy of the original array ; Sorting the vector in descending order . Please refer below link for details www . geeksforgeeks . org / sort - c - stl / https : ; Traversing through original array and printing all those elements that are in first k of sorted vector . goo . gl / 44 Rwgt Please refer https : for details of binary_search ( ) ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printMax ( int arr [ ] , int k , int n ) { vector < int > brr ( arr , arr + n ) ; sort ( brr . begin ( ) , brr . end ( ) , greater < int > ( ) ) ; for ( int i = 0 ; i < n ; ++ i ) if ( binary_search ( brr . begin ( ) , brr . begin ( ) + k , arr [ i ] , greater < int > ( ) ) ) cout << arr [ i ] << \" ▁ \" ; } int main ( ) { int arr [ ] = { 50 , 8 , 45 , 12 , 25 , 40 , 84 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; printMax ( arr , k , n ) ; return 0 ; }", "text_ms": "Cari K Unsur Maksimum Array dalam Perintah Asal | Program C ++ untuk mencari unsur maksimum array dalam urutan asal; Berfungsi untuk mencetak elemen maksimum; vektor untuk menyimpan salinan array asal; Menyusun vektor dalam urutan menurun. Sila rujuk pautan di bawah untuk butiran www. Geeksforgeeks. org / sort - c - stl / https :; Melintasi array asal dan mencetak semua unsur -unsur yang berada dalam k vektor yang disusun pertama. goo. GL / 44 RWGT Sila rujuk https: untuk butiran binary_search (); Kod pemacu"}
{"text": "Print n smallest elements from given array in their original order | CPP for printing smallest n number in order ; Function to print smallest n numbers ; Make copy of array ; Sort copy array ; For each arr [ i ] find whether it is a part of n - smallest with binary search ; Driver program", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printSmall ( int arr [ ] , int asize , int n ) { vector < int > copy_arr ( arr , arr + asize ) ; sort ( copy_arr . begin ( ) , copy_arr . begin ( ) + asize ) ; for ( int i = 0 ; i < asize ; ++ i ) if ( binary_search ( copy_arr . begin ( ) , copy_arr . begin ( ) + n , arr [ i ] ) ) cout << arr [ i ] << \" ▁ \" ; } int main ( ) { int arr [ ] = { 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 } ; int asize = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int n = 5 ; printSmall ( arr , asize , n ) ; return 0 ; }", "text_ms": "Cetak n elemen terkecil dari array yang diberikan dalam urutan asal mereka | CPP untuk mencetak nombor N terkecil dalam urutan; Berfungsi untuk mencetak nombor N terkecil; Buat salinan Array; Susun Arahan Salin; Bagi setiap arr [i] mendapati sama ada ia adalah sebahagian daripada N - terkecil dengan carian binari; Program Pemandu"}
{"text": "Check whether Arithmetic Progression can be formed from the given array | C ++ program to check if a given array can form arithmetic progression ; Returns true if a permutation of arr [ 0. . n - 1 ] can form arithmetic progression ; Sort array ; After sorting , difference between consecutive elements must be same . ; Driven Program", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkIsAP ( int arr [ ] , int n ) { if ( n == 1 ) return true ; sort ( arr , arr + n ) ; int d = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; return true ; } int main ( ) { int arr [ ] = { 20 , 15 , 5 , 0 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; ( checkIsAP ( arr , n ) ) ? ( cout << \" Yes \" << endl ) : ( cout << \" No \" << endl ) ; return 0 ; }", "text_ms": "Semak sama ada perkembangan aritmetik boleh dibentuk dari array yang diberikan | Program C ++ untuk memeriksa sama ada array yang diberikan boleh membentuk perkembangan aritmetik; Pulangan benar jika permutasi ARR [0 .. n - 1] boleh membentuk perkembangan aritmetik; Susun array; Selepas menyusun, perbezaan antara unsur -unsur berturut -turut mestilah sama. ; Program yang didorong"}
{"text": "Check whether Arithmetic Progression can be formed from the given array | C ++ program to check if a given array can form arithmetic progression ; Returns true if a permutation of arr [ 0. . n - 1 ] can form arithmetic progression ; Find the smallest and and update second smallest ; Find second smallest ; Check if the duplicate element found or not ; If duplicate found then return false ; Find the difference between smallest and second smallest ; As we have used smallest and second smallest , so we should now only check for n - 2 elements ; Driven Program", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkIsAP ( int arr [ ] , int n ) { unordered_map < int , int > hm ; int smallest = INT_MAX , second_smallest = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < smallest ) { second_smallest = smallest ; smallest = arr [ i ] ; } else if ( arr [ i ] != smallest && arr [ i ] < second_smallest ) second_smallest = arr [ i ] ; if ( hm . find ( arr [ i ] ) == hm . end ( ) ) hm [ arr [ i ] ] ++ ; else return false ; } int diff = second_smallest - smallest ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( hm . find ( second_smallest ) == hm . end ( ) ) return false ; second_smallest += diff ; } return true ; } int main ( ) { int arr [ ] = { 20 , 15 , 5 , 0 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; ( checkIsAP ( arr , n ) ) ? ( cout << \" Yes \" << endl ) : ( cout << \" No \" << endl ) ; return 0 ; }", "text_ms": "Semak sama ada perkembangan aritmetik boleh dibentuk dari array yang diberikan | Program C ++ untuk memeriksa sama ada array yang diberikan boleh membentuk perkembangan aritmetik; Pulangan benar jika permutasi ARR [0 .. n - 1] boleh membentuk perkembangan aritmetik; Cari yang terkecil dan kemas kini kedua terkecil; Cari kedua terkecil; Semak sama ada elemen pendua yang dijumpai atau tidak; Jika pendua dijumpai kemudian kembali palsu; Cari perbezaan antara terkecil dan kedua terkecil; Seperti yang kita telah menggunakan terkecil terkecil dan kedua, jadi kita hanya perlu menyemak unsur -unsur n - 2; Program yang didorong"}
{"text": "Count ways of choosing a pair with maximum difference | CPP Code to find no . of Ways of choosing a pair with maximum difference ; To find minimum and maximum of the array ; to find the count of minimum and maximum elements ; Count variables ; condition for all elements equal ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int a [ ] , int n ) { int mn = INT_MAX ; int mx = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { mn = min ( mn , a [ i ] ) ; mx = max ( mx , a [ i ] ) ; } int c1 = 0 ; int c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == mn ) c1 ++ ; if ( a [ i ] == mx ) c2 ++ ; } if ( mn == mx ) return n * ( n - 1 ) / 2 ; else return c1 * c2 ; } int main ( ) { int a [ ] = { 3 , 2 , 1 , 1 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << countPairs ( a , n ) ; return 0 ; }", "text_ms": "Kira cara memilih pasangan dengan perbezaan maksimum | Kod CPP untuk mencari tidak. cara memilih pasangan dengan perbezaan maksimum; Untuk mencari minimum dan maksimum array; untuk mencari kiraan elemen minimum dan maksimum; Kiraan pembolehubah; keadaan untuk semua elemen sama; Kod pemacu"}
{"text": "Rearrange a given linked list in | C ++ code to rearrange linked list in place ; function for rearranging a linked list with high and low value . ; Base case . ; two pointer variable . ; swap function for swapping data . ; swap function for swapping data . ; function to insert a node in the linked list at the beginning . ; function to display node of linked list . ; driver code ; let create a linked list . 9 -> 6 -> 8 -> 3 -> 7", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct node { int data ; struct node * next ; } ; typedef struct node Node ; void rearrange ( Node * head ) { if ( head == NULL ) return ; Node * prev = head , * curr = head -> next ; while ( curr ) { if ( prev -> data > curr -> data ) swap ( prev -> data , curr -> data ) ; if ( curr -> next && curr -> next -> data > curr -> data ) swap ( curr -> next -> data , curr -> data ) ; prev = curr -> next ; if ( ! curr -> next ) break ; curr = curr -> next -> next ; } } void push ( Node * * head , int k ) { Node * tem = ( Node * ) malloc ( sizeof ( Node ) ) ; tem -> data = k ; tem -> next = * head ; * head = tem ; } void display ( Node * head ) { Node * curr = head ; while ( curr != NULL ) { printf ( \" % d ▁ \" , curr -> data ) ; curr = curr -> next ; } } int main ( ) { Node * head = NULL ; push ( & head , 7 ) ; push ( & head , 3 ) ; push ( & head , 8 ) ; push ( & head , 6 ) ; push ( & head , 9 ) ; rearrange ( head ) ; display ( head ) ; return 0 ; }", "text_ms": "Susun semula senarai yang dipautkan dalam | C ++ kod untuk menyusun semula senarai yang dipautkan di tempat; Fungsi untuk menyusun semula senarai yang dipautkan dengan nilai tinggi dan rendah. ; Kes asas. ; Pembolehubah dua penunjuk. ; Fungsi swap untuk menukar data. ; Fungsi swap untuk menukar data. ; Fungsi untuk memasukkan nod dalam senarai yang dipautkan pada mulanya. ; Fungsi untuk memaparkan nod senarai yang dipautkan. ; kod pemacu; Biarkan membuat senarai yang dipautkan. 9 -> 6 -> 8 -> 3 -> 7"}
{"text": "Subtract Two Numbers represented as Linked Lists | C ++ program to subtract smaller valued list from larger valued list and return result as a list . ; A linked List Node ; A utility function to get length of linked list ; A Utility that padds zeros in front of the Node , with the given diff ; Subtract LinkedList Helper is a recursive function , move till the last Node , and subtract the digits and create the Node and return the Node . If d1 < d2 , we borrow the number from previous digit . ; if you have given the value value to next digit then reduce the d1 by 1 ; If d1 < d2 , then borrow the number from previous digit . Add 10 to d1 and set borrow = true ; ; subtract the digits ; Create a Node with sub value ; Set the Next pointer as Previous ; This API subtracts two linked lists and returns the linked list which shall have the subtracted result . ; Base Case . ; In either of the case , get the lengths of both Linked list . ; If lengths differ , calculate the smaller Node and padd zeros for smaller Node and ensure both larger Node and smaller Node has equal length . ; If both list lengths are equal , then calculate the larger and smaller list . If 5 - 6 - 7 & 5 - 6 - 8 are linked list , then walk through linked list at last Node as 7 < 8 , larger Node is 5 - 6 - 8 and smaller Node is 5 - 6 - 7. ; After calculating larger and smaller Node , call subtractLinkedListHelper which returns the subtracted linked list . ; A utility function to print linked list ; Driver program to test above functions", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; Node * newNode ( int data ) { Node * temp = new Node ; temp -> data = data ; temp -> next = NULL ; return temp ; } int getLength ( Node * Node ) { int size = 0 ; while ( Node != NULL ) { Node = Node -> next ; size ++ ; } return size ; } Node * paddZeros ( Node * sNode , int diff ) { if ( sNode == NULL ) return NULL ; Node * zHead = newNode ( 0 ) ; diff -- ; Node * temp = zHead ; while ( diff -- ) { temp -> next = newNode ( 0 ) ; temp = temp -> next ; } temp -> next = sNode ; return zHead ; } Node * subtractLinkedListHelper ( Node * l1 , Node * l2 , bool & borrow ) { if ( l1 == NULL && l2 == NULL && borrow == 0 ) return NULL ; Node * previous = subtractLinkedListHelper ( l1 ? l1 -> next : NULL , l2 ? l2 -> next : NULL , borrow ) ; int d1 = l1 -> data ; int d2 = l2 -> data ; int sub = 0 ; if ( borrow ) { d1 -- ; borrow = false ; } if ( d1 < d2 ) { borrow = true ; d1 = d1 + 10 ; } sub = d1 - d2 ; Node * current = newNode ( sub ) ; current -> next = previous ; return current ; } Node * subtractLinkedList ( Node * l1 , Node * l2 ) { if ( l1 == NULL && l2 == NULL ) return NULL ; int len1 = getLength ( l1 ) ; int len2 = getLength ( l2 ) ; Node * lNode = NULL , * sNode = NULL ; Node * temp1 = l1 ; Node * temp2 = l2 ; if ( len1 != len2 ) { lNode = len1 > len2 ? l1 : l2 ; sNode = len1 > len2 ? l2 : l1 ; sNode = paddZeros ( sNode , abs ( len1 - len2 ) ) ; } else { while ( l1 && l2 ) { if ( l1 -> data != l2 -> data ) { lNode = l1 -> data > l2 -> data ? temp1 : temp2 ; sNode = l1 -> data > l2 -> data ? temp2 : temp1 ; break ; } l1 = l1 -> next ; l2 = l2 -> next ; } } bool borrow = false ; return subtractLinkedListHelper ( lNode , sNode , borrow ) ; } void printList ( struct Node * Node ) { while ( Node != NULL ) { printf ( \" % d ▁ \" , Node -> data ) ; Node = Node -> next ; } printf ( \" STRNEWLINE \" ) ; } int main ( ) { Node * head1 = newNode ( 1 ) ; head1 -> next = newNode ( 0 ) ; head1 -> next -> next = newNode ( 0 ) ; Node * head2 = newNode ( 1 ) ; Node * result = subtractLinkedList ( head1 , head2 ) ; printList ( result ) ; return 0 ; }", "text_ms": "Kurangkan dua nombor yang diwakili sebagai senarai yang dipautkan | Program C ++ untuk menolak senarai bernilai yang lebih kecil dari senarai bernilai yang lebih besar dan hasil pulangan sebagai senarai. ; Nod senarai yang dipautkan; Fungsi utiliti untuk mendapatkan panjang senarai yang dipautkan; Utiliti yang sifar Padds di hadapan nod, dengan perbezaan yang diberikan; Kurangkan Helper LinkedList adalah fungsi rekursif, bergerak sehingga nod terakhir, dan tolak digit dan buat nod dan kembalikan nod. Jika D1 <D2, kami meminjam nombor dari digit sebelumnya. ; Jika anda telah memberikan nilai nilai kepada digit seterusnya maka kurangkan D1 dengan 1; Jika D1 <D2, kemudian pinjam nombor dari digit sebelumnya. Tambah 10 hingga D1 dan set Borrow = true; ; tolak digit; Buat nod dengan sub nilai; Tetapkan penunjuk seterusnya seperti sebelumnya; API ini menolak dua senarai yang dipautkan dan mengembalikan senarai yang dipautkan yang akan mempunyai hasil yang dikurangkan. ; Kes asas. ; Dalam kedua -dua kes itu, dapatkan panjang kedua -dua senarai yang dipautkan. ; Jika panjang berbeza, hitung nod yang lebih kecil dan sifar PADD untuk nod yang lebih kecil dan pastikan kedua -dua nod yang lebih besar dan nod yang lebih kecil mempunyai panjang yang sama. ; Jika kedua -dua senarai panjang adalah sama, maka hitung senarai yang lebih besar dan lebih kecil. Jika 5 - 6 - 7 & 5 - 6 - 8 adalah senarai yang dipautkan, kemudian berjalan melalui senarai yang dipautkan pada nod terakhir sebagai 7 <8, nod yang lebih besar adalah 5 - 6 - 8 dan nod yang lebih kecil ialah 5 - 6 - 7 .; Setelah mengira nod yang lebih besar dan lebih kecil, call tolakLinkedListHelper yang mengembalikan senarai yang dipautkan. ; Fungsi utiliti untuk mencetak senarai yang dipautkan; Program pemacu untuk menguji fungsi di atas"}
{"text": "Insert node into the middle of the linked list | C ++ implementation to insert node at the middle of the linked list ; structure of a node ; function to create and return a node ; function to insert node at the middle of the linked list ; if list is empty ; get a new node ; calculate length of the linked list , i . e , the number of nodes ; ' count ' the number of nodes after which the new node is to be inserted ; ' ptr ' points to the node after which the new node is to be inserted ; insert the ' newNode ' and adjust the required links ; function to display the linked list ; Driver program to test above ; Creating the list 1 -> 2 -> 4 -> 5", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * next ; } ; Node * getNode ( int data ) { Node * newNode = ( Node * ) malloc ( sizeof ( Node ) ) ; newNode -> data = data ; newNode -> next = NULL ; return newNode ; } void insertAtMid ( Node * * head_ref , int x ) { if ( * head_ref == NULL ) * head_ref = getNode ( x ) ; else { Node * newNode = getNode ( x ) ; Node * ptr = * head_ref ; int len = 0 ; while ( ptr != NULL ) { len ++ ; ptr = ptr -> next ; } int count = ( ( len % 2 ) == 0 ) ? ( len / 2 ) : ( len + 1 ) / 2 ; ptr = * head_ref ; while ( count -- > 1 ) ptr = ptr -> next ; newNode -> next = ptr -> next ; ptr -> next = newNode ; } } void display ( Node * head ) { while ( head != NULL ) { cout << head -> data << \" ▁ \" ; head = head -> next ; } } int main ( ) { Node * head = NULL ; head = getNode ( 1 ) ; head -> next = getNode ( 2 ) ; head -> next -> next = getNode ( 4 ) ; head -> next -> next -> next = getNode ( 5 ) ; cout << \" Linked ▁ list ▁ before ▁ insertion : ▁ \" ; display ( head ) ; int x = 3 ; insertAtMid ( & head , x ) ; cout << \" Linked list after insertion : \" display ( head ) ; return 0 ; }", "text_ms": "Masukkan nod ke tengah senarai yang dipautkan | C ++ pelaksanaan untuk memasukkan nod di tengah -tengah senarai yang dipautkan; struktur nod; berfungsi untuk membuat dan mengembalikan nod; berfungsi untuk memasukkan nod di tengah -tengah senarai yang dipautkan; Jika senarai kosong; Dapatkan nod baru; Kirakan panjang senarai yang dipautkan, i. e, bilangan nod; 'mengira' bilangan nod yang selepas nod baru dimasukkan; 'PTR' menunjuk ke nod yang mana nod baru dimasukkan; Masukkan 'newnode' dan laraskan pautan yang diperlukan; berfungsi untuk memaparkan senarai yang dipautkan; Program pemandu untuk menguji di atas; Membuat Senarai 1 -> 2 -> 4 -> 5"}
{"text": "Insert node into the middle of the linked list | C ++ implementation to insert node at the middle of the linked list ; structure of a node ; function to insert node at the middle of the linked list ; if list is empty ; get a new node ; assign values to the slow and fast pointers ; move slow pointer to next node ; move fast pointer two nodes at a time ; insert the ' newNode ' and adjust the required links ; function to display the linked list ; Driver program to test above ; Creating the list 1 -> 2 -> 4 -> 5", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * next ; } ; Node * getNode ( int data ) { Node * newNode = ( Node * ) malloc ( sizeof ( Node ) ) ; newNode -> data = data ; newNode -> next = NULL ; return newNode ; } void insertAtMid ( Node * * head_ref , int x ) { if ( * head_ref == NULL ) * head_ref = getNode ( x ) ; else { Node * newNode = getNode ( x ) ; Node * slow = * head_ref ; Node * fast = ( * head_ref ) -> next ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; } newNode -> next = slow -> next ; slow -> next = newNode ; } } void display ( Node * head ) { while ( head != NULL ) { cout << head -> data << \" ▁ \" ; head = head -> next ; } } int main ( ) { Node * head = NULL ; head = getNode ( 1 ) ; head -> next = getNode ( 2 ) ; head -> next -> next = getNode ( 4 ) ; head -> next -> next -> next = getNode ( 5 ) ; cout << \" Linked ▁ list ▁ before ▁ insertion : ▁ \" ; display ( head ) ; int x = 3 ; insertAtMid ( & head , x ) ; cout << \" Linked list after insertion : \" display ( head ) ; return 0 ; }", "text_ms": "Masukkan nod ke tengah senarai yang dipautkan | C ++ pelaksanaan untuk memasukkan nod di tengah -tengah senarai yang dipautkan; struktur nod; berfungsi untuk memasukkan nod di tengah -tengah senarai yang dipautkan; Jika senarai kosong; Dapatkan nod baru; Berikan nilai kepada petunjuk yang perlahan dan cepat; gerakkan penunjuk perlahan ke nod seterusnya; Pindahkan penunjuk cepat dua nod pada satu masa; Masukkan 'newnode' dan laraskan pautan yang diperlukan; berfungsi untuk memaparkan senarai yang dipautkan; Program pemandu untuk menguji di atas; Membuat Senarai 1 -> 2 -> 4 -> 5"}
{"text": "Insertion Sort for Doubly Linked List | C ++ implementation for insertion Sort on a doubly linked list ; Node of a doubly linked list ; function to create and return a new node of a doubly linked list ; allocate node ; put in the data ; function to insert a new node in sorted way in a sorted doubly linked list ; if list is empty ; if the node is to be inserted at the beginning of the doubly linked list ; locate the node after which the new node is to be inserted ; Make the appropriate links ; if the new node is not inserted at the end of the list ; function to sort a doubly linked list using insertion sort ; Initialize ' sorted ' - a sorted doubly linked list ; Traverse the given doubly linked list and insert every node to ' sorted ' ; Store next for next iteration ; removing all the links so as to create ' current ' as a new node for insertion ; insert current in ' sorted ' doubly linked list ; Update current ; Update head_ref to point to sorted doubly linked list ; function to print the doubly linked list ; function to insert a node at the beginning of the doubly linked list ; allocate node ; put in the data ; Make next of new node as head and previous as NULL ; change prev of head node to new node ; move the head to point to the new node ; Driver program to test above ; start with the empty doubly linked list ; insert the following data", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * prev , * next ; } ; struct Node * getNode ( int data ) { struct Node * newNode = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; newNode -> data = data ; newNode -> prev = newNode -> next = NULL ; return newNode ; } void sortedInsert ( struct Node * * head_ref , struct Node * newNode ) { struct Node * current ; if ( * head_ref == NULL ) * head_ref = newNode ; else if ( ( * head_ref ) -> data >= newNode -> data ) { newNode -> next = * head_ref ; newNode -> next -> prev = newNode ; * head_ref = newNode ; } else { current = * head_ref ; while ( current -> next != NULL && current -> next -> data < newNode -> data ) current = current -> next ; newNode -> next = current -> next ; if ( current -> next != NULL ) newNode -> next -> prev = newNode ; current -> next = newNode ; newNode -> prev = current ; } } void insertionSort ( struct Node * * head_ref ) { struct Node * sorted = NULL ; struct Node * current = * head_ref ; while ( current != NULL ) { struct Node * next = current -> next ; current -> prev = current -> next = NULL ; sortedInsert ( & sorted , current ) ; current = next ; } * head_ref = sorted ; } void printList ( struct Node * head ) { while ( head != NULL ) { cout << head -> data << \" ▁ \" ; head = head -> next ; } } void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; new_node -> prev = NULL ; if ( ( * head_ref ) != NULL ) ( * head_ref ) -> prev = new_node ; ( * head_ref ) = new_node ; } int main ( ) { struct Node * head = NULL ; push ( & head , 9 ) ; push ( & head , 3 ) ; push ( & head , 5 ) ; push ( & head , 10 ) ; push ( & head , 12 ) ; push ( & head , 8 ) ; cout << \" Doubly ▁ Linked ▁ List ▁ Before ▁ Sortingn \" ; printList ( head ) ; insertionSort ( & head ) ; cout << \" nDoubly ▁ Linked ▁ List ▁ After ▁ Sortingn \" ; printList ( head ) ; return 0 ; }", "text_ms": "SENARAI SENSI UNTUK SENARAI DUBLY LINKED | C ++ pelaksanaan untuk memasukkan sort pada senarai dikaitkan dua kali ganda; Nod senarai dikaitkan dua kali ganda; berfungsi untuk membuat dan mengembalikan nod baru senarai dikaitkan dua kali ganda; memperuntukkan nod; masukkan data; berfungsi untuk memasukkan nod baru dalam cara yang disusun dalam senarai dikaitkan dua kali ganda; Jika senarai kosong; Jika nod dimasukkan pada permulaan senarai dikaitkan dua kali ganda; cari nod yang selepas itu nod baru dimasukkan; Membuat pautan yang sesuai; Jika nod baru tidak dimasukkan pada akhir senarai; Fungsi untuk menyusun senarai yang dikaitkan dua kali menggunakan jenis penyisipan; Inisialisasi 'disusun' - senarai dikaitkan dua kali ganda yang disusun; Melintasi senarai dikaitkan dua kali ganda dan masukkan setiap nod untuk 'disusun'; Simpan seterusnya untuk lelaran seterusnya; Mengeluarkan semua pautan untuk membuat 'semasa' sebagai nod baru untuk dimasukkan; Masukkan arus dalam senarai dikaitkan 'disusun'; Mengemas kini semasa; Kemas kini head_ref untuk menunjuk ke senarai yang disusun dua kali ganda; berfungsi untuk mencetak senarai dikaitkan dua kali ganda; berfungsi untuk memasukkan nod pada permulaan senarai dikaitkan dua kali ganda; memperuntukkan nod; masukkan data; Buat seterusnya nod baru sebagai kepala dan sebelumnya sebagai batal; Tukar Node kepala ke nod baru; gerakkan kepala untuk menunjuk ke nod baru; Program pemandu untuk menguji di atas; Mulakan dengan senarai dikaitkan dua kali ganda; Masukkan data berikut"}
{"text": "Print all possible rotations of a given Array | C ++ program to print all possible rotations of the given array ; Global declaration of array ; Function to reverse array between indices s and e ; Function to generate all possible rotations of array ; Driver code", "code": "#include <iostream> NEW_LINE using namespace std ; int arr [ 10000 ] ; void reverse ( int arr [ ] , int s , int e ) { while ( s < e ) { int tem = arr [ s ] ; arr [ s ] = arr [ e ] ; arr [ e ] = tem ; s = s + 1 ; e = e - 1 ; } } void fun ( int arr [ ] , int k ) { int n = 4 - 1 ; int v = n - k ; if ( v >= 0 ) { reverse ( arr , 0 , v ) ; reverse ( arr , v + 1 , n ) ; reverse ( arr , 0 , n ) ; } } int main ( ) { arr [ 0 ] = 1 ; arr [ 1 ] = 2 ; arr [ 2 ] = 3 ; arr [ 3 ] = 4 ; for ( int i = 0 ; i < 4 ; i ++ ) { fun ( arr , i ) ; cout << ( \" [ \" ) ; for ( int j = 0 ; j < 4 ; j ++ ) { cout << ( arr [ j ] ) << \" , ▁ \" ; } cout << ( \" ] \" ) ; } }", "text_ms": "Cetak semua kemungkinan putaran array yang diberikan | Program C ++ untuk mencetak semua kemungkinan putaran array yang diberikan; Perisytiharan Global Array; Fungsi untuk membalikkan array antara indeks S dan E; Berfungsi untuk menjana semua kemungkinan putaran array; Kod pemacu"}
{"text": "Find array sum using Bitwise OR after splitting given array in two halves after K circular shifts | C ++ Program to find Bitwise OR of two equal halves of an array after performing K right circular shifts ; Array for storing the segment tree ; Function to build the segment tree ; Function to return the OR of elements in the range [ l , r ] ; Check for out of bound condition ; Find middle of the range ; Recurse for all the elements in array ; Function to find the OR sum ; Function to build the segment Tree ; Loop to handle q queries ; Effective number of right circular shifts ; OR of second half of the array [ n / 2 - i , n - 1 - i ] ; OR of first half of the array [ n - i , n - 1 ] OR [ 0 , n / 2 - 1 - i ] ; Print final answer to the query ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE const int MAX = 100005 ; using namespace std ; int seg [ 4 * MAX ] ; void build ( int node , int l , int r , int a [ ] ) { if ( l == r ) seg [ node ] = a [ l ] ; else { int mid = ( l + r ) / 2 ; build ( 2 * node , l , mid , a ) ; build ( 2 * node + 1 , mid + 1 , r , a ) ; seg [ node ] = ( seg [ 2 * node ] seg [ 2 * node + 1 ] ) ; } } int query ( int node , int l , int r , int start , int end , int a [ ] ) { if ( l > end or r < start ) return 0 ; if ( start <= l and r <= end ) return seg [ node ] ; int mid = ( l + r ) / 2 ; return ( ( query ( 2 * node , l , mid , start , end , a ) ) | ( query ( 2 * node + 1 , mid + 1 , r , start , end , a ) ) ) ; } void orsum ( int a [ ] , int n , int q , int k [ ] ) { build ( 1 , 0 , n - 1 , a ) ; for ( int j = 0 ; j < q ; j ++ ) { int i = k [ j ] % ( n / 2 ) ; int sec = query ( 1 , 0 , n - 1 , n / 2 - i , n - i - 1 , a ) ; int first = ( query ( 1 , 0 , n - 1 , 0 , n / 2 - 1 - i , a ) | query ( 1 , 0 , n - 1 , n - i , n - 1 , a ) ) ; int temp = sec + first ; cout << temp << endl ; } } int main ( ) { int a [ ] = { 7 , 44 , 19 , 86 , 65 , 39 , 75 , 101 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int q = 2 ; int k [ q ] = { 4 , 2 } ; orsum ( a , n , q , k ) ; return 0 ; }", "text_ms": "Cari jumlah array menggunakan bitwise atau selepas memisahkan array yang diberikan dalam dua bahagian selepas pergeseran bulat k | Program C ++ untuk mencari bitwise atau dua bahagian yang sama dengan array selepas melakukan peralihan bulat kanan K; Array untuk menyimpan pokok segmen; Berfungsi untuk membina pokok segmen; Berfungsi untuk mengembalikan atau unsur -unsur dalam julat [l, r]; Semak keadaan terikat; Cari tengah julat; Berulang untuk semua elemen dalam pelbagai; Berfungsi untuk mencari atau jumlah; Berfungsi untuk membina pokok segmen; Gelung untuk mengendalikan pertanyaan Q; Bilangan peralihan bulat yang betul; Atau separuh kedua array [n / 2 - i, n - 1 - i]; Atau separuh pertama array [n - i, n - 1] atau [0, n / 2 - 1 - i]; Cetak jawapan akhir untuk pertanyaan; Kod pemacu"}
{"text": "Maximize count of corresponding same elements in given Arrays by Rotation | C ++ program of the above approach ; Function that prints maximum equal elements ; Vector to store the index of elements of array b ; Storing the positions of array B ; frequency array to keep count of elements with similar difference in distances ; Iterate through all element in arr1 [ ] ; Calculate number of shift required to make current element equal ; If d is less than 0 ; Store the frequency of current diff ; Compute the maximum frequency stored ; Printing the maximum number of equal elements ; Driver Code ; Given two arrays ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void maximumEqual ( int a [ ] , int b [ ] , int n ) { vector < int > store ( 1e5 ) ; for ( int i = 0 ; i < n ; i ++ ) { store [ b [ i ] ] = i + 1 ; } vector < int > ans ( 1e5 ) ; for ( int i = 0 ; i < n ; i ++ ) { int d = abs ( store [ a [ i ] ] - ( i + 1 ) ) ; if ( store [ a [ i ] ] < i + 1 ) { d = n - d ; } ans [ d ] ++ ; } int finalans = 0 ; for ( int i = 0 ; i < 1e5 ; i ++ ) finalans = max ( finalans , ans [ i ] ) ; cout << finalans << \" STRNEWLINE \" ; } int main ( ) { int A [ ] = { 6 , 7 , 3 , 9 , 5 } ; int B [ ] = { 7 , 3 , 9 , 5 , 6 } ; int size = sizeof ( A ) / sizeof ( A [ 0 ] ) ; maximumEqual ( A , B , size ) ; return 0 ; }", "text_ms": "Memaksimumkan kiraan unsur -unsur yang sama dalam tatasusunan yang diberikan oleh putaran | C ++ program pendekatan di atas; Fungsi yang mencetak elemen maksimum yang sama; Vektor untuk menyimpan indeks elemen array b; Menyimpan kedudukan array b; Arahan frekuensi untuk mengekalkan unsur -unsur dengan perbezaan yang sama dalam jarak; Melangkah melalui semua elemen dalam ARR1 []; Kirakan bilangan peralihan yang diperlukan untuk menjadikan elemen semasa sama; Jika D kurang daripada 0; Simpan kekerapan perbezaan semasa; Kirakan kekerapan maksimum yang disimpan; Mencetak bilangan maksimum elemen yang sama; Kod pemacu; Diberikan dua tatasusunan; Panggilan fungsi"}
{"text": "Print array after it is right rotated K times | C ++ implementation of right rotation of an array K number of times ; Function to rightRotate array ; If rotation is greater than size of array ; Printing rightmost kth elements ; Prints array after ' k ' elements ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void RightRotate ( int a [ ] , int n , int k ) { k = k % n ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < k ) { cout << a [ n + i - k ] << \" ▁ \" ; } else { cout << ( a [ i - k ] ) << \" ▁ \" ; } } cout << \" STRNEWLINE \" ; } int main ( ) { int Array [ ] = { 1 , 2 , 3 , 4 , 5 } ; int N = sizeof ( Array ) / sizeof ( Array [ 0 ] ) ; int K = 2 ; RightRotate ( Array , N , K ) ; }", "text_ms": "Arahan cetak selepas ia betul -betul diputar k kali | C ++ pelaksanaan putaran kanan array k bilangan kali; Berfungsi untuk array rightrotate; Jika putaran lebih besar daripada saiz array; Mencetak elemen kth paling kanan; Cetak array selepas elemen 'k'; Kod pemacu"}
{"text": "Sort a Rotated Sorted Array | C ++ implementation for restoring original sort in rotated sorted array ; Function to restore the Original Sort ; In reverse ( ) , the first parameter is iterator to beginning element and second parameter is iterator to last element plus one . ; Function to print the Array ; Driver function", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void restoreSortedArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { reverse ( arr , arr + i + 1 ) ; reverse ( arr + i + 1 , arr + n ) ; reverse ( arr , arr + n ) ; } } } void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) cout << arr [ i ] << \" ▁ \" ; } int main ( ) { int arr [ ] = { 3 , 4 , 5 , 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; restoreSortedArray ( arr , n ) ; printArray ( arr , n ) ; return 0 ; }", "text_ms": "Sort Array Disusun Berputar | C ++ pelaksanaan untuk memulihkan jenis asal dalam array yang disusun diputar; Berfungsi untuk memulihkan jenis asal; Dalam sebaliknya (), parameter pertama adalah iterator untuk memulakan elemen dan parameter kedua adalah iterator untuk elemen terakhir ditambah satu. ; Berfungsi untuk mencetak array; Fungsi pemacu"}
{"text": "Sort a Rotated Sorted Array | C ++ implementation for restoring original sort in rotated sorted array using binary search ; Function to find start index of array ; Function to restore the Original Sort ; array is already sorted ; In reverse ( ) , the first parameter is iterator to beginning element and second parameter is iterator to last element plus one . ; Function to print the Array ; Driver function", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findStartIndexOfArray ( int arr [ ] , int low , int high ) { if ( low > high ) { return -1 ; } if ( low == high ) { return low ; } int mid = low + ( high - low ) / 2 ; if ( arr [ mid ] > arr [ mid + 1 ] ) return mid + 1 ; if ( arr [ mid - 1 ] > arr [ mid ] ) return mid ; if ( arr [ low ] > arr [ mid ] ) return findStartIndexOfArray ( arr , low , mid - 1 ) ; else return findStartIndexOfArray ( arr , mid + 1 , high ) ; } void restoreSortedArray ( int arr [ ] , int n ) { if ( arr [ 0 ] < arr [ n - 1 ] ) return ; int start = findStartIndexOfArray ( arr , 0 , n - 1 ) ; reverse ( arr , arr + start ) ; reverse ( arr + start , arr + n ) ; reverse ( arr , arr + n ) ; } void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) cout << arr [ i ] << \" ▁ \" ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; restoreSortedArray ( arr , n ) ; printArray ( arr , n ) ; return 0 ; }", "text_ms": "Sort Array Disusun Berputar | C ++ pelaksanaan untuk memulihkan jenis asal dalam array disusun yang diputar menggunakan carian binari; Fungsi untuk mencari indeks permulaan array; Berfungsi untuk memulihkan jenis asal; Array sudah disusun; Dalam sebaliknya (), parameter pertama adalah iterator untuk memulakan elemen dan parameter kedua adalah iterator untuk elemen terakhir ditambah satu. ; Berfungsi untuk mencetak array; Fungsi pemacu"}
{"text": "Left Rotation and Right Rotation of a String | C program for Left Rotation and Right Rotation of a String ; In - place rotates s towards left by d ; In - place rotates s towards right by d ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void leftrotate ( string & s , int d ) { reverse ( s . begin ( ) , s . begin ( ) + d ) ; reverse ( s . begin ( ) + d , s . end ( ) ) ; reverse ( s . begin ( ) , s . end ( ) ) ; } void rightrotate ( string & s , int d ) { leftrotate ( s , s . length ( ) - d ) ; } int main ( ) { string str1 = \" GeeksforGeeks \" ; leftrotate ( str1 , 2 ) ; cout << str1 << endl ; string str2 = \" GeeksforGeeks \" ; rightrotate ( str2 , 2 ) ; cout << str2 << endl ; return 0 ; }", "text_ms": "Putaran kiri dan putaran kanan rentetan | Program C untuk putaran kiri dan putaran kanan rentetan; Di tempat berputar ke kiri oleh D; Di - tempat berputar ke kanan oleh D; Kod pemacu"}
{"text": "Search an Element in Doubly Circular Linked List | C ++ program to illustrate inserting a Node in a Cicular Doubly Linked list in begging , end and middle ; Structure of a Node ; Function to insert a node at the end ; If the list is empty , create a single node circular and doubly list ; Find last node ; Create Node dynamically ; Start is going to be next of new_node ; Make new node previous of start ; Make last preivous of new node ; Make new node next of old last ; Function to display the circular doubly linked list ; Function to search the particular element from the list ; Declare the temp variable ; Declare other control variable for the searching ; If start is NULL return - 1 ; Move the temp pointer until , temp -> next doesn 't move  start address (Circular Fashion) ; Increment count for location ; If it is found raise the flag and break the loop ; Increment temp pointer ; Check whether last element in the list content the value if contain , raise a flag and increment count ; If flag is true , then element found , else not ; Driver code ; Start with the empty list ; Insert 4. So linked list becomes 4 -> NULL ; Insert 5. So linked list becomes 4 -> 5 ; Insert 7. So linked list becomes 4 -> 5 -> 7 ; Insert 8. So linked list becomes 4 -> 5 -> 7 -> 8 ; Insert 6. So linked list becomes 4 -> 5 -> 7 -> 8 -> 6", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; struct Node * prev ; } ; void insertNode ( struct Node * * start , int value ) { if ( * start == NULL ) { struct Node * new_node = new Node ; new_node -> data = value ; new_node -> next = new_node -> prev = new_node ; * start = new_node ; return ; } Node * last = ( * start ) -> prev ; struct Node * new_node = new Node ; new_node -> data = value ; new_node -> next = * start ; ( * start ) -> prev = new_node ; new_node -> prev = last ; last -> next = new_node ; } void displayList ( struct Node * start ) { struct Node * temp = start ; while ( temp -> next != start ) { printf ( \" % d ▁ \" , temp -> data ) ; temp = temp -> next ; } printf ( \" % d ▁ \" , temp -> data ) ; } int searchList ( struct Node * start , int search ) { struct Node * temp = start ; int count = 0 , flag = 0 , value ; if ( temp == NULL ) return -1 ; else { while ( temp -> next != start ) { count ++ ; if ( temp -> data == search ) { flag = 1 ; count -- ; break ; } temp = temp -> next ; } if ( temp -> data == search ) { count ++ ; flag = 1 ; } if ( flag == 1 ) cout << \" STRNEWLINE \" << search << \" ▁ found ▁ at ▁ location ▁ \" << count << endl ; else cout << \" STRNEWLINE \" << search << \" ▁ not ▁ found \" << endl ; } } int main ( ) { struct Node * start = NULL ; insertNode ( & start , 4 ) ; insertNode ( & start , 5 ) ; insertNode ( & start , 7 ) ; insertNode ( & start , 8 ) ; insertNode ( & start , 6 ) ; printf ( \" Created ▁ circular ▁ doubly ▁ linked ▁ list ▁ is : ▁ \" ) ; displayList ( start ) ; searchList ( start , 5 ) ; return 0 ; }", "text_ms": "Cari elemen dalam Senarai Berkaitan Pekeliling Ganda | Program C ++ untuk menggambarkan memasukkan nod dalam senarai dikaitkan dua kali ganda dalam mengemis, akhir dan tengah; Struktur nod; Berfungsi untuk memasukkan nod pada akhir; Jika senarai kosong, buat satu pekeliling nod tunggal dan senarai dua kali ganda; Cari nod terakhir; Buat nod secara dinamik; Mula akan menjadi yang akan datang dengan New_node; Buat nod baru sebelum permulaan; Membuat nod baru yang terakhir; Buat nod baru yang akan datang yang terakhir; Berfungsi untuk memaparkan senarai dikaitkan dua kali ganda; Berfungsi untuk mencari elemen tertentu dari senarai; Mengisytiharkan pemboleh ubah temp; Mengisytiharkan pemboleh ubah kawalan lain untuk mencari; Jika permulaan adalah NULL RETURN - 1; Gerakkan penunjuk temp sehingga, temp -> seterusnya tidak bergerak alamat permulaan (fesyen bulat); Kiraan kenaikan lokasi; Jika didapati menaikkan bendera dan memecahkan gelung; Penunjuk suhu kenaikan; Semak sama ada elemen terakhir dalam kandungan senarai nilai jika mengandungi, menaikkan bendera dan kiraan kenaikan; Jika bendera adalah benar, maka unsur dijumpai, lain tidak; Kod pemacu; Mulakan dengan senarai kosong; Masukkan 4. Jadi senarai yang dipautkan menjadi 4 -> null; Masukkan 5. Jadi senarai yang dipautkan menjadi 4 -> 5; Masukkan 7. Jadi senarai yang dipautkan menjadi 4 -> 5 -> 7; Masukkan 8. Jadi senarai yang dipautkan menjadi 4 -> 5 -> 7 -> 8; Masukkan 6. Jadi senarai yang dipautkan menjadi 4 -> 5 -> 7 -> 8 -> 6"}
{"text": "Reverse a doubly circular linked list | C ++ implementation to revesre a doubly circular linked list ; structure of a node of linked list ; function to create and return a new node ; Function to insert at the end ; If the list is empty , create a single node circular and doubly list ; Find last node ; Start is going to be next of new_node ; Make new node previous of start ; Make last preivous of new node ; Make new node next of old last ; Uitlity function to revesre a doubly circular linked list ; Initialize a new head pointer ; get pointer to the the last node ; set ' curr ' to last node ; traverse list in backward direction ; insert ' curr ' at the end of the list starting with the ' new _ head ' pointer ; head pointer of the reversed list ; function to display a doubly circular list in forward and backward direction ; Driver program to test above", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * next , * prev ; } ; Node * getNode ( int data ) { Node * newNode = ( Node * ) malloc ( sizeof ( Node ) ) ; newNode -> data = data ; return newNode ; } void insertEnd ( Node * * head , Node * new_node ) { if ( * head == NULL ) { new_node -> next = new_node -> prev = new_node ; * head = new_node ; return ; } Node * last = ( * head ) -> prev ; new_node -> next = * head ; ( * head ) -> prev = new_node ; new_node -> prev = last ; last -> next = new_node ; } Node * reverse ( Node * head ) { if ( ! head ) return NULL ; Node * new_head = NULL ; Node * last = head -> prev ; Node * curr = last , * prev ; while ( curr -> prev != last ) { prev = curr -> prev ; insertEnd ( & new_head , curr ) ; curr = prev ; } insertEnd ( & new_head , curr ) ; return new_head ; } void display ( Node * head ) { if ( ! head ) return ; Node * temp = head ; cout << \" Forward ▁ direction : ▁ \" ; while ( temp -> next != head ) { cout << temp -> data << \" ▁ \" ; temp = temp -> next ; } cout << temp -> data ; Node * last = head -> prev ; temp = last ; cout << \" Backward direction : \" while ( temp -> prev != last ) { cout << temp -> data << \" ▁ \" ; temp = temp -> prev ; } cout << temp -> data ; } int main ( ) { Node * head = NULL ; insertEnd ( & head , getNode ( 1 ) ) ; insertEnd ( & head , getNode ( 2 ) ) ; insertEnd ( & head , getNode ( 3 ) ) ; insertEnd ( & head , getNode ( 4 ) ) ; insertEnd ( & head , getNode ( 5 ) ) ; cout << \" Current ▁ list : STRNEWLINE \" ; display ( head ) ; head = reverse ( head ) ; cout << \" Reversed list : \" display ( head ) ; return 0 ; }", "text_ms": "Membalikkan senarai dikaitkan bulat berganda | C ++ pelaksanaan untuk mengulangi senarai dikaitkan bulat dua kali ganda; struktur nod senarai yang dipautkan; berfungsi untuk membuat dan mengembalikan nod baru; Berfungsi untuk memasukkan pada akhir; Jika senarai kosong, buat satu pekeliling nod tunggal dan senarai dua kali ganda; Cari nod terakhir; Mula akan menjadi yang akan datang dengan New_node; Buat nod baru sebelum permulaan; Membuat nod baru yang terakhir; Buat nod baru yang akan datang yang terakhir; Fungsi uitlity untuk mengulangi senarai dikaitkan bulat dua kali ganda; Memulakan penunjuk kepala baru; Dapatkan penunjuk ke nod terakhir; Tetapkan 'curr' ke nod terakhir; senarai melintasi arah ke belakang; Masukkan 'curr' pada akhir senarai bermula dengan penunjuk 'baru _ kepala'; penunjuk kepala senarai terbalik; berfungsi untuk memaparkan senarai bulat berganda dalam arah ke hadapan dan ke belakang; Program Pemandu untuk diuji di atas"}
{"text": "Sqrt ( or Square Root ) Decomposition | Set 2 ( LCA of Tree in O ( sqrt ( height ) ) time ) | Naive C ++ implementation to find LCA in a tree ; stores depth for each node ; stores first parent for each node ; marking parent for each node ; marking depth for each node ; propogating marking down the tree ; a dummy node ; precalclating 1 ) depth . 2 ) parent . for each node ; Time Complexity : O ( Height of tree ) recursively jumps one node above till both the nodes become equal ; Driver function to call the above functions ; adding edges to the tree", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAXN  1001 NEW_LINE int depth [ MAXN ] ; int parent [ MAXN ] ; vector < int > adj [ MAXN ] ; void addEdge ( int u , int v ) { adj [ u ] . push_back ( v ) ; adj [ v ] . push_back ( u ) ; } void dfs ( int cur , int prev ) { parent [ cur ] = prev ; depth [ cur ] = depth [ prev ] + 1 ; for ( int i = 0 ; i < adj [ cur ] . size ( ) ; i ++ ) if ( adj [ cur ] [ i ] != prev ) dfs ( adj [ cur ] [ i ] , cur ) ; } void preprocess ( ) { depth [ 0 ] = -1 ; dfs ( 1 , 0 ) ; } int LCANaive ( int u , int v ) { if ( u == v ) return u ; if ( depth [ u ] > depth [ v ] ) swap ( u , v ) ; v = parent [ v ] ; return LCANaive ( u , v ) ; } int main ( int argc , char const * argv [ ] ) { addEdge ( 1 , 2 ) ; addEdge ( 1 , 3 ) ; addEdge ( 1 , 4 ) ; addEdge ( 2 , 5 ) ; addEdge ( 2 , 6 ) ; addEdge ( 3 , 7 ) ; addEdge ( 4 , 8 ) ; addEdge ( 4 , 9 ) ; addEdge ( 9 , 10 ) ; addEdge ( 9 , 11 ) ; addEdge ( 7 , 12 ) ; addEdge ( 7 , 13 ) ; preprocess ( ) ; cout << \" LCA ( 11,8 ) ▁ : ▁ \" << LCANaive ( 11 , 8 ) << endl ; cout << \" LCA ( 3,13 ) ▁ : ▁ \" << LCANaive ( 3 , 13 ) << endl ; return 0 ; }", "text_ms": "SQRT (atau Square Root) Penguraian | Tetapkan 2 (LCA pokok dalam O (sqrt (ketinggian)) masa) | Pelaksanaan C ++ naif untuk mencari LCA di dalam pokok; Kedalaman kedai untuk setiap nod; Kedai ibu bapa pertama untuk setiap nod; menandakan ibu bapa untuk setiap nod; menandakan kedalaman untuk setiap nod; propogating menandakan pokok itu; nod dummy; precalclating 1) kedalaman. 2) ibu bapa. untuk setiap nod; Kerumitan masa: O (ketinggian pokok) secara rekursif melompat satu nod di atas sehingga kedua -dua nod menjadi sama; Fungsi pemacu untuk memanggil fungsi di atas; Menambah tepi ke pokok"}
{"text": "Sqrt ( or Square Root ) Decomposition | Set 2 ( LCA of Tree in O ( sqrt ( height ) ) time ) | C ++ program to find LCA using Sqrt decomposition ; block size = sqrt ( height ) ; stores depth for each node ; stores first parent for each node ; stores first ancestor in previous block ; precalculating the required parameters associated with every node ; marking depth of cur node ; marking parent of cur node ; making jump_parent of cur node ; if it is first node of the block then its jump_parent is its cur parent ; if it is not the first node of this block then its jump_parent is jump_parent of its parent ; propogating the marking down the subtree ; using sqrt decomposition trick ; maintaining depth [ v ] > depth [ u ] ; climb to its jump parent ; u and v have same jump_parent ; precalclating 1 ) depth . 2 ) parent . 3 ) jump_parent for each node ; Driver function to call the above functions ; adding edges to the tree ; here we are directly taking height = 4 according to the given tree but we can pre - calculate height = max depth in one more dfs", "code": "#include \" iostream \" NEW_LINE #include \" vector \" NEW_LINE #include \" math . h \" NEW_LINE using namespace std ; #define MAXN  1001 NEW_LINE int block_sz ; int depth [ MAXN ] ; int parent [ MAXN ] ; int jump_parent [ MAXN ] ; vector < int > adj [ MAXN ] ; void addEdge ( int u , int v ) { adj [ u ] . push_back ( v ) ; adj [ v ] . push_back ( u ) ; } int LCANaive ( int u , int v ) { if ( u == v ) return u ; if ( depth [ u ] > depth [ v ] ) swap ( u , v ) ; v = parent [ v ] ; return LCANaive ( u , v ) ; } void dfs ( int cur , int prev ) { depth [ cur ] = depth [ prev ] + 1 ; parent [ cur ] = prev ; if ( depth [ cur ] % block_sz == 0 ) jump_parent [ cur ] = parent [ cur ] ; else jump_parent [ cur ] = jump_parent [ prev ] ; for ( int i = 0 ; i < adj [ cur ] . size ( ) ; ++ i ) if ( adj [ cur ] [ i ] != prev ) dfs ( adj [ cur ] [ i ] , cur ) ; } int LCASQRT ( int u , int v ) { while ( jump_parent [ u ] != jump_parent [ v ] ) { if ( depth [ u ] > depth [ v ] ) swap ( u , v ) ; v = jump_parent [ v ] ; } return LCANaive ( u , v ) ; } void preprocess ( int height ) { block_sz = sqrt ( height ) ; depth [ 0 ] = -1 ; dfs ( 1 , 0 ) ; } int main ( int argc , char const * argv [ ] ) { addEdge ( 1 , 2 ) ; addEdge ( 1 , 3 ) ; addEdge ( 1 , 4 ) ; addEdge ( 2 , 5 ) ; addEdge ( 2 , 6 ) ; addEdge ( 3 , 7 ) ; addEdge ( 4 , 8 ) ; addEdge ( 4 , 9 ) ; addEdge ( 9 , 10 ) ; addEdge ( 9 , 11 ) ; addEdge ( 7 , 12 ) ; addEdge ( 7 , 13 ) ; int height = 4 ; preprocess ( height ) ; cout << \" LCA ( 11,8 ) ▁ : ▁ \" << LCASQRT ( 11 , 8 ) << endl ; cout << \" LCA ( 3,13 ) ▁ : ▁ \" << LCASQRT ( 3 , 13 ) << endl ; return 0 ; }", "text_ms": "SQRT (atau Square Root) Penguraian | Tetapkan 2 (LCA pokok dalam O (sqrt (ketinggian)) masa) | Program C ++ untuk mencari LCA menggunakan penguraian SQRT; blok saiz = sqrt (ketinggian); Kedalaman kedai untuk setiap nod; Kedai ibu bapa pertama untuk setiap nod; Kedai nenek moyang pertama di blok sebelumnya; mempraktikkan parameter yang diperlukan yang berkaitan dengan setiap nod; menandakan kedalaman node cur; menandakan ibu bapa node cur; membuat jump_parent node cur; Jika ia adalah nod pertama blok maka jump_parentnya adalah ibu bapa yang curnya; Jika bukan nod pertama blok ini maka jump_parentnya adalah jump_parent ibu bapanya; propogating menandakan subtree; menggunakan helah penguraian SQRT; mengekalkan kedalaman [v]> kedalaman [u]; Mendaki ke ibu bapa melompatnya; u dan v mempunyai jump_parent yang sama; precalclating 1) kedalaman. 2) ibu bapa. 3) Jump_parent untuk setiap nod; Fungsi pemacu untuk memanggil fungsi di atas; Menambah tepi ke pokok; Di sini kita terus mengambil ketinggian = 4 mengikut pokok yang diberikan tetapi kita boleh mengira ketinggian = kedalaman maksimum dalam satu lagi dfs"}
{"text": "Expected Number of Trials to get N Consecutive Heads | C ++ implementation of the above approach ; Driver Code ; Formula for number of trails for N consecutive heads", "code": "#include \" bits / stdc + + . h \" NEW_LINE using namespace std ; int main ( ) { int N = 3 ; cout << pow ( 2 , N + 1 ) - 2 ; return 0 ; }", "text_ms": "Bilangan ujian yang dijangkakan untuk mendapatkan kepala berturut -turut n | C ++ pelaksanaan pendekatan di atas; Kod pemacu; Formula untuk bilangan laluan untuk kepala berturut -turut n"}
{"text": "Find and Count total factors of co | C ++ implementation of the above approach ; Function to return the count of numbers which are divisible by both A and B in the range [ 1 , N ] in constant time ; Compute the count of numbers divisible by A in the range [ 1 , N ] ; Compute the count of numbers divisible by B in the range [ 1 , N ] ; Adding the counts which are divisible by A and B ; The above value might contain repeated values which are divisible by both A and B . Therefore , the count of numbers which are divisible by both A and B are found ; The count computed above is subtracted to compute the final count ; Function to return the sum of numbers which are divisible by both A and B in the range [ 1 , N ] ; Set to store the numbers so that the numbers are not repeated ; For loop to find the numbers which are divisible by A and insert them into the set ; For loop to find the numbers which are divisible by A and insert them into the set ; For loop to iterate through the set and find the sum ; Driver code", "code": "#include <algorithm> NEW_LINE #include <iostream> NEW_LINE #include <set> NEW_LINE #define ll  long long NEW_LINE using namespace std ; ll int countOfNum ( ll int n , ll int a , ll int b ) { ll int cnt_of_a , cnt_of_b , cnt_of_ab , sum ; cnt_of_a = n / a ; cnt_of_b = n / b ; sum = cnt_of_b + cnt_of_a ; cnt_of_ab = n / ( a * b ) ; sum = sum - cnt_of_ab ; return sum ; } ll int sumOfNum ( ll int n , ll int a , ll int b ) { ll int i ; ll int sum = 0 ; set < ll int > ans ; for ( i = a ; i <= n ; i = i + a ) { ans . insert ( i ) ; } for ( i = b ; i <= n ; i = i + b ) { ans . insert ( i ) ; } for ( auto it = ans . begin ( ) ; it != ans . end ( ) ; it ++ ) { sum = sum + * it ; } return sum ; } int main ( ) { ll int N = 88 ; ll int A = 11 ; ll int B = 8 ; ll int count = countOfNum ( N , A , B ) ; ll int sumofnum = sumOfNum ( N , A , B ) ; cout << sumofnum % count << endl ; return 0 ; }", "text_ms": "Cari dan kirakan jumlah faktor Co | C ++ pelaksanaan pendekatan di atas; Berfungsi untuk mengembalikan kiraan nombor yang boleh dibahagikan oleh kedua -dua A dan B dalam julat [1, n] dalam masa yang berterusan; Kirakan kiraan nombor yang boleh dibahagikan dengan A dalam julat [1, n]; Kirakan kiraan nombor yang boleh dibahagi dengan b dalam julat [1, n]; Menambah tuduhan yang boleh dibahagikan oleh A dan B; Nilai di atas mungkin mengandungi nilai berulang yang boleh dibahagikan oleh kedua -dua A dan B. Oleh itu, kiraan nombor yang boleh dibahagikan oleh kedua -dua A dan B ditemui; Kiraan yang dikira di atas dikurangkan untuk mengira kiraan akhir; Berfungsi untuk mengembalikan jumlah nombor yang boleh dibahagikan oleh kedua -dua A dan B dalam julat [1, n]; Tetapkan untuk menyimpan nombor supaya nombor tidak diulang; Untuk gelung untuk mencari nombor yang boleh dibahagikan dengan A dan masukkannya ke dalam set; Untuk gelung untuk mencari nombor yang boleh dibahagikan dengan A dan masukkannya ke dalam set; Untuk gelung untuk melangkah melalui set dan cari jumlahnya; Kod pemacu"}
{"text": "Find Range Value of the Expression | C ++ implementation of the approach ; Function to return the value of the given expression ; Value of the first term ; Value of the last term ; Driver code ; Get the result", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; double get ( double L , double R ) { double x = 1.0 / L ; double y = 1.0 / ( R + 1.0 ) ; return ( x - y ) ; } int main ( ) { int L = 6 , R = 12 ; double ans = get ( L , R ) ; cout << fixed << setprecision ( 2 ) << ans ; return 0 ; }", "text_ms": "Cari nilai julat ungkapan | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan nilai ungkapan yang diberikan; Nilai istilah pertama; Nilai istilah terakhir; Kod pemacu; Dapatkan hasilnya"}
{"text": "Find next greater element with no consecutive 1 in it 's binary representation | C ++ implementation of the approach ; To store the pre - computed integers ; Function that returns true if the binary representation of x contains consecutive 1 s ; To store the previous bit ; Check whether the previous bit and the current bit are both 1 ; Update previous bit ; Go to the next bit ; Function to pre - compute the valid numbers from 0 to MAX ; Store all the numbers which do not have consecutive 1 s ; Function to return the minimum number greater than n which does not contain consecutive 1 s ; Search for the next greater element with no consecutive 1 s ; Function to perform the queries ; Driver code ; Pre - compute the numbers ; Perform the queries", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100000 ; vector < int > v ; int consecutiveOnes ( int x ) { int p = 0 ; while ( x > 0 ) { if ( x % 2 == 1 and p == 1 ) return true ; p = x % 2 ; x /= 2 ; } return false ; } void preCompute ( ) { for ( int i = 0 ; i <= MAX ; i ++ ) { if ( ! consecutiveOnes ( i ) ) v . push_back ( i ) ; } } int nextValid ( int n ) { int it = upper_bound ( v . begin ( ) , v . end ( ) , n ) - v . begin ( ) ; int val = v [ it ] ; return val ; } void performQueries ( int queries [ ] , int q ) { for ( int i = 0 ; i < q ; i ++ ) cout << nextValid ( queries [ i ] ) << \" STRNEWLINE \" ; } int main ( ) { int queries [ ] = { 4 , 6 } ; int q = sizeof ( queries ) / sizeof ( int ) ; preCompute ( ) ; performQueries ( queries , q ) ; return 0 ; }", "text_ms": "Cari elemen yang lebih besar seterusnya tanpa berturut -turut 1 dalam perwakilan binari itu | C ++ pelaksanaan pendekatan; Untuk menyimpan bilangan bulat pra -dikira; Fungsi yang mengembalikan benar jika perwakilan binari x mengandungi 1 s; Untuk menyimpan sedikit sebelumnya; Semak sama ada bit sebelumnya dan bit semasa adalah kedua -dua 1; Mengemas kini sedikit sebelumnya; Pergi ke bit seterusnya; Fungsi untuk pra - mengira nombor yang sah dari 0 hingga maksimum; Simpan semua nombor yang tidak mempunyai 1 s berturut -turut; Berfungsi untuk mengembalikan nombor minimum yang lebih besar daripada n yang tidak mengandungi 1 s berturut -turut; Cari elemen yang lebih besar seterusnya tanpa berturut -turut 1 s; Berfungsi untuk melakukan pertanyaan; Kod pemacu; Pra - mengira nombor; Lakukan pertanyaan"}
{"text": "Minimum given operations required to convert a given binary string to all 1 's | C ++ implementation of the approach ; Function to return the number of operations required ; ctr will store the number of consecutive ones at the end of the given binary string ; Loop to find number of 1 s at the end of the string ; If the current character is 1 ; If we encounter the first 0 from the LSB position then we 'll break the loop ; Number of operations required is ( l - ctr ) ; Function to remove leading zeroes from the string ; Loop until s [ i ] becomes not equal to 1 ; If we reach the end of the string , it means that string contains only 0 's ; Return the string without leading zeros ; Driver code ; Removing the leading zeroes", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int changeToOnes ( string str ) { int i , l , ctr = 0 ; l = str . length ( ) ; for ( i = l - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == '1' ) ctr ++ ; else break ; } return l - ctr ; } string removeZeroesFromFront ( string str ) { string s ; int i = 0 ; while ( i < str . length ( ) && str [ i ] == '0' ) i ++ ; if ( i == str . length ( ) ) s = \"0\" ; else s = str . substr ( i , str . length ( ) - i ) ; return s ; } int main ( ) { string str = \"10010111\" ; str = removeZeroesFromFront ( str ) ; cout << changeToOnes ( str ) ; return 0 ; }", "text_ms": "Operasi minimum yang diperlukan untuk menukar rentetan binari yang diberikan kepada semua 1 s | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan bilangan operasi yang diperlukan; CTR akan menyimpan bilangan yang berturut -turut pada akhir rentetan binari yang diberikan; Gelung untuk mencari bilangan 1 s pada akhir rentetan; Jika watak semasa adalah 1; Jika kita menghadapi 0 pertama dari kedudukan LSB maka kita akan memecahkan gelung; Bilangan operasi yang diperlukan ialah (L - CTR); Berfungsi untuk mengeluarkan sifar utama dari rentetan; Gelung sehingga S [i] menjadi tidak sama dengan 1; Jika kita sampai ke hujung rentetan, ini bermakna rentetan hanya mengandungi 0 's; Kembalikan rentetan tanpa nol utama; Kod pemacu; Mengeluarkan sifar terkemuka"}
{"text": "Minimum deletions required such that any number X will occur exactly X times | C ++ implementation of the approach ; Function to return the minimum deletions required ; To store the frequency of the array elements ; Store frequency of each element ; To store the minimum deletions required ; Value ; It 's frequency ; If number less than or equal to it 's frequency ; Delete extra occurrences ; Delete every occurrence of x ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int MinDeletion ( int a [ ] , int n ) { unordered_map < int , int > map ; for ( int i = 0 ; i < n ; i ++ ) map [ a [ i ] ] ++ ; int ans = 0 ; for ( auto i : map ) { int x = i . first ; int frequency = i . second ; if ( x <= frequency ) { ans += ( frequency - x ) ; } else ans += frequency ; } return ans ; } int main ( ) { int a [ ] = { 2 , 3 , 2 , 3 , 4 , 4 , 4 , 4 , 5 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << MinDeletion ( a , n ) ; return 0 ; }", "text_ms": "Penghapusan minimum diperlukan sedemikian rupa sehingga mana -mana nombor x akan berlaku tepat x kali | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan penghapusan minimum yang diperlukan; Untuk menyimpan kekerapan elemen array; Kekerapan kedai setiap elemen; Untuk menyimpan penghapusan minimum yang diperlukan; Nilai; Kekerapan itu; Jika bilangan kurang daripada atau sama dengan kekerapannya; Padam kejadian tambahan; Padam setiap kejadian x; Kod pemacu"}
{"text": "Concatenate strings in any order to get Maximum Number of \" AB \" | C ++ implementation of above approach ; Function to find maximum number of ABs ; variable A , B , AB for count strings that end with ' A ' but not end with ' B ' , ' B ' but does not end with ' A ' and ' B ' and ends with ' A ' respectively . ; ' AB ' is already present in string before concatenate them ; count of strings that begins with ' B ' and ends with 'A ; count of strings that begins with ' B ' but does not end with ' A ' ; count of strings that ends with ' A ' but not end with ' B ' ; updating the value of ans and add extra count of ' AB ' ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxCountAB ( string s [ ] , int n ) { int A = 0 , B = 0 , BA = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { string S = s [ i ] ; int L = S . size ( ) ; for ( int j = 0 ; j < L - 1 ; j ++ ) { if ( S . at ( j ) == ' A ' && S . at ( j + 1 ) == ' B ' ) { ans ++ ; } } if ( S . at ( 0 ) == ' B ' && S . at ( L - 1 ) == ' A ' ) BA ++ ; else if ( S . at ( 0 ) == ' B ' ) B ++ ; else if ( S . at ( L - 1 ) == ' A ' ) A ++ ; } if ( BA == 0 ) ans += min ( B , A ) ; else if ( A + B == 0 ) ans += BA - 1 ; else ans += BA + min ( B , A ) ; return ans ; } int main ( ) { string s [ ] = { \" ABCA \" , \" BOOK \" , \" BAND \" } ; int n = sizeof ( s ) / sizeof ( s [ 0 ] ) ; cout << maxCountAB ( s , n ) ; return 0 ; }", "text_ms": "Rentetan concatenate dalam apa -apa perintah untuk mendapatkan bilangan maksimum \"ab\" | C ++ pelaksanaan pendekatan di atas; Berfungsi untuk mencari bilangan maksimum abs; Pembolehubah A, B, AB untuk mengira rentetan yang berakhir dengan 'A' tetapi tidak berakhir dengan 'B', 'B' tetapi tidak berakhir dengan 'A' dan 'B' dan berakhir dengan 'A' masing -masing. ; 'Ab' sudah ada dalam rentetan sebelum menggabungkan mereka; Count rentetan yang bermula dengan 'B' dan berakhir dengan 'A; Count rentetan yang bermula dengan 'B' tetapi tidak berakhir dengan 'A'; Count rentetan yang berakhir dengan 'a' tetapi tidak berakhir dengan 'b'; mengemas kini nilai ANS dan menambah kiraan tambahan 'ab'; Kod pemacu"}
{"text": "Minimum operations to make sum of neighbouring elements <= X | C ++ implementation of the approach ; Function to return the minimum number of operations required ; To store total operations required ; First make all elements equal to x which are currenctly greater ; Left scan the array ; Update the current element such that neighbouring sum is < x ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int MinOperations ( int n , int x , int * arr ) { int total = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( arr [ i ] > x ) { int difference = arr [ i ] - x ; total = total + difference ; arr [ i ] = x ; } } for ( int i = 1 ; i < n ; ++ i ) { int LeftNeigbouringSum = arr [ i ] + arr [ i - 1 ] ; if ( LeftNeigbouringSum > x ) { int current_diff = LeftNeigbouringSum - x ; arr [ i ] = max ( 0 , arr [ i ] - current_diff ) ; total = total + current_diff ; } } return total ; } int main ( ) { int X = 1 ; int arr [ ] = { 1 , 6 , 1 , 2 , 0 , 4 } ; int N = sizeof ( arr ) / sizeof ( int ) ; cout << MinOperations ( N , X , arr ) ; return 0 ; }", "text_ms": "Operasi minimum untuk membuat jumlah elemen jiran <= x | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan bilangan minimum operasi yang diperlukan; Untuk menyimpan jumlah operasi yang diperlukan; Mula -mula membuat semua elemen sama dengan x yang lebih besar; Kiri mengimbas array; Kemas kini elemen semasa supaya jumlah jiran adalah <x; Kod pemacu"}
{"text": "Find the repeating and the missing number using two equations | C ++ implementation of the approach ; Function to print the required numbers ; Sum of first n natural numbers ; Sum of squares of first n natural numbers ; To store the sum and sum of squares of the array elements ; Driver code", "code": "#include <cmath> NEW_LINE #include <bits/stdc++.h> NEW_LINE #include <iostream> NEW_LINE using namespace std ; void findNumbers ( int arr [ ] , int n ) { int sumN = ( n * ( n + 1 ) ) / 2 ; int sumSqN = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; int sum = 0 , sumSq = 0 , i ; for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; sumSq = sumSq + ( pow ( arr [ i ] , 2 ) ) ; } int B = ( ( ( sumSq - sumSqN ) / ( sum - sumN ) ) + sumN - sum ) / 2 ; int A = sum - sumN + B ; cout << \" A ▁ = ▁ \" ; cout << A << endl ; cout << \" B ▁ = ▁ \" ; cout << B << endl ; } int main ( ) { int arr [ ] = { 1 , 2 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findNumbers ( arr , n ) ; return 0 ; }", "text_ms": "Cari nombor berulang dan nombor yang hilang menggunakan dua persamaan | C ++ pelaksanaan pendekatan; Berfungsi untuk mencetak nombor yang diperlukan; Jumlah nombor semulajadi n pertama; Jumlah kuadrat nombor semulajadi n pertama; Untuk menyimpan jumlah dan jumlah kuadrat unsur -unsur array; Kod pemacu"}
{"text": "Lexicographically smallest string with given string as prefix | C ++ program for the above approach ; Function to find the whether the string temp starts with str or not ; Base Case ; Check for the corresponding characters in temp & str ; Function to find lexicographic smallest string consisting of the string str as prefix ; Sort the given array string arr [ ] ; If the i - th string contains given string as a prefix , then print the result ; If no string exists then return \" - 1\" ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool is_prefix ( string temp , string str ) { if ( temp . length ( ) < str . length ( ) ) return 0 ; else { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] != temp [ i ] ) return 0 ; } return 1 ; } } string lexicographicallyString ( string input [ ] , int n , string str ) { sort ( input , input + n ) ; for ( int i = 0 ; i < n ; i ++ ) { string temp = input [ i ] ; if ( is_prefix ( temp , str ) ) { return temp ; } } return \" - 1\" ; } int main ( ) { string arr [ ] = { \" apple \" , \" appe \" , \" apl \" , \" aapl \" , \" appax \" } ; string S = \" app \" ; int N = 5 ; cout << lexicographicallyString ( arr , N , S ) ; return 0 ; }", "text_ms": "Rentetan terkecil lexicographically dengan rentetan yang diberikan sebagai awalan | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari sama ada temp rentetan bermula dengan STR atau tidak; Kes asas; Semak aksara yang sepadan dalam temp & str; Berfungsi untuk mencari rentetan terkecil lexicographic yang terdiri daripada string str as awalan; Susun rentetan array yang diberikan []; Jika rentetan i - th mengandungi rentetan yang diberikan sebagai awalan, maka cetak hasilnya; Jika tiada rentetan wujud maka kembali \" - 1\"; Kod pemacu"}
{"text": "Rearrange Array to find K using Binary Search algorithm without sorting | C ++ program for the above approach ; Function to rearrange the array ; Stores the rearranged array ; Stores whether the arrangement is possible or not ; Update K with the position of K ; Stores all elements lesser than and greater than in vector smaller and greater respectively ; Traverse the array arr [ ] ; If arr [ i ] is less than arr [ K ] ; Else ; Iterate unil low is less than or equal to high ; Stores mid point ; If mid is equal to K ; If mid is less than K ; If mid is greater than K ; If f is - 1 ; Iterate in the range [ 1 , N ] ; If ans [ i ] is equal to - 1 ; Print the rearranged array ; Driver Code ; Input ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void Rearrange ( int arr [ ] , int K , int N ) { int ans [ N + 1 ] ; int f = -1 ; for ( int i = 0 ; i < N ; i ++ ) { ans [ i ] = -1 ; } K = find ( arr , arr + N , K ) - arr ; vector < int > smaller , greater ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] < arr [ K ] ) smaller . push_back ( arr [ i ] ) ; else if ( arr [ i ] > arr [ K ] ) greater . push_back ( arr [ i ] ) ; } int low = 0 , high = N - 1 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( mid == K ) { ans [ mid ] = arr [ K ] ; f = 1 ; break ; } else if ( mid < K ) { if ( smaller . size ( ) == 0 ) { break ; } ans [ mid ] = smaller . back ( ) ; smaller . pop_back ( ) ; low = mid + 1 ; } else { if ( greater . size ( ) == 0 ) { break ; } ans [ mid ] = greater . back ( ) ; greater . pop_back ( ) ; high = mid - 1 ; } } if ( f == -1 ) { cout << -1 << endl ; return ; } for ( int i = 0 ; i < N ; i ++ ) { if ( ans [ i ] == -1 ) { if ( smaller . size ( ) ) { ans [ i ] = smaller . back ( ) ; smaller . pop_back ( ) ; } else if ( greater . size ( ) ) { ans [ i ] = greater . back ( ) ; greater . pop_back ( ) ; } } } for ( int i = 0 ; i < N ; i ++ ) cout << ans [ i ] << \" ▁ \" ; cout << endl ; } int main ( ) { int arr [ ] = { 10 , 7 , 2 , 5 , 3 , 8 } ; int K = 7 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; Rearrange ( arr , K , N ) ; return 0 ; }", "text_ms": "Susun semula Arahan untuk mencari K menggunakan algoritma carian binari tanpa menyusun | Program C ++ untuk pendekatan di atas; Berfungsi untuk menyusun semula array; Menyimpan array yang disusun semula; Kedai sama ada pengaturan itu mungkin atau tidak; Kemas kini k dengan kedudukan k; Menyimpan semua elemen yang lebih rendah daripada dan lebih besar daripada vektor yang lebih kecil dan lebih besar masing -masing; Melintasi array arr []; Jika arr [i] kurang daripada arr [k]; Lain; Iterat Unil Low kurang daripada atau sama dengan tinggi; Kedai pertengahan titik; Jika pertengahan adalah sama dengan k; Jika pertengahan kurang daripada k; Jika pertengahan lebih besar daripada k; Jika f adalah - 1; Melangkah dalam julat [1, n]; Jika Ans [i] sama dengan - 1; Cetak array yang disusun semula; Kod pemacu; Input; Panggilan fungsi"}
{"text": "Minimize K to let Person A consume at least ceil ( N / ( M + 1 ) ) candies based on given rules | C ++ program for the above approach ; Function to find minimum value of K such that the first person gets at least ( N / ( M + 1 ) ) candies ; Find the minimum required value of candies for the first person ; Iterate K from [ 1 , n ] ; Total number of candies ; Candies taken by Person 1 ; Candies taken by 1 st person is minimum of K and candies left ; Traverse the array arr [ ] ; Amount consumed by the person j ; Update the number of candies ; Good share of candies achieved ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void minimumK ( vector < int > & arr , int M , int N ) { int good = ceil ( ( N * 1.0 ) / ( ( M + 1 ) * 1.0 ) ) ; for ( int i = 1 ; i <= N ; i ++ ) { int K = i ; int candies = N ; int taken = 0 ; while ( candies > 0 ) { taken += min ( K , candies ) ; candies -= min ( K , candies ) ; for ( int j = 0 ; j < M ; j ++ ) { int consume = ( arr [ j ] * candies ) / 100 ; candies -= consume ; } } if ( taken >= good ) { cout << i ; return ; } } } int main ( ) { int N = 13 , M = 1 ; vector < int > arr = { 50 } ; minimumK ( arr , M , N ) ; return 0 ; }", "text_ms": "Kurangkan k untuk membiarkan orang mengambil sekurang -kurangnya ceil (n / (m + 1)) gula -gula berdasarkan peraturan yang diberikan | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari nilai minimum k supaya orang pertama mendapat sekurang -kurangnya (n / (m + 1)) gula -gula; Cari nilai gula -gula minimum yang diperlukan untuk orang pertama; ITERATE K dari [1, n]; Jumlah gula -gula; Gula -gula yang diambil oleh orang 1; Gula -gula yang diambil oleh 1 orang adalah minimum k dan gula -gula yang tersisa; Melintasi array arr []; Jumlah yang digunakan oleh orang j; Mengemas kini bilangan gula -gula; Bahagian yang baik dari gula -gula yang dicapai; Kod pemacu"}
{"text": "Minimize K to let Person A consume at least ceil ( N / ( M + 1 ) ) candies based on given rules | C ++ program for the above approach ; Function to check if the value of mid gives at least ( N / ( M + 1 ) ) candies or not ; Candies taken by 1 st person is minimum of K and candies left ; Traverse the given array ; Amount consumed by person j ; Update the count of candies ; Check if person 1 gets the good share of candies ; Function to find minimum value of K such that the first person gets at least ( N / ( M + 1 ) ) candies ; Find the minimum required value of candies for the first person ; Iterate until low is less than or equal to mid ; Find the value of mid ; Check for mid , whether it can be the possible value of K or not ; Update the value of hi ; Otherwise , update the value of lo ; Print the resultant minimum value of K ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( int K , int n , int m , vector < int > arr , int good_share ) { int candies = n , taken = 0 ; while ( candies > 0 ) { taken += min ( K , candies ) ; candies -= min ( K , candies ) ; for ( int j = 0 ; j < m ; j ++ ) { int consume = ( arr [ j ] * candies ) / 100 ; candies -= consume ; } } return ( taken >= good_share ) ; } void minimumK ( vector < int > & arr , int N , int M ) { int good_share = ceil ( ( N * 1.0 ) / ( ( M + 1 ) * 1.0 ) ) ; int lo = 1 , hi = N ; while ( lo < hi ) { int mid = ( lo + hi ) / 2 ; if ( check ( mid , N , M , arr , good_share ) ) { hi = mid ; } else { lo = mid + 1 ; } } cout << hi ; } int main ( ) { int N = 13 , M = 1 ; vector < int > arr = { 50 } ; minimumK ( arr , N , M ) ; return 0 ; }", "text_ms": "Kurangkan k untuk membiarkan orang mengambil sekurang -kurangnya ceil (n / (m + 1)) gula -gula berdasarkan peraturan yang diberikan | Program C ++ untuk pendekatan di atas; Fungsi untuk memeriksa sama ada nilai pertengahan memberikan sekurang -kurangnya (n / (m + 1)) gula -gula atau tidak; Gula -gula yang diambil oleh 1 orang adalah minimum k dan gula -gula yang tersisa; Melintasi array yang diberikan; Jumlah yang digunakan oleh orang j; Mengemas kini kiraan gula -gula; Semak sama ada orang 1 mendapat bahagian yang baik dari gula -gula; Fungsi untuk mencari nilai minimum k supaya orang pertama mendapat sekurang -kurangnya (n / (m + 1)) gula -gula; Cari nilai gula -gula minimum yang diperlukan untuk orang pertama; Melangkah sehingga rendah kurang dari atau sama dengan pertengahan; Cari nilai pertengahan; Semak pertengahan, sama ada ia boleh menjadi nilai k atau tidak; Kemas kini nilai hi; Jika tidak, kemas kini nilai LO; Cetak nilai minimum yang dihasilkan k; Kod pemacu"}
{"text": "Total time required to travel a path denoted by a given string | C ++ code for the above approach ; Function to calculate time taken to travel the path ; Stores total time ; Initial position ; Stores visited segments ; Check whether segment is present in the set ; Increment the value of time by 2 ; Insert segment into the set ; Print the value of time ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void calcTotalTime ( string path ) { int time = 0 ; int x = 0 , y = 0 ; set < pair < int , int > > s ; for ( int i = 0 ; i < path . size ( ) ; i ++ ) { int p = x ; int q = y ; if ( path [ i ] == ' N ' ) y ++ ; else if ( path [ i ] == ' S ' ) y -- ; else if ( path [ i ] == ' E ' ) x ++ ; else if ( path [ i ] == ' W ' ) x -- ; if ( s . find ( { p + x , q + y } ) == s . end ( ) ) { time += 2 ; s . insert ( { p + x , q + y } ) ; } else time += 1 ; } cout << time << endl ; } int main ( ) { string path = \" NSE \" ; calcTotalTime ( path ) ; return 0 ; }", "text_ms": "Jumlah masa yang diperlukan untuk mengembara jalan yang dilambangkan oleh rentetan yang diberikan | C ++ kod untuk pendekatan di atas; Fungsi untuk mengira masa yang diambil untuk perjalanan jalan; Kedai jumlah masa; Kedudukan awal; Kedai -kedai melawat segmen; Semak sama ada segmen hadir dalam set; Meningkatkan nilai masa dengan 2; Masukkan segmen ke dalam set; Cetak nilai masa; Kod pemacu"}
{"text": "Cost required to make all array elements equal to 1 | C ++ program for the above approach ; Function to calculate the cost required to make all array elements equal to 1 ; Stores the total cost ; Traverse the array arr [ ] ; If current element is 0 ; Convert 0 to 1 ; Add the cost ; Return the total cost ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findCost ( int A [ ] , int N ) { int totalCost = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] == 0 ) { A [ i ] = 1 ; totalCost += i ; } } return totalCost ; } int main ( ) { int arr [ ] = { 1 , 0 , 1 , 0 , 1 , 0 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findCost ( arr , N ) ; return 0 ; }", "text_ms": "Kos yang diperlukan untuk menjadikan semua elemen array sama dengan 1 | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira kos yang diperlukan untuk membuat semua elemen array sama dengan 1; Menyimpan jumlah kos; Melintasi array arr []; Jika elemen semasa ialah 0; Tukar 0 hingga 1; Tambah kos; Mengembalikan jumlah kos; Kod pemacu"}
{"text": "Find the peak index of a given array | C ++ program for the above approach ; Function to find the peak index for the given array ; Base Case ; Check for strictly increasing array ; If the strictly increasing condition is violated , then break ; Stores the value of i , which is a potential peak index ; Second traversal , for strictly decreasing array ; When the strictly decreasing condition is violated , then break ; If i = N - 1 , it means that ans is the peak index ; Otherwise , peak index doesn 't exist ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int peakIndex ( int arr [ ] , int N ) { if ( N < 3 ) return -1 ; int i = 0 ; while ( i + 1 < N ) { if ( arr [ i + 1 ] < arr [ i ] arr [ i ] == arr [ i + 1 ] ) break ; i ++ ; } if ( i == 0 i == N - 1 ) return -1 ; int ans = i ; while ( i < N - 1 ) { if ( arr [ i ] < arr [ i + 1 ] arr [ i ] == arr [ i + 1 ] ) break ; i ++ ; } if ( i == N - 1 ) return ans ; return -1 ; } int main ( ) { int arr [ ] = { 0 , 1 , 0 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << peakIndex ( arr , N ) << \" STRNEWLINE \" ; return 0 ; }", "text_ms": "Cari indeks puncak array yang diberikan | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari indeks puncak untuk array yang diberikan; Kes asas; Semak array yang semakin meningkat; Sekiranya keadaan yang semakin meningkat dilanggar, maka pecah; Menyimpan nilai i, yang merupakan indeks puncak yang berpotensi; Traversal kedua, untuk array yang ketat; Apabila keadaan ketat yang dikurangkan dilanggar, kemudian pecah; Jika i = n - 1, ini bermakna bahawa ANS adalah indeks puncak; Jika tidak, indeks puncak tidak wujud; Kod pemacu"}
{"text": "Given an array A [ ] and a number x , check for pair in A [ ] with sum as x | Set 2 | C ++ program for the above approach ; Function to check if the array has 2 elements whose sum is equal to the given value ; Sort the array in increasing order ; Traverse the array , nums [ ] ; Store the required number to be found ; Perform binary search ; Store the mid value ; If nums [ mid ] is greater than x , then update high to mid - 1 ; If nums [ mid ] is less than x , then update low to mid + 1 ; Otherwise ; If mid is equal i , check mid - 1 and mid + 1 ; Otherwise , print the pair and return ; If no such pair is found , then print - 1 ; Driver Code ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void hasArrayTwoPairs ( int nums [ ] , int n , int target ) { sort ( nums , nums + n ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = target - nums [ i ] ; int low = 0 , high = n - 1 ; while ( low <= high ) { int mid = low + ( ( high - low ) / 2 ) ; if ( nums [ mid ] > x ) { high = mid - 1 ; } else if ( nums [ mid ] < x ) { low = mid + 1 ; } else { if ( mid == i ) { if ( ( mid - 1 >= 0 ) && nums [ mid - 1 ] == x ) { cout << nums [ i ] << \" , ▁ \" ; cout << nums [ mid - 1 ] ; return ; } if ( ( mid + 1 < n ) && nums [ mid + 1 ] == x ) { cout << nums [ i ] << \" , ▁ \" ; cout << nums [ mid + 1 ] ; return ; } break ; } else { cout << nums [ i ] << \" , ▁ \" ; cout << nums [ mid ] ; return ; } } } } cout << -1 ; } int main ( ) { int A [ ] = { 0 , -1 , 2 , -3 , 1 } ; int X = -2 ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; hasArrayTwoPairs ( A , N , X ) ; return 0 ; }", "text_ms": "Memandangkan array A [] dan nombor x, periksa pasangan dalam [] dengan jumlah sebagai x | Tetapkan 2 | Program C ++ untuk pendekatan di atas; Fungsi untuk memeriksa sama ada array mempunyai 2 elemen yang jumlahnya sama dengan nilai yang diberikan; Menyusun array dalam peningkatan urutan; Melintasi array, nums []; Simpan nombor yang diperlukan untuk dijumpai; Melakukan carian binari; Simpan nilai pertengahan; Jika nums [mid] lebih besar daripada x, maka kemas kini tinggi hingga pertengahan - 1; Jika Nums [Mid] kurang daripada X, maka kemas kini rendah hingga pertengahan + 1; Jika tidak; Jika pertengahan adalah sama i, periksa pertengahan - 1 dan pertengahan + 1; Jika tidak, cetak pasangan dan kembali; Jika tidak ada pasangan yang dijumpai, maka cetak - 1; Kod pemacu; Panggilan fungsi"}
{"text": "Smallest divisor of N closest to X | C ++ program for the above approach ; Function to find the divisor of N closest to the target ; Iterate till square root of N ; Check if divisors are equal ; Check if i is the closest ; Check if i is the closest ; Check if n / i is the closest ; Print the closest value ; Driver Code ; Given N & X ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findClosest ( int N , int target ) { int closest = -1 ; int diff = INT_MAX ; for ( int i = 1 ; i <= sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { if ( N / i == i ) { if ( abs ( target - i ) < diff ) { diff = abs ( target - i ) ; closest = i ; } } else { if ( abs ( target - i ) < diff ) { diff = abs ( target - i ) ; closest = i ; } if ( abs ( target - N / i ) < diff ) { diff = abs ( target - N / i ) ; closest = N / i ; } } } } cout << closest ; } int main ( ) { int N = 16 , X = 5 ; findClosest ( N , X ) ; return 0 ; }", "text_ms": "Pembahagi terkecil n paling dekat dengan x | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari pembahagi n paling dekat dengan sasaran; Berulang sehingga akar persegi n; Semak jika pembahagi adalah sama; Semak jika saya adalah yang paling dekat; Semak jika saya adalah yang paling dekat; Semak jika N / I adalah yang paling dekat; Cetak nilai terdekat; Kod pemacu; Diberikan N & X; Panggilan fungsi"}
{"text": "Find a pair ( a , b ) such that Aa + Bb = N | C ++ program for the above approach ; Function to calculate the minimum power of A and B greater than N ; Stores the power of A which is greater than N ; Increment count by 1 ; Divide N by A ; Function to find a pair ( a , b ) such that A ^ a + B ^ b = N ; Calculate the minimum power of A greater than N ; Calculate the minimum power of B greater than N ; Make copy of A and B ; Traverse for every pair ( i , j ) ; Check if B ^ j + A ^ i = N To overcome the overflow problem use B = N - A rather than B + A = N ; Increment power B by 1 ; Increment power A by 1 ; Finally print - 1 if no pair is found ; Driver Code ; Given A , B and N ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int power ( long long int A , long long int N ) { int count = 0 ; if ( A == 1 ) return 0 ; while ( N ) { count ++ ; N /= A ; } return count ; } void Pairs ( long long int N , long long int A , long long int B ) { int powerA , powerB ; powerA = power ( A , N ) ; powerB = power ( B , N ) ; long long int intialB = B , intialA = A ; A = 1 ; for ( int i = 0 ; i <= powerA ; i ++ ) { B = 1 ; for ( int j = 0 ; j <= powerB ; j ++ ) { if ( B == N - A ) { cout << i << \" ▁ \" << j << endl ; return ; } B *= intialB ; } A *= intialA ; } cout << -1 << endl ; return ; } int main ( ) { long long int N = 106 , A = 3 , B = 5 ; Pairs ( N , A , B ) ; return 0 ; }", "text_ms": "Cari pasangan (a, b) seperti AA + BB = n | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira kuasa minimum a dan b lebih besar daripada n; Menyimpan kuasa A yang lebih besar daripada n; Kiraan kenaikan sebanyak 1; Bahagikan n oleh A; Fungsi untuk mencari pasangan (a, b) sedemikian rupa sehingga a ^ a + b ^ b = n; Kirakan kuasa minimum yang lebih besar daripada n; Kirakan kuasa minimum B lebih besar daripada N; Buat salinan A dan B; Melintasi setiap pasangan (i, j); Semak jika B ^ j + a ^ i = n untuk mengatasi masalah limpahan Gunakan b = n - a bukan b + a = n; Kuasa kenaikan B oleh 1; Kuasa kenaikan A sebanyak 1; Akhirnya cetak - 1 jika tiada pasangan dijumpai; Kod pemacu; Diberikan A, B dan N; Panggilan fungsi"}
{"text": "Count numbers from a given range that are not divisible by any of the array elements | C ++ program for the above approach ; Function to find the non - multiples till k ; Stores all unique multiples ; Iterate the array ; For finding duplicates only once ; Inserting all multiples into the set ; Returning only the count of numbers that are not divisible by any of the array elements ; Function to count the total values in the range [ L , R ] ; Count all values in the range using exclusion principle ; Driver Code ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findNonMultiples ( int arr [ ] , int n , int k ) { set < int > multiples ; for ( int i = 0 ; i < n ; ++ i ) { if ( multiples . find ( arr [ i ] ) == multiples . end ( ) ) { for ( int j = 1 ; j <= k / arr [ i ] ; j ++ ) { multiples . insert ( arr [ i ] * j ) ; } } } return k - multiples . size ( ) ; } int countValues ( int arr [ ] , int N , int L , int R ) { return findNonMultiples ( arr , N , R ) - findNonMultiples ( arr , N , L - 1 ) ; } int main ( ) { int arr [ ] = { 2 , 3 , 4 , 5 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int L = 1 , R = 20 ; cout << countValues ( arr , N , L , R ) ; return 0 ; }", "text_ms": "Mengira nombor dari julat tertentu yang tidak dapat dibahagikan oleh mana -mana elemen array | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari gandaan bukan sehingga k; Menyimpan semua gandaan yang unik; Melelehkan array; Untuk mencari pendua sekali sahaja; Memasukkan semua gandaan ke dalam set; Kembali hanya kiraan nombor yang tidak dapat dibahagikan oleh mana -mana elemen array; Berfungsi untuk mengira jumlah nilai dalam julat [l, r]; Mengira semua nilai dalam julat menggunakan prinsip pengecualian; Kod pemacu; Panggilan fungsi"}
{"text": "Minimum number of coins to be collected per hour to empty N piles in at most H hours | C ++ program for the above approach ; Function to find the minimum number of coins to be collected per hour to empty N piles in H hours ; Stores the minimum coins to be removed per hour ; Find the maximum array element ; Perform Binary Search ; Store the mid value of the range in K ; Find the total time taken to empty N piles by removing K coins per hour ; If total time does not exceed H ; Otherwise ; Print the required result ; Driver Code ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minCollectingSpeed ( vector < int > & piles , int H ) { int ans = -1 ; int low = 1 , high ; high = * max_element ( piles . begin ( ) , piles . end ( ) ) ; while ( low <= high ) { int K = low + ( high - low ) / 2 ; int time = 0 ; for ( int ai : piles ) { time += ( ai + K - 1 ) / K ; } if ( time <= H ) { ans = K ; high = K - 1 ; } else { low = K + 1 ; } } cout << ans ; } int main ( ) { vector < int > arr = { 3 , 6 , 7 , 11 } ; int H = 8 ; minCollectingSpeed ( arr , H ) ; return 0 ; }", "text_ms": "Bilangan minimum duit syiling yang akan dikumpulkan setiap jam untuk mengosongkan n buasir di paling banyak jam | | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari bilangan minimum duit syiling yang akan dikumpulkan setiap jam untuk mengosongkan n buasir dalam jam H; Menyimpan syiling minimum untuk dikeluarkan setiap jam; Cari elemen array maksimum; Melakukan carian binari; Simpan nilai pertengahan julat dalam k; Cari jumlah masa yang diambil untuk mengosongkan n buasir dengan mengeluarkan sy syiling sejam; Jika jumlah masa tidak melebihi h; Jika tidak; Cetak hasil yang diperlukan; Kod pemacu; Panggilan fungsi"}
{"text": "Count distinct pairs with given sum | C ++ program to implement the above approach ; Function to count distinct pairs in array whose sum equal to K ; Stores count of distinct pairs whose sum equal to K ; Sort the array ; Stores index of the left pointer ; Stores index of the right pointer ; Calculate count of distinct pairs whose sum equal to K ; If sum of current pair is equal to K ; Remove consecutive duplicate array elements ; Update i ; Remove consecutive duplicate array elements ; Update j ; Update cntPairs ; Update i ; Update j ; if sum of current pair less than K ; Update i ; Update j ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntDisPairs ( int arr [ ] , int N , int K ) { int cntPairs = 0 ; sort ( arr , arr + N ) ; int i = 0 ; int j = N - 1 ; while ( i < j ) { if ( arr [ i ] + arr [ j ] == K ) { while ( i < j && arr [ i ] == arr [ i + 1 ] ) { i ++ ; } while ( i < j && arr [ j ] == arr [ j - 1 ] ) { j -- ; } cntPairs += 1 ; i ++ ; j -- ; } else if ( arr [ i ] + arr [ j ] < K ) { i ++ ; } else { j -- ; } } return cntPairs ; } int main ( ) { int arr [ ] = { 5 , 6 , 5 , 7 , 7 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 13 ; cout << cntDisPairs ( arr , N , K ) ; }", "text_ms": "Kira pasangan yang berbeza dengan jumlah yang diberikan | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk mengira pasangan yang berbeza dalam array yang jumlahnya sama dengan k; Kedai kiraan pasangan yang berbeza yang jumlahnya sama dengan k; Susun array; Kedai indeks penunjuk kiri; Kedai indeks penunjuk yang betul; Hitung kiraan pasangan yang berbeza yang jumlahnya sama dengan k; Jika jumlah pasangan semasa adalah sama dengan k; Keluarkan elemen array duplikat berturut -turut; Kemas kini i; Keluarkan elemen array duplikat berturut -turut; Kemas kini j; Kemas kini CNTPairs; Kemas kini i; Kemas kini j; jika jumlah pasangan semasa kurang daripada k; Kemas kini i; Kemas kini j; Kod pemacu"}
{"text": "Count distinct pairs with given sum | C ++ program to implement the above approach ; Function to count distinct pairs in array whose sum equal to K ; Stores count of distinct pairs whose sum equal to K ; Store frequency of each distinct element of the array ; Update frequency of arr [ i ] ; Traverse the map ; Stores key value of the map ; If i is the half of K ; If frequency of i greater than 1 ; Update cntPairs ; Update cntPairs ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntDisPairs ( int arr [ ] , int N , int K ) { int cntPairs = 0 ; unordered_map < int , int > cntFre ; for ( int i = 0 ; i < N ; i ++ ) { cntFre [ arr [ i ] ] ++ ; } for ( auto it : cntFre ) { int i = it . first ; if ( 2 * i == K ) { if ( cntFre [ i ] > 1 ) cntPairs += 2 ; } else { if ( cntFre [ K - i ] ) { cntPairs += 1 ; } } } cntPairs = cntPairs / 2 ; return cntPairs ; } int main ( ) { int arr [ ] = { 5 , 6 , 5 , 7 , 7 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 13 ; cout << cntDisPairs ( arr , N , K ) ; }", "text_ms": "Kira pasangan yang berbeza dengan jumlah yang diberikan | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk mengira pasangan yang berbeza dalam array yang jumlahnya sama dengan k; Kedai kiraan pasangan yang berbeza yang jumlahnya sama dengan k; Kekerapan kedai setiap elemen yang berbeza dari array; Kemas kini kekerapan ARR [i]; Melintasi peta; Menyimpan nilai utama peta; Jika saya adalah separuh daripada k; Jika kekerapan saya lebih besar daripada 1; Kemas kini CNTPairs; Kemas kini CNTPairs; Kod pemacu"}
{"text": "Queries to find longest subsequence having no similar adjacent elements with updates | C ++ program for the above approach ; Function to find the length of the longest subsequence such that no two adjacent elements are equal ; Replace element at index x with y ; Since x is 1 - indexed , decrement x by 1 ; Keep track of number of elements in subsequence ; If previous element is not same as current element ; Print the desired count ; Driver Code ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void longestSubsequence ( int N , int Q , int arr [ ] , int Queries [ ] [ 2 ] ) { for ( int i = 0 ; i < Q ; i ++ ) { int x = Queries [ i ] [ 0 ] ; int y = Queries [ i ] [ 1 ] ; arr [ x - 1 ] = y ; int count = 1 ; for ( int j = 1 ; j < N ; j ++ ) { if ( arr [ j ] != arr [ j - 1 ] ) { count += 1 ; } } cout << count << ' ▁ ' ; } } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 5 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int Q = 2 ; int Queries [ Q ] [ 2 ] = { { 1 , 3 } , { 4 , 2 } } ; longestSubsequence ( N , Q , arr , Queries ) ; return 0 ; }", "text_ms": "Pertanyaan untuk mencari seterusnya yang paling lama tidak mempunyai unsur bersebelahan yang sama dengan kemas kini | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari panjang seterusnya yang paling lama supaya tidak ada dua elemen bersebelahan yang sama; Gantikan elemen pada indeks x dengan y; Oleh kerana x adalah 1 - diindeks, penurunan x oleh 1; Jejaki bilangan elemen dalam masa depan; Jika elemen sebelumnya tidak sama dengan elemen semasa; Cetak kiraan yang dikehendaki; Kod pemacu; Panggilan fungsi"}
{"text": "Queries to find longest subsequence having no similar adjacent elements with updates | C ++ program for the above approach ; Traverse the array arr [ ] ; If previous element is not same as current element ; Traverse the queries ; Replace element at index x with y ; Recalculate for index x ; Subtract contribution of element at index x ; Add contribution of y ; Recalculate for index x + 1 ; Subtract contribution of element at index x + 1 ; Adds contribution of y ; Replace the element ; Driver Code ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void longestSubsequence ( int N , int Q , int arr [ ] , int Queries [ ] [ 2 ] ) { int count = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] != arr [ i - 1 ] ) { count += 1 ; } } for ( int i = 0 ; i < Q ; i ++ ) { int x = Queries [ i ] [ 0 ] ; int y = Queries [ i ] [ 1 ] ; if ( x > 1 ) { if ( arr [ x - 1 ] != arr [ x - 2 ] ) { count -= 1 ; } if ( arr [ x - 2 ] != y ) { count += 1 ; } } if ( x < N ) { if ( arr [ x ] != arr [ x - 1 ] ) { count -= 1 ; } if ( y != arr [ x ] ) { count += 1 ; } } cout << count << ' ▁ ' ; arr [ x - 1 ] = y ; } } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 5 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int Q = 2 ; int Queries [ Q ] [ 2 ] = { { 1 , 3 } , { 4 , 2 } } ; longestSubsequence ( N , Q , arr , Queries ) ; return 0 ; }", "text_ms": "Pertanyaan untuk mencari seterusnya yang paling lama tidak mempunyai unsur bersebelahan yang sama dengan kemas kini | Program C ++ untuk pendekatan di atas; Melintasi array arr []; Jika elemen sebelumnya tidak sama dengan elemen semasa; Melintasi pertanyaan; Gantikan elemen pada indeks x dengan y; Mengira semula untuk Indeks X; Tolak sumbangan elemen pada indeks x; Tambah sumbangan y; Mengira semula untuk indeks x + 1; Tolak sumbangan elemen pada indeks x + 1; Menambah sumbangan y; Menggantikan elemen; Kod pemacu; Panggilan fungsi"}
{"text": "Sum of absolute differences of indices of occurrences of each array element | C ++ program for the above approach ; Function to find sum of differences of indices of occurrences of each unique array element ; Stores indices of each array element ; Store the indices ; Stores the sums ; Traverse the array ; Find sum for each element ; Iterate over the Map ; Calculate sum of occurrences of arr [ i ] ; Store sum for current element ; Print answer for each element ; Driver Code ; Given array ; Given size ; Function call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void sum ( int arr [ ] , int n ) { map < int , vector < int > > mp ; for ( int i = 0 ; i < n ; i ++ ) { mp [ arr [ i ] ] . push_back ( i ) ; } int ans [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( auto it : mp [ arr [ i ] ] ) { sum += abs ( it - i ) ; } ans [ i ] = sum ; } for ( int i = 0 ; i < n ; i ++ ) { cout << ans [ i ] << \" ▁ \" ; } return ; } int main ( ) { int arr [ ] = { 1 , 3 , 1 , 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sum ( arr , n ) ; return 0 ; }", "text_ms": "Jumlah perbezaan mutlak indeks kejadian setiap elemen array | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari jumlah perbezaan indeks kejadian setiap elemen array yang unik; Menyimpan indeks setiap elemen array; Simpan indeks; Menyimpan jumlahnya; Melintasi array; Cari jumlah untuk setiap elemen; Melangkah ke atas peta; Hitung jumlah kejadian ARR [i]; Simpan jumlah untuk elemen semasa; Cetak jawapan untuk setiap elemen; Kod pemacu; Diberikan array; Saiz yang diberikan; Panggilan fungsi"}
{"text": "Convert vowels into upper case character in a given string | C ++ program to implement the above approach ; Function to convert vowels into uppercase ; Stores the length of str ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string conVowUpp ( string & str ) { int N = str . length ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == ' a ' str [ i ] == ' e ' str [ i ] == ' i ' str [ i ] == ' o ' str [ i ] == ' u ' ) { str [ i ] = str [ i ] - ' a ' + ' A ' ; } } return str ; } int main ( ) { string str = \" eutopia \" ; cout << conVowUpp ( str ) ; }", "text_ms": "Tukar vokal ke dalam watak kes atas dalam rentetan yang diberikan | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk menukar vokal menjadi huruf besar; Menyimpan panjang str; Kod pemacu"}
{"text": "Maximize number of days for which P chocolates can be distributed consecutively to N people | C ++ program to implement the above approach ; Stores the frequency of each type of chocolate ; Function to check if chocolates can be eaten for ' mid ' no . of days ; If cnt exceeds N , return true ; Function to find the maximum number of days for which chocolates can be eaten ; Store the frequency of each type of chocolate ; Initialize start and end with 0 and P respectively ; Calculate mid ; Check if chocolates can be distributed for mid days ; Check if chocolates can be distributed for more than mid consecutive days ; Driver code ; Function call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; map < int , int > mp ; int N , P ; bool helper ( int mid ) { int cnt = 0 ; for ( auto i : mp ) { int temp = i . second ; while ( temp >= mid ) { temp -= mid ; cnt ++ ; } } return cnt >= N ; } int findMaximumDays ( int arr [ ] ) { for ( int i = 0 ; i < P ; i ++ ) { mp [ arr [ i ] ] ++ ; } int start = 0 , end = P , ans = 0 ; while ( start <= end ) { int mid = start + ( ( end - start ) / 2 ) ; if ( mid != 0 and helper ( mid ) ) { ans = mid ; start = mid + 1 ; } else if ( mid == 0 ) { start = mid + 1 ; } else { end = mid - 1 ; } } return ans ; } int main ( ) { N = 3 , P = 10 ; int arr [ ] = { 1 , 2 , 2 , 1 , 1 , 3 , 3 , 3 , 2 , 4 } ; cout << findMaximumDays ( arr ) ; return 0 ; }", "text_ms": "Memaksimumkan bilangan hari yang mana c coklat boleh diedarkan secara berturut -turut kepada orang -orang n | Program C ++ untuk melaksanakan pendekatan di atas; Menyimpan kekerapan setiap jenis coklat; Fungsi untuk memeriksa sama ada coklat boleh dimakan untuk 'pertengahan' tidak. hari; Jika CNT melebihi n, kembali benar; Berfungsi untuk mencari bilangan maksimum hari yang mana coklat boleh dimakan; Simpan kekerapan setiap jenis coklat; Memulakan permulaan dan berakhir dengan 0 dan P masing -masing; Hitung pertengahan; Semak jika coklat boleh diedarkan selama pertengahan hari; Semak jika coklat boleh diedarkan selama lebih dari pertengahan hari berturut -turut; Kod pemacu; Panggilan fungsi"}
{"text": "Count subarrays having sum modulo K same as the length of the subarray | C ++ program of the above approach ; Function that counts the subarrays having sum modulo k equal to the length of subarray ; Stores the count of subarrays ; Stores prefix sum of the array ; Calculate prefix sum array ; Generate all the subarrays ; Check if this subarray is a valid subarray or not ; Total count of subarrays ; Driver Code ; Given arr [ ] ; Size of the array ; Given K ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int countSubarrays ( int a [ ] , int n , int k ) { int ans = 0 ; vector < int > pref ; pref . push_back ( 0 ) ; for ( int i = 0 ; i < n ; i ++ ) pref . push_back ( ( a [ i ] + pref [ i ] ) % k ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { if ( ( pref [ j ] - pref [ i - 1 ] + k ) % k == j - i + 1 ) { ans ++ ; } } } cout << ans << ' ▁ ' ; } int main ( ) { int arr [ ] = { 2 , 3 , 5 , 3 , 1 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 4 ; countSubarrays ( arr , N , K ) ; return 0 ; }", "text_ms": "Count Subarrays yang mempunyai jumlah modulo k sama dengan panjang subarray | C ++ program pendekatan di atas; Fungsi yang mengira subarray yang mempunyai jumlah modulo k sama dengan panjang subarray; Menyimpan kiraan subarray; Kedai awalan jumlah array; Kirakan Array Jumlah Awalan; Menjana semua subarray; Semak sama ada subarray ini adalah subarray yang sah atau tidak; Jumlah kiraan subarray; Kod pemacu; Diberikan arr []; Saiz array; Diberikan k; Panggilan fungsi"}
{"text": "Count subarrays having sum modulo K same as the length of the subarray | C ++ program of the above approach ; Function that counts the subarrays s . t . sum of elements in the subarray modulo k is equal to size of subarray ; Stores the count of ( pref [ i ] - i ) % k ; Stores the count of subarray ; Stores prefix sum of the array ; Find prefix sum array ; Base Condition ; Remove the index at present after K indices from the current index ; Update the answer for subarrays ending at the i - th index ; Add the calculated value of current index to count ; Print the count of subarrays ; Driver Code ; Given arr [ ] ; Size of the array ; Given K ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int countSubarrays ( int a [ ] , int n , int k ) { unordered_map < int , int > cnt ; long long int ans = 0 ; vector < int > pref ; pref . push_back ( 0 ) ; for ( int i = 0 ; i < n ; i ++ ) pref . push_back ( ( a [ i ] + pref [ i ] ) % k ) ; cnt [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { int remIdx = i - k ; if ( remIdx >= 0 ) { cnt [ ( pref [ remIdx ] - remIdx % k + k ) % k ] -- ; } ans += cnt [ ( pref [ i ] - i % k + k ) % k ] ; cnt [ ( pref [ i ] - i % k + k ) % k ] ++ ; } cout << ans << ' ▁ ' ; } int main ( ) { int arr [ ] = { 2 , 3 , 5 , 3 , 1 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 4 ; countSubarrays ( arr , N , K ) ; return 0 ; }", "text_ms": "Count Subarrays yang mempunyai jumlah modulo k sama dengan panjang subarray | C ++ program pendekatan di atas; Fungsi yang mengira subarray s. t. Jumlah elemen dalam subarray Modulo K adalah sama dengan saiz subarray; Menyimpan kiraan (pref [i] - i) % k; Menyimpan kiraan subarray; Kedai awalan jumlah array; Cari Array Jumlah Awalan; Keadaan asas; Keluarkan indeks pada masa ini selepas indeks k dari indeks semasa; Kemas kini jawapan untuk subarrays yang berakhir pada indeks i - th; Tambah nilai yang dikira indeks semasa untuk dikira; Cetak kiraan subarray; Kod pemacu; Diberikan arr []; Saiz array; Diberikan k; Panggilan fungsi"}
{"text": "Check if all substrings of length K of a Binary String has equal count of 0 s and 1 s | C ++ program for the above approach ; Function to check if the substring of length K has equal 0 and 1 ; Traverse the string ; Check if every K - th character is the same or not ; Traverse substring of length K ; If current character is 0 ; Increment count ; Otherwise ; Decrement count ; Check for equal 0 s and 1 s ; Driver code", "code": "#include <iostream> NEW_LINE using namespace std ; int check ( string & s , int k ) { int n = s . size ( ) ; for ( int i = 0 ; i < k ; i ++ ) { for ( int j = i ; j < n ; j += k ) { if ( s [ i ] != s [ j ] ) return false ; } } int c = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( s [ i ] == '0' ) c ++ ; else c -- ; } if ( c == 0 ) return true ; else return false ; } int main ( ) { string s = \"101010\" ; int k = 2 ; if ( check ( s , k ) ) cout << \" Yes \" << endl ; else cout << \" No \" << endl ; return 0 ; }", "text_ms": "Semak jika semua substring panjang k dari rentetan binari mempunyai kiraan yang sama dengan 0 s dan 1 s | Program C ++ untuk pendekatan di atas; Fungsi untuk memeriksa sama ada substring panjang k mempunyai sama 0 dan 1; Melintasi rentetan; Semak sama ada setiap watak k - th adalah sama atau tidak; Melintasi substring panjang k; Jika watak semasa adalah 0; Kiraan kenaikan; Jika tidak; Kiraan pengurangan; Semak sama 0 s dan 1 s; Kod pemacu"}
{"text": "Check if characters of a given string can be used to form any N equal strings | C ++ program for the above approach ; Function to check if the freq of any character is divisible by N ; Stores the frequency of characters ; If frequency of a character is not divisible by n ; If no character has frequency at least N ; Driver Code ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isSame ( string str , int n ) { map < int , int > mp ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { mp [ str [ i ] - ' a ' ] ++ ; } for ( auto it : mp ) { if ( ( it . second ) >= n ) { return true ; } } return false ; } int main ( ) { string str = \" ccabcba \" ; int n = 4 ; if ( isSame ( str , n ) ) { cout << \" Yes \" ; } else { cout << \" No \" ; } }", "text_ms": "Semak jika watak -watak rentetan yang diberikan boleh digunakan untuk membentuk sebarang rentetan yang sama | Program C ++ untuk pendekatan di atas; Fungsi untuk memeriksa sama ada freq dari mana -mana watak boleh dibahagikan dengan n; Menyimpan kekerapan aksara; Jika kekerapan watak tidak dapat dibahagikan dengan n; Jika tiada watak mempunyai kekerapan sekurang -kurangnya n; Kod pemacu; Panggilan fungsi"}
{"text": "Find the root of given non decreasing function between A and B | C ++ program for the above approach ; Given function ; Function to find the root of the given non - decreasing Function ; To get the minimum possible answer for the root ; Find mid ; Search in [ low , x ] ; Search in [ x , high ] ; Return the required answer ; Function to find the roots of the given equation within range [ a , b ] ; If root doesn 't exists ; Else find the root upto 4 decimal places ; Driver Code ; Given range ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define eps  1e-6 NEW_LINE double func ( double a , double b , double c , double x ) { return a * x * x + b * x + c ; } double findRoot ( double a , double b , double c , double low , double high ) { double x ; while ( fabs ( high - low ) > eps ) { x = ( low + high ) / 2 ; if ( func ( a , b , c , low ) * func ( a , b , c , x ) <= 0 ) { high = x ; } else { low = x ; } } return x ; } void solve ( double a , double b , double c , double A , double B ) { if ( func ( a , b , c , A ) * func ( a , b , c , B ) > 0 ) { cout << \" No ▁ solution \" ; } else { cout << fixed << setprecision ( 4 ) << findRoot ( a , b , c , A , B ) ; } } int main ( ) { double a = 2 , b = -3 , c = -2 , A = 0 , B = 3 ; solve ( a , b , c , A , B ) ; return 0 ; }", "text_ms": "Cari akar fungsi yang tidak berkurangan antara a dan b | Program C ++ untuk pendekatan di atas; Fungsi yang diberikan; Fungsi untuk mencari akar fungsi yang tidak berkurangan; Untuk mendapatkan jawapan minimum yang mungkin untuk akar; Cari pertengahan; Cari di [rendah, x]; Cari di [x, tinggi]; Mengembalikan jawapan yang diperlukan; Berfungsi untuk mencari akar persamaan yang diberikan dalam julat [a, b]; Jika akar tidak wujud; Lain mencari akar sehingga 4 tempat perpuluhan; Kod pemacu; Julat yang diberikan; Panggilan fungsi"}
{"text": "Median of difference of all pairs from an Array | C ++ Program to implement the above approach ; Function check if mid can be median index of the difference array ; Size of the array ; Total possible no of pair possible ; The index of the element in the difference of all pairs from the array ; Count the number of pairs having difference <= mid ; If the difference between end and first element is less then or equal to mid ; Checking for the no of element less than or equal to mid is greater than median or not ; Function to calculate the median of differences of all pairs from the array ; Size of the array ; Initialising the low and high ; Binary search ; Calculate mid ; If mid can be the median of the array ; Returning the median of the differences of pairs from the array ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE #define ll  long long NEW_LINE using namespace std ; bool possible ( ll mid , vector < ll > & a ) { ll n = a . size ( ) ; ll total = ( n * ( n - 1 ) ) / 2 ; ll need = ( total + 1 ) / 2 ; ll count = 0 ; ll start = 0 , end = 1 ; while ( end < n ) { if ( a [ end ] - a [ start ] <= mid ) { end ++ ; } else { count += ( end - start - 1 ) ; start ++ ; } } if ( end == n && start < end && a [ end - 1 ] - a [ start ] <= mid ) { ll t = end - start - 1 ; count += ( t * ( t + 1 ) / 2 ) ; } if ( count >= need ) return true ; else return false ; } ll findMedian ( vector < ll > & a ) { ll n = a . size ( ) ; ll low = 0 , high = a [ n - 1 ] - a [ 0 ] ; while ( low <= high ) { ll mid = ( low + high ) / 2 ; if ( possible ( mid , a ) ) high = mid - 1 ; else low = mid + 1 ; } return high + 1 ; } int main ( ) { vector < ll > a = { 1 , 7 , 5 , 2 } ; sort ( a . begin ( ) , a . end ( ) ) ; cout << findMedian ( a ) << endl ; }", "text_ms": "Median perbezaan semua pasangan dari array | Program C ++ untuk melaksanakan pendekatan di atas; Pemeriksaan fungsi jika pertengahan boleh menjadi indeks median pelbagai perbezaan; Saiz array; Jumlah mungkin tidak ada pasangan yang mungkin; Indeks elemen dalam perbezaan semua pasangan dari array; Kira bilangan pasangan yang mempunyai perbezaan <= MID; Jika perbezaan antara akhir dan elemen pertama kurang atau sama dengan pertengahan; Memeriksa unsur tidak kurang daripada atau sama dengan pertengahan adalah lebih besar daripada median atau tidak; Fungsi untuk mengira median perbezaan semua pasangan dari array; Saiz array; Memulakan yang rendah dan tinggi; Carian binari; Hitung pertengahan; Jika pertengahan boleh menjadi median array; Mengembalikan median perbezaan pasangan dari array; Kod pemacu"}
{"text": "Print all Strings from array A [ ] having all strings from array B [ ] as subsequence | C ++ Program to implement the above approach ; Function to find strings from A [ ] having all strings in B [ ] as subsequence ; Calculate respective sizes ; Stores the answer ; Stores the frequency of each character in strings of A [ ] ; Compute the frequencies of characters of all strings ; Stores the frequency of each character in strings of B [ ] each character of a string in B [ ] ; If the frequency of a character in B [ ] exceeds that in A [ ] ; A string exists in B [ ] which is not a proper subset of A [ i ] ; If all strings in B [ ] are proper subset of A [ ] ; Push the string in resultant vector ; If any string is found ; Print those strings ; Otherwise ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void UniversalSubset ( vector < string > A , vector < string > B ) { int n1 = A . size ( ) ; int n2 = B . size ( ) ; vector < string > res ; int A_fre [ n1 ] [ 26 ] ; for ( int i = 0 ; i < n1 ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) A_fre [ i ] [ j ] = 0 ; } for ( int i = 0 ; i < n1 ; i ++ ) { for ( int j = 0 ; j < A [ i ] . size ( ) ; j ++ ) { A_fre [ i ] [ A [ i ] [ j ] - ' a ' ] ++ ; } } int B_fre [ 26 ] = { 0 } ; for ( int i = 0 ; i < n2 ; i ++ ) { int arr [ 26 ] = { 0 } ; for ( int j = 0 ; j < B [ i ] . size ( ) ; j ++ ) { arr [ B [ i ] [ j ] - ' a ' ] ++ ; B_fre [ B [ i ] [ j ] - ' a ' ] = max ( B_fre [ B [ i ] [ j ] - ' a ' ] , arr [ B [ i ] [ j ] - ' a ' ] ) ; } } for ( int i = 0 ; i < n1 ; i ++ ) { int flag = 0 ; for ( int j = 0 ; j < 26 ; j ++ ) { if ( A_fre [ i ] [ j ] < B_fre [ j ] ) { flag = 1 ; break ; } } if ( flag == 0 ) res . push_back ( A [ i ] ) ; } if ( res . size ( ) ) { for ( int i = 0 ; i < res . size ( ) ; i ++ ) { for ( int j = 0 ; j < res [ i ] . size ( ) ; j ++ ) cout << res [ i ] [ j ] ; } cout << \" ▁ \" ; } else cout << \" - 1\" ; } int main ( ) { vector < string > A = { \" geeksforgeeks \" , \" topcoder \" , \" leetcode \" } ; vector < string > B = { \" geek \" , \" ee \" } ; UniversalSubset ( A , B ) ; return 0 ; }", "text_ms": "Cetak semua rentetan dari array a [] mempunyai semua rentetan dari array b [] sebagai berikutnya | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari rentetan dari [] mempunyai semua rentetan dalam b [] sebagai seterusnya; Hitung saiz masing -masing; Menyimpan jawapannya; Menyimpan kekerapan setiap watak dalam rentetan []; Kirakan frekuensi watak semua rentetan; Menyimpan kekerapan setiap aksara dalam rentetan b [] setiap watak rentetan dalam b []; Jika kekerapan watak dalam b [] melebihi itu dalam []; Rentetan wujud dalam B [] yang bukan subset yang betul dari [i]; Jika semua rentetan dalam b [] adalah subset yang betul dari []; Tolak rentetan dalam vektor yang dihasilkan; Jika ada rentetan yang dijumpai; Cetak rentetan itu; Jika tidak; Kod pemacu"}
{"text": "Closest pair in an Array such that one number is multiple of the other | C ++ program for the above approach ; Function to find the minimum distance pair where one is the multiple of the other ; Initialize the variables ; Iterate for all the elements ; Loop to make pairs ; Check for minimum distance ; Check if one is a multiple of other ; Update the distance ; Store indexes ; If no such pair exists ; Print the answer ; Driver Code ; Given array arr [ ] ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPair ( int a [ ] , int n ) { int min_dist = INT_MAX ; int index_a = -1 , index_b = -1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( j - i < min_dist ) { if ( a [ i ] % a [ j ] == 0 a [ j ] % a [ i ] == 0 ) { min_dist = j - i ; index_a = i ; index_b = j ; } } } } if ( index_a == -1 ) { cout << ( \" - 1\" ) ; } else { cout << \" ( \" << a [ index_a ] << \" , ▁ \" << a [ index_b ] << \" ) \" ; } } int main ( ) { int a [ ] = { 2 , 3 , 4 , 5 , 6 } ; int n = sizeof ( a ) / sizeof ( int ) ; findPair ( a , n ) ; }", "text_ms": "Pasangan terdekat dalam array supaya satu nombor adalah pelbagai yang lain | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari pasangan jarak minimum di mana seseorang adalah pelbagai yang lain; Memulakan pembolehubah; Melangkah untuk semua elemen; Gelung untuk membuat pasangan; Semak jarak minimum; Semak jika seseorang adalah pelbagai yang lain; Mengemas kini jarak; Indeks kedai; Jika tidak ada pasangan seperti itu; Cetak jawapannya; Kod pemacu; Diberikan array arr []; Panggilan fungsi"}
{"text": "Print all numbers in given range having digits in strictly increasing order | C ++ program for the above approach ; Function to print all numbers in the range [ L , R ] having digits in strictly increasing order ; Iterate over the range ; Iterate over the digits ; Check if the current digit is >= the previous digit ; If the digits are in ascending order ; Driver Code ; Given range L and R ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printNum ( int L , int R ) { for ( int i = L ; i <= R ; i ++ ) { int temp = i ; int c = 10 ; int flag = 0 ; while ( temp > 0 ) { if ( temp % 10 >= c ) { flag = 1 ; break ; } c = temp % 10 ; temp /= 10 ; } if ( flag == 0 ) cout << i << \" ▁ \" ; } } int main ( ) { int L = 10 , R = 15 ; printNum ( L , R ) ; return 0 ; }", "text_ms": "Cetak semua nombor dalam julat yang diberikan dengan digit dalam perintah yang semakin meningkat | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencetak semua nombor dalam julat [l, r] yang mempunyai digit dalam urutan yang semakin meningkat; Melangkah ke atas julat; Melangkah ke atas digit; Semak sama ada digit semasa adalah> = digit sebelumnya; Sekiranya digit berada dalam urutan menaik; Kod pemacu; Diberikan julat l dan r; Panggilan fungsi"}
{"text": "Find the missing number in unordered Arithmetic Progression | C ++ program for the above approach ; Function to find the missing element ; Fix left and right boundary for binary search ; Find index of middle element ; Check if the element just after the middle element is missing ; Check if the element just before mid is missing ; Check if the elements till mid follow the AP , then recur for right half ; Else recur for left half ; Function to find the missing element in AP series ; Sort the array arr [ ] ; Calculate Common Difference ; Binary search for the missing ; Driver Code ; Given array arr [ ] ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMissing ( int arr [ ] , int left , int right , int diff ) { if ( right <= left ) return INT_MAX ; int mid = left + ( right - left ) / 2 ; if ( arr [ mid + 1 ] - arr [ mid ] != diff ) return ( arr [ mid ] + diff ) ; if ( mid > 0 && arr [ mid ] - arr [ mid - 1 ] != diff ) return ( arr [ mid - 1 ] + diff ) ; if ( arr [ mid ] == arr [ 0 ] + mid * diff ) return findMissing ( arr , mid + 1 , right , diff ) ; return findMissing ( arr , left , mid - 1 , diff ) ; } int missingElement ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int diff = ( arr [ n - 1 ] - arr [ 0 ] ) / n ; return findMissing ( arr , 0 , n - 1 , diff ) ; } int main ( ) { int arr [ ] = { 2 , 8 , 6 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << missingElement ( arr , n ) ; return 0 ; }", "text_ms": "Cari nombor yang hilang dalam perkembangan aritmetik yang tidak teratur | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari elemen yang hilang; Betulkan sempadan kiri dan kanan untuk carian binari; Cari Indeks Elemen Tengah; Semak jika elemen hanya selepas elemen tengah hilang; Semak jika elemen sebelum pertengahan hilang; Semak jika unsur -unsur sehingga pertengahan mengikuti AP, kemudian berulang untuk separuh kanan; Lain berulang untuk separuh kiri; Berfungsi untuk mencari elemen yang hilang dalam siri AP; Susun array arr []; Mengira perbezaan biasa; Pencarian binari untuk yang hilang; Kod pemacu; Diberikan array arr []; Panggilan fungsi"}
{"text": "Floor value Kth root of a number using Recursive Binary Search | C ++ program for the above approach ; Function to calculate x raised to the power y in O ( logn ) ; Function to find the Kth root of the number N using BS ; If the range is still valid ; Find the mid - value of range ; Base Case ; Condition to check if the left search space is useless ; Driver Code ; Given N and K ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int power ( int x , unsigned int y ) { int temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else return x * temp * temp ; } int nthRootSearch ( int low , int high , int N , int K ) { if ( low <= high ) { int mid = ( low + high ) / 2 ; if ( ( power ( mid , K ) <= N ) && ( power ( mid + 1 , K ) > N ) ) { return mid ; } else if ( power ( mid , K ) < N ) { return nthRootSearch ( mid + 1 , high , N , K ) ; } else { return nthRootSearch ( low , mid - 1 , N , K ) ; } } return low ; } int main ( ) { int N = 16 , K = 4 ; cout << nthRootSearch ( 0 , N , N , K ) << endl ; return 0 ; }", "text_ms": "Nilai lantai kth akar nombor menggunakan carian binari rekursif | Program C ++ untuk pendekatan di atas; Berfungsi untuk mengira x yang dibangkitkan kepada kuasa y dalam o (logn); Berfungsi untuk mencari akar kth nombor n menggunakan BS; Sekiranya julat masih sah; Cari nilai pertengahan julat; Kes asas; Keadaan untuk memeriksa sama ada ruang carian kiri tidak berguna; Kod pemacu; Diberikan n dan k; Panggilan fungsi"}
{"text": "Count of subsets having sum of min and max element less than K | C ++ program to print count of subsets S such that min ( S ) + max ( S ) < K ; Function that return the count of subset such that min ( S ) + max ( S ) < K ; Sorting the array ; ans stores total number of subsets ; add all possible subsets between i and j ; Decrease the sum ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int get_subset_count ( int arr [ ] , int K , int N ) { sort ( arr , arr + N ) ; int left , right ; left = 0 ; right = N - 1 ; int ans = 0 ; while ( left <= right ) { if ( arr [ left ] + arr [ right ] < K ) { ans += 1 << ( right - left ) ; left ++ ; } else { right -- ; } } return ans ; } int main ( ) { int arr [ ] = { 2 , 4 , 5 , 7 } ; int K = 8 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << get_subset_count ( arr , K , N ) ; return 0 ; }", "text_ms": "Count subset yang mempunyai jumlah elemen min dan max kurang daripada k | C ++ program untuk mencetak kiraan subset s seperti min (s) + max (s) <k; Fungsi yang mengembalikan kiraan subset sedemikian rupa sehingga min (s) + max (s) <k; Menyusun array; Ans menyimpan jumlah subset; Tambah semua subset yang mungkin antara I dan J; Mengurangkan jumlah; Kod pemacu"}
{"text": "Minimize the maximum difference of adjacent elements after at most K insertions | C ++ Program to find the minimum of maximum differerence between adjacent elements after at most K insertions ; Calculate the maximum adjacent difference ; If the maximum adjacent difference is already zero ; best and worst specifies range of the maximum adjacent difference ; To store the no of insertions required for respective values of mid ; If the number of insertions required exceeds K ; Otherwise ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minMaxDiff ( int arr [ ] , int n , int k ) { int max_adj_dif = INT_MIN ; for ( int i = 0 ; i < n - 1 ; i ++ ) max_adj_dif = max ( max_adj_dif , abs ( arr [ i ] - arr [ i + 1 ] ) ) ; if ( max_adj_dif == 0 ) return 0 ; int best = 1 ; int worst = max_adj_dif ; int mid , required ; while ( best < worst ) { mid = ( best + worst ) / 2 ; required = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { required += ( abs ( arr [ i ] - arr [ i + 1 ] ) - 1 ) / mid ; } if ( required > k ) best = mid + 1 ; else worst = mid ; } return worst ; } int main ( ) { int arr [ ] = { 3 , 12 , 25 , 50 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 7 ; cout << minMaxDiff ( arr , n , k ) ; return 0 ; }", "text_ms": "Kurangkan perbezaan maksimum unsur -unsur bersebelahan selepas kebanyakan sisipan k | Program C ++ untuk mencari perbezaan maksimum maksimum antara unsur -unsur bersebelahan selepas kebanyakan penyisipan K; Kirakan perbezaan bersebelahan maksimum; Jika perbezaan bersebelahan maksimum sudah sifar; Terbaik dan terburuk menentukan pelbagai perbezaan bersebelahan maksimum; Untuk menyimpan tidak ada sisipan yang diperlukan untuk nilai masing -masing MID; Jika bilangan sisipan diperlukan melebihi k; Jika tidak; Kod pemacu"}
{"text": "Check if minimum element in array is less than or equals half of every other element | C ++ implementation to Check if the minimum element in the array is greater than or equal to half of every other elements ; Function to Check if the minimum element in the array is greater than or equal to half of every other element ; Initialise the variables to store smallest and second smallest ; Check if current element is smaller than smallest , the current smallest will become secondSmallest and current element will be the new smallest ; Check if current element is smaller than secondSmallest simply update the latter ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkMin ( int arr [ ] , int len ) { int smallest = INT_MAX , secondSmallest = INT_MAX ; for ( int i = 0 ; i < len ; i ++ ) { if ( arr [ i ] < smallest ) { secondSmallest = smallest ; smallest = arr [ i ] ; } else if ( arr [ i ] < secondSmallest ) { secondSmallest = arr [ i ] ; } } if ( 2 * smallest <= secondSmallest ) cout << \" Yes \" ; else cout << \" No \" ; } int main ( ) { int arr [ ] = { 2 , 3 , 4 , 5 } ; int len = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; checkMin ( arr , len ) ; }", "text_ms": "Semak jika elemen minimum dalam array kurang daripada atau sama dengan separuh daripada setiap elemen lain | Pelaksanaan C ++ untuk memeriksa sama ada elemen minimum dalam array adalah lebih besar daripada atau sama dengan separuh daripada setiap elemen lain; Fungsi untuk memeriksa sama ada elemen minimum dalam array adalah lebih besar daripada atau sama dengan separuh daripada setiap elemen lain; Memulakan pembolehubah untuk menyimpan terkecil terkecil dan kedua terkecil; Semak jika elemen semasa lebih kecil daripada yang terkecil, terkecil semasa akan menjadi unsur detik yang paling teruk dan semasa akan menjadi yang terkecil baru; Semak jika elemen semasa lebih kecil daripada saat yang paling kecil hanya mengemas kini yang terakhir; Kod pemacu"}
{"text": "Largest and smallest Fibonacci numbers in an Array | C ++ program to find minimum and maximum fibonacci number in given array ; Function to create hash table to check Fibonacci numbers ; Insert initial two numbers in the hash table ; Sum of previous two numbers ; Update the variable each time ; Function to find minimum and maximum fibonacci number in given array ; Find maximum value in the array ; Creating a set containing all Fibonacci numbers up to maximum value in the array ; For storing the Minimum and Maximum Fibonacci number ; Check if current element is a fibonacci number ; Update the maximum and minimum accordingly ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void createHash ( set < int > & hash , int maxElement ) { int prev = 0 , curr = 1 ; hash . insert ( prev ) ; hash . insert ( curr ) ; while ( curr <= maxElement ) { int temp = curr + prev ; hash . insert ( temp ) ; prev = curr ; curr = temp ; } } void fibonacci ( int arr [ ] , int n ) { int max_val = * max_element ( arr , arr + n ) ; set < int > hash ; createHash ( hash , max_val ) ; int minimum = INT_MAX ; int maximum = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { if ( hash . find ( arr [ i ] ) != hash . end ( ) ) { minimum = min ( minimum , arr [ i ] ) ; maximum = max ( maximum , arr [ i ] ) ; } } cout << minimum << \" , ▁ \" << maximum << endl ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; fibonacci ( arr , n ) ; return 0 ; }", "text_ms": "Nombor fibonacci terbesar dan terkecil dalam array | Program C ++ untuk mencari nombor fibonacci minimum dan maksimum dalam array yang diberikan; Fungsi untuk membuat jadual hash untuk memeriksa nombor Fibonacci; Masukkan dua nombor awal dalam jadual hash; Jumlah dua nombor sebelumnya; Kemas kini pembolehubah setiap kali; Berfungsi untuk mencari nombor fibonacci minimum dan maksimum dalam array yang diberikan; Cari nilai maksimum dalam array; Mewujudkan satu set yang mengandungi semua nombor Fibonacci sehingga nilai maksimum dalam array; Untuk menyimpan nombor Fibonacci minimum dan maksimum; Semak jika elemen semasa adalah nombor Fibonacci; Mengemas kini maksimum dan minimum yang sewajarnya; Kod pemacu"}
{"text": "Longest substring with K unique characters using Binary Search | C ++ implementation of the approach ; Function that returns true if there is a substring of length len with <= k unique characters ; Size of the string ; Map to store the characters and their frequency ; Update the map for the first substring ; Check for the rest of the substrings ; Add the new character ; Remove the first character of the previous window ; Update the map ; Function to return the length of the longest substring which has K unique characters ; Check if the complete string contains K unique characters ; Size of the string ; Apply binary search ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isValidLen ( string s , int len , int k ) { int n = s . size ( ) ; unordered_map < char , int > mp ; int right = 0 ; while ( right < len ) { mp [ s [ right ] ] ++ ; right ++ ; } if ( mp . size ( ) <= k ) return true ; while ( right < n ) { mp [ s [ right ] ] ++ ; mp [ s [ right - len ] ] -- ; if ( mp [ s [ right - len ] ] == 0 ) mp . erase ( s [ right - len ] ) ; if ( mp . size ( ) <= k ) return true ; right ++ ; } return mp . size ( ) <= k ; } int maxLenSubStr ( string s , int k ) { set < char > uni ; for ( auto x : s ) uni . insert ( x ) ; if ( uni . size ( ) < k ) return -1 ; int n = s . size ( ) ; int lo = -1 , hi = n + 1 ; while ( hi - lo > 1 ) { int mid = lo + hi >> 1 ; if ( isValidLen ( s , mid , k ) ) lo = mid ; else hi = mid ; } return lo ; } int main ( ) { string s = \" aabacbebebe \" ; int k = 3 ; cout << maxLenSubStr ( s , k ) ; return 0 ; }", "text_ms": "Substring terpanjang dengan K aksara unik menggunakan carian binari | C ++ pelaksanaan pendekatan; Fungsi yang mengembalikan benar jika terdapat substring panjang len dengan <= k aksara unik; Saiz rentetan; Peta untuk menyimpan watak dan kekerapannya; Kemas kini peta untuk substring pertama; Periksa selebihnya substrings; Tambah watak baru; Keluarkan watak pertama tetingkap sebelumnya; Kemas kini peta; Berfungsi untuk mengembalikan panjang substring terpanjang yang mempunyai aksara unik K; Semak sama ada rentetan lengkap mengandungi aksara unik K; Saiz rentetan; Memohon carian binari; Kod pemacu"}
{"text": "Largest area square in an array when elements can be shuffled | C ++ implementation of the approach ; Function that returns true if it is possible to make a square with side equal to l ; To store the count of elements greater than or equal to l ; Increment the count ; If the count becomes greater than or equal to l ; Function to return the maximum area of the square that can be obtained ; If square is possible with side length m ; Try to find a square with smaller side length ; Return the area ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isSquarePossible ( int arr [ ] , int n , int l ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= l ) cnt ++ ; if ( cnt >= l ) return true ; } return false ; } int maxArea ( int arr [ ] , int n ) { int l = 0 , r = n ; int len = 0 ; while ( l <= r ) { int m = l + ( ( r - l ) / 2 ) ; if ( isSquarePossible ( arr , n , m ) ) { len = m ; l = m + 1 ; } else r = m - 1 ; } return ( len * len ) ; } int main ( ) { int arr [ ] = { 1 , 3 , 4 , 5 , 5 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << maxArea ( arr , n ) ; return 0 ; }", "text_ms": "Dataran Kawasan Terbesar di Array Apabila Elemen Boleh Dipandu | C ++ pelaksanaan pendekatan; Fungsi yang mengembalikan benar jika mungkin untuk membuat persegi dengan sisi sama dengan L; Untuk menyimpan kiraan elemen yang lebih besar daripada atau sama dengan L; Kenaikan kiraan; Jika kiraan menjadi lebih besar daripada atau sama dengan L; Berfungsi untuk mengembalikan kawasan maksimum dataran yang boleh diperolehi; Jika persegi mungkin dengan panjang sisi m; Cuba cari persegi dengan panjang sampingan yang lebih kecil; Mengembalikan kawasan itu; Kod pemacu"}
{"text": "Check duplicates in a stream of strings | C ++ implementation of the approach ; Function to insert the names and check whether they appear for the first time ; To store the names of the employees ; If current name is appearing for the first time ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void insertNames ( string arr [ ] , int n ) { unordered_set < string > set ; for ( int i = 0 ; i < n ; i ++ ) { if ( set . find ( arr [ i ] ) == set . end ( ) ) { cout << \" No STRNEWLINE \" ; set . insert ( arr [ i ] ) ; } else { cout << \" Yes STRNEWLINE \" ; } } } int main ( ) { string arr [ ] = { \" geeks \" , \" for \" , \" geeks \" } ; int n = sizeof ( arr ) / sizeof ( string ) ; insertNames ( arr , n ) ; return 0 ; }", "text_ms": "Semak pendua dalam aliran rentetan | C ++ pelaksanaan pendekatan; Fungsi untuk memasukkan nama dan periksa sama ada ia muncul untuk kali pertama; Untuk menyimpan nama pekerja; Jika nama semasa muncul untuk kali pertama; Kod pemacu"}
{"text": "Count the triplets such that A [ i ] < B [ j ] < C [ k ] | C ++ implementation of the approach ; Function to return the count of elements in arr [ ] which are less than the given key ; Modified binary search ; Function to return the count of elements in arr [ ] which are greater than the given key ; Modified binary search ; Function to return the count of the required triplets ; Sort all three arrays ; Iterate for all the elements of array B ; Count of elements in A [ ] which are less than the chosen element from B [ ] ; Count of elements in C [ ] which are greater than the chosen element from B [ ] ; Update the count ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countLessThan ( int arr [ ] , int n , int key ) { int l = 0 , r = n - 1 ; int index = -1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( arr [ m ] < key ) { l = m + 1 ; index = m ; } else { r = m - 1 ; } } return ( index + 1 ) ; } int countGreaterThan ( int arr [ ] , int n , int key ) { int l = 0 , r = n - 1 ; int index = -1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( arr [ m ] <= key ) { l = m + 1 ; } else { r = m - 1 ; index = m ; } } if ( index == -1 ) return 0 ; return ( n - index ) ; } int countTriplets ( int n , int * a , int * b , int * c ) { sort ( a , a + n ) ; sort ( b , b + n ) ; sort ( c , c + n ) ; int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int current = b [ i ] ; int a_index = -1 , c_index = -1 ; int low = countLessThan ( a , n , current ) ; int high = countGreaterThan ( c , n , current ) ; count += ( low * high ) ; } return count ; } int main ( ) { int a [ ] = { 1 , 5 } ; int b [ ] = { 2 , 4 } ; int c [ ] = { 3 , 6 } ; int size = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << countTriplets ( size , a , b , c ) ; return 0 ; }", "text_ms": "Kira tiga kali ganda supaya A [i] <b [j] <c [k] | C ++ pelaksanaan pendekatan; Fungsi untuk mengembalikan kiraan elemen dalam arr [] yang kurang daripada kunci yang diberikan; Carian binari yang diubah suai; Fungsi untuk mengembalikan kiraan elemen dalam arr [] yang lebih besar daripada kunci yang diberikan; Carian binari yang diubah suai; Berfungsi untuk mengembalikan kiraan tiga kali ganda yang diperlukan; Menyusun ketiga -tiga tatasusunan; Melangkah untuk semua elemen array b; Kiraan elemen dalam [] yang kurang daripada elemen yang dipilih dari B []; Kiraan unsur -unsur dalam C [] yang lebih besar daripada elemen yang dipilih dari B []; Mengemas kini kiraan; Kod pemacu"}
{"text": "Cost to Balance the parentheses | CPP code to calculate the minimum cost to make the given parentheses balanced ; To store absolute count of balanced and unbalanced parenthesis ; o ( open bracket ) stores count of ' ( ' and c ( close bracket ) stores count of ' ) ' ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int costToBalance ( string s ) { if ( s . length ( ) == 0 ) cout << 0 << endl ; int ans = 0 ; int o = 0 , c = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == ' ( ' ) o ++ ; if ( s [ i ] == ' ) ' ) c ++ ; } if ( o != c ) return -1 ; int a [ s . size ( ) ] ; if ( s [ 0 ] == ' ( ' ) a [ 0 ] = 1 ; else a [ 0 ] = -1 ; if ( a [ 0 ] < 0 ) ans += abs ( a [ 0 ] ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == ' ( ' ) a [ i ] = a [ i - 1 ] + 1 ; else a [ i ] = a [ i - 1 ] - 1 ; if ( a [ i ] < 0 ) ans += abs ( a [ i ] ) ; } return ans ; } int main ( ) { string s ; s = \" ) ) ) ( ( ( \" ; cout << costToBalance ( s ) << endl ; s = \" ) ) ( ( \" ; cout << costToBalance ( s ) << endl ; return 0 ; }", "text_ms": "Kos untuk mengimbangi kurungan | Kod CPP untuk mengira kos minimum untuk membuat tanda kurung yang diberikan seimbang; Untuk menyimpan kiraan mutlak kurungan yang seimbang dan tidak seimbang; o (pendakap terbuka) menyimpan kiraan '(' dan c (pendakap dekat) kiraan ')'; Kod pemacu"}
{"text": "Middle of three using minimum comparisons | CPP program to find middle of three distinct numbers ; Function to find the middle of three number ; x is positive if a is greater than b . x is negative if b is greater than a . ; Similar to x ; Similar to x and y . ; Checking if b is middle ( x and y both are positive ) ; Checking if c is middle ( x and z both are positive ) ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int middleOfThree ( int a , int b , int c ) { int x = a - b ; int y = b - c ; int z = a - c ; if ( x * y > 0 ) return b ; else if ( x * z > 0 ) return c ; else return a ; } int main ( ) { int a = 20 , b = 30 , c = 40 ; cout << middleOfThree ( a , b , c ) ; return 0 ; }", "text_ms": "Pertengahan tiga menggunakan perbandingan minimum | Program CPP untuk mencari pertengahan tiga nombor yang berbeza; Berfungsi untuk mencari pertengahan tiga nombor; x adalah positif jika a lebih besar daripada b. x adalah negatif jika b lebih besar daripada a. ; Sama seperti x; Sama seperti x dan y. ; Memeriksa jika B adalah tengah (X dan Y kedua -duanya adalah positif); Memeriksa jika C adalah tengah (x dan z kedua -duanya positif); Kod pemacu"}
{"text": "Find four missing numbers in an array containing elements from 1 to N | CPP program to find missing 4 elements in an array of size N where elements are in range from 1 to N + 4. ; Finds missing 4 numbers in O ( N ) time and O ( 1 ) auxiliary space . ; To keep track of 4 possible numbers greater than length of input array In Java , helper is automatically initialized as 0. ; Traverse the input array and mark visited elements either by marking them as negative in arr [ ] or in helper [ ] . ; If element is smaller than or equal to length , mark its presence in arr [ ] ; Mark presence in helper [ ] ; Print all those elements whose presence is not marked . ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void missing4 ( int arr [ ] , int n ) { int helper [ 4 ] ; for ( int i = 0 ; i < n ; i ++ ) { int temp = abs ( arr [ i ] ) ; if ( temp <= n ) arr [ temp - 1 ] *= ( -1 ) ; else if ( temp > n ) { if ( temp % n != 0 ) helper [ temp % n - 1 ] = -1 ; else helper [ ( temp % n ) + n - 1 ] = -1 ; } } for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] > 0 ) cout << ( i + 1 ) << \" ▁ \" ; for ( int i = 0 ; i < 4 ; i ++ ) if ( helper [ i ] >= 0 ) cout << ( n + i + 1 ) << \" ▁ \" ; return ; } int main ( ) { int arr [ ] = { 1 , 7 , 3 , 12 , 5 , 10 , 8 , 4 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; missing4 ( arr , n ) ; return 0 ; }", "text_ms": "Cari empat nombor yang hilang dalam array yang mengandungi elemen dari 1 hingga n | Program CPP untuk mencari 4 elemen yang hilang dalam pelbagai saiz n di mana unsur -unsur berada dalam jarak dari 1 hingga n + 4 .; Menemukan 4 nombor dalam O (n) masa dan O (1) ruang tambahan. ; Untuk menjejaki 4 nombor yang mungkin lebih besar daripada panjang input di Java, penolong secara automatik diasaskan sebagai 0 .; Melintasi array input dan menandakan unsur -unsur yang dilawati sama ada dengan menandakan mereka sebagai negatif dalam arr [] atau dalam pembantu []. ; Jika elemen lebih kecil daripada atau sama dengan panjang, tandakan kehadirannya di arr []; Mark kehadiran dalam pembantu []; Cetak semua elemen yang kehadirannya tidak ditandakan. ; Kod pemacu"}
{"text": "Permutation present at the middle of lexicographic ordering of permutations of at most length N made up integers up to K | C ++ program for the above approach ; Function that finds the middle the lexicographical smallest sequence ; If K is even ; First element is K / 2 ; Remaining elements of the sequence are all integer K ; Stores the sequence when K is odd ; Iterate over the range [ 0 , N / 2 ] ; Check if the sequence ends with in 1 or not ; Remove the sequence ending in 1 ; If it doesn 't end in 1 ; Decrement by 1 ; Insert K to the sequence till its size is N ; Print the sequence stored in the vector ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void lexiMiddleSmallest ( int K , int N ) { if ( K % 2 == 0 ) { cout << K / 2 << \" ▁ \" ; for ( int i = 0 ; i < N - 1 ; ++ i ) { cout << K << \" ▁ \" ; } cout << \" STRNEWLINE \" ; exit ( 0 ) ; } vector < int > a ( N , ( K + 1 ) / 2 ) ; for ( int i = 0 ; i < N / 2 ; ++ i ) { if ( a . back ( ) == 1 ) { a . pop_back ( ) ; } else { -- a . back ( ) ; while ( ( int ) a . size ( ) < N ) { a . push_back ( K ) ; } } } for ( auto i : a ) { cout << i << \" ▁ \" ; } cout << \" STRNEWLINE \" ; } int main ( ) { int K = 2 , N = 4 ; lexiMiddleSmallest ( K , N ) ; return 0 ; }", "text_ms": "Permutasi yang hadir di tengah -tengah pesanan leksikografi permutasi paling panjang n yang terdiri daripada bilangan bulat sehingga k | Program C ++ untuk pendekatan di atas; Fungsi yang menemui tengah -tengah urutan terkecil leksikografi; Jika k ada; Elemen pertama ialah K / 2; Unsur -unsur yang tersisa dari urutan adalah semua integer k; Menyimpan urutan apabila k adalah ganjil; Melangkah ke atas julat [0, n / 2]; Semak sama ada urutan berakhir dengan 1 atau tidak; Keluarkan urutan yang berakhir dalam 1; Sekiranya ia tidak berakhir dalam 1; Penurunan sebanyak 1; Masukkan k ke urutan sehingga saiznya adalah n; Cetak urutan yang disimpan dalam vektor; Kod pemacu"}
{"text": "Remaining array element after repeated removal of the smallest element from pairs with absolute difference of 2 or 0 | C ++ program for the above approach ; Function to find the last remaining array element after repeatedly removing the smallest from pairs having absolute difference 2 or 0 ; Sort the given array in ascending order ; Traverse the array ; If difference between adjacent elements is not equal to 0 or 2 ; If operations can be performed ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findLastElement ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; int i = 0 ; for ( i = 1 ; i < N ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] != 0 && arr [ i ] - arr [ i - 1 ] != 2 ) { cout << \" - 1\" << endl ; return ; } } cout << arr [ N - 1 ] << endl ; } int main ( ) { int arr [ ] = { 2 , 4 , 6 , 8 , 0 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findLastElement ( arr , N ) ; return 0 ; }", "text_ms": "Elemen array yang tinggal selepas penyingkiran elemen terkecil dari pasangan dengan perbezaan mutlak 2 atau 0 | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari elemen array yang terakhir selepas berulang kali mengeluarkan terkecil dari pasangan yang mempunyai perbezaan mutlak 2 atau 0; Susun array yang diberikan dalam urutan menaik; Melintasi array; Jika perbezaan antara unsur -unsur bersebelahan tidak sama dengan 0 atau 2; Jika operasi boleh dilakukan; Kod pemacu"}
{"text": "Maximize count of subsets into which the given array can be split such that it satisfies the given condition | C ++ program for the above approach ; Function to count maximum subsets into which the given array can be split such that it satisfies the given condition ; Sort the array in decreasing order ; Stores count of subsets possible ; Stores count of elements in current subset ; Traverse the array arr [ ] ; Update size ; If product of the smallest element present in the current subset and size of current subset is >= K ; Update maxSub ; Update size ; Driver Code ; Given array ; Size of the array ; Given value of X", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxDivisions ( int arr [ ] , int N , int X ) { sort ( arr , arr + N , greater < int > ( ) ) ; int maxSub = 0 ; int size = 0 ; for ( int i = 0 ; i < N ; i ++ ) { size ++ ; if ( arr [ i ] * size >= X ) { maxSub ++ ; size = 0 ; } } cout << maxSub << endl ; } int main ( ) { int arr [ ] = { 1 , 3 , 3 , 7 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int X = 3 ; maxDivisions ( arr , N , X ) ; return 0 ; }", "text_ms": "Memaksimumkan kiraan subset ke mana array yang diberikan dapat dibahagikan sehingga ia memenuhi syarat yang diberikan | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira subset maksimum ke mana array yang diberikan dapat dibahagikan sehingga ia memenuhi syarat yang diberikan; Susun array dalam penurunan urutan; Kedai -kedai Count Subset mungkin; Kedai mengira unsur -unsur dalam subset semasa; Melintasi array arr []; Saiz kemas kini; Jika produk elemen terkecil yang terdapat dalam subset semasa dan saiz subset semasa ialah> = k; Kemas kini MaxSub; Saiz kemas kini; Kod pemacu; Diberikan array; Saiz array; Diberi nilai x"}
{"text": "Maximize sum of second minimums in all quadruples of a given array | C ++ program for the above approach ; Function to find maximum possible sum of second minimums in each quadruple ; Sort the array ; Add the second minimum ; Print maximum possible sum ; Driver Code ; Given array ; Size of the array", "code": "#include <iostream> NEW_LINE #include <bits/stdc++.h> NEW_LINE using namespace std ; void maxPossibleSum ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; int sum = 0 ; int j = N - 3 ; while ( j >= 0 ) { sum += arr [ j ] ; j -= 3 ; } cout << sum ; } int main ( ) { int arr [ ] = { 7 , 4 , 5 , 2 , 3 , 1 , 5 , 9 } ; int N = 8 ; maxPossibleSum ( arr , N ) ; return 0 ; }", "text_ms": "Memaksimumkan jumlah minimum kedua dalam semua empat kali ganda dari array yang diberikan | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari jumlah maksimum minimum minimum kedua dalam setiap empat kali ganda; Susun array; Tambah minimum kedua; Cetak jumlah maksimum yang mungkin; Kod pemacu; Diberikan array; Saiz array"}
{"text": "Difference between Insertion sort and Selection sort | C ++ program for the insertion sort ; Function to sort an array using insertion sort ; Move elements of arr [ 0. . i - 1 ] , that are greater than key to one position ahead of their current position ; Function to print an array of size N ; Print the array ; Driver Code ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void insertionSort ( int arr [ ] , int n ) { int i , key , j ; for ( i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; j = i - 1 ; while ( j >= 0 && arr [ j ] > key ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } arr [ j + 1 ] = key ; } } void printArray ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { cout << arr [ i ] << \" ▁ \" ; } cout << endl ; } int main ( ) { int arr [ ] = { 12 , 11 , 13 , 5 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; insertionSort ( arr , N ) ; printArray ( arr , N ) ; return 0 ; }", "text_ms": "Perbezaan antara jenis penyisipan dan pilihan pemilihan | Program C ++ untuk jenis penyisipan; Berfungsi untuk menyusun array menggunakan jenis penyisipan; Gerakkan unsur -unsur ARR [0 .. i - 1], yang lebih besar daripada kunci kepada satu kedudukan di hadapan kedudukan semasa mereka; Berfungsi untuk mencetak pelbagai saiz n; Cetak array; Kod pemacu; Panggilan fungsi"}
{"text": "Count pairs ( i , j ) from given array such that i K * arr [ j ] | C ++ program for the above approach ; Function to find the count required pairs ; Stores count of pairs ; Traverse the array ; Check if the condition is satisfied or not ; Driver Code ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int getPairs ( int arr [ ] , int N , int K ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] > K * arr [ i + 1 ] ) count ++ ; } } cout << count ; } int main ( ) { int arr [ ] = { 5 , 6 , 2 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 2 ; getPairs ( arr , N , K ) ; return 0 ; }", "text_ms": "Kiraan pasangan (i, j) dari array yang diberikan supaya saya k * arr [j] | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari kiraan pasangan yang diperlukan; Kedai kiraan pasangan; Melintasi array; Periksa sama ada keadaan itu berpuas hati atau tidak; Kod pemacu; Panggilan fungsi"}
{"text": "Count pairs ( i , j ) from given array such that i K * arr [ j ] | C ++ program for the above approach ; Function to merge two sorted arrays ; i : index to left subarray ; j : index to right subarray ; Stores count of pairs that satisfy the given condition ; Traverse to check for the valid conditions ; If condition satisfies ; All elements in the right side of the left subarray also satisfies ; Sort the two given arrays and store in the resultant array ; Elements which are left in the left subarray ; Elements which are left in the right subarray ; Return the count obtained ; Function to partition array into two halves ; Same as ( l + r ) / 2 , but avoids overflow for large l and h ; Sort first and second halves ; Call the merging function ; Function to print the count of required pairs using Merge Sort ; Driver code ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int merge ( int arr [ ] , int temp [ ] , int l , int m , int r , int K ) { int i = l ; int j = m + 1 ; int cnt = 0 ; for ( int l = 0 ; i <= m ; i ++ ) { bool found = false ; while ( j <= r ) { if ( arr [ i ] >= K * arr [ j ] ) { found = true ; } else break ; j ++ ; } if ( found ) { cnt += j - ( m + 1 ) ; j -- ; } } int k = l ; i = l ; j = m + 1 ; while ( i <= m && j <= r ) { if ( arr [ i ] <= arr [ j ] ) temp [ k ++ ] = arr [ i ++ ] ; else temp [ k ++ ] = arr [ j ++ ] ; } while ( i <= m ) temp [ k ++ ] = arr [ i ++ ] ; while ( j <= r ) temp [ k ++ ] = arr [ j ++ ] ; for ( int i = l ; i <= r ; i ++ ) arr [ i ] = temp [ i ] ; return cnt ; } int mergeSortUtil ( int arr [ ] , int temp [ ] , int l , int r , int K ) { int cnt = 0 ; if ( l < r ) { int m = ( l + r ) / 2 ; cnt += mergeSortUtil ( arr , temp , l , m , K ) ; cnt += mergeSortUtil ( arr , temp , m + 1 , r , K ) ; cnt += merge ( arr , temp , l , m , r , K ) ; } return cnt ; } int mergeSort ( int arr [ ] , int N , int K ) { int temp [ N ] ; cout << mergeSortUtil ( arr , temp , 0 , N - 1 , K ) ; } int main ( ) { int arr [ ] = { 5 , 6 , 2 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 2 ; mergeSort ( arr , N , K ) ; return 0 ; }", "text_ms": "Kiraan pasangan (i, j) dari array yang diberikan supaya saya k * arr [j] | Program C ++ untuk pendekatan di atas; Berfungsi untuk menggabungkan dua susunan yang disusun; i: indeks ke subarray kiri; J: Indeks ke Subarray Kanan; Kedai kiraan pasangan yang memenuhi syarat yang diberikan; Melintasi untuk memeriksa keadaan yang sah; Jika keadaan memenuhi; Semua elemen di sebelah kanan subarray kiri juga memuaskan; Susun dua tatasusunan yang diberikan dan simpan dalam array yang dihasilkan; Unsur -unsur yang tersisa di subarray kiri; Unsur -unsur yang tersisa di subarray kanan; Mengembalikan kiraan yang diperoleh; Berfungsi untuk memisahkan array menjadi dua bahagian; Sama seperti (L + R) / 2, tetapi mengelakkan limpahan untuk L dan H yang besar; Menyusun bahagian pertama dan kedua; Hubungi fungsi penggabungan; Berfungsi untuk mencetak kiraan pasangan yang diperlukan menggunakan jenis gabungan; Kod pemacu; Panggilan fungsi"}
{"text": "Minimize consecutive removals of elements of the same type to empty given array | C ++ implementation of the above approach ; Function to count minimum consecutive removals of elements of the same type ; Sort the array ; Stores the maximum element present in the array ; Stores sum of the array ; Calculate sum of the array ; Driver Code ; Function call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void minRemovals ( int A [ ] , int N ) { sort ( A , A + N ) ; int mx = A [ N - 1 ] ; int sum = 1 ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; } if ( sum - mx >= mx ) { cout << 0 << \" STRNEWLINE \" ; } else { cout << 2 * mx - sum << \" STRNEWLINE \" ; } } int main ( ) { int A [ ] = { 3 , 3 , 2 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; minRemovals ( A , N ) ; return 0 ; }", "text_ms": "Kurangkan penyingkiran berturut -turut unsur -unsur jenis yang sama untuk kosong yang diberikan | C ++ pelaksanaan pendekatan di atas; Fungsi untuk mengira penyingkiran minimum berturut -turut unsur -unsur jenis yang sama; Susun array; Menyimpan elemen maksimum yang terdapat dalam array; Kedai jumlah array; Hitung jumlah array; Kod pemacu; Panggilan fungsi"}
{"text": "Rearrange given array such that no array element is same as its index | C ++ program for the above approach ; Function to rearrange the array a [ ] such that none of the array elements is same as its index ; Sort the array ; Traverse the indices [ 0 , N - 2 ] of the given array ; Check if the current element is equal to its index ; If found to be true , swap current element with the next element ; Check if the last element is same as its index ; If found to be true , swap current element with the previous element ; Print the modified array ; Driver Code ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void rearrangeArray ( int a [ ] , int n ) { sort ( a , a + n ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( a [ i ] == i + 1 ) { swap ( a [ i ] , a [ i + 1 ] ) ; } } if ( a [ n - 1 ] == n ) { swap ( a [ n - 1 ] , a [ n - 2 ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { cout << a [ i ] << \" ▁ \" ; } } int main ( ) { int arr [ ] = { 1 , 5 , 3 , 2 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; rearrangeArray ( arr , N ) ; return 0 ; }", "text_ms": "Menyusun semula array yang diberikan supaya tiada elemen array yang sama dengan indeksnya | Program C ++ untuk pendekatan di atas; Berfungsi untuk menyusun semula array a [] supaya tidak ada unsur array yang sama dengan indeksnya; Susun array; Melintasi indeks [0, n - 2] dari array yang diberikan; Periksa sama ada elemen semasa adalah sama dengan indeksnya; Jika didapati benar, swap elemen semasa dengan elemen seterusnya; Semak jika elemen terakhir adalah sama dengan indeksnya; Jika didapati benar, swap elemen semasa dengan elemen sebelumnya; Cetak array yang diubah suai; Kod pemacu; Panggilan fungsi"}
{"text": "Count minimum number of moves to front or end to sort an array | C ++ program for the above approach ; Function that counts the minimum moves required to covert arr [ ] to brr [ ] ; Base Case ; If arr [ i ] < arr [ j ] ; Include the current element ; Otherwise , excluding the current element ; Function that counts the minimum moves required to sort the array ; If both the arrays are equal ; No moves required ; Otherwise ; Print minimum operations required ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( int arr1 [ ] , int arr2 [ ] , int i , int j , int n ) { int f = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr1 [ i ] != arr2 [ i ] ) f = 1 ; break ; } if ( f == 0 ) return 0 ; if ( i >= n j >= n ) return 0 ; if ( arr1 [ i ] < arr2 [ j ] ) return 1 + minOperations ( arr1 , arr2 , i + 1 , j + 1 , n ) ; return max ( minOperations ( arr1 , arr2 , i , j + 1 , n ) , minOperations ( arr1 , arr2 , i + 1 , j , n ) ) ; } void minOperationsUtil ( int arr [ ] , int n ) { int brr [ n ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ i ] = arr [ i ] ; sort ( brr , brr + n ) ; int f = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != brr [ i ] ) f = 1 ; break ; } if ( f == 1 ) cout << ( minOperations ( arr , brr , 0 , 0 , n ) ) ; else cout << \"0\" ; } int main ( ) { int arr [ ] = { 4 , 7 , 2 , 3 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; minOperationsUtil ( arr , n ) ; }", "text_ms": "Kira bilangan minimum bergerak ke depan atau akhir untuk menyusun array | Program C ++ untuk pendekatan di atas; Fungsi yang mengira langkah minimum yang diperlukan untuk rahsia ARR [] kepada BRR []; Kes asas; Jika arr [i] <arr [j]; Termasuk elemen semasa; Jika tidak, tidak termasuk elemen semasa; Fungsi yang mengira langkah minimum yang diperlukan untuk menyusun array; Jika kedua -dua tatasusunan adalah sama; Tiada langkah yang diperlukan; Jika tidak; Mencetak operasi minimum yang diperlukan; Kod pemacu"}
{"text": "Check if a string can be transformed to another by sorting substrings | C ++ Program to implement the above approach ; Function to check if str1 can be transformed to t by sorting substrings ; Occur [ i ] stores the indices of char ( ' a ' + i ) in string s ; idx [ i ] stores the next available index of char ( ' a ' + i ) in occur [ i ] ; If this char is not available anymore ; Conversion not possible ; If one of the smaller characters is available and occurs before ; Conversion not possible ; Print the answer ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void canTransform ( string & s , string & t ) { int n = s . length ( ) ; vector < int > occur [ 26 ] ; for ( int x = 0 ; x < n ; x ++ ) { char ch = s [ x ] - ' a ' ; occur [ ch ] . push_back ( x ) ; } vector < int > idx ( 26 , 0 ) ; bool poss = true ; for ( int x = 0 ; x < n ; x ++ ) { char ch = t [ x ] - ' a ' ; if ( idx [ ch ] >= occur [ ch ] . size ( ) ) { poss = false ; break ; } for ( int small = 0 ; small < ch ; small ++ ) { if ( idx [ small ] < occur [ small ] . size ( ) && occur [ small ] [ idx [ small ] ] < occur [ ch ] [ idx [ ch ] ] ) { poss = false ; break ; } } idx [ ch ] ++ ; } if ( poss ) { cout << \" Yes \" << endl ; } else { cout << \" No \" << endl ; } } int main ( ) { string s , t ; s = \" hdecb \" ; t = \" cdheb \" ; canTransform ( s , t ) ; return 0 ; }", "text_ms": "Semak jika rentetan boleh diubah kepada yang lain dengan menyusun substrings | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk memeriksa sama ada Str1 boleh diubah menjadi T dengan menyusun substrings; Berlaku [i] menyimpan indeks char ('a' + i) dalam rentetan s; Idx [i] menyimpan indeks char yang tersedia seterusnya ('a' + i) berlaku [i]; Sekiranya char ini tidak tersedia lagi; Penukaran tidak mungkin; Jika salah satu watak yang lebih kecil tersedia dan berlaku sebelum ini; Penukaran tidak mungkin; Cetak jawapannya; Kod pemacu"}
{"text": "Check whether two strings can be made equal by reversing substring of equal length from both strings | C ++ program for the above approach ; function to count inversion count of the string ; for storing frequency ; Add all the characters which are less than the ith character before i . ; adding the count to inversion count ; updating the character in the frequency array ; function to check whether any of the string have a repeated character ; function to check whether the string S1 and S2 can be made equal by reversing sub strings of same size in both strings ; frequency array to check whether both string have same character or not ; adding the frequency ; ; if the character is not in S1 ; decrementing the frequency ; If both string doesnot have same characters or not ; finding inversion count of both strings ; If inversion count is same , or have same parity or if any of the string have a repeated character then the answer is Yes else No ; driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int inversionCount ( string & s ) { int freq [ 26 ] = { 0 } ; int inv = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int temp = 0 ; for ( int j = 0 ; j < int ( s [ i ] - ' a ' ) ; j ++ ) temp += freq [ j ] ; inv += ( i - temp ) ; freq [ s [ i ] - ' a ' ] ++ ; } return inv ; } bool haveRepeated ( string & S1 , string & S2 ) { int freq [ 26 ] = { 0 } ; for ( char i : S1 ) { if ( freq [ i - ' a ' ] > 0 ) return true ; freq [ i - ' a ' ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) freq [ i ] = 0 ; for ( char i : S2 ) { if ( freq [ i - ' a ' ] > 0 ) return true ; freq [ i - ' a ' ] ++ ; } return false ; } void checkToMakeEqual ( string S1 , string S2 ) { int freq [ 26 ] = { 0 } ; for ( int i = 0 ; i < S1 . length ( ) ; i ++ ) { freq [ S1 [ i ] - ' a ' ] ++ ; } bool flag = 0 ; for ( int i = 0 ; i < S2 . length ( ) ; i ++ ) { if ( freq [ S2 [ i ] - ' a ' ] == 0 ) { flag = true ; break ; } freq [ S2 [ i ] - ' a ' ] -- ; } if ( flag == true ) { cout << \" No STRNEWLINE \" ; return ; } int invCount1 = inversionCount ( S1 ) ; int invCount2 = inversionCount ( S2 ) ; if ( invCount1 == invCount2 || ( invCount1 & 1 ) == ( invCount2 & 1 ) || haveRepeated ( S1 , S2 ) ) { cout << \" Yes STRNEWLINE \" ; } else cout << \" No STRNEWLINE \" ; } int main ( ) { string S1 = \" abbca \" , S2 = \" acabb \" ; checkToMakeEqual ( S1 , S2 ) ; return 0 ; }", "text_ms": "Semak sama ada dua rentetan boleh dibuat sama dengan membalikkan substring panjang yang sama dari kedua -dua rentetan | Program C ++ untuk pendekatan di atas; fungsi untuk mengira kiraan penyongsangan rentetan; untuk menyimpan kekerapan; Tambah semua watak yang kurang daripada watak ITH sebelum saya. ; Menambah kiraan kepada kiraan penyongsangan; mengemas kini watak dalam pelbagai frekuensi; berfungsi untuk memeriksa sama ada mana -mana rentetan mempunyai watak berulang; fungsi untuk memeriksa sama ada String S1 dan S2 boleh dibuat sama dengan membalikkan sub rentetan saiz yang sama dalam kedua -dua rentetan; Arahan kekerapan untuk memeriksa sama ada kedua -dua rentetan mempunyai watak yang sama atau tidak; menambah kekerapan; ; Jika watak tidak berada di S1; menurunkan kekerapan; Jika kedua -dua rentetan tidak mempunyai aksara yang sama atau tidak; mencari kiraan penyongsangan kedua -dua rentetan; Jika kiraan penyongsangan adalah sama, atau mempunyai pariti yang sama atau jika mana -mana rentetan mempunyai watak berulang maka jawapannya ya tidak lagi; kod pemacu"}
{"text": "Sort a Bitonic Array | C ++ program for the above approach ; Function to Sort a Bitonic array in constant space ; Initialize the value of k ; In each iteration compare elements k distance apart and swap if they are not in order ; k is reduced to half after every iteration ; Print the array elements ; Driver Code ; Given array arr [ ] ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void sortArr ( int a [ ] , int n ) { int i , k ; k = ( int ) log2 ( n ) ; k = pow ( 2 , k ) ; while ( k > 0 ) { for ( i = 0 ; i + k < n ; i ++ ) if ( a [ i ] > a [ i + k ] ) swap ( a [ i ] , a [ i + k ] ) ; k = k / 2 ; } for ( i = 0 ; i < n ; i ++ ) { cout << a [ i ] << \" ▁ \" ; } } int main ( ) { int arr [ ] = { 5 , 20 , 30 , 40 , 36 , 33 , 25 , 15 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sortArr ( arr , n ) ; return 0 ; }", "text_ms": "Susun Arahan Bitonic | Program C ++ untuk pendekatan di atas; Berfungsi untuk menyusun array bitonic dalam ruang malar; Memulakan nilai k; Dalam setiap lelaran Bandingkan Elemen K jarak jauh dan bertukar jika mereka tidak teratur; K dikurangkan kepada separuh selepas setiap lelaran; Cetak elemen array; Kod pemacu; Diberikan array arr []; Panggilan fungsi"}
{"text": "Split array into K subsets to maximize their sum of maximums and minimums | C ++ Program to implement the above approach ; Function that prints the maximum sum possible ; Find elements in each group ; Sort all elements in non - descending order ; Add K largest elements ; For sum of minimum elements from each subset ; Printing the maximum sum ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void maximumSum ( int arr [ ] , int n , int k ) { int elt = n / k ; int sum = 0 ; sort ( arr , arr + n ) ; int count = 0 ; int i = n - 1 ; while ( count < k ) { sum += arr [ i ] ; i -- ; count ++ ; } count = 0 ; i = 0 ; while ( count < k ) { sum += arr [ i ] ; i += elt - 1 ; count ++ ; } cout << sum << \" STRNEWLINE \" ; } int main ( ) { int Arr [ ] = { 1 , 13 , 7 , 17 , 6 , 5 } ; int K = 2 ; int size = sizeof ( Arr ) / sizeof ( Arr [ 0 ] ) ; maximumSum ( Arr , size , K ) ; return 0 ; }", "text_ms": "Split array ke dalam sub subset untuk memaksimumkan jumlah maksimum dan minimum mereka | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi yang mencetak jumlah maksimum yang mungkin; Cari elemen dalam setiap kumpulan; Menyusun semua elemen dalam perintah bukan menurun; Tambah un elemen terbesar; Untuk jumlah elemen minimum dari setiap subset; Mencetak jumlah maksimum; Kod pemacu"}
{"text": "Minimize sum of smallest elements from K subsequences of length L | C ++ Program to find the minimum possible sum of the smallest elements from K subsequences ; Function to find the minimum sum ; Sort the array ; Calculate sum of smallest K elements ; Return the sum ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinSum ( int arr [ ] , int K , int L , int size ) { if ( K * L > size ) return -1 ; int minsum = 0 ; sort ( arr , arr + size ) ; for ( int i = 0 ; i < K ; i ++ ) minsum += arr [ i ] ; return minsum ; } int main ( ) { int arr [ ] = { 2 , 15 , 5 , 1 , 35 , 16 , 67 , 10 } ; int K = 3 ; int L = 2 ; int length = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMinSum ( arr , K , L , length ) ; return 0 ; }", "text_ms": "Kurangkan jumlah unsur -unsur terkecil dari k -lekukan panjang l | Program C ++ untuk mencari jumlah minimum elemen terkecil dari kaum K; Berfungsi untuk mencari jumlah minimum; Susun array; Hitung jumlah elemen k terkecil; Mengembalikan jumlahnya; Kod pemacu"}
{"text": "Kth smallest or largest element in unsorted Array | Set 4 | C ++ program for the above approach ; Function to find the Kth smallest element in Unsorted Array ; Initialize the max Element as 0 ; Iterate arr [ ] and find the maximum element in it ; Frequency array to store the frequencies ; Counter variable ; Counting the frequencies ; Iterate through the freq [ ] ; Check if num is present in the array ; Increment the counter with the frequency of num ; Checking if we have reached the Kth smallest element ; Return the Kth smallest element ; Driver Code ; Given array ; Function Call", "code": "#include <iostream> NEW_LINE using namespace std ; int findKthSmallest ( int arr [ ] , int n , int k ) { int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } int counter [ max + 1 ] = { 0 } ; int smallest = 0 ; for ( int i = 0 ; i < n ; i ++ ) { counter [ arr [ i ] ] ++ ; } for ( int num = 1 ; num <= max ; num ++ ) { if ( counter [ num ] > 0 ) { smallest += counter [ num ] ; } if ( smallest >= k ) { return num ; } } } int main ( ) { int arr [ ] = { 7 , 1 , 4 , 4 , 20 , 15 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 5 ; cout << findKthSmallest ( arr , N , K ) ; return 0 ; }", "text_ms": "KTH elemen terkecil atau terbesar dalam array yang tidak disusun | Tetapkan 4 | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari elemen terkecil kth dalam array yang tidak disusun; Memulakan elemen max sebagai 0; ARR [] dan cari elemen maksimum di dalamnya; Arahan kekerapan untuk menyimpan frekuensi; Pemboleh ubah kaunter; Mengira frekuensi; Melangkah melalui freq []; Semak sama ada NUM terdapat dalam array; Meningkatkan kaunter dengan kekerapan NUM; Memeriksa jika kita telah mencapai elemen terkecil KTH; Mengembalikan elemen terkecil kth; Kod pemacu; Diberikan array; Panggilan fungsi"}
{"text": "Generate all numbers up to N in Lexicographical Order | C ++ Program to implement the above approach ; Function to print all the numbers up to n in lexicographical order ; Driver Program", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void lexNumbers ( int n ) { vector < string > s ; for ( int i = 1 ; i <= n ; i ++ ) { s . push_back ( to_string ( i ) ) ; } sort ( s . begin ( ) , s . end ( ) ) ; vector < int > ans ; for ( int i = 0 ; i < n ; i ++ ) ans . push_back ( stoi ( s [ i ] ) ) ; for ( int i = 0 ; i < n ; i ++ ) cout << ans [ i ] << \" ▁ \" ; } int main ( ) { int n = 15 ; lexNumbers ( n ) ; return 0 ; }", "text_ms": "Menjana semua nombor sehingga n dalam urutan leksikografi | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mencetak semua nombor sehingga n dalam urutan leksikografi; Program Pemandu"}
{"text": "Sort Matrix in alternating ascending and descending order rowwise | C ++ implementation to print row of matrix in ascending or descending order alternatively ; Iterate matrix rowwise ; Sort even rows in ascending order ; compare adjacent elements ; swap adjacent element ; Sort even rows in descending order ; compare adjacent elements ; swap adjacent element ; Printing the final Output ; Driver code", "code": "#include <stdio.h> NEW_LINE #define N  4 NEW_LINE void func ( int a [ ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) { if ( i % 2 == 0 ) { for ( int j = 0 ; j < N ; j ++ ) { for ( int k = j + 1 ; k < N ; ++ k ) { if ( a [ i ] [ j ] > a [ i ] [ k ] ) { int temp = a [ i ] [ j ] ; a [ i ] [ j ] = a [ i ] [ k ] ; a [ i ] [ k ] = temp ; } } } } else { for ( int j = 0 ; j < N ; j ++ ) { for ( int k = j + 1 ; k < N ; ++ k ) { if ( a [ i ] [ j ] < a [ i ] [ k ] ) { int temp = a [ i ] [ j ] ; a [ i ] [ j ] = a [ i ] [ k ] ; a [ i ] [ k ] = temp ; } } } } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { printf ( \" % d ▁ \" , a [ i ] [ j ] ) ; } printf ( \" STRNEWLINE \" ) ; } } int main ( ) { int a [ N ] [ N ] = { { 5 , 7 , 3 , 4 } , { 9 , 5 , 8 , 2 } , { 6 , 3 , 8 , 1 } , { 5 , 8 , 9 , 3 } } ; func ( a ) ; return 0 ; }", "text_ms": "Susun Matriks dalam Perintah Menaik dan Menurun Rowwise | C ++ pelaksanaan untuk mencetak baris matriks dalam urutan menaik atau menurun secara alternatif; Matriks iterate rowwise; Menyusun baris dalam urutan menaik; Bandingkan unsur -unsur bersebelahan; swap elemen bersebelahan; Menyusun baris dalam urutan menurun; Bandingkan unsur -unsur bersebelahan; swap elemen bersebelahan; Mencetak output akhir; Kod pemacu"}
{"text": "Find weight of MST in a complete graph with edge | C ++ Program to find weight of minimum spanning tree in a complete graph where edges have weight either 0 or 1 ; To store the edges of the given graph ; A utility function to perform DFS Traversal ; Check those vertices which are stored in the set ; Vertices are included if the weight of edge is 0 ; A utility function to find the weight of Minimum Spanning Tree ; To count the connected components ; Inserting the initial vertices in the set ; Traversing vertices stored in the set and Run DFS Traversal for each vertices ; Incrementing the zero weight connected components ; DFS Traversal for every vertex remove ; Driver 's Code ; Insert edges ; Function call find the weight of Minimum Spanning Tree", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; map < int , int > g [ 200005 ] ; set < int > s , ns ; void dfs ( int x ) { vector < int > v ; v . clear ( ) ; ns . clear ( ) ; for ( int it : s ) { if ( ! g [ x ] [ it ] ) { v . push_back ( it ) ; } else { ns . insert ( it ) ; } } s = ns ; for ( int i : v ) { dfs ( i ) ; } } void weightOfMST ( int N ) { int cnt = 0 ; for ( int i = 1 ; i <= N ; ++ i ) { s . insert ( i ) ; } for ( ; s . size ( ) ; ) { ++ cnt ; int t = * s . begin ( ) ; s . erase ( t ) ; dfs ( t ) ; } cout << cnt - 1 ; } int main ( ) { int N = 6 , M = 11 ; int edges [ ] [ ] = { { 1 , 3 } , { 1 , 4 } , { 1 , 5 } , { 1 , 6 } , { 2 , 3 } , { 2 , 4 } , { 2 , 5 } , { 2 , 6 } , { 3 , 4 } , { 3 , 5 } , { 3 , 6 } } ; for ( int i = 0 ; i < M ; ++ i ) { int u = edges [ i ] [ 0 ] ; int v = edges [ i ] [ 1 ] ; g [ u ] [ v ] = 1 ; g [ v ] [ u ] = 1 ; } weightOfMST ( N ) ; return 0 ; }", "text_ms": "Cari berat MST dalam graf lengkap dengan Edge | Program C ++ untuk mencari berat pokok merangkumi minimum dalam graf lengkap di mana tepi mempunyai berat badan sama ada 0 atau 1; Untuk menyimpan tepi graf yang diberikan; Fungsi utiliti untuk melaksanakan traversal DFS; Semak simpang yang disimpan dalam set; Vertices dimasukkan jika berat kelebihan adalah 0; Fungsi utiliti untuk mencari berat pokok minimum; Untuk mengira komponen yang disambungkan; Memasukkan simpul awal dalam set; Melintasi simpang yang disimpan dalam set dan menjalankan traversal DFS untuk setiap simpang; Meningkatkan komponen bersambung berat sifar; DFS traversal untuk setiap vertex mengeluarkan; Kod pemandu; Masukkan tepi; Fungsi Panggilan Cari berat pokok minimum"}
{"text": "Count of distinct possible pairs such that the element from A is greater than the element from B | C ++ Program to count number of distinct pairs possible from the two arrays such that element selected from one array is always greater than the one selected from the other array ; Function to return the count of pairs ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( vector < int > A , vector < int > B ) { int n = A . size ( ) ; sort ( A . begin ( ) , A . end ( ) ) ; sort ( B . begin ( ) , B . end ( ) ) ; int ans = 0 , i ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] > B [ ans ] ) { ans ++ ; } } return ans ; } int main ( ) { vector < int > A = { 30 , 28 , 45 , 22 } ; vector < int > B = { 35 , 25 , 22 , 48 } ; cout << countPairs ( A , B ) ; return 0 ; }", "text_ms": "Kira pasangan yang mungkin berbeza supaya elemen dari A lebih besar daripada elemen dari b | Program C ++ untuk mengira bilangan pasangan yang berbeza yang mungkin dari kedua -dua tatasusunan seperti elemen yang dipilih dari satu array selalu lebih besar daripada yang dipilih dari array yang lain; Berfungsi untuk mengembalikan kiraan pasangan; Kod pemacu"}
{"text": "Maximum possible remainder when an element is divided by other element in the array | C ++ implementation of the approach ; Function to return the maximum mod value for any pair from the array ; Find the second maximum element from the array ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxMod ( int arr [ ] , int n ) { int maxVal = * max_element ( arr , arr + n ) ; int secondMax = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < maxVal && arr [ i ] > secondMax ) { secondMax = arr [ i ] ; } } return secondMax ; } int main ( ) { int arr [ ] = { 2 , 4 , 1 , 5 , 3 , 6 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << maxMod ( arr , n ) ; return 0 ; }", "text_ms": "Sisa maksimum mungkin apabila elemen dibahagikan dengan elemen lain dalam array | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan nilai mod maksimum untuk mana -mana pasangan dari array; Cari elemen maksimum kedua dari array; Kod pemacu"}
{"text": "Choose X elements from A [ ] and Y elements from B [ ] which satisfy the given condition | C ++ implementation of the approach ; Function to that returns true if it possible to choose the elements ; If elements can 't be chosen ; Sort both the arrays ; If xth smallest element of A [ ] is smaller than the yth greatest element of B [ ] ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPossible ( int A [ ] , int B [ ] , int n , int m , int x , int y ) { if ( x > n y > m ) return false ; sort ( A , A + n ) ; sort ( B , B + m ) ; if ( A [ x - 1 ] < B [ m - y ] ) return true ; else return false ; } int main ( ) { int A [ ] = { 1 , 1 , 1 , 1 , 1 } ; int B [ ] = { 2 , 2 } ; int n = sizeof ( A ) / sizeof ( int ) ; int m = sizeof ( B ) / sizeof ( int ) ; int x = 3 , y = 1 ; if ( isPossible ( A , B , n , m , x , y ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "text_ms": "Pilih x elemen dari elemen [] dan y dari b [] yang memenuhi syarat yang diberikan | C ++ pelaksanaan pendekatan; Berfungsi untuk pulangan yang benar jika mungkin untuk memilih unsur -unsur; Jika unsur -unsur tidak dapat dipilih; Menyusun kedua -dua tatasusunan; Jika elemen terkecil x [] adalah lebih kecil daripada elemen terbesar Yth B []; Kod pemacu"}
{"text": "Find minimum changes required in an array for it to contain k distinct elements | CPP program to minimum changes required in an array for k distinct elements . ; Function to minimum changes required in an array for k distinct elements . ; Store the frequency of each element ; Store the frequency of elements ; Sort frequencies in descending order ; To store the required answer ; Return the required answer ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100005 NEW_LINE int Min_Replace ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int freq [ MAX ] ; memset ( freq , 0 , sizeof freq ) ; int p = 0 ; freq [ p ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) ++ freq [ p ] ; else ++ freq [ ++ p ] ; } sort ( freq , freq + n , greater < int > ( ) ) ; int ans = 0 ; for ( int i = k ; i <= p ; i ++ ) ans += freq [ i ] ; return ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 7 , 8 , 2 , 3 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; cout << Min_Replace ( arr , n , k ) ; return 0 ; }", "text_ms": "Cari perubahan minimum yang diperlukan dalam array untuk mengandungi elemen K yang berbeza | Program CPP kepada perubahan minimum yang diperlukan dalam array untuk elemen K yang berbeza. ; Fungsi kepada perubahan minimum yang diperlukan dalam array untuk elemen K yang berbeza. ; Simpan kekerapan setiap elemen; Simpan kekerapan elemen; Jenis frekuensi dalam urutan menurun; Untuk menyimpan jawapan yang diperlukan; Mengembalikan jawapan yang diperlukan; Kod pemacu"}
{"text": "Maximum number of elements without overlapping in a Line | CPP program to find maximum number of elements without overlapping in a line ; Function to find maximum number of elements without overlapping in a line ; If n = 1 , then answer is one ; We can always make 1 st element to cover left segment and nth the right segment ; If left segment for ith element doesnt overlap with i - 1 th element then do left ; else try towards right if possible ; update x [ i ] to right endpoint of segment covered by it ; Return the required answer ; Driver code ; Function call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Segment ( int x [ ] , int l [ ] , int n ) { if ( n == 1 ) return 1 ; int ans = 2 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( x [ i ] - l [ i ] > x [ i - 1 ] ) ans ++ ; else if ( x [ i ] + l [ i ] < x [ i + 1 ] ) { x [ i ] = x [ i ] + l [ i ] ; ans ++ ; } } return ans ; } int main ( ) { int x [ ] = { 1 , 3 , 4 , 5 , 8 } , l [ ] = { 10 , 1 , 2 , 2 , 5 } ; int n = sizeof ( x ) / sizeof ( x [ 0 ] ) ; cout << Segment ( x , l , n ) ; return 0 ; }", "text_ms": "Bilangan maksimum elemen tanpa bertindih dalam garis | Program CPP untuk mencari bilangan elemen maksimum tanpa bertindih dalam satu baris; Berfungsi untuk mencari bilangan elemen maksimum tanpa bertindih dalam garis; Jika n = 1, maka jawapannya adalah satu; Kami sentiasa boleh membuat elemen 1 st untuk menutup segmen kiri dan nth segmen yang betul; Jika segmen kiri untuk elemen ith tidak bertindih dengan elemen i - 1 maka kemudian kiri; lain cuba ke arah yang betul jika boleh; Kemas kini x [i] ke titik akhir kanan segmen yang diliputi olehnya; Mengembalikan jawapan yang diperlukan; Kod pemacu; Panggilan fungsi"}
{"text": "Delete odd and even numbers at alternate step such that sum of remaining elements is minimized | C ++ implementation of the approach ; Function to find the minimized sum ; If more odd elements ; Sort the elements ; Left - over elements ; Find the sum of leftover elements ; Return the sum ; If more even elements ; Sort the elements ; Left - over elements ; Find the sum of leftover elements ; Return the sum ; If same elements ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int MinimizeleftOverSum ( int a [ ] , int n ) { vector < int > v1 , v2 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 ) v1 . push_back ( a [ i ] ) ; else v2 . push_back ( a [ i ] ) ; } if ( v1 . size ( ) > v2 . size ( ) ) { sort ( v1 . begin ( ) , v1 . end ( ) ) ; sort ( v2 . begin ( ) , v2 . end ( ) ) ; int x = v1 . size ( ) - v2 . size ( ) - 1 ; int sum = 0 ; int i = 0 ; while ( i < x ) { sum += v1 [ i ++ ] ; } return sum ; } else if ( v2 . size ( ) > v1 . size ( ) ) { sort ( v1 . begin ( ) , v1 . end ( ) ) ; sort ( v2 . begin ( ) , v2 . end ( ) ) ; int x = v2 . size ( ) - v1 . size ( ) - 1 ; int sum = 0 ; int i = 0 ; while ( i < x ) { sum += v2 [ i ++ ] ; } return sum ; } else return 0 ; } int main ( ) { int a [ ] = { 2 , 2 , 2 , 2 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << MinimizeleftOverSum ( a , n ) ; return 0 ; }", "text_ms": "Padam ganjil dan bahkan nombor pada langkah alternatif supaya jumlah elemen yang tinggal diminimumkan | C ++ pelaksanaan pendekatan; Berfungsi untuk mencari jumlah yang diminimumkan; Jika lebih banyak elemen ganjil; Menyusun unsur -unsur; Kiri - lebih dari elemen; Cari jumlah unsur sisa; Mengembalikan jumlahnya; Jika lebih banyak elemen; Menyusun unsur -unsur; Kiri - lebih dari elemen; Cari jumlah unsur sisa; Mengembalikan jumlahnya; Jika elemen yang sama; Kod pemacu"}
{"text": "Minimum operations to make frequency of all characters equal K | C ++ program to convert the given string ; Function to find the minimum number of operations to convert the given string ; Check if N is divisible by K ; Array to store frequency of characters in given string ; Two arrays with number of operations required ; Checking for all possibility ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void minOperation ( string S , int N , int K ) { if ( N % K ) { cout << \" Not ▁ Possible \" << endl ; return ; } int count [ 26 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { count [ S [ i ] - 97 ] ++ ; } int E = N / K ; vector < int > greaterE ; vector < int > lessE ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( count [ i ] < E ) lessE . push_back ( E - count [ i ] ) ; else greaterE . push_back ( count [ i ] - E ) ; } sort ( greaterE . begin ( ) , greaterE . end ( ) ) ; sort ( lessE . begin ( ) , lessE . end ( ) ) ; int mi = INT_MAX ; for ( int i = 0 ; i <= K ; i ++ ) { int set1 = i ; int set2 = K - i ; if ( greaterE . size ( ) >= set1 && lessE . size ( ) >= set2 ) { int step1 = 0 ; int step2 = 0 ; for ( int j = 0 ; j < set1 ; j ++ ) step1 += greaterE [ j ] ; for ( int j = 0 ; j < set2 ; j ++ ) step2 += lessE [ j ] ; mi = min ( mi , max ( step1 , step2 ) ) ; } } cout << mi << endl ; } int main ( ) { string S = \" accb \" ; int N = S . size ( ) ; int K = 2 ; minOperation ( S , N , K ) ; return 0 ; }", "text_ms": "Operasi minimum untuk membuat kekerapan semua aksara sama k | Program C ++ untuk menukar rentetan yang diberikan; Berfungsi untuk mencari bilangan minimum operasi untuk menukar rentetan yang diberikan; Semak jika n boleh dibahagikan dengan k; Array untuk menyimpan kekerapan aksara dalam rentetan yang diberikan; Dua tatasusunan dengan bilangan operasi yang diperlukan; Memeriksa semua kemungkinan; Kod pemacu"}
{"text": "Minimum range increment operations to Sort an array | C ++ program to find minimum range increments to sort an array ; Function to find minimum range increments to sort an array ; If current element is found greater than last element Increment all terms in range i + 1 to n - 1 ; mn = arr [ i ] ; Minimum in range i to n - 1 ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minMovesToSort ( int arr [ ] , int n ) { int moves = 0 ; int i , mn = arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > mn ) moves += arr [ i ] - mn ; } return moves ; } int main ( ) { int arr [ ] = { 3 , 5 , 2 , 8 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minMovesToSort ( arr , n ) ; return 0 ; }", "text_ms": "Operasi Peningkatan Julat Minimum Untuk Mengasingkan Array | Program C ++ untuk mencari kenaikan julat minimum untuk menyusun array; Berfungsi untuk mencari kenaikan julat minimum untuk menyusun array; Jika elemen semasa didapati lebih besar daripada kenaikan elemen terakhir semua istilah dalam julat i + 1 hingga n - 1; mn = arr [i]; Minimum dalam julat I hingga n - 1; Kod pemacu"}
{"text": "Sort prime numbers of an array in descending order | C ++ implementation of the approach ; false here indicates that it is not prime ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p , set them to non - prime ; Function that sorts all the prime numbers from the array in descending ; this vector will contain prime numbers to sort ; if the element is prime ; update the array elements ; Driver code ; print the results .", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool prime [ 100005 ] ; void SieveOfEratosthenes ( int n ) { memset ( prime , true , sizeof ( prime ) ) ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } } void sortPrimes ( int arr [ ] , int n ) { SieveOfEratosthenes ( 100005 ) ; vector < int > v ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) v . push_back ( arr [ i ] ) ; } sort ( v . begin ( ) , v . end ( ) , greater < int > ( ) ) ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) arr [ i ] = v [ j ++ ] ; } } int main ( ) { int arr [ ] = { 4 , 3 , 2 , 6 , 100 , 17 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sortPrimes ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) { cout << arr [ i ] << \" ▁ \" ; } return 0 ; }", "text_ms": "Susun nombor utama array dalam perintah menurun | C ++ pelaksanaan pendekatan; Palsu di sini menunjukkan bahawa ia bukan perdana; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P, tetapkannya kepada bukan perdana; Fungsi yang menyusun semua nombor utama dari array dalam menurun; Vektor ini akan mengandungi nombor utama untuk disusun; Jika elemen itu adalah perdana; mengemas kini elemen array; Kod pemacu; Cetak hasilnya."}
{"text": "Pair formation such that maximum pair sum is minimized | CPP Program to divide the array into N pairs such that maximum pair is minimized ; After Sorting Maintain two variables i and j pointing to start and end of array Such that smallest element of array pairs with largest element ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findOptimalPairs ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; for ( int i = 0 , j = N - 1 ; i <= j ; i ++ , j -- ) cout << \" ( \" << arr [ i ] << \" , ▁ \" << arr [ j ] << \" ) \" << \" ▁ \" ; } int main ( ) { int arr [ ] = { 9 , 6 , 5 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findOptimalPairs ( arr , N ) ; return 0 ; }", "text_ms": "Pembentukan pasangan sedemikian rupa sehingga jumlah pasangan maksimum diminimumkan | Program CPP untuk membahagikan array ke pasangan N sedemikian rupa sehingga pasangan maksimum diminimumkan; Selepas menyusun mengekalkan dua pembolehubah i dan j menunjuk untuk memulakan dan mengakhiri array sedemikian rupa sehingga elemen terkecil pasangan array dengan elemen terbesar; Kod pemacu"}
{"text": "Sort an array according to count of set bits | C ++ program to implement simple approach to sort an array according to count of set bits . ; a utility function that returns total set bits count in an integer ; Function to simultaneously sort both arrays using insertion sort ( https : www . geeksforgeeks . org / insertion - sort / ) ; use 2 keys because we need to sort both arrays simultaneously ; Move elements of arr [ 0. . i - 1 ] and aux [ 0. . i - 1 ] , such that elements of aux [ 0. . i - 1 ] are greater than key1 , to one position ahead of their current position ; Function to sort according to bit count using an auxiliary array ; Create an array and store count of set bits in it . ; Sort arr [ ] according to values in aux [ ] ; Utility function to print an array ; Driver Code", "code": "#include <iostream> NEW_LINE using namespace std ; int countBits ( int a ) { int count = 0 ; while ( a ) { if ( a & 1 ) count += 1 ; a = a >> 1 ; } return count ; } void insertionSort ( int arr [ ] , int aux [ ] , int n ) { for ( int i = 1 ; i < n ; i ++ ) { int key1 = aux [ i ] ; int key2 = arr [ i ] ; int j = i - 1 ; while ( j >= 0 && aux [ j ] < key1 ) { aux [ j + 1 ] = aux [ j ] ; arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } aux [ j + 1 ] = key1 ; arr [ j + 1 ] = key2 ; } } void sortBySetBitCount ( int arr [ ] , int n ) { int aux [ n ] ; for ( int i = 0 ; i < n ; i ++ ) aux [ i ] = countBits ( arr [ i ] ) ; insertionSort ( arr , aux , n ) ; } void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << \" ▁ \" ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sortBySetBitCount ( arr , n ) ; printArr ( arr , n ) ; return 0 ; }", "text_ms": "Sort Array mengikut kiraan bit set | Program C ++ untuk melaksanakan pendekatan mudah untuk menyusun array mengikut kiraan bit set. ; fungsi utiliti yang mengembalikan jumlah bit set dalam integer; Berfungsi secara serentak menyusun kedua -dua tatasusunan menggunakan jenis penyisipan (https: www. Geeksforgeeks. Org / sisipan - sort /); Gunakan 2 kekunci kerana kita perlu menyusun kedua -dua tatasusunan secara serentak; Gerakkan unsur -unsur ARR [0 .. i - 1] dan aux [0 .. i - 1], seperti unsur -unsur aux [0 .. i - 1] adalah lebih besar daripada Key1, ke satu kedudukan di hadapan kedudukan semasa mereka; Fungsi untuk disusun mengikut kiraan bit menggunakan array tambahan; Buat array dan kiraan bit set di dalamnya. ; Susun arr [] mengikut nilai dalam aux []; Fungsi utiliti untuk mencetak array; Kod pemacu"}
{"text": "Sort an array according to count of set bits | C ++ program to sort an array according to count of set bits using std :: sort ( ) ; a utility function that returns total set bits count in an integer ; Function to sort according to bit count This function assumes that there are 32 bits in an integer . ; Traverse through all bit counts ( Note that we sort array in decreasing order ) ; Utility function to print an array ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countBits ( int a ) { int count = 0 ; while ( a ) { if ( a & 1 ) count += 1 ; a = a >> 1 ; } return count ; } void sortBySetBitCount ( int arr [ ] , int n ) { vector < vector < int > > count ( 32 ) ; int setbitcount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { setbitcount = countBits ( arr [ i ] ) ; count [ setbitcount ] . push_back ( arr [ i ] ) ; } for ( int i = 31 ; i >= 0 ; i -- ) { vector < int > v1 = count [ i ] ; for ( int i = 0 ; i < v1 . size ( ) ; i ++ ) arr [ j ++ ] = v1 [ i ] ; } } void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << \" ▁ \" ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sortBySetBitCount ( arr , n ) ; printArr ( arr , n ) ; return 0 ; }", "text_ms": "Sort Array mengikut kiraan bit set | Program C ++ untuk menyusun array mengikut kiraan set bit menggunakan std :: sort (); fungsi utiliti yang mengembalikan jumlah bit set dalam integer; Fungsi untuk disusun mengikut bit Count fungsi ini mengandaikan bahawa terdapat 32 bit dalam integer. ; Melintasi semua bit bit (perhatikan bahawa kami menyusun array dalam penurunan urutan); Fungsi utiliti untuk mencetak array; Kod pemacu"}
{"text": "Lexicographically smallest binary string formed by flipping bits at indices not divisible K1 or K2 such that count of 1 s is always greater than 0 s from left | C ++ program for the above approach ; Function to find lexicographically smallest string having number of 1 s greater than number of 0 s ; C1s And C0s stores the count of 1 s and 0 s at every position ; Traverse the string S ; If the position is not divisible by k1 and k2 ; If C0s >= C1s and pos [ ] is empty then the string can 't  be formed ; If pos [ ] is not empty then flip the bit of last position present in pos [ ] ; Print the result ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void generateString ( int k1 , int k2 , string s ) { int C1s = 0 , C0s = 0 ; int flag = 0 ; vector < int > pos ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == '0' ) { C0s ++ ; if ( ( i + 1 ) % k1 != 0 && ( i + 1 ) % k2 != 0 ) { pos . push_back ( i ) ; } } else { C1s ++ ; } if ( C0s >= C1s ) { if ( pos . size ( ) == 0 ) { cout << -1 ; flag = 1 ; break ; } else { int k = pos . back ( ) ; s [ k ] = '1' ; C0s -- ; C1s ++ ; pos . pop_back ( ) ; } } } if ( flag == 0 ) { cout << s ; } } int main ( ) { int K1 = 2 , K2 = 4 ; string S = \"11000100\" ; generateString ( K1 , K2 , S ) ; return 0 ; }", "text_ms": "Rentetan binari terkecil lexicographically dibentuk dengan membalikkan bit pada indeks yang tidak dapat dibahagi k1 atau k2 supaya kiraan 1 s sentiasa lebih besar daripada 0 s dari kiri | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari rentetan terkecil secara lexicographically yang mempunyai bilangan 1 s lebih besar daripada bilangan 0 s; C1S dan C0S menyimpan kiraan 1 s dan 0 s pada setiap kedudukan; Melintasi rentetan s; Jika kedudukan tidak dapat dibahagikan dengan k1 dan k2; Jika c0s> = c1s dan pos [] kosong maka rentetan tidak dapat dibentuk; Jika POS [] tidak kosong maka flip sedikit kedudukan terakhir yang terdapat di POS []; Cetak hasilnya; Kod pemacu"}
{"text": "Find a pair of numbers with set bit count as at most that of N and whose Bitwise XOR is N | C ++ program for the above approach ; Function to find the pair ( X , Y ) such that X xor Y = N and the count of set bits in X and Y is less than count of set bit in N ; Stores MSB ( Most Significant Bit ) ; Stores the value of X ; Stores the value of Y ; Traversing over all bits of N ; If ith bit of N is 0 ; Set ith bit of X to 1 ; Set ith bit of Y to 1 ; Print Answer ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void maximizeProduct ( int N ) { int MSB = ( int ) log2 ( N ) ; int X = 1 << MSB ; int Y = N - ( 1 << MSB ) ; for ( int i = 0 ; i < MSB ; i ++ ) { if ( ! ( N & ( 1 << i ) ) ) { X += 1 << i ; Y += 1 << i ; } } cout << X << \" ▁ \" << Y ; } int main ( ) { int N = 45 ; maximizeProduct ( N ) ; return 0 ; }", "text_ms": "Cari sepasang nombor dengan set bit set sebagai kebanyakan n dan yang bitwise xor adalah n | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari pasangan (x, y) sedemikian rupa sehingga x xor y = n dan kiraan bit set dalam x dan y kurang daripada kiraan set bit dalam n; Kedai MSB (Bit Paling Penting); Menyimpan nilai x; Menyimpan nilai y; Melintasi semua bit N; Jika ia bit n ialah 0; Tetapkan sedikit x hingga 1; Tetapkan sedikit Y hingga 1; Jawapan cetak; Kod pemacu"}
{"text": "Count of numbers in range [ L , R ] having sum of digits of its square equal to square of sum of digits | C ++ program for the above approach ; Function to check if the number is valid ; Sum of digits of num ; Squared number ; Sum of digits of ( num * num ) ; Function to convert a string to an integer ; Function to generate all possible strings of length len ; Desired string ; Take only valid numbers ; Recurse for all possible digits ; Function to calculate unique numbers in range [ L , R ] ; Initialize a variable to store the answer ; Calculate the maximum possible length ; Set to store distinct valid numbers ; Generate all possible strings of length i ; Iterate the set to get the count of valid numbers in the range [ L , R ] ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( int num ) { int sm = 0 ; int num2 = num * num ; while ( num ) { sm += num % 10 ; num /= 10 ; } int sm2 = 0 ; while ( num2 ) { sm2 += num2 % 10 ; num2 /= 10 ; } return ( ( sm * sm ) == sm2 ) ; } int convert ( string s ) { int val = 0 ; reverse ( s . begin ( ) , s . end ( ) ) ; int cur = 1 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { val += ( s [ i ] - '0' ) * cur ; cur *= 10 ; } return val ; } void generate ( string s , int len , set < int > & uniq ) { if ( s . size ( ) == len ) { if ( check ( convert ( s ) ) ) { uniq . insert ( convert ( s ) ) ; } return ; } for ( int i = 0 ; i <= 3 ; i ++ ) { generate ( s + char ( i + '0' ) , len , uniq ) ; } } int totalNumbers ( int L , int R ) { int ans = 0 ; int max_len = log10 ( R ) + 1 ; set < int > uniq ; for ( int i = 1 ; i <= max_len ; i ++ ) { generate ( \" \" , i , uniq ) ; } for ( auto x : uniq ) { if ( x >= L && x <= R ) { ans ++ ; } } return ans ; } int main ( ) { int L = 22 , R = 22 ; cout << totalNumbers ( L , R ) ; }", "text_ms": "Count of Numbers in Range [l, r] mempunyai jumlah digit persegi sama dengan kuadrat jumlah digit | Program C ++ untuk pendekatan di atas; Fungsi untuk memeriksa sama ada nombor itu sah; Jumlah digit Num; Nombor kuadrat; Jumlah digit (num * num); Berfungsi untuk menukar rentetan ke integer; Berfungsi untuk menghasilkan semua rentetan panjang yang mungkin; Rentetan yang dikehendaki; Hanya mengambil nombor yang sah; Berulang untuk semua digit yang mungkin; Berfungsi untuk mengira nombor unik dalam julat [l, r]; Memulakan pembolehubah untuk menyimpan jawapannya; Kirakan panjang maksimum yang mungkin; Tetapkan untuk menyimpan nombor yang sah yang berbeza; Menjana semua rentetan panjang yang mungkin i; I -meletakkan set untuk mendapatkan kiraan nombor yang sah dalam julat [l, r]; Kod pemacu"}
{"text": "Convert X into Y by repeatedly multiplying X with 2 or appending 1 at the end | C ++ program for the above approach ; Function to check if X can be converted to Y by multiplying X by 2 or appending 1 at the end ; Iterate until Y is at least X ; If Y is even ; If the last digit of Y is 1 ; Otherwise ; Check if X is equal to Y ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void convertXintoY ( int X , int Y ) { while ( Y > X ) { if ( Y % 2 == 0 ) Y /= 2 ; else if ( Y % 10 == 1 ) Y /= 10 ; else break ; } if ( X == Y ) cout << \" Yes \" ; else cout << \" No \" ; } int main ( ) { int X = 100 , Y = 40021 ; convertXintoY ( X , Y ) ; return 0 ; }", "text_ms": "Tukar x ke y dengan berulang kali mengalikan x dengan 2 atau tampuk 1 pada akhir | Program C ++ untuk pendekatan di atas; Fungsi untuk memeriksa sama ada x boleh ditukar kepada y dengan mengalikan x dengan 2 atau menambahkan 1 pada akhir; ITERATE Sehingga Y adalah sekurang -kurangnya x; Jika y juga; Jika digit terakhir Y ialah 1; Jika tidak; Semak sama ada x sama dengan y; Kod pemacu"}
{"text": "Lexicographically smallest string of maximum length made up of first K alphabets that does not contain any repeating substring | C ++ program for the above approach ; Function to find the lexicographically smallest string of the first K lower case alphabets having unique substrings ; Stores the resultant string ; Iterate through all the characters ; Inner Loop for making pairs and adding them into string ; Adding first character so that substring consisting of the last the first alphabet is present ; Print the resultant string ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void generateString ( int K ) { string s = \" \" ; for ( int i = 97 ; i < 97 + K ; i ++ ) { s = s + char ( i ) ; for ( int j = i + 1 ; j < 97 + K ; j ++ ) { s += char ( i ) ; s += char ( j ) ; } } s += char ( 97 ) ; cout << s ; } int main ( ) { int K = 4 ; generateString ( K ) ; return 0 ; }", "text_ms": "Lexicographically terkecil rentetan panjang maksimum yang terdiri daripada huruf k pertama yang tidak mengandungi apa -apa substring berulang | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari rentetan terkecil lexicographically dari huruf kaum K bawah pertama yang mempunyai substrings yang unik; Menyimpan rentetan yang dihasilkan; Melewati semua watak; Gelung dalaman untuk membuat pasangan dan menambahkannya ke dalam rentetan; Menambah watak pertama supaya substring yang terdiri daripada abjad yang terakhir hadir; Cetak rentetan yang dihasilkan; Kod pemacu"}
{"text": "Generate Quadratic Equation having given sum and product of roots | C ++ program for the above approach ; Function to find the quadratic equation from the given sum and products of roots ; Print the coefficients ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findEquation ( int S , int M ) { cout << \"1 ▁ \" << ( -1 ) * S << \" ▁ \" << M << endl ; } int main ( ) { int S = 5 , M = 6 ; findEquation ( S , M ) ; return 0 ; }", "text_ms": "Menjana Persamaan Kuadratik setelah memberikan jumlah dan produk akar | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari persamaan kuadratik dari jumlah dan produk akar yang diberikan; Cetak pekali; Kod pemacu"}
{"text": "Make all array elements equal by replacing adjacent pairs by their sum | C ++ program for the above approach ; Function to count the minimum number of pairs of adjacent elements required to be replaced by their sum to make all array elements equal ; Stores the prefix sum of the array ; Calculate the prefix sum array ; Stores the maximum number of subarrays into which the array can be split ; Iterate over all possible sums ; Traverse the array ; If the sum is equal to the current prefix sum ; Increment count of groups by 1 ; Otherwise discard this subgroup sum ; Update the maximum this of subarrays ; Return the minimum number of operations ; Driver Code ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minSteps ( vector < int > a , int n ) { vector < int > prefix_sum ( n ) ; prefix_sum [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix_sum [ i ] += prefix_sum [ i - 1 ] + a [ i ] ; int mx = -1 ; for ( int subgroupsum : prefix_sum ) { int sum = 0 ; int i = 0 ; int grp_count = 0 ; while ( i < n ) { sum += a [ i ] ; if ( sum == subgroupsum ) { grp_count += 1 ; sum = 0 ; } else if ( sum > subgroupsum ) { grp_count = -1 ; break ; } i += 1 ; } if ( grp_count > mx ) mx = grp_count ; } return n - mx ; } int main ( ) { vector < int > A = { 1 , 2 , 3 , 2 , 1 , 3 } ; int N = A . size ( ) ; cout << minSteps ( A , N ) ; return 0 ; }", "text_ms": "Buat semua elemen array sama dengan menggantikan pasangan bersebelahan dengan jumlah mereka | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira bilangan minimum pasang unsur -unsur bersebelahan yang diperlukan untuk digantikan oleh jumlah mereka untuk membuat semua elemen array sama; Menyimpan jumlah awalan array; Kirakan Array Jumlah Awalan; Menyimpan bilangan maksimum subarray yang mana array boleh dibahagikan; Melangkah ke atas semua jumlah yang mungkin; Melintasi array; Jika jumlahnya sama dengan jumlah awalan semasa; Kira kenaikan kumpulan sebanyak 1; Jika tidak buang jumlah subkumpulan ini; Mengemas kini maksimum ini subarray; Mengembalikan bilangan operasi minimum; Kod pemacu; Panggilan fungsi"}
{"text": "Most frequent character in a string after replacing all occurrences of X in a Binary String | C ++ program for the above approach ; Function to find the most frequent character after replacing X with either '0' or '1' according as per the given conditions ; Store the count of 0 s and 1 s in the string S ; Count the frequency of 0 and 1 ; If the character is 1 ; If the character is 0 ; Stores first occurence of 1 ; Traverse the string to count the number of X between two consecutive 1 s ; If the current character is not X ; If the current character is 1 , add the number of Xs to count1 and set prev to i ; Otherwise ; Find next occurence of 1 in the string ; If it is found , set i to prev ; Otherwise , break out of the loop ; Store the first occurence of 0 ; Repeat the same procedure to count the number of X between two consecutive 0 s ; If the current character is not X ; If the current character is 0 ; Add the count of Xs to count0 ; Set prev to i ; Otherwise ; Find the next occurence of 0 in the string ; If it is found , set i to prev ; Otherwise , break out of the loop ; Count number of X present in the starting of the string as XXXX1 ... ; Store the count of X ; Increment count1 by count if the condition is satisfied ; Count the number of X present in the ending of the string as ... XXXX0 ; Store the count of X ; Increment count0 by count if the condition is satisfied ; If count of 1 is equal to count of 0 , print X ; Otherwise , if count of 1 is greater than count of 0 ; Otherwise , print 0 ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxOccuringCharacter ( string s ) { int count0 = 0 , count1 = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == '1' ) { count1 ++ ; } else if ( s [ i ] == '0' ) { count0 ++ ; } } int prev = -1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == '1' ) { prev = i ; break ; } } for ( int i = prev + 1 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] != ' X ' ) { if ( s [ i ] == '1' ) { count1 += i - prev - 1 ; prev = i ; } else { bool flag = true ; for ( int j = i + 1 ; j < s . length ( ) ; j ++ ) { if ( s [ j ] == '1' ) { flag = false ; prev = j ; break ; } } if ( ! flag ) { i = prev ; } else { i = s . length ( ) ; } } } } prev = -1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == '0' ) { prev = i ; break ; } } for ( int i = prev + 1 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] != ' X ' ) { if ( s [ i ] == '0' ) { count0 += i - prev - 1 ; prev = i ; } else { bool flag = true ; for ( int j = i + 1 ; j < s . length ( ) ; j ++ ) { if ( s [ j ] == '0' ) { prev = j ; flag = false ; break ; } } if ( ! flag ) { i = prev ; } else { i = s . length ( ) ; } } } } if ( s [ 0 ] == ' X ' ) { int count = 0 ; int i = 0 ; while ( s [ i ] == ' X ' ) { count ++ ; i ++ ; } if ( s [ i ] == '1' ) { count1 += count ; } } if ( s [ ( s . length ( ) - 1 ) ] == ' X ' ) { int count = 0 ; int i = s . length ( ) - 1 ; while ( s [ i ] == ' X ' ) { count ++ ; i -- ; } if ( s [ i ] == '0' ) { count0 += count ; } } if ( count0 == count1 ) { cout << \" X \" << endl ; } else if ( count0 > count1 ) { cout << 0 << endl ; } else cout << 1 << endl ; } int main ( ) { string S = \" XX10XX10XXX1XX \" ; maxOccuringCharacter ( S ) ; }", "text_ms": "Karakter yang paling kerap dalam rentetan selepas menggantikan semua kejadian x dalam rentetan binari | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari watak yang paling kerap selepas menggantikan x dengan sama ada '0' atau '1' mengikut syarat -syarat yang diberikan; Simpan kiraan 0 s dan 1 s dalam rentetan S; Hitung kekerapan 0 dan 1; Jika wataknya adalah 1; Jika wataknya 0; Kedai pertama berlaku 1; Melintasi rentetan untuk mengira bilangan x antara dua berturut -turut 1 s; Jika watak semasa bukan x; Jika aksara semasa adalah 1, tambahkan bilangan Xs ke Count1 dan tetapkan sebelum i; Jika tidak; Cari kejadian seterusnya 1 dalam rentetan; Jika ia dijumpai, tetapkan saya ke sebelumnya; Jika tidak, keluar dari gelung; Simpan kejadian pertama 0; Ulangi prosedur yang sama untuk mengira bilangan x antara dua berturut -turut 0 s; Jika watak semasa bukan x; Jika watak semasa adalah 0; Tambah kiraan XS ke Count0; Tetapkan sebelumnya ke i; Jika tidak; Cari kejadian seterusnya 0 dalam rentetan; Jika ia dijumpai, tetapkan saya ke sebelumnya; Jika tidak, keluar dari gelung; Kiraan bilangan x yang hadir dalam permulaan rentetan sebagai xxxx1 ...; Simpan kiraan x; Kenaikan kiraan1 dengan kiraan jika keadaan itu berpuas hati; Hitung bilangan x yang hadir pada akhir rentetan sebagai ... xxxx0; Simpan kiraan x; Kenaikan kiraan dengan kiraan jika keadaan itu berpuas hati; Jika kiraan 1 adalah sama dengan kiraan 0, cetak x; Jika tidak, jika kiraan 1 lebih besar daripada kiraan 0; Jika tidak, cetak 0; Kod pemacu"}
{"text": "Maximize count of sheets possible by repeatedly reducing its area to half | C ++ program for the above approach ; Function to calculate the maximum number of sheets possible by given operations ; Initial count of sheets ; Keep dividing the sheets into half ; Reduce area by half ; Increase count by twice ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSheets ( int A , int B ) { int area = A * B ; int count = 1 ; while ( area % 2 == 0 ) { area /= 2 ; count *= 2 ; } return count ; } int main ( ) { int A = 5 , B = 10 ; cout << maxSheets ( A , B ) ; return 0 ; }", "text_ms": "Memaksimumkan kiraan lembaran yang mungkin dengan berulang kali mengurangkan kawasannya kepada separuh | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira bilangan maksimum lembaran yang mungkin dengan operasi yang diberikan; Kiraan awal lembaran; Terus membahagikan kepingan ke separuh; Mengurangkan kawasan dengan separuh; Meningkatkan kiraan dua kali; Kod pemacu"}
{"text": "Minimum number of steps required to reach origin from a given point | C ++ program for the above approach ; Function to find the minimum moves required to reach origin from ( a , b ) ; Stores the minimum number of moves ; Check if the absolute difference is 1 or 0 ; Store the minimum of a , b ; Store the maximum of a , b ; Print the answer ; Driver Code ; Given co - ordinates ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMinMoves ( int a , int b ) { int ans = 0 ; if ( a == b || abs ( a - b ) == 1 ) { ans = a + b ; } else { int k = min ( a , b ) ; int j = max ( a , b ) ; ans = 2 * k + 2 * ( j - k ) - 1 ; } cout << ans ; } int main ( ) { int a = 3 , b = 5 ; findMinMoves ( a , b ) ; return 0 ; }", "text_ms": "Bilangan langkah minimum yang diperlukan untuk mencapai asal dari titik tertentu | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari langkah minimum yang diperlukan untuk mencapai asal dari (a, b); Menyimpan bilangan minimum bergerak; Periksa sama ada perbezaan mutlak ialah 1 atau 0; Simpan minimum a, b; Simpan maksimum a, b; Cetak jawapannya; Kod pemacu; Diberikan Co - ordinat; Panggilan fungsi"}
{"text": "Count even sum pairs possible by selecting two integers from two given ranges respectively | C ++ program to implement the above approach ; Function to count even sum pairs in the given range ; Stores the count of even numbers between 1 to X ; Stores the count of odd numbers between 1 to X ; Stores the count of even numbers between 1 to Y ; Stores the count of odd numbers between 1 to Y ; Stores the count of pairs having even sum ; Retuens the count of pairs having even sum ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long long cntEvenSumPairs ( long long X , long long Y ) { long long cntXEvenNums = X / 2 ; long long cntXOddNums = ( X + 1 ) / 2 ; long long cntYEvenNums = Y / 2 ; long long cntYOddNums = ( Y + 1 ) / 2 ; long long cntPairs = ( cntXEvenNums * 1LL * cntYEvenNums ) + ( cntXOddNums * 1LL * cntYOddNums ) ; return cntPairs ; } int main ( ) { long long X = 2 ; long long Y = 3 ; cout << cntEvenSumPairs ( X , Y ) ; return 0 ; }", "text_ms": "Kira walaupun jumlah pasangan yang mungkin dengan memilih dua bilangan bulat dari dua julat yang diberikan masing -masing | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mengira walaupun jumlah pasangan dalam julat yang diberikan; Menyimpan kiraan nombor antara 1 hingga x; Menyimpan kiraan nombor ganjil antara 1 hingga x; Menyimpan kiraan nombor antara 1 hingga y; Menyimpan kiraan nombor ganjil antara 1 hingga y; Menyimpan kiraan pasangan yang mempunyai jumlah wang; Mengimbangi kiraan pasangan yang mempunyai jumlah; Kod pemacu"}
{"text": "Minimize array elements required to be incremented or decremented to convert given array into a Fibonacci Series | C ++ program for the above approach ; Function to calculate minimum number of moves to make the sequence a Fibonacci series ; If number of elements is less than 3 ; Initialize the value of the result ; Try all permutations of the first two elements ; Value of first element after operation ; Value of second element after operation ; Calculate number of moves for rest of the elements of the array ; Element at idx index ; If it is not possible to change the element in atmost one move ; Otherwise ; Update the answer ; Return the answer ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minMoves ( vector < int > arr ) { int N = arr . size ( ) ; if ( N <= 2 ) return 0 ; int ans = INT_MAX ; for ( int i = -1 ; i <= 1 ; i ++ ) { for ( int j = -1 ; j <= 1 ; j ++ ) { int num1 = arr [ 0 ] + i ; int num2 = arr [ 1 ] + j ; int flag = 1 ; int moves = abs ( i ) + abs ( j ) ; for ( int idx = 2 ; idx < N ; idx ++ ) { int num = num1 + num2 ; if ( abs ( arr [ idx ] - num ) > 1 ) flag = 0 ; else moves += abs ( arr [ idx ] - num ) ; num1 = num2 ; num2 = num ; } if ( flag ) ans = min ( ans , moves ) ; } } if ( ans == INT_MAX ) return -1 ; return ans ; } int main ( ) { vector < int > arr = { 4 , 8 , 9 , 17 , 27 } ; cout << minMoves ( arr ) << endl ; return 0 ; }", "text_ms": "Kurangkan elemen array yang diperlukan untuk ditingkatkan atau diturunkan untuk menukar array yang diberikan ke dalam siri Fibonacci | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira bilangan minimum bergerak untuk membuat urutan siri Fibonacci; Jika bilangan elemen kurang daripada 3; Memulakan nilai hasilnya; Cuba semua permutasi dua elemen pertama; Nilai elemen pertama selepas operasi; Nilai elemen kedua selepas operasi; Hitung bilangan gerakan untuk unsur -unsur array; Elemen pada indeks IDX; Sekiranya tidak mungkin untuk menukar elemen dalam satu langkah; Jika tidak; Mengemas kini jawapannya; Kembalikan jawapannya; Kod pemacu"}
{"text": "Queries to calculate sum of array elements present at every Yth index starting from the index X | C ++ program for the above approach ; Function to Find the sum of arr [ x ] + arr [ x + y ] + arr [ x + 2 * y ] + ... for all queries ; Iterate over each query ; Stores the sum of arr [ x ] + arr [ x + y ] + arr [ x + 2 * y ] + ... ; Traverse the array and calculate the sum of the expression ; Update sum ; Update x ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void querySum ( int arr [ ] , int N , int Q [ ] [ 2 ] , int M ) { for ( int i = 0 ; i < M ; i ++ ) { int x = Q [ i ] [ 0 ] ; int y = Q [ i ] [ 1 ] ; int sum = 0 ; while ( x < N ) { sum += arr [ x ] ; x += y ; } cout << sum << \" ▁ \" ; } } int main ( ) { int arr [ ] = { 1 , 2 , 7 , 5 , 4 } ; int Q [ ] [ 2 ] = { { 2 , 1 } , { 3 , 2 } } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int M = sizeof ( Q ) / sizeof ( Q [ 0 ] ) ; querySum ( arr , N , Q , M ) ; return 0 ; }", "text_ms": "Pertanyaan untuk mengira jumlah elemen array yang hadir pada setiap indeks yth bermula dari indeks x | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari jumlah arr [x] + arr [x + y] + arr [x + 2 * y] + ... untuk semua pertanyaan; Melangkah ke atas setiap pertanyaan; Menyimpan jumlah arr [x] + arr [x + y] + arr [x + 2 * y] + ...; Melintasi array dan mengira jumlah ungkapan; Kemas kini Jumlah; Kemas kini x; Kod pemacu"}
{"text": "Calculate Bitwise OR of two integers from their given Bitwise AND and Bitwise XOR values | C ++ program to implement the above approach ; Function to calculate Bitwise OR from given bitwise XOR and bitwise AND values ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findBitwiseORGivenXORAND ( int X , int Y ) { return X + Y ; } int main ( ) { int X = 5 , Y = 2 ; cout << findBitwiseORGivenXORAND ( X , Y ) ; }", "text_ms": "Kirakan bitwise atau dua bilangan bulat dari nilai bitwise dan bitwise mereka yang diberikan | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk mengira bitwise atau dari bitwise xor dan bitwise dan nilai -nilai; Kod pemacu"}
{"text": "Check if a given value can be reached from another value in a Circular Queue by K | C ++ program for the above approach ; Function to return GCD of two numbers a and b ; Base Case ; Recursively Find the GCD ; Function to check of B can be reaced from A with a jump of K elements in the circular queue ; Find GCD of N and K ; If A - B is divisible by gcd then print Yes ; Otherwise ; Driver Code ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int GCD ( int a , int b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; } void canReach ( int N , int A , int B , int K ) { int gcd = GCD ( N , K ) ; if ( abs ( A - B ) % gcd == 0 ) { cout << \" Yes \" ; } else { cout << \" No \" ; } } int main ( ) { int N = 5 , A = 2 , B = 1 , K = 2 ; canReach ( N , A , B , K ) ; return 0 ; }", "text_ms": "Semak jika nilai yang diberikan dapat dicapai dari nilai lain dalam barisan bulat oleh k | Program C ++ untuk pendekatan di atas; Berfungsi untuk mengembalikan GCD dua nombor A dan B; Kes asas; Recursif mencari GCD; Fungsi untuk memeriksa B boleh digunakan dari A dengan lompatan elemen K dalam barisan bulat; Cari GCD N dan K; Jika A - B boleh dibahagikan dengan GCD maka cetak ya; Jika tidak; Kod pemacu; Panggilan fungsi"}
{"text": "Count of subarrays having sum equal to its length | Set 2 | C ++ program for the above approach ; Function that counts the subarrays with sum of its elements as its length ; Store count of elements upto current element with length i ; Stores the final count of subarray ; Stores the prefix sum ; If size of subarray is 1 ; Iterate the array ; Find the sum ; Update frequency in map ; Print the total count ; Driver Code ; Given array arr [ ] ; Size of array ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countOfSubarray ( int arr [ ] , int N ) { unordered_map < int , int > mp ; int answer = 0 ; int sum = 0 ; mp [ 1 ] ++ ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; answer += mp [ sum - i ] ; mp [ sum - i ] ++ ; } cout << answer ; } int main ( ) { int arr [ ] = { 1 , 0 , 2 , 1 , 2 , -2 , 2 , 4 } ; int N = sizeof arr / sizeof arr [ 0 ] ; countOfSubarray ( arr , N ) ; return 0 ; }", "text_ms": "Count subarrays mempunyai jumlah yang sama dengan panjangnya | Tetapkan 2 | Program C ++ untuk pendekatan di atas; Fungsi yang mengira subarray dengan jumlah elemennya sebagai panjangnya; Simpan kiraan elemen sehingga elemen semasa dengan panjang i; Menyimpan kiraan akhir subarray; Menyimpan jumlah awalan; Jika saiz subarray adalah 1; Melelehkan array; Cari jumlahnya; Kekerapan kemas kini dalam peta; Cetak jumlah kiraan; Kod pemacu; Diberikan array arr []; Saiz array; Panggilan fungsi"}
{"text": "Split first N natural numbers into two sets with minimum absolute difference of their sums | C ++ program to implement the above approach ; Function to split the first N natural numbers into two sets having minimum absolute difference of their sums ; Stores the sum of elements of set1 ; Stores the sum of elements of set2 ; Traverse first N natural numbers ; Check if sum of elements of set1 is less than or equal to sum of elements of set2 ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minAbsDiff ( int N ) { int sumSet1 = 0 ; int sumSet2 = 0 ; for ( int i = N ; i > 0 ; i -- ) { if ( sumSet1 <= sumSet2 ) { sumSet1 += i ; } else { sumSet2 += i ; } } return abs ( sumSet1 - sumSet2 ) ; } int main ( ) { int N = 6 ; cout << minAbsDiff ( N ) ; }", "text_ms": "Split First N Natural Numbers menjadi dua set dengan perbezaan mutlak minimum jumlah mereka | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk memecah nombor semulajadi N pertama ke dalam dua set yang mempunyai perbezaan mutlak minimum jumlah mereka; Menyimpan jumlah unsur set1; Menyimpan jumlah unsur set2; Melintasi nombor semulajadi n pertama; Semak sama ada jumlah unsur set1 kurang daripada atau sama dengan jumlah unsur set2; Kod pemacu"}
{"text": "Check if a number is prime in Flipped Upside Down , Mirror Flipped and Mirror Flipped Upside Down | C ++ program to implement the above approach ; Function to check if N contains digits 0 , 1 , 2 , 5 , 8 only ; Extract digits of N ; Return false if any of these digits are present ; Function to check if N is prime or not ; Check for all factors ; Function to check if n is prime in all the desired forms ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkDigits ( int n ) { do { int r = n % 10 ; if ( r == 3 r == 4 r == 6 r == 7 r == 9 ) return false ; n /= 10 ; } while ( n != 0 ) ; return true ; } bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } int isAllPrime ( int n ) { return isPrime ( n ) && checkDigits ( n ) ; } int main ( ) { int N = 101 ; if ( isAllPrime ( N ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "text_ms": "Semak jika nombor adalah perdana terbalik terbalik, cermin dibalik dan cermin terbalik terbalik | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk memeriksa sama ada n mengandungi digit 0, 1, 2, 5, 8 sahaja; Ekstrak digit n; Kembali palsu jika mana -mana digit ini hadir; Fungsi untuk memeriksa sama ada n adalah perdana atau tidak; Semak semua faktor; Fungsi untuk memeriksa sama ada n adalah perdana dalam semua bentuk yang dikehendaki; Kod pemacu"}
{"text": "Minimum Cost required to generate a balanced Bracket Sequence | C ++ Program to implement the above approach ; Function to calculate the minimum cost required to generate a balanced bracket sequence ; Stores the count of unbalanced open brackets ; Stores the count of unbalanced closed brackets ; Stores the count of open brackets ; Stores the count of closed brackets ; If open brace is encountered ; Otherwise ; If no unbalanced open brackets are present ; Increase count of unbalanced closed brackets ; Otherwise ; Reduce count of unbalanced open brackets ; Increase count of closed brackets ; Calculate lower bound of minimum cost ; Reduce excess open or closed brackets to prevent counting them twice ; Update answer by adding minimum of removing both unbalanced open and closed brackets or inserting closed unbalanced brackets to end of string ; Print the result ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void minCost ( string str , int a , int b ) { int openUnbalanced = 0 ; int closedUnbalanced = 0 ; int openCount = 0 ; int closedCount = 0 ; for ( int i = 0 ; str [ i ] != ' \\0' ; i ++ ) { if ( str [ i ] == ' ( ' ) { openUnbalanced ++ ; openCount ++ ; } else { if ( openUnbalanced == 0 ) closedUnbalanced ++ ; else openUnbalanced -- ; closedCount ++ ; } } int result = a * ( abs ( openCount - closedCount ) ) ; if ( closedCount > openCount ) closedUnbalanced -= ( closedCount - openCount ) ; if ( openCount > closedCount ) openUnbalanced -= ( openCount - closedCount ) ; result += min ( a * ( openUnbalanced + closedUnbalanced ) , b * closedUnbalanced ) ; cout << result << endl ; } int main ( ) { string str = \" ) ) ( ) ( ( ) ( ) ( \" ; int A = 1 , B = 3 ; minCost ( str , A , B ) ; return 0 ; }", "text_ms": "Kos minimum diperlukan untuk menjana urutan pendakap seimbang | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk mengira kos minimum yang diperlukan untuk menjana urutan pendakap yang seimbang; Menyimpan kiraan kurungan terbuka tidak seimbang; Menyimpan kiraan kurungan tertutup yang tidak seimbang; Menyimpan kiraan kurungan terbuka; Menyimpan kiraan kurungan tertutup; Jika pendakap terbuka ditemui; Jika tidak; Sekiranya tiada kurungan terbuka tidak seimbang; Meningkatkan kiraan kurungan tertutup yang tidak seimbang; Jika tidak; Mengurangkan kiraan kurungan terbuka yang tidak seimbang; Meningkatkan kiraan kurungan tertutup; Mengira batas kos minimum yang lebih rendah; Mengurangkan kurungan terbuka atau tertutup yang berlebihan untuk mengelakkan mengira mereka dua kali; Kemas kini jawapan dengan menambahkan minimum mengeluarkan kedua -dua kurungan terbuka dan tertutup yang tidak seimbang atau memasukkan kurungan tidak seimbang tertutup ke hujung rentetan; Cetak hasilnya; Kod pemacu"}
{"text": "Count of permutations such that sum of K numbers from given range is even | C ++ program for the above approach ; Function to return the number of all permutations such that sum of K numbers in range is even ; Find total count of even and odd number in given range ; Iterate loop k times and update even_sum & odd_sum using previous values ; Update the prev_even and odd_sum ; Even sum ; Odd sum ; Return even_sum ; Driver Code ; Given ranges ; Length of permutation ; Function call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countEvenSum ( int low , int high , int k ) { int even_count = high / 2 - ( low - 1 ) / 2 ; int odd_count = ( high + 1 ) / 2 - low / 2 ; long even_sum = 1 ; long odd_sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) { long prev_even = even_sum ; long prev_odd = odd_sum ; even_sum = ( prev_even * even_count ) + ( prev_odd * odd_count ) ; odd_sum = ( prev_even * odd_count ) + ( prev_odd * even_count ) ; } cout << ( even_sum ) ; } int main ( ) { int low = 4 ; int high = 5 ; int K = 3 ; countEvenSum ( low , high , K ) ; }", "text_ms": "Count of permutasi seperti jumlah nombor k dari julat yang diberikan adalah | Program C ++ untuk pendekatan di atas; Berfungsi untuk mengembalikan bilangan semua permutasi seperti jumlah nombor k dalam julat adalah walaupun; Cari jumlah kiraan nombor walaupun dan ganjil dalam julat yang diberikan; ITERATE LOOP K TIMES DAN UPDATE EVER_SUM & ODD_SUM Menggunakan nilai sebelumnya; Kemas kini prev_even dan odd_sum; Malah jumlah; Jumlah ganjil; Kembali even_sum; Kod pemacu; Diberikan julat; Panjang permutasi; Panggilan fungsi"}
{"text": "Count of N digit Numbers whose sum of every K consecutive digits is equal | Set 2 | C ++ Program to implement the above approach ; Function to count the number of N - digit numbers such that sum of every K consecutive digits are equal ; Print the answer ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void count ( int n , int k ) { long count = ( long ) ( pow ( 10 , k ) - pow ( 10 , k - 1 ) ) ; cout << ( count ) ; } int main ( ) { int n = 2 , k = 1 ; count ( n , k ) ; }", "text_ms": "Count of N digit nombor yang jumlahnya setiap digit berturut -turut adalah sama | Tetapkan 2 | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk mengira bilangan nombor n - digit sedemikian rupa sehingga jumlah setiap digit berturut -turut adalah sama; Cetak jawapannya; Kod pemacu"}
{"text": "Sum of largest divisor of numbers upto N not divisible by given prime number P | C ++ program for the above approach ; Function to find the sum of largest divisors of numbers in range 1 to N not divisible by prime number P ; Total sum upto N ; If no multiple of P exist up to N ; If only P itself is in the range from 1 to N ; Sum of those that are divisible by P ; Recursively function call to find the sum for N / P ; Driver Code ; Given N and P ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int func ( int N , int P ) { int sumUptoN = ( N * ( N + 1 ) / 2 ) ; int sumOfMultiplesOfP ; if ( N < P ) { return sumUptoN ; } else if ( ( N / P ) == 1 ) { return sumUptoN - P + 1 ; } sumOfMultiplesOfP = ( ( N / P ) * ( 2 * P + ( N / P - 1 ) * P ) ) / 2 ; return ( sumUptoN + func ( N / P , P ) - sumOfMultiplesOfP ) ; } int main ( ) { int N = 10 , P = 5 ; cout << func ( N , P ) << \" STRNEWLINE \" ; return 0 ; }", "text_ms": "Jumlah pembahagi terbesar nombor sehingga tidak dibahagikan dengan nombor perdana p | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari jumlah pembahagi terbesar nombor dalam julat 1 hingga n tidak boleh dibahagikan dengan nombor perdana p; Jumlah jumlah sehingga n; Jika tidak ada beberapa p yang ada sehingga n; Jika hanya p sendiri berada dalam lingkungan 1 hingga n; Jumlah mereka yang boleh dibahagikan dengan p; Panggilan fungsi rekursif untuk mencari jumlah untuk N / P; Kod pemacu; Diberikan n dan p; Panggilan fungsi"}
{"text": "Count of right shifts for each array element to be in its sorted position | C ++ Program to implement the approach ; Function to find the right shifts required for each element to reach its sorted array position in A [ ] ; Stores required number of shifts for each element ; If the element is at sorted position ; Otherwise ; Calculate right shift ; Print the respective shifts ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findShifts ( int A [ ] , int N ) { int shift [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == A [ i ] - 1 ) shift [ i ] = 0 ; else shift [ i ] = ( A [ i ] - 1 - i + N ) % N ; } for ( int i = 0 ; i < N ; i ++ ) cout << shift [ i ] << \" ▁ \" ; } int main ( ) { int arr [ ] = { 1 , 4 , 3 , 2 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findShifts ( arr , N ) ; return 0 ; }", "text_ms": "Kira peralihan kanan untuk setiap elemen array berada dalam kedudukan yang disusun | Program C ++ untuk melaksanakan pendekatan; Berfungsi untuk mencari peralihan yang betul yang diperlukan untuk setiap elemen untuk mencapai kedudukan array yang disusun dalam []; Kedai yang diperlukan bilangan peralihan untuk setiap elemen; Jika elemen berada pada kedudukan yang disusun; Jika tidak; Kirakan peralihan kanan; Cetak peralihan masing -masing; Kod pemacu"}
{"text": "Construct a matrix with sum equal to the sum of diagonal elements | C ++ program to implement the above approach ; Function to construct matrix with diagonal sum equal to matrix sum ; If diagonal position ; Positive element ; Negative element ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void constructmatrix ( int N ) { bool check = true ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( i == j ) { cout << 1 << \" ▁ \" ; } else if ( check ) { cout << 2 << \" ▁ \" ; check = false ; } else { cout << -2 << \" ▁ \" ; check = true ; } } cout << endl ; } } int main ( ) { int N = 5 ; constructmatrix ( 5 ) ; return 0 ; }", "text_ms": "Membina matriks dengan jumlah yang sama dengan jumlah unsur pepenjuru | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk membina matriks dengan jumlah pepenjuru yang sama dengan jumlah matriks; Jika kedudukan pepenjuru; Elemen positif; Elemen negatif; Kod pemacu"}
{"text": "Minimum count of numbers required with unit digit X that sums up to N | C ++ Program to implement the above approach ; Function to calculate and return the minimum number of times a number with unit digit X needs to be added to get a sum N ; Calculate the number of additions required to get unit digit of N ; If unit digit of N cannot be obtained ; Function to return the minimum number required to represent N ; Stores unit digit of N ; Stores minimum addition of X required to obtain unit digit of N ; If unit digit of N cannot be obtained ; Otherwise ; If N is greater than or equal to ( X * times ) ; Minimum count of numbers that needed to represent N ; Representation not possible ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int check ( int unit_digit , int X ) { int times , digit ; for ( int times = 1 ; times <= 10 ; times ++ ) { digit = ( X * times ) % 10 ; if ( digit == unit_digit ) return times ; } return -1 ; } int getNum ( int N , int X ) { int unit_digit ; unit_digit = N % 10 ; int times = check ( unit_digit , X ) ; if ( times == -1 ) return times ; else { if ( N >= ( times * X ) ) return times ; else return -1 ; } } int main ( ) { int N = 58 , X = 7 ; cout << getNum ( N , X ) << endl ; return 0 ; }", "text_ms": "Kiraan minimum nombor yang diperlukan dengan unit digit x yang merangkum sehingga n | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk mengira dan mengembalikan bilangan minimum kali nombor dengan unit digit X perlu ditambah untuk mendapatkan jumlah n; Kirakan bilangan penambahan yang diperlukan untuk mendapatkan digit unit N; Jika digit unit n tidak dapat diperoleh; Berfungsi untuk mengembalikan nombor minimum yang diperlukan untuk mewakili n; Kedai Unit Digit N; Penambahan minimum x yang diperlukan untuk mendapatkan digit unit N; Jika digit unit n tidak dapat diperoleh; Jika tidak; Jika n lebih besar daripada atau sama dengan (x * kali); Kiraan minimum nombor yang diperlukan untuk mewakili n; Perwakilan tidak mungkin; Kod pemacu"}
{"text": "Minimum number of points required to cover all blocks of a 2 | C ++ program for the above approach ; Function to find the minimum number of Points required to cover a grid ; If number of block is even ; Return the minimum points ; Driver Code ; Given size of grid ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minPoints ( int n , int m ) { int ans = 0 ; if ( ( n % 2 != 0 ) && ( m % 2 != 0 ) ) { ans = ( ( n * m ) / 2 ) + 1 ; } else { ans = ( n * m ) / 2 ; } return ans ; } int main ( ) { int N = 5 , M = 7 ; cout << minPoints ( N , M ) ; return 0 ; }", "text_ms": "Bilangan minimum mata yang diperlukan untuk menampung semua blok 2 | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari bilangan minimum mata yang diperlukan untuk menampung grid; Jika bilangan blok adalah juga; Mengembalikan mata minimum; Kod pemacu; Diberikan saiz grid; Panggilan fungsi"}
{"text": "Largest lexicographical string with at most K consecutive elements | C ++ code for the above approach ; Function to find the largest lexicographical string with given constraints . ; vector containing frequency of each character . ; assigning frequency to ; empty string of string class type ; loop to iterate over maximum priority first . ; if frequency is greater than or equal to k . ; temporary variable to operate in - place of k . ; concatenating with the resultant string ans . ; handling k case by adjusting with just smaller priority element . ; condition to verify if index j does have frequency greater than 0 ; ; if no such element is found than string can not be processed further . ; if frequency is greater than 0 and less than k . ; here we don 't need to fix K  consecutive element criteria. ; otherwise check for next possible element . ; Driver program", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE string getLargestString ( string s , ll k ) { vector < int > frequency_array ( 26 , 0 ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { frequency_array [ s [ i ] - ' a ' ] ++ ; } string ans = \" \" ; for ( int i = 25 ; i >= 0 ; ) { if ( frequency_array [ i ] > k ) { int temp = k ; string st ( 1 , i + ' a ' ) ; while ( temp > 0 ) { ans += st ; temp -- ; } frequency_array [ i ] -= k ; int j = i - 1 ; while ( frequency_array [ j ] <= 0 && j >= 0 ) { j -- ; } if ( frequency_array [ j ] > 0 && j >= 0 ) { string str ( 1 , j + ' a ' ) ; ans += str ; frequency_array [ j ] -= 1 ; } else { break ; } } else if ( frequency_array [ i ] > 0 ) { int temp = frequency_array [ i ] ; frequency_array [ i ] -= temp ; string st ( 1 , i + ' a ' ) ; while ( temp > 0 ) { ans += st ; temp -- ; } } else { i -- ; } } return ans ; } int main ( ) { string S = \" xxxxzza \" ; int k = 3 ; cout << getLargestString ( S , k ) << endl ; return 0 ; }", "text_ms": "String lexicographical terbesar dengan paling banyak unsur berturut -turut K | C ++ kod untuk pendekatan di atas; Fungsi untuk mencari rentetan leksikografi terbesar dengan kekangan yang diberikan. ; vektor yang mengandungi kekerapan setiap aksara. ; Menetapkan kekerapan kepada; kosongkan rentetan jenis kelas rentetan; Gelung untuk melangkah ke atas keutamaan maksimum terlebih dahulu. ; Jika kekerapan lebih besar daripada atau sama dengan k. ; Pembolehubah sementara untuk beroperasi di tempat k. ; menggabungkan dengan rentetan yang dihasilkan. ; Pengendalian kes K dengan menyesuaikan dengan unsur keutamaan yang lebih kecil. ; keadaan untuk mengesahkan sama ada indeks j mempunyai kekerapan yang lebih besar daripada 0; ; Jika tiada elemen sedemikian dijumpai daripada rentetan tidak dapat diproses lagi. ; Jika kekerapan lebih besar daripada 0 dan kurang daripada k. ; Di sini kita tidak perlu memperbaiki kriteria elemen berturut -turut. ; Jika tidak, periksa elemen seterusnya yang mungkin. ; Program Pemandu"}
{"text": "Minimum operations to make all elements equal using the second array | C ++ implementation to find the minimum operations make all elements equal using the second array ; Function to find the minimum operations required to make all elements of the array equal ; Minimum element of A [ ] ; Traverse through all final values ; Variable indicating whether all elements can be converted to x or not ; Total operations ; Traverse through all array elements ; All elements can 't  be converted to x ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( int a [ ] , int b [ ] , int n ) { int minA = * min_element ( a , a + n ) ; for ( int x = minA ; x >= 0 ; x -- ) { bool check = 1 ; int operations = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( x % b [ i ] == a [ i ] % b [ i ] ) { operations += ( a [ i ] - x ) / b [ i ] ; } else { check = 0 ; break ; } } if ( check ) return operations ; } return -1 ; } int main ( ) { int N = 5 ; int A [ N ] = { 5 , 7 , 10 , 5 , 15 } ; int B [ N ] = { 2 , 2 , 1 , 3 , 5 } ; cout << minOperations ( A , B , N ) ; return 0 ; }", "text_ms": "Operasi minimum untuk menjadikan semua elemen sama menggunakan array kedua | Pelaksanaan C ++ untuk mencari operasi minimum menjadikan semua elemen sama menggunakan array kedua; Berfungsi untuk mencari operasi minimum yang diperlukan untuk membuat semua elemen array sama; Elemen minimum []; Melintasi semua nilai akhir; Pembolehubah yang menunjukkan sama ada semua elemen boleh ditukar kepada x atau tidak; Jumlah operasi; Melintasi semua elemen array; Semua elemen tidak boleh ditukar kepada x; Kod pemacu"}
{"text": "Find the maximum sum ( a + b ) for a given input integer N satisfying the given condition | C ++ implementation to find the largest value of a + b satisfying the given condition ; Function to return the maximum sum of a + b satisfying the given condition ; Initialize max_sum ; Consider all the possible pairs ; Check if the product is divisible by the sum ; Storing the maximum sum in the max_sum variable ; Return the max_sum value ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int getLargestSum ( int N ) { int max_sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = i + 1 ; j <= N ; j ++ ) { if ( i * j % ( i + j ) == 0 ) max_sum = max ( max_sum , i + j ) ; } } return max_sum ; } int main ( ) { int N = 25 ; int max_sum = getLargestSum ( N ) ; cout << max_sum << endl ; return 0 ; }", "text_ms": "Cari jumlah maksimum (a + b) untuk integer input yang diberikan dan memenuhi syarat yang diberikan | C ++ pelaksanaan untuk mencari nilai terbesar A + B yang memenuhi syarat yang diberikan; Berfungsi untuk mengembalikan jumlah maksimum A + B yang memenuhi syarat yang diberikan; Memulakan max_sum; Pertimbangkan semua pasangan yang mungkin; Semak sama ada produk itu boleh dibahagikan dengan jumlah; Menyimpan jumlah maksimum dalam pembolehubah max_sum; Kembalikan nilai max_sum; Kod pemacu"}
{"text": "Maximize the sum of array after multiplying a prefix and suffix by | C ++ implementation to find the maximum sum of the array by multiplying the prefix and suffix of the array by - 1 ; Kadane 's algorithm to find the maximum subarray sum ; Loop to find the maximum subarray array sum in the given array ; Function to find the maximum sum of the array by multiplying the prefix and suffix by - 1 ; Total intital sum ; Loop to find the maximum sum of the array ; Maximum value ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = INT_MIN , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_ending_here < 0 ) max_ending_here = 0 ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; } return max_so_far ; } int maxSum ( int a [ ] , int n ) { int S = 0 ; for ( int i = 0 ; i < n ; i ++ ) S += a [ i ] ; int X = maxSubArraySum ( a , n ) ; return 2 * X - S ; } int main ( ) { int a [ ] = { -1 , -2 , -3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int max_sum = maxSum ( a , n ) ; cout << max_sum ; return 0 ; }", "text_ms": "Memaksimumkan jumlah array selepas mengalikan awalan dan akhiran oleh | C ++ pelaksanaan untuk mencari jumlah maksimum array dengan mengalikan awalan dan akhiran array oleh - 1; Algoritma Kadane untuk mencari jumlah subarray maksimum; Gelung untuk mencari jumlah array subarray maksimum dalam array yang diberikan; Berfungsi untuk mencari jumlah maksimum array dengan mengalikan awalan dan akhiran oleh - 1; Jumlah jumlah intital; Gelung untuk mencari jumlah maksimum array; Nilai maksimum; Kod pemacu"}
{"text": "Count of interesting primes upto N | C ++ program to find the number of interesting primes up to N ; Function to check if a number is prime or not ; If n is divisible by any number between 2 and sqrt ( n ) , it is not prime ; Function to check if a number is perfect square or not ; Find floating point value of square root of x . ; If square root is an integer ; Function to find the number of interesting primes less than equal to N . ; Check whether the number is prime or not ; Iterate for values of b ; Check condition for a ; Return the required answer ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { int flag = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { flag = 0 ; break ; } } return ( flag == 1 ? true : false ) ; } bool isPerfectSquare ( int x ) { long double sr = sqrt ( x ) ; return ( ( sr - floor ( sr ) ) == 0 ) ; } int countInterestingPrimes ( int n ) { int answer = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( isPrime ( i ) ) { for ( int j = 1 ; j * j * j * j <= i ; j ++ ) { if ( isPerfectSquare ( i - j * j * j * j ) ) { answer ++ ; break ; } } } } return answer ; } int main ( ) { int N = 10 ; cout << countInterestingPrimes ( N ) ; return 0 ; }", "text_ms": "Count of Prima yang menarik sehingga n | Program C ++ untuk mencari bilangan prima yang menarik sehingga N; Berfungsi untuk memeriksa sama ada nombor adalah perdana atau tidak; Jika n boleh dibahagikan dengan mana -mana nombor antara 2 dan sqrt (n), ia bukan perdana; Berfungsi untuk memeriksa sama ada nombor adalah persegi sempurna atau tidak; Cari nilai titik terapung akar persegi x. ; Jika akar persegi adalah integer; Fungsi untuk mencari bilangan prima yang menarik kurang daripada sama dengan n. ; Periksa sama ada nombor itu adalah perdana atau tidak; Berulang untuk nilai b; Periksa syarat untuk a; Mengembalikan jawapan yang diperlukan; Kod pemacu"}
{"text": "Maximize the number by flipping at most K bits | C ++ implementation of the approach ; Function to convert decimal number n to its binary representation stored as an array arr [ ] ; Function to convert the number represented as a binary array arr [ ] into its decimal equivalent ; Function to return the maximized number by flipping atmost k bits ; Number of bits in n ; Find the binary representation of n ; To count the number of 0 s flipped ; Return the decimal equivalent of the maximized number ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void decBinary ( int arr [ ] , int n ) { int k = log2 ( n ) ; while ( n > 0 ) { arr [ k -- ] = n % 2 ; n /= 2 ; } } int binaryDec ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += arr [ i ] << ( n - i - 1 ) ; return ans ; } int maxNum ( int n , int k ) { int l = log2 ( n ) + 1 ; int a [ l ] = { 0 } ; decBinary ( a , n ) ; int cn = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( a [ i ] == 0 && cn < k ) { a [ i ] = 1 ; cn ++ ; } } return binaryDec ( a , l ) ; } int main ( ) { int n = 4 , k = 1 ; cout << maxNum ( n , k ) ; return 0 ; }", "text_ms": "Memaksimumkan nombor dengan membalikkan kebanyakan bit k | C ++ pelaksanaan pendekatan; Berfungsi untuk menukar nombor perpuluhan n ke perwakilan binari yang disimpan sebagai array arr []; Berfungsi untuk menukar nombor yang diwakili sebagai array perduaan [] ke dalam setara perpuluhannya; Berfungsi untuk mengembalikan nombor yang dimaksimumkan dengan membalikkan atmost k bit; Bilangan bit dalam n; Cari perwakilan binari n; Untuk mengira bilangan 0 s terbalik; Mengembalikan setara perpuluhan nombor yang dimaksimumkan; Kod pemacu"}
{"text": "Find the subsequence with given sum in a superincreasing sequence | C ++ implementation of the approach ; Function to find the required subsequence ; Current element cannot be a part of the required subsequence ; Include current element in the required subsequence So update the sum ; Print the elements of the required subsequence ; If the current element was included in the subsequence ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findSubSeq ( int arr [ ] , int n , int sum ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( sum < arr [ i ] ) arr [ i ] = -1 ; else sum -= arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != -1 ) cout << arr [ i ] << \" ▁ \" ; } } int main ( ) { int arr [ ] = { 17 , 25 , 46 , 94 , 201 , 400 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int sum = 272 ; findSubSeq ( arr , n , sum ) ; return 0 ; }", "text_ms": "Cari berikutnya dengan jumlah yang diberikan dalam urutan superincreasing | C ++ pelaksanaan pendekatan; Berfungsi untuk mencari seterusnya yang diperlukan; Elemen semasa tidak boleh menjadi sebahagian daripada berikutnya yang diperlukan; Termasuk elemen semasa dalam seterusnya yang diperlukan supaya mengemas kini jumlah; Cetak unsur -unsur berikutnya yang diperlukan; Jika elemen semasa dimasukkan ke dalam berikutnya; Kod pemacu"}
{"text": "Find the most valued alphabet in the String | C ++ implementation of the approach ; Function to return the maximum valued alphabet ; To store the first and the last occurrence of all the characters ; Set the first and the last occurrence of all the characters to - 1 ; Update the occurrences of the characters ; Only set the first occurrence if it hasn 't already been set ; To store the result ; For every alphabet ; If current alphabet doesn 't appear  in the given string ; If the current character has the highest value so far ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 26 ; char maxAlpha ( string str , int len ) { int first [ MAX ] , last [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { first [ i ] = -1 ; last [ i ] = -1 ; } for ( int i = 0 ; i < len ; i ++ ) { int index = ( str [ i ] - ' a ' ) ; if ( first [ index ] == -1 ) first [ index ] = i ; last [ index ] = i ; } int ans = -1 , maxVal = -1 ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( first [ i ] == -1 ) continue ; if ( ( last [ i ] - first [ i ] ) > maxVal ) { maxVal = last [ i ] - first [ i ] ; ans = i ; } } return ( char ) ( ans + ' a ' ) ; } int main ( ) { string str = \" abbba \" ; int len = str . length ( ) ; cout << maxAlpha ( str , len ) ; return 0 ; }", "text_ms": "Cari abjad yang paling bernilai dalam rentetan | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan abjad bernilai maksimum; Untuk menyimpan kejadian pertama dan terakhir semua watak; Tetapkan kejadian pertama dan terakhir semua aksara kepada - 1; Kemas kini kejadian watak -watak; Hanya menetapkan kejadian pertama jika ia tidak telah ditetapkan; Untuk menyimpan hasilnya; Untuk setiap abjad; Jika abjad semasa tidak muncul dalam rentetan yang diberikan; Jika watak semasa mempunyai nilai tertinggi setakat ini; Kod pemacu"}
{"text": "Queries for number of distinct elements from a given index till last index in an array | C ++ implementation of the approach ; Function to perform queries to find number of distinct elements from a given index till last index in an array ; Check if current element already visited or not ; If not visited store current counter and increment it and mark check as 1 ; Otherwise if visited simply store current counter ; Perform queries ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100001 NEW_LINE void find_distinct ( int a [ ] , int n , int q , int queries [ ] ) { int check [ MAX ] = { 0 } ; int idx [ MAX ] ; int cnt = 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( check [ a [ i ] ] == 0 ) { idx [ i ] = cnt ; check [ a [ i ] ] = 1 ; cnt ++ ; } else { idx [ i ] = cnt - 1 ; } } for ( int i = 0 ; i < q ; i ++ ) { int m = queries [ i ] ; cout << idx [ m ] << \" ▁ \" ; } } int main ( ) { int a [ ] = { 1 , 2 , 3 , 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( a ) / sizeof ( int ) ; int queries [ ] = { 0 , 3 , 5 , 7 } ; int q = sizeof ( queries ) / sizeof ( int ) ; find_distinct ( a , n , q , queries ) ; return 0 ; }", "text_ms": "Pertanyaan untuk bilangan elemen yang berbeza dari indeks yang diberikan sehingga indeks terakhir dalam array | C ++ pelaksanaan pendekatan; Berfungsi untuk melakukan pertanyaan untuk mencari bilangan elemen yang berbeza dari indeks yang diberikan sehingga indeks terakhir dalam array; Periksa sama ada elemen semasa sudah dilawati atau tidak; Jika tidak melawat kaunter semasa dan kenaikannya dan semak semak sebagai 1; Jika tidak, jika dikunjungi hanya menyimpan kaunter semasa; Melakukan pertanyaan; Kod pemacu"}
{"text": "Convert given integer X to the form 2 ^ N | C ++ implementation of the approach ; Function to return the count of operations required ; To store the powers of 2 ; Temporary variable to store x ; To store the index of smaller number larger than x ; To store the count of operations ; Stores the index of number in the form of 2 ^ n - 1 ; If x is already in the form 2 ^ n - 1 then no operation is required ; If number is less than x increase the index ; Calculate all the values ( x xor 2 ^ n - 1 ) for all possible n ; Only take value which is closer to the number ; If number is in the form of 2 ^ n - 1 then break ; Return the count of operations required to obtain the number ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 24 ; int countOp ( int x ) { int arr [ MAX ] ; arr [ 0 ] = 1 ; for ( int i = 1 ; i < MAX ; i ++ ) arr [ i ] = arr [ i - 1 ] * 2 ; int temp = x ; bool flag = true ; int ans ; int operations = 0 ; bool flag2 = false ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( arr [ i ] - 1 == x ) flag2 = true ; if ( arr [ i ] > x ) { ans = i ; break ; } } if ( flag2 ) return 0 ; while ( flag ) { if ( arr [ ans ] < x ) ans ++ ; operations ++ ; for ( int i = 0 ; i < MAX ; i ++ ) { int take = x ^ ( arr [ i ] - 1 ) ; if ( take <= arr [ ans ] - 1 ) { if ( take > temp ) temp = take ; } } if ( temp == arr [ ans ] - 1 ) { flag = false ; break ; } temp ++ ; operations ++ ; x = temp ; if ( x == arr [ ans ] - 1 ) flag = false ; } return operations ; } int main ( ) { int x = 39 ; cout << countOp ( x ) ; return 0 ; }", "text_ms": "Tukar Integer X diberikan kepada Borang 2 ^ n | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan kiraan operasi yang diperlukan; Untuk menyimpan kuasa 2; Pembolehubah sementara untuk menyimpan X; Untuk menyimpan indeks nombor yang lebih kecil daripada x; Untuk menyimpan kiraan operasi; Menyimpan indeks nombor dalam bentuk 2 ^ n - 1; Jika x sudah ada dalam bentuk 2 ^ n - 1 maka tiada operasi diperlukan; Jika nombor kurang daripada x meningkatkan indeks; Kirakan semua nilai (x xor 2 ^ n - 1) untuk semua yang mungkin n; Hanya mengambil nilai yang lebih dekat dengan nombor; Jika nombor berada dalam bentuk 2 ^ n - 1 maka pecah; Mengembalikan kiraan operasi yang diperlukan untuk mendapatkan nombor; Kod pemacu"}
{"text": "Minimum number of given operations required to reduce the array to 0 element | C ++ implementation of the approach ; Function to return the minimum operations required ; Count the frequency of each element ; Maximum element from the array ; Find all the multiples of i ; Delete the multiples ; Increment the operations ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( int * arr , int n ) { int maxi , result = 0 ; vector < int > freq ( 1000001 , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ; freq [ x ] ++ ; } maxi = * ( max_element ( arr , arr + n ) ) ; for ( int i = 1 ; i <= maxi ; i ++ ) { if ( freq [ i ] != 0 ) { for ( int j = i * 2 ; j <= maxi ; j = j + i ) { freq [ j ] = 0 ; } result ++ ; } } return result ; } int main ( ) { int arr [ ] = { 2 , 4 , 2 , 4 , 4 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minOperations ( arr , n ) ; return 0 ; }", "text_ms": "Bilangan minimum operasi yang diberikan untuk mengurangkan array ke 0 elemen | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan operasi minimum yang diperlukan; Hitung kekerapan setiap elemen; Elemen maksimum dari array; Cari semua gandaan i; Padamkan gandaan; Meningkatkan operasi; Kod pemacu"}
{"text": "Minimum LCM and GCD possible among all possible sub | C ++ implementation of the approach ; Function to return minimum GCD among all subarrays ; Minimum GCD among all sub - arrays will be the GCD of all the elements of the array ; Function to return minimum LCM among all subarrays ; Minimum LCM among all sub - arrays will be the minimum element from the array ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minGCD ( int arr [ ] , int n ) { int minGCD = 0 ; for ( int i = 0 ; i < n ; i ++ ) minGCD = __gcd ( minGCD , arr [ i ] ) ; return minGCD ; } int minLCM ( int arr [ ] , int n ) { int minLCM = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) minLCM = min ( minLCM , arr [ i ] ) ; return minLCM ; } int main ( ) { int arr [ ] = { 2 , 66 , 14 , 521 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << \" LCM ▁ = ▁ \" << minLCM ( arr , n ) << \" , ▁ GCD ▁ = ▁ \" << minGCD ( arr , n ) ; return 0 ; }", "text_ms": "Minimum LCM dan GCD mungkin di antara semua sub | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan GCD minimum di kalangan semua subarray; GCD minimum di antara semua sub -tatasusunan akan menjadi GCD dari semua elemen array; Berfungsi untuk mengembalikan LCM minimum di kalangan semua subarray; LCM minimum di antara semua sub - tatasusunan akan menjadi elemen minimum dari array; Kod pemacu"}
{"text": "Form lexicographically smallest string with minimum replacements having equal number of 0 s , 1 s and 2 s | C ++ implementation of the approach ; Function that returns the modified lexicographically smallest string after performing minimum number of given operations ; Stores the initial frequencies of characters 0 s , 1 s and 2 s ; Stores number of processed characters upto that point of each type ; Required number of characters of each type ; If the current type has already reqd number of characters , no need to perform any operation ; Process all 3 cases ; Check for 1 first ; Else 2 ; Here we need to check processed [ 1 ] only for 2 since 0 is less than 1 and we can replace it anytime ; Here we can replace 2 with 0 and 1 anytime ; keep count of processed characters of each type ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string formStringMinOperations ( string s ) { int count [ 3 ] = { 0 } ; for ( auto & c : s ) count ++ ; int processed [ 3 ] = { 0 } ; int reqd = ( int ) s . size ( ) / 3 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( count [ s [ i ] - '0' ] == reqd ) continue ; if ( s [ i ] == '0' && count [ 0 ] > reqd && processed [ 0 ] >= reqd ) { if ( count [ 1 ] < reqd ) { s [ i ] = '1' ; count [ 1 ] ++ ; count [ 0 ] -- ; } else if ( count [ 2 ] < reqd ) { s [ i ] = '2' ; count [ 2 ] ++ ; count [ 0 ] -- ; } } if ( s [ i ] == '1' && count [ 1 ] > reqd ) { if ( count [ 0 ] < reqd ) { s [ i ] = '0' ; count [ 0 ] ++ ; count [ 1 ] -- ; } else if ( count [ 2 ] < reqd && processed [ 1 ] >= reqd ) { s [ i ] = '2' ; count [ 2 ] ++ ; count [ 1 ] -- ; } } if ( s [ i ] == '2' && count [ 2 ] > reqd ) { if ( count [ 0 ] < reqd ) { s [ i ] = '0' ; count [ 0 ] ++ ; count [ 2 ] -- ; } else if ( count [ 1 ] < reqd ) { s [ i ] = '1' ; count [ 1 ] ++ ; count [ 2 ] -- ; } } processed [ s [ i ] - '0' ] ++ ; } return s ; } int main ( ) { string s = \"011200\" ; cout << formStringMinOperations ( s ) ; return 0 ; }", "text_ms": "Bentuk rentetan terkecil secara lexicographically dengan penggantian minimum yang mempunyai bilangan yang sama 0 s, 1 s dan 2 s | C ++ pelaksanaan pendekatan; Fungsi yang mengembalikan rentetan terkecil lexicographically yang diubahsuai selepas melakukan bilangan minimum operasi yang diberikan; Menyimpan frekuensi awal aksara 0 s, 1 s dan 2 s; Menyimpan bilangan aksara yang diproses sehingga titik setiap jenis; Bilangan aksara yang diperlukan setiap jenis; Jika jenis semasa telah membatalkan bilangan aksara, tidak perlu melakukan apa -apa operasi; Proses semua 3 kes; Semak 1 pertama; Lain 2; Di sini kita perlu menyemak yang diproses [1] hanya untuk 2 kerana 0 adalah kurang daripada 1 dan kita boleh menggantikannya pada bila -bila masa; Di sini kita boleh menggantikan 2 dengan 0 dan 1 bila -bila masa; Simpan kiraan aksara yang diproses setiap jenis; Kod pemacu"}
{"text": "Minimum number of adjacent swaps for arranging similar elements together | C ++ Program to find the minimum number of adjacent swaps to arrange similar items together ; Function to find minimum swaps ; visited array to check if value is seen already ; If the arr [ i ] is seen first time ; stores the number of swaps required to find the correct position of current element 's partner ; Increment count only if the current element has not been visited yet ( if is visited , means it has already been placed at its correct position ) ; If current element 's partner is found ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinimumAdjacentSwaps ( int arr [ ] , int N ) { bool visited [ N + 1 ] ; int minimumSwaps = 0 ; memset ( visited , false , sizeof ( visited ) ) ; for ( int i = 0 ; i < 2 * N ; i ++ ) { if ( visited [ arr [ i ] ] == false ) { visited [ arr [ i ] ] = true ; int count = 0 ; for ( int j = i + 1 ; j < 2 * N ; j ++ ) { if ( visited [ arr [ j ] ] == false ) count ++ ; else if ( arr [ i ] == arr [ j ] ) minimumSwaps += count ; } } } return minimumSwaps ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 3 , 1 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; N /= 2 ; cout << findMinimumAdjacentSwaps ( arr , N ) << endl ; return 0 ; }", "text_ms": "Bilangan minimum swap bersebelahan untuk mengatur unsur -unsur yang sama bersama -sama | Program C ++ untuk mencari bilangan minimum swap bersebelahan untuk mengatur item yang sama bersama -sama; Berfungsi untuk mencari swap minimum; Arahan yang dikunjungi untuk memeriksa sama ada nilai sudah dilihat; Jika arr [i] dilihat kali pertama; menyimpan bilangan swap yang diperlukan untuk mencari kedudukan yang betul dari rakan kongsi elemen semasa; Kiraan kenaikan hanya jika elemen semasa belum dikunjungi (jika dikunjungi, bermakna ia telah diletakkan pada kedudukan yang betul); Jika rakan kongsi elemen semasa dijumpai; Kod pemacu"}
{"text": "Largest palindromic number by permuting digits | CPP program to print the largest palindromic number by permuting digits of a number ; function to check if a number can be permuted to form a palindrome number ; counts the occurrence of number which is odd ; if occurrence is odd ; if number exceeds 1 ; function to print the largest palindromic number by permuting digits of a number ; string length ; map that marks the occurrence of a number ; check the possibility of a palindromic number ; string array that stores the largest permuted palindromic number ; pointer of front ; greedily start from 9 to 0 and place the greater number in front and odd in the middle ; if the occurrence of number is odd ; place one odd occurring number in the middle ; decrease the count ; place the rest of numbers greedily ; if all numbers occur even times , then place greedily ; place greedily at front ; 2 numbers are placed , so decrease the count ; increase placing position ; print the largest string thus formed ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool possibility ( unordered_map < int , int > m , int length , string s ) { int countodd = 0 ; for ( int i = 0 ; i < length ; i ++ ) { if ( m [ s [ i ] - '0' ] & 1 ) countodd ++ ; if ( countodd > 1 ) return false ; } return true ; } void largestPalindrome ( string s ) { int l = s . length ( ) ; unordered_map < int , int > m ; for ( int i = 0 ; i < l ; i ++ ) m [ s [ i ] - '0' ] ++ ; if ( possibility ( m , l , s ) == false ) { cout << \" Palindrome ▁ cannot ▁ be ▁ formed \" ; return ; } char largest [ l ] ; int front = 0 ; for ( int i = 9 ; i >= 0 ; i -- ) { if ( m [ i ] & 1 ) { largest [ l / 2 ] = char ( i + 48 ) ; m [ i ] -- ; while ( m [ i ] > 0 ) { largest [ front ] = char ( i + 48 ) ; largest [ l - front - 1 ] = char ( i + 48 ) ; m [ i ] -= 2 ; front ++ ; } } else { while ( m [ i ] > 0 ) { largest [ front ] = char ( i + 48 ) ; largest [ l - front - 1 ] = char ( i + 48 ) ; m [ i ] -= 2 ; front ++ ; } } } for ( int i = 0 ; i < l ; i ++ ) cout << largest [ i ] ; } int main ( ) { string s = \"313551\" ; largestPalindrome ( s ) ; return 0 ; }", "text_ms": "Nombor Palindromic Terbesar dengan Permuting Digits | Program CPP untuk mencetak nombor palindromik terbesar dengan membenarkan digit nombor; berfungsi untuk memeriksa sama ada nombor boleh dibentuk untuk membentuk nombor palindrome; Mengira kejadian nombor yang ganjil; Sekiranya kejadian ganjil; jika nombor melebihi 1; berfungsi untuk mencetak nombor palindromik terbesar dengan membenarkan digit nombor; panjang rentetan; peta yang menandakan kejadian nombor; Semak kemungkinan nombor palindromik; array rentetan yang menyimpan nombor palindromik yang terbesar; penunjuk depan; Ramuan bermula dari 9 hingga 0 dan letakkan nombor yang lebih besar di depan dan ganjil di tengah; Sekiranya berlakunya nombor adalah ganjil; Letakkan satu nombor ganjil di tengah; mengurangkan kiraan; Letakkan seluruh nombor dengan tamak; Jika semua nombor berlaku walaupun masa, maka letakkan dengan tamak; Letakkan tamak di hadapan; 2 nombor diletakkan, jadi mengurangkan kiraan; meningkatkan kedudukan meletakkan; Cetak rentetan terbesar yang terbentuk; Kod pemacu"}
{"text": "Minimum Swaps for Bracket Balancing | C ++ program to count swaps required to balance string ; Function to calculate swaps required ; Keep track of ' [ ' ; To count number of encountered ' [ ' ; To track position of next ' [ ' in pos ; To store result ; Increment count and move p to next position ; We have encountered an unbalanced part of string ; Increment sum by number of swaps required i . e . position of next ' [ ' - current position ; Reset count to 1 ; Driver code", "code": "#include <iostream> NEW_LINE #include <vector> NEW_LINE #include <algorithm> NEW_LINE using namespace std ; long swapCount ( string s ) { vector < int > pos ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) if ( s [ i ] == ' [ ' ) pos . push_back ( i ) ; int count = 0 ; int p = 0 ; long sum = 0 ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { if ( s [ i ] == ' [ ' ) { ++ count ; ++ p ; } else if ( s [ i ] == ' ] ' ) -- count ; if ( count < 0 ) { sum += pos [ p ] - i ; swap ( s [ i ] , s [ pos [ p ] ] ) ; ++ p ; count = 1 ; } } return sum ; } int main ( ) { string s = \" [ ] ] [ ] [ \" ; cout << swapCount ( s ) << \" STRNEWLINE \" ; s = \" [ [ ] [ ] ] \" ; cout << swapCount ( s ) << \" STRNEWLINE \" ; return 0 ; }", "text_ms": "Swap minimum untuk mengimbangi pendakap | Program C ++ untuk mengira swap yang diperlukan untuk mengimbangi rentetan; Fungsi untuk mengira swap yang diperlukan; Jejaki '['; Untuk mengira bilangan yang ditemui '['; Untuk mengesan kedudukan seterusnya '[' dalam POS; Untuk menyimpan hasil; Kiraan kenaikan dan bergerak P ke kedudukan seterusnya; Kami telah menemui bahagian rentetan yang tidak seimbang; Jumlah kenaikan dengan bilangan swap yang diperlukan i. e. kedudukan seterusnya '[' - kedudukan semasa; Tetapkan semula kiraan kepada 1; Kod pemacu"}
{"text": "Minimum Cost to cut a board into squares | C ++ program to divide a board into m * n squares ; method returns minimum cost to break board into m * n squares ; sort the horizontal cost in reverse order ; sort the vertical cost in reverse order ; initialize current width as 1 ; loop until one or both cost array are processed ; increase current horizontal part count by 1 ; increase current vertical part count by 1 ; loop for horizontal array , if remains ; loop for vertical array , if remains ; Driver code to test above methods", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumCostOfBreaking ( int X [ ] , int Y [ ] , int m , int n ) { int res = 0 ; sort ( X , X + m , greater < int > ( ) ) ; sort ( Y , Y + n , greater < int > ( ) ) ; int hzntl = 1 , vert = 1 ; int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( X [ i ] > Y [ j ] ) { res += X [ i ] * vert ; hzntl ++ ; i ++ ; } else { res += Y [ j ] * hzntl ; vert ++ ; j ++ ; } } int total = 0 ; while ( i < m ) total += X [ i ++ ] ; res += total * vert ; total = 0 ; while ( j < n ) total += Y [ j ++ ] ; res += total * hzntl ; return res ; } int main ( ) { int m = 6 , n = 4 ; int X [ m - 1 ] = { 2 , 1 , 3 , 1 , 4 } ; int Y [ n - 1 ] = { 4 , 1 , 2 } ; cout << minimumCostOfBreaking ( X , Y , m - 1 , n - 1 ) ; return 0 ; }", "text_ms": "Kos minimum untuk memotong papan ke dalam dataran | Program C ++ untuk membahagikan papan ke dalam kotak m * n; kaedah mengembalikan kos minimum untuk memecahkan papan ke dalam kotak m * n; menyusun kos mendatar dalam urutan terbalik; menyusun kos menegak dalam urutan terbalik; memulakan lebar semasa sebagai 1; gelung sehingga satu atau kedua -dua kos kos diproses; meningkatkan kiraan bahagian mendatar semasa dengan 1; meningkatkan kiraan bahagian menegak semasa dengan 1; gelung untuk array mendatar, jika kekal; gelung untuk pelbagai menegak, jika kekal; Kod pemacu untuk menguji kaedah di atas"}
{"text": "Minimize the count of characters to be added or removed to make String repetition of same substring | C ++ program for the above approach ; Function to find the minimum of the three numbers ; Function to find the minimum number operations required to convert string str1 to str2 using the operations ; Stores the results of subproblems ; Fill dp [ ] [ ] in bottom up manner ; If str1 is empty , then insert all characters of string str2 ; Minimum operations is j ; If str2 is empty , then remove all characters of string str2 ; Minimum operations is i ; If the last characters are same , then ignore last character ; If the last character is different , then find the minimum ; Perform one of the insert , remove and the replace ; Return the minimum number of steps required ; Function to find the minimum number of steps to modify the string such that first half and second half becomes the same ; Stores the minimum number of operations required ; Traverse the given string S ; Find the minimum operations ; Update the ans ; Print the result ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMin ( int x , int y , int z ) { return min ( min ( x , y ) , z ) ; } int editDistance ( string str1 , string str2 , int m , int n ) { int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i ] [ j ] = j ; else if ( j == 0 ) dp [ i ] [ j ] = i ; else if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else { dp [ i ] [ j ] = 1 + getMin ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - 1 ] ) ; } } } return dp [ m ] [ n ] ; } void minimumSteps ( string & S , int N ) { int ans = INT_MAX ; for ( int i = 1 ; i < N ; i ++ ) { string S1 = S . substr ( 0 , i ) ; string S2 = S . substr ( i ) ; int count = editDistance ( S1 , S2 , S1 . length ( ) , S2 . length ( ) ) ; ans = min ( ans , count ) ; } cout << ans << ' ' ; } int main ( ) { string S = \" aabb \" ; int N = S . length ( ) ; minimumSteps ( S , N ) ; return 0 ; }", "text_ms": "Kurangkan kiraan aksara yang akan ditambah atau dikeluarkan untuk membuat pengulangan rentetan substring yang sama | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari minimum tiga nombor; Berfungsi untuk mencari operasi bilangan minimum yang diperlukan untuk menukar string str1 ke str2 menggunakan operasi; Menyimpan hasil subproblem; Isi dp [] [] dengan cara bawah; Jika str1 kosong, masukkan semua aksara string str2; Operasi minimum ialah J; Jika str2 kosong, maka keluarkan semua aksara string str2; Operasi minimum ialah i; Jika watak terakhir adalah sama, maka abaikan watak terakhir; Jika watak terakhir berbeza, maka cari minimum; Lakukan salah satu sisipan, keluarkan dan ganti; Mengembalikan bilangan langkah minimum yang diperlukan; Berfungsi untuk mencari bilangan langkah minimum untuk mengubah suai rentetan sedemikian rupa sehingga separuh pertama dan separuh kedua menjadi sama; Menyimpan bilangan minimum operasi yang diperlukan; Melintasi rentetan yang diberikan; Cari operasi minimum; Kemas kini ANS; Cetak hasilnya; Kod pemacu"}
{"text": "Minimize operations to reduce N to 2 by repeatedly reducing by 3 or dividing by 5 | C ++ program for the above approach ; Function to find the minimum number of operations to reduce N to 2 by dividing N by 5 or decrementing by 3 ; Initialize the dp array ; Initialize the array dp [ ] ; For N = 2 number of operations needed is zero ; Iterating over the range [ 1 , N ] ; If it 's not possible to  create current N ; Multiply with 5 ; Adding the value 3 ; Checking if not possible to make the number as 2 ; Return the minimum number of operations ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumOperations ( int N ) { int dp [ N + 1 ] ; int i ; for ( int i = 0 ; i <= N ; i ++ ) { dp [ i ] = 1e9 ; } dp [ 2 ] = 0 ; for ( i = 2 ; i <= N ; i ++ ) { if ( dp [ i ] == 1e9 ) continue ; if ( i * 5 <= N ) { dp [ i * 5 ] = min ( dp [ i * 5 ] , dp [ i ] + 1 ) ; } if ( i + 3 <= N ) { dp [ i + 3 ] = min ( dp [ i + 3 ] , dp [ i ] + 1 ) ; } } if ( dp [ N ] == 1e9 ) return -1 ; return dp [ N ] ; } int main ( ) { int N = 25 ; cout << minimumOperations ( N ) ; return 0 ; }", "text_ms": "Kurangkan operasi untuk mengurangkan n hingga 2 dengan berulang kali mengurangkan 3 atau membahagikan dengan 5 | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari bilangan minimum operasi untuk mengurangkan n hingga 2 dengan membahagikan n dengan 5 atau penurunan sebanyak 3; Memulakan array DP; Memulakan array dp []; Untuk n = 2 bilangan operasi yang diperlukan adalah sifar; Melangkah ke atas julat [1, n]; Jika ia tidak mungkin untuk membuat n semasa; Kalikan dengan 5; Menambah nilai 3; Memeriksa jika tidak mungkin untuk membuat nombor sebagai 2; Mengembalikan bilangan operasi minimum; Kod pemacu"}
{"text": "Maximum profit after buying and selling the stocks with transaction fees | Set 2 | C ++ program for the above approach ; Function to find the maximum profit with transaction fee ; Traversing the stocks for each day ; Update buy and sell ; Return the maximum profit ; Driver code ; Given Input ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int MaxProfit ( int arr [ ] , int n , int transactionFee ) { int buy = - arr [ 0 ] ; int sell = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int temp = buy ; buy = max ( buy , sell - arr [ i ] ) ; sell = max ( sell , temp + arr [ i ] - transactionFee ) ; } return max ( sell , buy ) ; } int main ( ) { int arr [ ] = { 6 , 1 , 7 , 2 , 8 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int transactionFee = 2 ; cout << MaxProfit ( arr , n , transactionFee ) ; return 0 ; }", "text_ms": "Keuntungan maksimum selepas membeli dan menjual stok dengan yuran transaksi | Tetapkan 2 | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari keuntungan maksimum dengan yuran transaksi; Melintasi stok untuk setiap hari; Kemas kini membeli dan menjual; Mengembalikan keuntungan maksimum; Kod pemacu; Diberikan input; Panggilan fungsi"}
{"text": "Maximum path sum from top left to bottom right of a matrix passing through one of the given cells | C ++ program for the above approach ; Stores the maximum path sum from the cell ( 1 , 1 ) to ( N , M ) ; Stores the maximum path sum from the cell ( j , j ) to ( N , M ) ; Function to find the maximum path sum from the cell ( 1 , 1 ) to ( N , M ) ; Traverse the first row ; Traverse the first column ; Traverse the matrix ; Update the value of start [ i ] [ j ] ; Function to find the maximum path sum from the cell ( j , j ) to ( N , M ) ; Traverse the last row ; Traverse the last column ; Traverse the matrix ; Update the value of ending [ i ] [ j ] ; Function to find the maximum path sum from the top - left to the bottom right cell such that path contains one of the cells in the array coordinates [ ] [ ] ; Initialize the start and the end matrices ; Calculate the start matrix ; Calculate the end matrix ; Stores the maximum path sum ; Traverse the coordinates ; Update the value of ans ; Print the resultant maximum sum path value ; Drive Code", "code": "#include <iostream> NEW_LINE using namespace std ; int start [ 3 ] [ 3 ] ; int ending [ 3 ] [ 3 ] ; void calculateStart ( int n , int m ) { for ( int i = 1 ; i < m ; ++ i ) { start [ 0 ] [ i ] += start [ 0 ] [ i - 1 ] ; } for ( int i = 1 ; i < n ; ++ i ) { start [ i ] [ 0 ] += start [ i - 1 ] [ 0 ] ; } for ( int i = 1 ; i < n ; ++ i ) { for ( int j = 1 ; j < m ; ++ j ) { start [ i ] [ j ] += max ( start [ i - 1 ] [ j ] , start [ i ] [ j - 1 ] ) ; } } } void calculateEnd ( int n , int m ) { for ( int i = n - 2 ; i >= 0 ; -- i ) { ending [ i ] [ m - 1 ] += ending [ i + 1 ] [ m - 1 ] ; } for ( int i = m - 2 ; i >= 0 ; -- i ) { ending [ n - 1 ] [ i ] += ending [ n - 1 ] [ i + 1 ] ; } for ( int i = n - 2 ; i >= 0 ; -- i ) { for ( int j = m - 2 ; j >= 0 ; -- j ) { ending [ i ] [ j ] += max ( ending [ i + 1 ] [ j ] , ending [ i ] [ j + 1 ] ) ; } } } void maximumPathSum ( int mat [ ] [ 3 ] , int n , int m , int q , int coordinates [ ] [ 2 ] ) { for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { start [ i ] [ j ] = mat [ i ] [ j ] ; ending [ i ] [ j ] = mat [ i ] [ j ] ; } } calculateStart ( n , m ) ; calculateEnd ( n , m ) ; int ans = 0 ; for ( int i = 0 ; i < q ; ++ i ) { int X = coordinates [ i ] [ 0 ] - 1 ; int Y = coordinates [ i ] [ 1 ] - 1 ; ans = max ( ans , start [ X ] [ Y ] + ending [ X ] [ Y ] - mat [ X ] [ Y ] ) ; } cout << ans ; } int main ( ) { int mat [ ] [ 3 ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; int N = 3 ; int M = 3 ; int Q = 2 ; int coordinates [ ] [ 2 ] = { { 1 , 2 } , { 2 , 2 } } ; maximumPathSum ( mat , N , M , Q , coordinates ) ; }", "text_ms": "Jumlah maksimum dari kiri ke bawah kanan matriks melalui salah satu sel yang diberikan | Program C ++ untuk pendekatan di atas; Menyimpan jumlah laluan maksimum dari sel (1, 1) hingga (n, m); Menyimpan jumlah laluan maksimum dari sel (j, j) hingga (n, m); Berfungsi untuk mencari jumlah laluan maksimum dari sel (1, 1) hingga (n, m); Melintasi baris pertama; Melintasi lajur pertama; Melintasi matriks; Kemas kini nilai permulaan [i] [j]; Berfungsi untuk mencari jumlah laluan maksimum dari sel (j, j) hingga (n, m); Melintasi baris terakhir; Melintasi lajur terakhir; Melintasi matriks; Kemas kini nilai berakhir [i] [j]; Berfungsi untuk mencari jumlah laluan maksimum dari atas - kiri ke sel kanan bawah supaya laluan itu mengandungi salah satu sel dalam koordinat array [] []; Memulakan permulaan dan matriks akhir; Kirakan matriks permulaan; Kirakan matriks akhir; Menyimpan jumlah laluan maksimum; Melintasi koordinat; Kemas kini nilai ANS; Cetak nilai laluan jumlah maksimum yang dihasilkan; Kod pemacu"}
{"text": "Length of longest subset consisting of A 0 s and B 1 s from an array of strings | Set 2 | C ++ program for the above approach ; Function to find the length of the longest subset of an array of strings with at most A 0 s and B 1 s ; Initialize a 2D array with its entries as 0 ; Traverse the given array ; Store the count of 0 s and 1 s in the current string ; Iterate in the range [ A , zeros ] ; Iterate in the range [ B , ones ] ; Update the value of dp [ i ] [ j ] ; Print the result ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int MaxSubsetlength ( vector < string > arr , int A , int B ) { int dp [ A + 1 ] [ B + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( auto & str : arr ) { int zeros = count ( str . begin ( ) , str . end ( ) , '0' ) ; int ones = count ( str . begin ( ) , str . end ( ) , '1' ) ; for ( int i = A ; i >= zeros ; i -- ) for ( int j = B ; j >= ones ; j -- ) dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - zeros ] [ j - ones ] + 1 ) ; } return dp [ A ] [ B ] ; } int main ( ) { vector < string > arr = { \"1\" , \"0\" , \"0001\" , \"10\" , \"111001\" } ; int A = 5 , B = 3 ; cout << MaxSubsetlength ( arr , A , B ) ; return 0 ; }", "text_ms": "Panjang subset terpanjang yang terdiri daripada 0 s dan b 1 s dari pelbagai rentetan | Tetapkan 2 | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari panjang subset terpanjang pelbagai rentetan dengan paling banyak 0 s dan b 1 s; Memulakan array 2D dengan penyertaannya sebagai 0; Melintasi array yang diberikan; Simpan kiraan 0 s dan 1 s dalam rentetan semasa; Melangkah dalam julat [a, sifar]; Berulang dalam julat [b, yang]; Mengemas kini nilai dp [i] [j]; Cetak hasilnya; Kod pemacu"}
{"text": "Count ways to select N pairs of candies of distinct colors ( Dynamic Programming + Bitmasking ) | C ++ 14 program to implement the above approach ; Function to count ways to select N distinct pairs of candies with different colours ; If n pairs are selected ; Stores count of ways to select the i - th pair ; Iterate over the range [ 0 , n ] ; If pair ( i , j ) is not included ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int numOfWays ( vector < vector < int > > a , int n , int i , set < int > & blue ) { if ( i == n ) return 1 ; int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( a [ i ] [ j ] == 1 && blue . find ( j ) == blue . end ( ) ) { blue . insert ( j ) ; count += numOfWays ( a , n , i + 1 , blue ) ; blue . erase ( j ) ; } } return count ; } int main ( ) { int n = 3 ; vector < vector < int > > mat = { { 0 , 1 , 1 } , { 1 , 0 , 1 } , { 1 , 1 , 1 } } ; set < int > mpp ; cout << ( numOfWays ( mat , n , 0 , mpp ) ) ; }", "text_ms": "Kira cara untuk memilih pasangan gula -gula warna yang berbeza (pengaturcaraan dinamik + bitmasking) | C ++ 14 Program untuk melaksanakan pendekatan di atas; Fungsi untuk mengira cara untuk memilih N yang berbeza pasangan gula -gula dengan warna yang berbeza; Jika pasangan N dipilih; Kedai mengira cara untuk memilih pasangan i - th; Melangkah ke atas julat [0, n]; Jika pasangan (i, j) tidak termasuk; Kod pemacu"}
{"text": "Minimize cost to reach end of an array by two forward jumps or one backward jump in each move | C ++ program for the above approach ; Function to find the minimum cost to reach the end of an array ; Base Case : When N < 3 ; Store the results in table ; Initialize base cases ; Iterate over the range [ 2 , N - 2 ] to construct the dp array ; Handle case for the last index , i . e . N - 1 ; Print the answer ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void minCost ( int arr [ ] , int n ) { if ( n < 3 ) { cout << arr [ 0 ] ; return ; } int * dp = new int [ n ] ; dp [ 0 ] = arr [ 0 ] ; dp [ 1 ] = dp [ 0 ] + arr [ 1 ] + arr [ 2 ] ; for ( int i = 2 ; i < n - 1 ; i ++ ) dp [ i ] = min ( dp [ i - 2 ] + arr [ i ] , dp [ i - 1 ] + arr [ i ] + arr [ i + 1 ] ) ; dp [ n - 1 ] = min ( dp [ n - 2 ] , dp [ n - 3 ] + arr [ n - 1 ] ) ; cout << dp [ n - 1 ] ; } int main ( ) { int arr [ ] = { 9 , 4 , 6 , 8 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; minCost ( arr , N ) ; return 0 ; }", "text_ms": "Kurangkan kos untuk mencapai hujung array oleh dua lompatan ke hadapan atau satu lompatan ke belakang dalam setiap langkah | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari kos minimum untuk mencapai akhir array; Kes asas: apabila n <3; Simpan hasil dalam jadual; Memulakan kes asas; Melangkah ke atas julat [2, n - 2] untuk membina array DP; Mengendalikan kes untuk indeks terakhir, i. e. N - 1; Cetak jawapannya; Kod pemacu"}
{"text": "Calculate the value of 2 raised to the power of twice the binary representation of N | C ++ program to implement the above approach ; Function to find the value of power ( X , Y ) in O ( log Y ) ; Stores power ( X , Y ) ; Update X ; Base Case ; Calculate power ( X , Y ) ; If Y is an odd number ; Update res ; Update Y ; Update X ; Function to calculate ( 2 ^ ( 2 * x ) ) % ( 10 ^ 9 + 7 ) ; Stores binary representation of n ; Stores power of 10 ; Calculate the binary representation of n ; If n is an odd number ; Update X ; Update pow_10 ; Update n ; Double the value of X ; Stores the value of ( 2 ^ ( 2 * x ) ) % ( 10 ^ 9 + 7 ) ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define M  1000000007 NEW_LINE long long power ( long long X , long long Y ) { long long res = 1 ; X = X % M ; if ( X == 0 ) return 0 ; while ( Y > 0 ) { if ( Y & 1 ) { res = ( res * X ) % M ; } Y = Y >> 1 ; X = ( X * X ) % M ; } return res ; } int findValue ( long long int n ) { long long X = 0 ; long long pow_10 = 1 ; while ( n ) { if ( n & 1 ) { X += pow_10 ; } pow_10 *= 10 ; n /= 2 ; } X = ( X * 2 ) % M ; long long res = power ( 2 , X ) ; return res ; } int main ( ) { long long n = 2 ; cout << findValue ( n ) ; return 0 ; }", "text_ms": "Kirakan nilai 2 yang dibangkitkan kepada kuasa dua kali ganda perwakilan binari n | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk mencari nilai kuasa (x, y) dalam o (log y); Kedai kuasa (x, y); Kemas kini x; Kes asas; Hitung kuasa (x, y); Jika y adalah nombor ganjil; Kemas kini res; Kemas kini y; Kemas kini x; Fungsi untuk mengira (2 ^ (2 * x)) % (10 ^ 9 + 7); Kedai perwakilan binari n; Kedai kuasa 10; Kirakan perwakilan binari n; Jika n adalah nombor ganjil; Kemas kini x; Kemas kini pow_10; Kemas kini n; Dua kali ganda nilai x; Menyimpan nilai (2 ^ (2 * x)) % (10 ^ 9 + 7); Kod pemacu"}
{"text": "Calculate the value of 2 raised to the power of twice the binary representation of N | C ++ program to implement the above approach ; Function to find the value of power ( X , Y ) in O ( log Y ) ; Stores power ( X , Y ) ; Update X ; Base Case ; Calculate power ( X , Y ) ; If Y is an odd number ; Update res ; Update Y ; Update X ; Function to calculate ( 2 ^ ( 2 * x ) ) % ( 10 ^ 9 + 7 ) ; dp [ N ] * dp [ N ] : Stores value of ( 2 ^ ( 2 * x ) ) % ( 10 ^ 9 + 7 ) ; Base Case ; Iterate over the range [ 3 , N ] ; Stores rightmost bit of i ; Stores the value of ( i - y ) ; If x is power of 2 ; Update dp [ i ] ; Update dp [ i ] ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define M  1000000007 NEW_LINE long long power ( long long X , long long Y ) { long long res = 1 ; X = X % M ; if ( X == 0 ) return 0 ; while ( Y > 0 ) { if ( Y & 1 ) { res = ( res * X ) % M ; } Y = Y >> 1 ; X = ( X * X ) % M ; } return res ; } long long findValue ( long long N ) { long long dp [ N + 1 ] ; dp [ 1 ] = 2 ; dp [ 2 ] = 1024 ; for ( int i = 3 ; i <= N ; i ++ ) { int y = ( i & ( - i ) ) ; int x = i - y ; if ( x == 0 ) { dp [ i ] = power ( dp [ i / 2 ] , 10 ) ; } else { dp [ i ] = ( dp [ x ] * dp [ y ] ) % M ; } } return ( dp [ N ] * dp [ N ] ) % M ; } int main ( ) { long long n = 150 ; cout << findValue ( n ) ; return 0 ; }", "text_ms": "Kirakan nilai 2 yang dibangkitkan kepada kuasa dua kali ganda perwakilan binari n | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk mencari nilai kuasa (x, y) dalam o (log y); Kedai kuasa (x, y); Kemas kini x; Kes asas; Hitung kuasa (x, y); Jika y adalah nombor ganjil; Kemas kini res; Kemas kini y; Kemas kini x; Fungsi untuk mengira (2 ^ (2 * x)) % (10 ^ 9 + 7); dp [n] * dp [n]: Kedai nilai (2 ^ (2 * x)) % (10 ^ 9 + 7); Kes asas; Melangkah ke atas julat [3, n]; Kedai paling tepat dari saya; Menyimpan nilai (i - y); Jika x adalah kuasa 2; Kemas kini DP [i]; Kemas kini DP [i]; Kod pemacu"}
{"text": "Count ways to obtain given sum by repeated throws of a dice | C ++ program for the above approach ; Function to find the number of ways to get the sum N with throw of dice ; Base Case ; Stores the count of total number of ways to get sum N ; Recur for all 6 states ; Return answer ; Driver Code ; Function call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findWays ( int N ) { if ( N == 0 ) { return 1 ; } int cnt = 0 ; for ( int i = 1 ; i <= 6 ; i ++ ) { if ( N - i >= 0 ) { cnt = cnt + findWays ( N - i ) ; } } return cnt ; } int main ( ) { int N = 4 ; cout << findWays ( N ) ; return 0 ; }", "text_ms": "Kira cara untuk mendapatkan jumlah yang diberikan oleh lontaran berulang dadu | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari bilangan cara untuk mendapatkan jumlah n dengan membuang dadu; Kes asas; Menyimpan jumlah jumlah cara untuk mendapatkan jumlah n; Berulang untuk semua 6 negeri; Jawapan kembali; Kod pemacu; Panggilan fungsi"}
{"text": "Check if an array can be split into 3 subsequences of equal sum or not | C ++ program for the above approach ; Utility function to check array can be partition to 3 subsequences of equal sum or not ; Base Case ; When element at index j is added to sm1 ; When element at index j is added to sm2 ; When element at index j is added to sm3 ; Return maximum value among all above 3 recursive call ; Function to check array can be partition to 3 subsequences of equal sum or not ; Initialise 3 sums to 0 ; Function Call ; Driver Code ; Given array arr [ ] ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int checkEqualSumUtil ( int arr [ ] , int N , int sm1 , int sm2 , int sm3 , int j ) { if ( j == N ) { if ( sm1 == sm2 && sm2 == sm3 ) return 1 ; else return 0 ; } else { int l = checkEqualSumUtil ( arr , N , sm1 + arr [ j ] , sm2 , sm3 , j + 1 ) ; int m = checkEqualSumUtil ( arr , N , sm1 , sm2 + arr [ j ] , sm3 , j + 1 ) ; int r = checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 + arr [ j ] , j + 1 ) ; return max ( max ( l , m ) , r ) ; } } void checkEqualSum ( int arr [ ] , int N ) { int sum1 , sum2 , sum3 ; sum1 = sum2 = sum3 = 0 ; if ( checkEqualSumUtil ( arr , N , sum1 , sum2 , sum3 , 0 ) == 1 ) { cout << \" Yes \" ; } else { cout << \" No \" ; } } int main ( ) { int arr [ ] = { 17 , 34 , 59 , 23 , 17 , 67 , 57 , 2 , 18 , 59 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; checkEqualSum ( arr , N ) ; return 0 ; }", "text_ms": "Semak jika array boleh dibahagikan kepada 3 seterusnya jumlah yang sama atau tidak | Program C ++ untuk pendekatan di atas; Fungsi utiliti untuk memeriksa array boleh menjadi partition kepada 3 seterusnya jumlah yang sama atau tidak; Kes asas; Apabila elemen di Indeks J ditambah kepada SM1; Apabila elemen di Indeks J ditambah kepada SM2; Apabila elemen di Indeks J ditambah kepada SM3; Mengembalikan nilai maksimum di antara semua 3 panggilan rekursif; Fungsi untuk memeriksa array boleh menjadi partition kepada 3 seterusnya jumlah yang sama atau tidak; Permulaan 3 jumlah ke 0; Panggilan fungsi; Kod pemacu; Diberikan array arr []; Panggilan fungsi"}
{"text": "Check if an array can be split into 3 subsequences of equal sum or not | C ++ program for the above approach ; Function to check array can be partition into sum of 3 equal ; Base Case ; If value at particular index is not - 1 then return value at that index which ensure no more further calls ; When element at index j is added to sm1 ; When element at index j is added to sm2 ; When element at index j is added to sm3 ; Update the current state and return that value ; Function to check array can be partition to 3 subsequences of equal sum or not ; Initialise 3 sums to 0 ; Function Call ; Driver Code ; Given array arr [ ] ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; map < string , int > dp ; int checkEqualSumUtil ( int arr [ ] , int N , int sm1 , int sm2 , int sm3 , int j ) { string s = to_string ( sm1 ) + \" _ \" + to_string ( sm2 ) + to_string ( j ) ; if ( j == N ) { if ( sm1 == sm2 && sm2 == sm3 ) return 1 ; else return 0 ; } if ( dp . find ( s ) != dp . end ( ) ) return dp [ s ] ; else { int l = checkEqualSumUtil ( arr , N , sm1 + arr [ j ] , sm2 , sm3 , j + 1 ) ; int m = checkEqualSumUtil ( arr , N , sm1 , sm2 + arr [ j ] , sm3 , j + 1 ) ; int r = checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 + arr [ j ] , j + 1 ) ; return dp [ s ] = max ( max ( l , m ) , r ) ; } } void checkEqualSum ( int arr [ ] , int N ) { int sum1 , sum2 , sum3 ; sum1 = sum2 = sum3 = 0 ; if ( checkEqualSumUtil ( arr , N , sum1 , sum2 , sum3 , 0 ) == 1 ) { cout << \" Yes \" ; } else { cout << \" No \" ; } } int main ( ) { int arr [ ] = { 17 , 34 , 59 , 23 , 17 , 67 , 57 , 2 , 18 , 59 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; checkEqualSum ( arr , N ) ; return 0 ; }", "text_ms": "Semak jika array boleh dibahagikan kepada 3 seterusnya jumlah yang sama atau tidak | Program C ++ untuk pendekatan di atas; Fungsi untuk memeriksa array boleh menjadi partition ke dalam jumlah 3 sama; Kes asas; Jika nilai pada indeks tertentu tidak - 1 maka nilai pulangan pada indeks itu yang memastikan tiada lagi panggilan lagi; Apabila elemen di Indeks J ditambah kepada SM1; Apabila elemen di Indeks J ditambah kepada SM2; Apabila elemen di Indeks J ditambah kepada SM3; Mengemas kini keadaan semasa dan mengembalikan nilai itu; Fungsi untuk memeriksa array boleh menjadi partition kepada 3 seterusnya jumlah yang sama atau tidak; Permulaan 3 jumlah ke 0; Panggilan fungsi; Kod pemacu; Diberikan array arr []; Panggilan fungsi"}
{"text": "Smallest index in given range of indices which is not equal to X | C ++ Program to find the smallest index in the array in the range [ L , R ] which does not contain X ; Precompute the index of next different element in the array for every array element ; Default value ; Compute nextpos [ i ] using nextpos [ i + 1 ] ; Function to return the smallest index ; nextpos [ i ] will store the next position p where arr [ p ] != arr [ i ] ; If X is not present at l ; Otherwise ; Find the index which stores a value different from X ; If that index is within the range ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void precompute ( int nextpos [ ] , int arr [ ] , int N ) { nextpos [ N - 1 ] = N ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] == arr [ i + 1 ] ) nextpos [ i ] = nextpos [ i + 1 ] ; else nextpos [ i ] = i + 1 ; } } void findIndex ( int query [ ] [ 3 ] , int arr [ ] , int N , int Q ) { int nextpos [ N ] ; precompute ( nextpos , arr , N ) ; for ( int i = 0 ; i < Q ; i ++ ) { int l , r , x ; l = query [ i ] [ 0 ] ; r = query [ i ] [ 1 ] ; x = query [ i ] [ 2 ] ; int ans = -1 ; if ( arr [ l ] != x ) ans = l ; else { int d = nextpos [ l ] ; if ( d <= r ) ans = d ; } cout << ans << \" STRNEWLINE \" ; } } int main ( ) { int N , Q ; N = 6 ; Q = 3 ; int arr [ ] = { 1 , 2 , 1 , 1 , 3 , 5 } ; int query [ Q ] [ 3 ] = { { 0 , 3 , 1 } , { 1 , 5 , 2 } , { 2 , 3 , 1 } } ; findIndex ( query , arr , N , Q ) ; return 0 ; }", "text_ms": "Indeks terkecil dalam pelbagai indeks yang tidak sama dengan x | Program C ++ untuk mencari indeks terkecil dalam array dalam julat [l, r] yang tidak mengandungi x; Precompute Indeks elemen yang berbeza seterusnya dalam array untuk setiap elemen array; Nilai lalai; Kirakan Nextpos [i] menggunakan Nextpos [i + 1]; Berfungsi untuk mengembalikan indeks terkecil; Nextpos [i] akan menyimpan kedudukan seterusnya p di mana arr [p]! = arr [i]; Jika x tidak hadir di l; Jika tidak; Cari indeks yang menyimpan nilai yang berbeza dari x; Jika indeks itu berada dalam julat; Kod pemacu"}
{"text": "Count number of ways to convert string S to T by performing K cyclic shifts | C ++ program for the above approach ; Function to count number of ways to convert string S to string T by performing K cyclic shifts ; Calculate length of string ; ' a ' is no of good cyclic shifts ' b ' is no of bad cyclic shifts ; Iterate in the string ; Precompute the number of good and bad cyclic shifts ; dp2 [ i ] to store the no of ways to get to a bad shift in i moves ; Calculate good and bad shifts ; Return the required number of ways ; Driver Code ; Given Strings ; Given K shifts required ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define mod  10000000007 NEW_LINE long long countWays ( string s , string t , int k ) { int n = s . size ( ) ; int a = 0 , b = 0 ; for ( int i = 0 ; i < n ; i ++ ) { string p = s . substr ( i , n - i ) + s . substr ( 0 , i ) ; if ( p == t ) a ++ ; else b ++ ; } vector < long long > dp1 ( k + 1 ) , dp2 ( k + 1 ) ; if ( s == t ) { dp1 [ 0 ] = 1 ; dp2 [ 0 ] = 0 ; } else { dp1 [ 0 ] = 0 ; dp2 [ 0 ] = 1 ; } for ( int i = 1 ; i <= k ; i ++ ) { dp1 [ i ] = ( ( dp1 [ i - 1 ] * ( a - 1 ) ) % mod + ( dp2 [ i - 1 ] * a ) % mod ) % mod ; dp2 [ i ] = ( ( dp1 [ i - 1 ] * ( b ) ) % mod + ( dp2 [ i - 1 ] * ( b - 1 ) ) % mod ) % mod ; } return dp1 [ k ] ; } int main ( ) { string S = \" ab \" , T = \" ab \" ; int K = 2 ; cout << countWays ( S , T , K ) ; return 0 ; }", "text_ms": "Mengira bilangan cara untuk menukar rentetan s ke t dengan melakukan peralihan kitaran k | Program C ++ untuk pendekatan di atas; Berfungsi untuk mengira bilangan cara untuk menukar rentetan s ke rentetan t dengan melakukan peralihan kitaran k; Hitung panjang rentetan; 'A' bukan peralihan siklik yang baik 'B' bukan peralihan siklik yang buruk; Iterat dalam rentetan; Precompute bilangan peralihan kitaran yang baik dan buruk; DP2 [i] untuk menyimpan tidak ada cara untuk mendapatkan peralihan yang buruk dalam saya bergerak; Kirakan peralihan yang baik dan buruk; Mengembalikan bilangan cara yang diperlukan; Kod pemacu; Diberikan rentetan; Memandangkan pergeseran k diperlukan; Panggilan fungsi"}
{"text": "Minimize steps to reach K from 0 by adding 1 or doubling at each step | C ++ program to implement the above approach ; Function to find minimum operations ; vector dp is initialised to store the steps ; For all even numbers ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperation ( int k ) { vector < int > dp ( k + 1 , 0 ) ; for ( int i = 1 ; i <= k ; i ++ ) { dp [ i ] = dp [ i - 1 ] + 1 ; if ( i % 2 == 0 ) { dp [ i ] = min ( dp [ i ] , dp [ i / 2 ] + 1 ) ; } } return dp [ k ] ; } int main ( ) { int K = 12 ; cout << minOperation ( k ) ; }", "text_ms": "Kurangkan langkah -langkah untuk mencapai k dari 0 dengan menambah 1 atau menggandakan pada setiap langkah | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari operasi minimum; Vektor DP diasaskan untuk menyimpan langkah -langkah; Untuk semua nombor walaupun; Kod pemacu"}
{"text": "Find maximum subset sum formed by partitioning any subset of array into 2 partitions with equal sum | CPP implementation for the above mentioned recursive approach ; Function to find the maximum subset sum ; Ignore the current element ; including element in partition 1 ; including element in partition 2 ; Driver code ; size of the array", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSum ( int p0 , int p1 , int a [ ] , int pos , int n ) { if ( pos == n ) { if ( p0 == p1 ) return p0 ; else return 0 ; } int ans = maxSum ( p0 , p1 , a , pos + 1 , n ) ; ans = max ( ans , maxSum ( p0 + a [ pos ] , p1 , a , pos + 1 , n ) ) ; ans = max ( ans , maxSum ( p0 , p1 + a [ pos ] , a , pos + 1 , n ) ) ; return ans ; } int main ( ) { int n = 4 ; int a [ n ] = { 1 , 2 , 3 , 6 } ; cout << maxSum ( 0 , 0 , a , 0 , n ) ; return 0 ; }", "text_ms": "Cari jumlah subset maksimum yang dibentuk dengan memisahkan mana -mana subset array ke dalam 2 partition dengan jumlah yang sama | Pelaksanaan CPP untuk pendekatan rekursif yang disebutkan di atas; Berfungsi untuk mencari jumlah subset maksimum; Abaikan elemen semasa; termasuk elemen dalam partition 1; termasuk elemen dalam partition 2; Kod pemacu; saiz array"}
{"text": "Find maximum subset sum formed by partitioning any subset of array into 2 partitions with equal sum | CPP implementation for the above mentioned Dynamic Programming approach ; Function to find the maximum subset sum ; sum of all elements ; bottom up lookup table ; ; initialising dp table with INT_MIN where , INT_MIN means no solution ; Case when diff is 0 ; Putting ith element in g0 ; Putting ith element in g1 ; Ignoring ith element ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSum ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; int limit = 2 * sum + 1 ; int dp [ n + 1 ] [ limit ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < limit ; j ++ ) dp [ i ] [ j ] = INT_MIN ; } dp [ 0 ] [ sum ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j < limit ; j ++ ) { if ( ( j - a [ i - 1 ] ) >= 0 && dp [ i - 1 ] [ j - a [ i - 1 ] ] != INT_MIN ) dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - a [ i - 1 ] ] + a [ i - 1 ] ) ; if ( ( j + a [ i - 1 ] ) < limit && dp [ i - 1 ] [ j + a [ i - 1 ] ] != INT_MIN ) dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j + a [ i - 1 ] ] ) ; if ( dp [ i - 1 ] [ j ] != INT_MIN ) dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j ] ) ; } } return dp [ n ] [ sum ] ; } int main ( ) { int n = 4 ; int a [ n ] = { 1 , 2 , 3 , 6 } ; cout << maxSum ( a , n ) ; return 0 ; }", "text_ms": "Cari jumlah subset maksimum yang dibentuk dengan memisahkan mana -mana subset array ke dalam 2 partition dengan jumlah yang sama | Pelaksanaan CPP untuk pendekatan pengaturcaraan dinamik yang disebutkan di atas; Berfungsi untuk mencari jumlah subset maksimum; jumlah semua elemen; Jadual carian bawah; ; jadual DP yang memulakan dengan int_min di mana, int_min bermaksud tiada penyelesaian; Kes apabila diff adalah 0; Meletakkan elemen ITH dalam G0; Meletakkan elemen ITH dalam G1; Mengabaikan elemen ith; Kod pemacu"}
{"text": "Count of strings possible by replacing two consecutive same character with new character | C ++ program to count the different possible string form by replacing two same characters with one ; Array to find the fibonacci sequence ; Function to find the fibonacci sequence ; Function to count all possible strings ; Initialize ans = 1 ; If two consecutive char are same increase cnt ; Else multiply the fib [ cnt ] to ans and initialize ans to 1 ; If str = abcdeeee , then for last \" eeee \" the count munst be updated ; Return the total count ; Driver 's Code ; Function to precompute all the fibonacci number ; Function call to find the count", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int fib [ 100005 ] ; void computeFibonacci ( ) { fib [ 0 ] = 1 ; fib [ 1 ] = 1 ; for ( int i = 2 ; i < 100005 ; i ++ ) { fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; } } int countString ( string str ) { int ans = 1 ; int cnt = 1 ; for ( int i = 1 ; str [ i ] ; i ++ ) { if ( str [ i ] == str [ i - 1 ] ) { cnt ++ ; } else { ans = ans * fib [ cnt ] ; cnt = 1 ; } } ans = ans * fib [ cnt ] ; return ans ; } int main ( ) { string str = \" abdllldefkkkk \" ; computeFibonacci ( ) ; cout << countString ( str ) ; return 0 ; }", "text_ms": "Count of Strings mungkin dengan menggantikan dua watak yang sama berturut -turut dengan watak baru | Program C ++ untuk mengira borang rentetan yang berbeza dengan menggantikan dua aksara yang sama dengan satu; Array untuk mencari urutan Fibonacci; Berfungsi untuk mencari urutan Fibonacci; Berfungsi untuk mengira semua rentetan yang mungkin; Memulakan ans = 1; Jika dua char berturut -turut adalah peningkatan yang sama CNT; Lain melipatgandakan FIB [CNT] ke Ans dan memulakan Ans hingga 1; Jika str = abcdeeee, maka untuk terakhir \"eeee\" kiraan munst dikemas kini; Mengembalikan jumlah jumlah; Kod pemandu; Berfungsi untuk precompute semua nombor Fibonacci; Fungsi panggilan untuk mencari kiraan"}
{"text": "Golomb Sequence | Set 2 | C ++ program to find the first N terms of Golomb Sequence ; Function to print the Golomb Sequence ; Initialise the array ; Initialise the cnt to 0 ; First and second element of Golomb Sequence is 0 , 1 ; Map to store the count of current element in Golomb Sequence ; Store the count of 2 ; Iterate over 2 to N ; If cnt is equals to 0 then we have new number for Golomb Sequence which is 1 + previous element ; Else the current element is the previous element in this Sequence ; Map the current index to current value in arr [ ] ; Print the Golomb Sequence ; Driver Code", "code": "#include \" bits / stdc + + . h \" NEW_LINE #define MAX  100001 NEW_LINE using namespace std ; void printGolombSequence ( int N ) { int arr [ MAX ] ; int cnt = 0 ; arr [ 0 ] = 0 ; arr [ 1 ] = 1 ; map < int , int > M ; M [ 2 ] = 2 ; for ( int i = 2 ; i <= N ; i ++ ) { if ( cnt == 0 ) { arr [ i ] = 1 + arr [ i - 1 ] ; cnt = M [ arr [ i ] ] ; cnt -- ; } else { arr [ i ] = arr [ i - 1 ] ; cnt -- ; } M [ i ] = arr [ i ] ; } for ( int i = 1 ; i <= N ; i ++ ) { cout << arr [ i ] << ' ▁ ' ; } } int main ( ) { int N = 11 ; printGolombSequence ( N ) ; return 0 ; }", "text_ms": "Urutan Golomb | Tetapkan 2 | Program C ++ untuk mencari terma pertama N Golomb urutan; Berfungsi untuk mencetak urutan Golomb; Memulakan array; Memulakan CNT hingga 0; Elemen pertama dan kedua urutan Golomb ialah 0, 1; Peta untuk menyimpan kiraan elemen semasa dalam urutan Golomb; Simpan kiraan 2; Melangkah lebih dari 2 hingga n; Jika CNT sama dengan 0 maka kami mempunyai nombor baru untuk urutan Golomb yang 1 + elemen sebelumnya; Lain elemen semasa adalah elemen sebelumnya dalam urutan ini; Peta indeks semasa ke nilai semasa dalam arr []; Cetak urutan Golomb; Kod pemacu"}
{"text": "Count ways to reach Nth Stairs by taking 1 and 2 steps with exactly one 3 step | C ++ implementation to find the number the number of ways to reach Nth stair by taking 1 , 2 step at a time and 3 Steps at a time exactly once . ; Function to find the number the number of ways to reach Nth stair ; Array including number of ways that includes 3 ; Array including number of ways that doesn 't includes 3 ; Initially to reach 3 stairs by taking 3 steps can be reached by 1 way ; Loop to find the number the number of ways to reach Nth stair ; Driver Code", "code": "#include <iostream> NEW_LINE using namespace std ; int number_of_ways ( int n ) { int includes_3 [ n + 1 ] = { } ; int not_includes_3 [ n + 1 ] = { } ; includes_3 [ 3 ] = 1 ; not_includes_3 [ 1 ] = 1 ; not_includes_3 [ 2 ] = 2 ; not_includes_3 [ 3 ] = 3 ; for ( int i = 4 ; i <= n ; i ++ ) { includes_3 [ i ] = includes_3 [ i - 1 ] + includes_3 [ i - 2 ] + not_includes_3 [ i - 3 ] ; not_includes_3 [ i ] = not_includes_3 [ i - 1 ] + not_includes_3 [ i - 2 ] ; } return includes_3 [ n ] ; } int main ( ) { int n = 7 ; cout << number_of_ways ( n ) ; return 0 ; }", "text_ms": "Kira cara untuk mencapai tangga nth dengan mengambil 1 dan 2 langkah dengan tepat satu 3 langkah | C ++ pelaksanaan untuk mencari bilangan bilangan cara untuk mencapai tangga nth dengan mengambil 1, 2 langkah pada satu masa dan 3 langkah pada satu masa tepat sekali. ; Berfungsi untuk mencari bilangan bilangan cara untuk mencapai tangga nth; Array termasuk bilangan cara yang merangkumi 3; Array termasuk bilangan cara yang tidak termasuk 3; Pada mulanya untuk mencapai 3 tangga dengan mengambil 3 langkah boleh dicapai dengan 1 cara; Gelung untuk mencari nombor bilangan cara untuk mencapai tangga nth; Kod pemacu"}
{"text": "Maximum number of multiples in an array before any element | C ++ implementation of the approach ; Map to store the divisor count ; Function to generate the divisors of all the array elements ; Function to find the maximum number of multiples in an array before it ; To store the maximum divisor count ; Update ans if more number of divisors are found ; Generating all the divisors of the next element of the array ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100000 ; int divisors [ MAX ] ; int generateDivisors ( int n ) { for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { divisors [ i ] ++ ; } else { divisors [ i ] ++ ; divisors [ n / i ] ++ ; } } } } int findMaxMultiples ( int * arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans = max ( divisors [ arr [ i ] ] , ans ) ; generateDivisors ( arr [ i ] ) ; } return ans ; } int main ( ) { int arr [ ] = { 8 , 1 , 28 , 4 , 2 , 6 , 7 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << findMaxMultiples ( arr , n ) ; return 0 ; }", "text_ms": "Bilangan maksimum gandaan dalam array sebelum mana -mana elemen | C ++ pelaksanaan pendekatan; Peta untuk menyimpan kiraan pembahagi; Berfungsi untuk menjana pembahagi semua elemen array; Berfungsi untuk mencari bilangan maksimum gandaan dalam array sebelum itu; Untuk menyimpan kiraan pembahagi maksimum; Kemas kini Ans Jika lebih banyak bilangan pembahagi dijumpai; Menjana semua pembahagi elemen seterusnya dari array; Kod pemacu"}
{"text": "Number of ways to reach the end of matrix with non | C ++ implementation of the approach ; 3d array to store states of dp ; Array to determine whether a state has been solved before ; Function to return the count of required paths ; Base cases ; If a state has been solved before it won 't be evaluated again ; Recurrence relation ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE #define n  3 NEW_LINE #define maxV  20 NEW_LINE using namespace std ; int dp [ n ] [ n ] [ maxV ] ; int v [ n ] [ n ] [ maxV ] ; int countWays ( int i , int j , int x , int arr [ ] [ n ] ) { if ( i == n j == n ) return 0 ; x = ( x & arr [ i ] [ j ] ) ; if ( x == 0 ) return 0 ; if ( i == n - 1 && j == n - 1 ) return 1 ; if ( v [ i ] [ j ] [ x ] ) return dp [ i ] [ j ] [ x ] ; v [ i ] [ j ] [ x ] = 1 ; dp [ i ] [ j ] [ x ] = countWays ( i + 1 , j , x , arr ) + countWays ( i , j + 1 , x , arr ) ; return dp [ i ] [ j ] [ x ] ; } int main ( ) { int arr [ n ] [ n ] = { { 1 , 2 , 1 } , { 1 , 1 , 0 } , { 2 , 1 , 1 } } ; cout << countWays ( 0 , 0 , arr [ 0 ] [ 0 ] , arr ) ; return 0 ; }", "text_ms": "Bilangan cara untuk mencapai akhir matriks dengan bukan | C ++ pelaksanaan pendekatan; Arahan 3D untuk menyimpan negeri -negeri DP; Array untuk menentukan sama ada keadaan telah diselesaikan sebelum ini; Fungsi untuk mengembalikan kiraan laluan yang diperlukan; Kes asas; Sekiranya negara telah diselesaikan sebelum ia tidak dinilai semula; Hubungan berulang; Kod pemacu"}
{"text": "Maximum sum from three arrays such that picking elements consecutively from same is not allowed | C ++ implementation of the approach ; Function to return the maximum sum ; Base case ; Already visited ; If the element has been taken from first array in previous step ; If the element has been taken from second array in previous step ; If the element has been taken from third array in previous step ; Driver code ; Pick element from first array ; Pick element from second array ; Pick element from third array ; Print the maximum of them", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int N = 3 ; int FindMaximumSum ( int ind , int kon , int a [ ] , int b [ ] , int c [ ] , int n , int dp [ ] [ N ] ) { if ( ind == n ) return 0 ; if ( dp [ ind ] [ kon ] != -1 ) return dp [ ind ] [ kon ] ; int ans = -1e9 + 5 ; if ( kon == 0 ) { ans = max ( ans , b [ ind ] + FindMaximumSum ( ind + 1 , 1 , a , b , c , n , dp ) ) ; ans = max ( ans , c [ ind ] + FindMaximumSum ( ind + 1 , 2 , a , b , c , n , dp ) ) ; } else if ( kon == 1 ) { ans = max ( ans , a [ ind ] + FindMaximumSum ( ind + 1 , 0 , a , b , c , n , dp ) ) ; ans = max ( ans , c [ ind ] + FindMaximumSum ( ind + 1 , 2 , a , b , c , n , dp ) ) ; } else if ( kon == 2 ) { ans = max ( ans , a [ ind ] + FindMaximumSum ( ind + 1 , 1 , a , b , c , n , dp ) ) ; ans = max ( ans , b [ ind ] + FindMaximumSum ( ind + 1 , 0 , a , b , c , n , dp ) ) ; } return dp [ ind ] [ kon ] = ans ; } int main ( ) { int a [ ] = { 6 , 8 , 2 , 7 , 4 , 2 , 7 } ; int b [ ] = { 7 , 8 , 5 , 8 , 6 , 3 , 5 } ; int c [ ] = { 8 , 3 , 2 , 6 , 8 , 4 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int dp [ n ] [ N ] ; memset ( dp , -1 , sizeof dp ) ; int x = FindMaximumSum ( 0 , 0 , a , b , c , n , dp ) ; int y = FindMaximumSum ( 0 , 1 , a , b , c , n , dp ) ; int z = FindMaximumSum ( 0 , 2 , a , b , c , n , dp ) ; cout << max ( x , max ( y , z ) ) ; return 0 ; }", "text_ms": "Jumlah maksimum dari tiga tatasusunan yang memilih unsur -unsur berturut -turut dari yang sama tidak dibenarkan | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan jumlah maksimum; Kes asas; Sudah dikunjungi; Jika elemen telah diambil dari array pertama dalam langkah sebelumnya; Jika elemen telah diambil dari array kedua dalam langkah sebelumnya; Jika elemen telah diambil dari array ketiga dalam langkah sebelumnya; Kod pemacu; Pilih elemen dari array pertama; Pilih elemen dari array kedua; Pilih elemen dari array ketiga; Cetak maksimum mereka"}
{"text": "Number of ways to make binary string of length N such that 0 s always occur together in groups of size K | C ++ implementation of the above approach ; Function to return no of ways to build a binary string of length N such that 0 s always occur in groups of size K ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int mod = 1000000007 ; int noOfBinaryStrings ( int N , int k ) { int dp [ 100002 ] ; for ( int i = 1 ; i <= k - 1 ; i ++ ) { dp [ i ] = 1 ; } dp [ k ] = 2 ; for ( int i = k + 1 ; i <= N ; i ++ ) { dp [ i ] = ( dp [ i - 1 ] + dp [ i - k ] ) % mod ; } return dp [ N ] ; } int main ( ) { int N = 4 ; int K = 2 ; cout << noOfBinaryStrings ( N , K ) ; return 0 ; }", "text_ms": "Bilangan cara untuk membuat rentetan panjang panjang n sedemikian rupa sehingga 0 s sentiasa berlaku bersama dalam kumpulan saiz k | C ++ pelaksanaan pendekatan di atas; Berfungsi untuk mengembalikan tidak ada cara untuk membina rentetan panjang binari sehingga 0 s selalu berlaku dalam kumpulan saiz k; Kod pemacu"}
{"text": "Number of ways to pair people | CPP program to find number of ways to pair people in party ; Function to find number of ways to pair people in party ; To store count of number of ways . ; Using the recurrence defined find count for different values of p . ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findWaysToPair ( int p ) { int dp [ p + 1 ] ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; for ( int i = 3 ; i <= p ; i ++ ) { dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ p ] ; } int main ( ) { int p = 3 ; cout << findWaysToPair ( p ) ; return 0 ; }", "text_ms": "Bilangan cara untuk memasangkan orang | Program CPP untuk mencari beberapa cara untuk memasangkan orang dalam parti; Berfungsi untuk mencari bilangan cara untuk memasangkan orang dalam parti; Untuk menyimpan jumlah cara. ; Menggunakan kiraan cari yang ditakrifkan berulang untuk nilai yang berbeza p. ; Kod pemacu"}
{"text": "Count ways to reach a score using 1 and 2 with no consecutive 2 s | A simple recursive implementation for counting ways to reach a score using 1 and 2 with consecutive 2 allowed ; base cases ; For cases n > 2 ; Driver code", "code": "#include <iostream> NEW_LINE using namespace std ; int CountWays ( int n ) { if ( n == 0 ) { return 1 ; } if ( n == 1 ) { return 1 ; } if ( n == 2 ) { return 1 + 1 ; } return CountWays ( n - 1 ) + CountWays ( n - 3 ) ; } int main ( ) { int n = 10 ; cout << CountWays ( n ) ; return 0 ; }", "text_ms": "Kira cara untuk mencapai skor menggunakan 1 dan 2 tanpa berturut -turut 2 S | Pelaksanaan rekursif mudah untuk mengira cara untuk mencapai skor menggunakan 1 dan 2 dengan berturut -turut 2 dibenarkan; kes asas; Untuk kes n> 2; Kod pemacu"}
{"text": "Weird Number | C ++ program to check if the number is weird or not ; code to find all the factors of the number excluding the number itself ; vector to store the factors ; note that this loop runs till sqrt ( n ) ; if the value of i is a factor ; condition to check the divisor is not the number itself ; return the vector ; Function to check if the number is abundant or not ; find the divisors using function ; sum all the factors ; check for abundant or not ; Function to check if the number is semi - perfect or not ; find the divisors ; sorting the vector ; subset to check if no is semiperfect ; initialising 1 st column to true ; initialing 1 st row except zero position to 0 ; loop to find whether the number is semiperfect ; calculation to check if the number can be made by summation of divisors ; if not possible to make the number by any combination of divisors ; Function to check for weird or not ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > factors ( int n ) { vector < int > v ; v . push_back ( 1 ) ; for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { v . push_back ( i ) ; if ( n / i != i ) { v . push_back ( n / i ) ; } } } return v ; } bool checkAbundant ( int n ) { vector < int > v ; int sum = 0 ; v = factors ( n ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { sum += v [ i ] ; } if ( sum > n ) return true ; else return false ; } bool checkSemiPerfect ( int n ) { vector < int > v ; v = factors ( n ) ; sort ( v . begin ( ) , v . end ( ) ) ; int r = v . size ( ) ; bool subset [ r + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= r ; i ++ ) subset [ i ] [ 0 ] = true ; for ( int i = 1 ; i <= n ; i ++ ) subset [ 0 ] [ i ] = false ; for ( int i = 1 ; i <= r ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( j < v [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] ; else { subset [ i ] [ j ] = subset [ i - 1 ] [ j ] || subset [ i - 1 ] [ j - v [ i - 1 ] ] ; } } } if ( ( subset [ r ] [ n ] ) == 0 ) return false ; else return true ; } bool checkweird ( int n ) { if ( checkAbundant ( n ) == true && checkSemiPerfect ( n ) == false ) return true ; else return false ; } int main ( ) { int n = 70 ; if ( checkweird ( n ) ) cout << \" Weird ▁ Number \" ; else cout << \" Not ▁ Weird ▁ Number \" ; return 0 ; }", "text_ms": "Nombor pelik | Program C ++ untuk memeriksa sama ada nombor itu pelik atau tidak; Kod untuk mencari semua faktor nombor tidak termasuk nombor itu sendiri; vektor untuk menyimpan faktor -faktor; Perhatikan bahawa gelung ini berjalan sehingga sqrt (n); jika nilai saya adalah faktor; Keadaan untuk memeriksa pembahagi bukan nombor itu sendiri; mengembalikan vektor; Berfungsi untuk memeriksa sama ada nombor itu banyak atau tidak; Cari pembahagi menggunakan fungsi; Jumlah semua faktor; Periksa banyak atau tidak; Berfungsi untuk memeriksa sama ada nombor itu separuh - sempurna atau tidak; Cari pembahagi; menyusun vektor; subset untuk memeriksa sama ada tidak semiperfect; memulakan lajur 1 st untuk benar; memulakan baris 1 st kecuali kedudukan sifar ke 0; gelung untuk mencari sama ada nombor itu semiperfect; pengiraan untuk memeriksa sama ada nombor itu boleh dibuat dengan penjumlahan pembahagi; jika tidak mungkin untuk membuat nombor dengan gabungan mana -mana pembahagi; Berfungsi untuk memeriksa pelik atau tidak; Kod pemacu"}
{"text": "Maximum subarray sum in an array created after repeated concatenation | C ++ program to print largest contiguous array sum when array is created after concatenating a small array k times . ; Returns sum of maximum sum subarray created after concatenating a [ 0. . n - 1 ] k times . ; This is where it differs from Kadane 's  algorithm. We use modular arithmetic to  find next element. ; Driver program to test maxSubArraySum", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSubArraySumRepeated ( int a [ ] , int n , int k ) { int max_so_far = INT_MIN , max_ending_here = 0 ; for ( int i = 0 ; i < n * k ; i ++ ) { max_ending_here = max_ending_here + a [ i % n ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; } int main ( ) { int a [ ] = { 10 , 20 , -30 , -1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int k = 3 ; cout << \" Maximum ▁ contiguous ▁ sum ▁ is ▁ \" << maxSubArraySumRepeated ( a , n , k ) ; return 0 ; }", "text_ms": "SUM MAXIMUM SUMS DALAM TRADE DALAM SELEPAS CONCATENATION UTAMA | Program C ++ untuk mencetak jumlah array bersebelahan terbesar apabila array dicipta selepas menggabungkan kali array kecil. ; Mengembalikan jumlah maksimum subarray yang dibuat selepas menggabungkan [0 .. n - 1] k kali. ; Di sinilah ia berbeza dari algoritma Kadane. Kami menggunakan aritmetik modular untuk mencari elemen seterusnya. ; Program pemacu untuk menguji maxsubarraysum"}
{"text": "Longest Increasing Odd Even Subsequence | C ++ implementation to find the longest increasing odd even subsequence ; function to find the longest increasing odd even subsequence ; lioes [ i ] stores longest increasing odd even subsequence ending at arr [ i ] ; to store the length of longest increasing odd even subsequence ; Initialize LIOES values for all indexes ; Compute optimized LIOES values in bottom up manner ; Pick maximum of all LIOES values ; required maximum length ; Driver program to test above", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int longOddEvenIncSeq ( int arr [ ] , int n ) { int lioes [ n ] ; int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) lioes [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && ( arr [ i ] + arr [ j ] ) % 2 != 0 && lioes [ i ] < lioes [ j ] + 1 ) lioes [ i ] = lioes [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( maxLen < lioes [ i ] ) maxLen = lioes [ i ] ; return maxLen ; } int main ( ) { int arr [ ] = { 1 , 12 , 2 , 22 , 5 , 30 , 31 , 14 , 17 , 11 } ; int n = sizeof ( arr ) / sizeof ( n ) ; cout << \" Longest ▁ Increasing ▁ Odd ▁ Even ▁ \" << \" Subsequence : ▁ \" << longOddEvenIncSeq ( arr , n ) ; return 0 ; }", "text_ms": "Terpanjang peningkatan ganjil walaupun berikutnya | C ++ pelaksanaan untuk mencari peningkatan yang paling lama meningkat walaupun berikutnya; berfungsi untuk mencari peningkatan yang paling lama walaupun seterusnya; lioes [i] menyimpan paling lama meningkatkan ganjil walaupun berikutnya yang berakhir di arr [i]; untuk menyimpan panjang yang paling lama meningkat ganjil walaupun berikutnya; Memulakan nilai lio untuk semua indeks; Mengira nilai lio yang dioptimumkan dengan cara bawah; Pilih maksimum semua nilai lio; panjang maksimum yang diperlukan; Program Pemandu untuk diuji di atas"}
{"text": "Minimum and Maximum values of an expression with * and + | C ++ program to get maximum and minimum values of an expression ; Utility method to check whether a character is operator or not ; method prints minimum and maximum value obtainable from an expression ; store operator and numbers in different vectors ; storing last number in vector ; initializing minval and maxval 2D array ; initializing main diagonal by num values ; looping similar to matrix chain multiplication and updating both 2D arrays ; if current operator is ' + ' , updating tmp variable by addition ; if current operator is ' * ' , updating tmp variable by multiplication ; updating array values by tmp variables ; last element of first row will store the result ; Driver code to test above methods", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isOperator ( char op ) { return ( op == ' + ' op == ' * ' ) ; } void printMinAndMaxValueOfExp ( string exp ) { vector < int > num ; vector < char > opr ; string tmp = \" \" ; for ( int i = 0 ; i < exp . length ( ) ; i ++ ) { if ( isOperator ( exp [ i ] ) ) { opr . push_back ( exp [ i ] ) ; num . push_back ( atoi ( tmp . c_str ( ) ) ) ; tmp = \" \" ; } else { tmp += exp [ i ] ; } } num . push_back ( atoi ( tmp . c_str ( ) ) ) ; int len = num . size ( ) ; int minVal [ len ] [ len ] ; int maxVal [ len ] [ len ] ; for ( int i = 0 ; i < len ; i ++ ) { for ( int j = 0 ; j < len ; j ++ ) { minVal [ i ] [ j ] = INT_MAX ; maxVal [ i ] [ j ] = 0 ; if ( i == j ) minVal [ i ] [ j ] = maxVal [ i ] [ j ] = num [ i ] ; } } for ( int L = 2 ; L <= len ; L ++ ) { for ( int i = 0 ; i < len - L + 1 ; i ++ ) { int j = i + L - 1 ; for ( int k = i ; k < j ; k ++ ) { int minTmp = 0 , maxTmp = 0 ; if ( opr [ k ] == ' + ' ) { minTmp = minVal [ i ] [ k ] + minVal [ k + 1 ] [ j ] ; maxTmp = maxVal [ i ] [ k ] + maxVal [ k + 1 ] [ j ] ; } else if ( opr [ k ] == ' * ' ) { minTmp = minVal [ i ] [ k ] * minVal [ k + 1 ] [ j ] ; maxTmp = maxVal [ i ] [ k ] * maxVal [ k + 1 ] [ j ] ; } if ( minTmp < minVal [ i ] [ j ] ) minVal [ i ] [ j ] = minTmp ; if ( maxTmp > maxVal [ i ] [ j ] ) maxVal [ i ] [ j ] = maxTmp ; } } } cout << \" Minimum ▁ value ▁ : ▁ \" << minVal [ 0 ] [ len - 1 ] << \" , ▁ Maximum ▁ value ▁ : ▁ \" << maxVal [ 0 ] [ len - 1 ] ; } int main ( ) { string expression = \"1 + 2*3 + 4*5\" ; printMinAndMaxValueOfExp ( expression ) ; return 0 ; }", "text_ms": "Nilai minimum dan maksimum ungkapan dengan * dan + | Program C ++ untuk mendapatkan nilai maksimum dan minimum ungkapan; Kaedah utiliti untuk memeriksa sama ada watak adalah pengendali atau tidak; kaedah mencetak nilai minimum dan maksimum yang boleh diperolehi daripada ungkapan; pengendali kedai dan nombor dalam vektor yang berbeza; menyimpan nombor terakhir dalam vektor; memulakan array Minval dan Maxval 2D; memulakan pepenjuru utama dengan nilai NUM; Looping serupa dengan pendaraban rantai matriks dan mengemas kini kedua -dua tatasusunan 2D; Jika pengendali semasa adalah ' +', mengemas kini pembolehubah TMP dengan tambahan; Jika pengendali semasa adalah ' *', mengemas kini pembolehubah TMP dengan pendaraban; mengemas kini nilai array oleh pembolehubah TMP; Elemen terakhir baris pertama akan menyimpan hasilnya; Kod pemacu untuk menguji kaedah di atas"}
{"text": "Matrix Chain Multiplication | DP | A naive recursive implementation that simply follows the above optimal substructure property ; Matrix Ai has dimension p [ i - 1 ] x p [ i ] for i = 1. . n ; place parenthesis at different places between first and last matrix , recursively calculate count of multiplications for each parenthesis placement and return the minimum count ; Return minimum count ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int MatrixChainOrder ( int p [ ] , int i , int j ) { if ( i == j ) return 0 ; int k ; int min = INT_MAX ; int count ; for ( k = i ; k < j ; k ++ ) { count = MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( count < min ) min = count ; } return min ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << \" Minimum ▁ number ▁ of ▁ multiplications ▁ is ▁ \" << MatrixChainOrder ( arr , 1 , n - 1 ) ; }", "text_ms": "Pendaraban rantai matriks | DP | Pelaksanaan rekursif naif yang hanya mengikuti harta substruktur yang optimum di atas; Matrix AI mempunyai dimensi p [i - 1] x p [i] untuk i = 1. n; Letakkan kurungan di tempat yang berbeza antara matriks pertama dan terakhir, mengira kiraan pendaraban untuk setiap penempatan kurungan dan mengembalikan kiraan minimum; Mengembalikan kiraan minimum; Kod pemacu"}
{"text": "Matrix Chain Multiplication | DP | C ++ program using memoization ; Function for matrix chain multiplication ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int dp [ 100 ] [ 100 ] ; int matrixChainMemoised ( int * p , int i , int j ) { if ( i == j ) { return 0 ; } if ( dp [ i ] [ j ] != -1 ) { return dp [ i ] [ j ] ; } dp [ i ] [ j ] = INT_MAX ; for ( int k = i ; k < j ; k ++ ) { dp [ i ] [ j ] = min ( dp [ i ] [ j ] , matrixChainMemoised ( p , i , k ) + matrixChainMemoised ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) ; } return dp [ i ] [ j ] ; } int MatrixChainOrder ( int * p , int n ) { int i = 1 , j = n - 1 ; return matrixChainMemoised ( p , i , j ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; memset ( dp , -1 , sizeof dp ) ; cout << \" Minimum ▁ number ▁ of ▁ multiplications ▁ is ▁ \" << MatrixChainOrder ( arr , n ) ; }", "text_ms": "Pendaraban rantai matriks | DP | Program C ++ menggunakan memoisasi; Fungsi untuk pendaraban rantai matriks; Kod pemacu"}
{"text": "Numbers formed by flipping common set bits in two given integers | C ++ program to implement the above approach ; Function to flip bits of A and B which are set in both of them ; Clear the bits of A which are set in both A and B ; Clear the bits of B which are set in both A and B ; Print updated A and B ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void flipBitsOfAandB ( int A , int B ) { A = A ^ ( A & B ) ; B = B ^ ( A & B ) ; cout << A << \" ▁ \" << B ; } int main ( ) { int A = 10 , B = 20 ; flipBitsOfAandB ( A , B ) ; return 0 ; }", "text_ms": "Nombor yang dibentuk dengan membalikkan bit set biasa dalam dua bilangan bulat yang diberikan | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk membalikkan bit A dan B yang ditetapkan dalam kedua -dua mereka; Kosongkan bit A yang ditetapkan dalam kedua -dua A dan B; Kosongkan bit B yang ditetapkan dalam kedua -dua A dan B; Cetak dikemas kini A dan B; Kod pemacu"}
{"text": "Sum of Hamming difference of consecutive numbers from 0 to N | Set 2 | C ++ Program to implement the above approach ; Function to calculate and return the hamming distance between all consecutive numbers from 0 to N ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int TotalHammingDistance ( int n ) { int i = 1 , sum = 0 ; while ( n / i > 0 ) { sum = sum + n / i ; i = i * 2 ; } return sum ; } int main ( ) { int N = 9 ; cout << TotalHammingDistance ( N ) ; return 0 ; }", "text_ms": "Jumlah perbezaan perbezaan nombor berturut -turut dari 0 hingga n | Tetapkan 2 | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk mengira dan mengembalikan jarak Hamming antara semua nombor berturut -turut dari 0 hingga n; Kod pemacu"}
{"text": "Sum of all divisors from 1 to N | Set 3 | C ++ Program to implement the above approach ; Function to find the sum of all divisors of all numbers from 1 to N ; Stores the sum ; Marks the last point of occurence with same count ; Calculate the sum ; Return the result ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define int  long long int NEW_LINE #define m  1000000007 NEW_LINE void solve ( long long n ) { long long s = 0 ; for ( int l = 1 ; l <= n ; ) { int r = n / floor ( n / l ) ; int x = ( ( ( r % m ) * ( ( r + 1 ) % m ) ) / 2 ) % m ; int y = ( ( ( l % m ) * ( ( l - 1 ) % m ) ) / 2 ) % m ; int p = ( ( n / l ) % m ) ; s = ( s + ( ( ( x - y ) % m ) * p ) % m + m ) % m ; s %= m ; l = r + 1 ; } cout << ( s + m ) % m ; } signed main ( ) { long long n = 12 ; solve ( n ) ; return 0 ; }", "text_ms": "Jumlah semua pembahagi dari 1 hingga N | Set 3 | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk mencari jumlah semua pembahagi semua nombor dari 1 hingga n; Menyimpan jumlah; Menandakan titik terakhir kejadian dengan kiraan yang sama; Kirakan jumlahnya; Mengembalikan hasilnya; Kod pemacu"}
{"text": "Minimize number of cuts required to break N length stick into N unit length sticks | C ++ program to find minimum time required to split a stick of N length into unit pieces ; Function to return the minimum time required to split stick of N into length into unit pieces ; Return the minimum unit of time required ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int min_time_to_cut ( int N ) { if ( N == 0 ) return 0 ; return ceil ( log2 ( N ) ) ; } int main ( ) { int N = 100 ; cout << min_time_to_cut ( N ) ; return 0 ; }", "text_ms": "Kurangkan bilangan luka yang diperlukan untuk memecahkan panjang n tongkat ke dalam n unit panjang tongkat | Program C ++ untuk mencari masa minimum yang diperlukan untuk memecah tongkat panjang N ke dalam kepingan unit; Berfungsi untuk mengembalikan masa minimum yang diperlukan untuk memecah tongkat n ke dalam kepingan unit; Mengembalikan unit minimum masa yang diperlukan; Kod pemacu"}
{"text": "Count of distinct pair sum between two 1 to N value Arrays | C ++ implementation to count of distinct pair sum between two Array with values 1 to N ; Function to find the distinct sums ; Set to store distinct sums ; Inserting every sum ; returning distinct sums ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findDistinctSums ( int n ) { set < int > s ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { s . insert ( i + j ) ; } } return s . size ( ) ; } int main ( ) { int N = 3 ; cout << findDistinctSums ( N ) ; return 0 ; }", "text_ms": "Kira jumlah pasangan yang berbeza antara dua array nilai 1 hingga n | C ++ pelaksanaan untuk mengira jumlah pasangan yang berbeza antara dua array dengan nilai 1 hingga n; Berfungsi untuk mencari jumlah yang berbeza; Tetapkan untuk menyimpan jumlah yang berbeza; Memasukkan setiap jumlah; kembali jumlah yang berbeza; Kod pemacu"}
{"text": "Print Triangle separated pattern | C ++ program to print the triangle separated pattern using star and slash character ; Function to print pattern recursively ; Base Case ; Conditions to print slash ; Condition to print forword slash ; Condition to print backward slash ; Else print ' * ' ; Recursive call for rows ; Recursive call for changing the rows ; Driver Code ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int printPattern ( int i , int j , int n ) { if ( j >= n ) { return 0 ; } if ( i >= n ) { return 1 ; } if ( j == i j == n - 1 - i ) { if ( i == n - 1 - j ) { cout << \" / \" ; } else { cout << \" \\ \\\" ; } } else { cout << \" * \" ; } if ( printPattern ( i , j + 1 , n ) == 1 ) { return 1 ; } cout << endl ; return printPattern ( i + 1 , 0 , n ) ; } int main ( ) { int N = 9 ; printPattern ( 0 , 0 , N ) ; return 0 ; }", "text_ms": "Cetak Segitiga Terasing Corak | Program C ++ untuk mencetak corak terpisah segitiga menggunakan watak bintang dan slash; Berfungsi untuk mencetak corak secara rekursif; Kes asas; Syarat untuk mencetak slash; Keadaan untuk mencetak slash forword; Keadaan untuk mencetak slash ke belakang; Lain cetak ' *'; Panggilan rekursif untuk baris; Panggilan rekursif untuk menukar baris; Kod pemacu; Panggilan fungsi"}
{"text": "Find starting index for every occurrence of given array B in array A using Z | CPP implementation for pattern searching in an array using Z - Algorithm ; Function to calculate Z - Array ; Loop to calculate Z - Array ; Outside the Z - box ; Inside Z - box ; Helper function to merge two arrays and create a single array ; Array to store merged array ; Copying array B ; Adding a separator ; Copying array A ; Calling Z - function ; Function to help compute the Z array ; Printing indexes where array B occur ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > zArray ( vector < int > arr ) { int n = arr . size ( ) ; vector < int > z ( n ) ; int r = 0 , l = 0 ; for ( int k = 1 ; k < n ; k ++ ) { if ( k > r ) { r = l = k ; while ( r < n && arr [ r ] == arr [ r - l ] ) r ++ ; z [ k ] = r - l ; r -- ; } else { int k1 = k - l ; if ( z [ k1 ] < r - k + 1 ) z [ k ] = z [ k1 ] ; else { l = k ; while ( r < n && arr [ r ] == arr [ r - l ] ) r ++ ; z [ k ] = r - l ; r -- ; } } } return z ; } vector < int > mergeArray ( vector < int > A , vector < int > B ) { int n = A . size ( ) ; int m = B . size ( ) ; vector < int > z ; vector < int > c ( n + m + 1 ) ; for ( int i = 0 ; i < m ; i ++ ) c [ i ] = B [ i ] ; c [ m ] = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) c [ m + i + 1 ] = A [ i ] ; z = zArray ( c ) ; return z ; } void findZArray ( vector < int > A , vector < int > B , int n ) { int flag = 0 ; vector < int > z ; z = mergeArray ( A , B ) ; for ( int i = 0 ; i < z . size ( ) ; i ++ ) { if ( z [ i ] == n ) { cout << ( i - n - 1 ) << \" ▁ \" ; flag = 1 ; } } if ( flag == 0 ) { cout << ( \" Not ▁ Found \" ) ; } } int main ( ) { vector < int > A { 1 , 2 , 3 , 2 , 3 , 2 } ; vector < int > B { 2 , 3 } ; int n = B . size ( ) ; findZArray ( A , B , n ) ; }", "text_ms": "Cari indeks permulaan untuk setiap kejadian array yang diberikan b dalam array A menggunakan z | Pelaksanaan CPP untuk mencari corak dalam array menggunakan algoritma Z; Fungsi untuk mengira z - array; Gelung untuk mengira z - array; Di luar kotak z; Di dalam z - kotak; Fungsi penolong untuk menggabungkan dua tatasusunan dan membuat satu array; Array untuk menyimpan array yang digabungkan; Menyalin Array B; Menambah pemisah; Menyalin Array A; Memanggil Z - Fungsi; Fungsi untuk membantu mengira array Z; Indeks percetakan di mana array b berlaku; Kod pemacu"}
{"text": "Check if a string can be repeated to make another string | CPP implementation of the approach ; Function to return the count of repetitions of string a to generate string b ; If b cannot be generated by repeating a ; Repeat a count number of times ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int getCount ( string a , string b ) { if ( b . length ( ) % a . length ( ) != 0 ) return -1 ; int count = b . length ( ) / a . length ( ) ; string str = \" \" ; for ( int i = 0 ; i < count ; i ++ ) { str = str + a ; } if ( str == b ) return count ; return -1 ; } int main ( ) { string a = \" geeks \" ; string b = \" geeksgeeks \" ; cout << ( getCount ( a , b ) ) ; return 0 ; }", "text_ms": "Semak jika rentetan boleh diulang untuk membuat rentetan lain | Pelaksanaan CPP pendekatan; Berfungsi untuk mengembalikan kiraan pengulangan String A untuk menjana rentetan b; Jika B tidak dapat dihasilkan dengan mengulangi A; Ulangi jumlah kiraan; Kod pemacu"}
{"text": "Check if a string can be formed from another string using given constraints | CPP program to Check if a given string can be formed from another string using given constraints ; Function to check if S2 can be formed of S1 ; length of strings ; hash - table to store count ; store count of each character ; traverse and check for every character ; if the character of s2 is present in s1 ; if the character of s2 is not present in S1 , then check if previous two ASCII characters are present in S1 ; Driver Code ; Calling function to check", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( string S1 , string S2 ) { int n1 = S1 . size ( ) ; int n2 = S2 . size ( ) ; unordered_map < int , int > mp ; for ( int i = 0 ; i < n1 ; i ++ ) { mp [ S1 [ i ] ] ++ ; } for ( int i = 0 ; i < n2 ; i ++ ) { if ( mp [ S2 [ i ] ] ) { mp [ S2 [ i ] ] -- ; } else if ( mp [ S2 [ i ] - 1 ] && mp [ S2 [ i ] - 2 ] ) { mp [ S2 [ i ] - 1 ] -- ; mp [ S2 [ i ] - 2 ] -- ; } else { return false ; } } return true ; } int main ( ) { string S1 = \" abbat \" ; string S2 = \" cat \" ; if ( check ( S1 , S2 ) ) cout << \" YES \" ; else cout << \" NO \" ; }", "text_ms": "Semak jika rentetan boleh dibentuk dari rentetan lain menggunakan kekangan yang diberikan | Program CPP untuk memeriksa sama ada rentetan yang diberikan boleh dibentuk dari rentetan lain menggunakan kekangan yang diberikan; Fungsi untuk memeriksa sama ada S2 boleh dibentuk dari S1; panjang rentetan; Hash - Jadual untuk menyimpan kiraan; menyimpan kiraan setiap watak; melintasi dan memeriksa setiap watak; Jika watak S2 hadir dalam S1; Jika watak S2 tidak hadir dalam S1, maka periksa sama ada dua aksara ASCII terdahulu hadir dalam S1; Kod pemacu; Fungsi panggilan untuk memeriksa"}
{"text": "Count of occurrences of a \"1(0 + ) 1\" pattern in a string | C ++ program to calculate number of times the pattern occurred in given string ; Returns count of occurrences of \"1(0 + ) 1\" int str . ; int count = 0 ; Initialize result ; Check if encountered '1' forms a valid pattern as specified ; if 1 encountered for first time set oneSeen to 1 ; Check if there is any other character other than '0' or '1' . If so then set oneSeen to 0 to search again for new pattern ; Driver program to test above function", "code": "#include <iostream> NEW_LINE using namespace std ; int countPattern ( string str ) { int len = str . size ( ) ; bool oneSeen = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == '1' && oneSeen == 1 ) if ( str [ i - 1 ] == '0' ) count ++ ; if ( str [ i ] == '1' && oneSeen == 0 ) { oneSeen = 1 ; continue ; } if ( str [ i ] != '0' && str [ i ] != '1' ) oneSeen = 0 ; } return count ; } int main ( ) { string str = \"100001abc101\" ; cout << countPattern ( str ) ; return 0 ; }", "text_ms": "Count kejadian corak \"1 (0 +) 1\" dalam rentetan | Program C ++ untuk mengira bilangan kali corak berlaku dalam rentetan yang diberikan; Mengembalikan kiraan kejadian \"1 (0 +) 1\" int str. ; int count = 0; Memulakan hasil; Semak jika ditemui '1' membentuk corak yang sah seperti yang ditentukan; jika 1 ditemui untuk pertama kali ditetapkan satu ke 1; Semak jika terdapat watak lain selain daripada '0' atau '1'. Jika demikian kemudian tetapkan Oneseen hingga 0 untuk mencari lagi untuk corak baru; Program pemacu untuk menguji fungsi di atas"}
{"text": "Convert given Strings into T by replacing characters in between strings any number of times | C ++ program for the above approach ; Function to check if it possible to make all the strings equal to the string T ; Stores the frequency of all the strings in the array arr [ ] ; Stores the frequency of the string T ; Iterate over the characters of the string T ; Iterate in the range [ 0 , N - 1 ] ; Iterate over the characters of the string arr [ i ] ; If freqT [ i ] is 0 and freqS [ i ] is not 0 ; If freqS [ i ] is 0 and freqT [ i ] is not 0 ; If freqS [ i ] is not freqT [ i ] * N ; Otherwise , return \" Yes \" ; Driver Code", "code": "#include <iostream> NEW_LINE using namespace std ; string checkIfPossible ( int N , string arr [ ] , string T ) { int freqS [ 256 ] = { 0 } ; int freqT [ 256 ] = { 0 } ; for ( char ch : T ) { freqT [ ch - ' a ' ] ++ ; } for ( int i = 0 ; i < N ; i ++ ) { for ( char ch : arr [ i ] ) { freqS [ ch - ' a ' ] ++ ; } } for ( int i = 0 ; i < 256 ; i ++ ) { if ( freqT [ i ] == 0 && freqS [ i ] != 0 ) { return \" No \" ; } else if ( freqS [ i ] == 0 && freqT [ i ] != 0 ) { return \" No \" ; } else if ( freqT [ i ] != 0 && freqS [ i ] != ( freqT [ i ] * N ) ) { return \" No \" ; } } return \" Yes \" ; } int main ( ) { string arr [ ] = { \" abc \" , \" abb \" , \" acc \" } ; string T = \" abc \" ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << checkIfPossible ( N , arr , T ) ; return 0 ; }", "text_ms": "Tukar rentetan yang diberikan ke dalam T dengan menggantikan aksara di antara rentetan sebilangan kali | Program C ++ untuk pendekatan di atas; Berfungsi untuk memeriksa sama ada mungkin untuk membuat semua rentetan sama dengan rentetan t; Menyimpan kekerapan semua rentetan dalam array arr []; Menyimpan kekerapan rentetan t; Melangkah ke atas watak -watak rentetan t; Melangkah dalam julat [0, n - 1]; Melangkah ke atas watak -watak rentetan arr [i]; Jika freqt [i] adalah 0 dan freqs [i] bukan 0; Jika freqs [i] adalah 0 dan freqt [i] bukan 0; Jika freqs [i] bukan freqt [i] * n; Jika tidak, kembalikan \"ya\"; Kod pemacu"}
{"text": "Count of groups of consecutive 1 s in a given Binary String | C ++ program for the above approach ; Function to find the number of the groups of 1 s only in the binary string ; Stores number of groups of 1 s ; Initialization of the stack ; Traverse the string S ; If S [ i ] is '1' ; Otherwise ; If st is empty ; If st is not empty ; Return answer ; Driver code ; Input ; Function call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int groupsOfOnes ( string S , int N ) { int count = 0 ; stack < int > st ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] == '1' ) st . push ( 1 ) ; else { if ( ! st . empty ( ) ) { count ++ ; while ( ! st . empty ( ) ) { st . pop ( ) ; } } } } if ( ! st . empty ( ) ) count ++ ; return count ; } int main ( ) { string S = \"100110111\" ; int N = S . length ( ) ; cout << groupsOfOnes ( S , N ) << endl ; return 0 ; }", "text_ms": "Count kumpulan berturut -turut 1 s dalam rentetan binari yang diberikan | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari bilangan kumpulan 1 s hanya dalam rentetan binari; Kedai bilangan kumpulan 1 s; Permulaan timbunan; Melintasi rentetan s; Jika s [i] adalah '1'; Jika tidak; Jika St kosong; Jika ST tidak kosong; Jawapan kembali; Kod pemacu; Input; Panggilan fungsi"}
{"text": "Palindromic strings of length 3 possible by using characters of a given string | C ++ program for the above approach ; Function to print all palindromic strings of length 3 that can be formed using characters of string S ; Stores the count of character ; Traverse the string S ; Stores all palindromic strings ; Iterate over the charchaters over the range [ ' a ' , ' z ' ] ; If Hash [ ch ] is equal to 2 ; Iterate over the characters over the range [ ' a ' , ' z ' ] ; Stores all the palindromic string ; Push the s into the set st ; If Hash [ i ] is greater than or equal to 3 ; Iterate over charchaters over the range [ ' a ' , ' z ' ] ; Stores all the palindromic string ; If Hash [ j ] is positive ; Push s into the set st ; Iterate over the set ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void generatePalindrome ( string S ) { unordered_map < char , int > Hash ; for ( auto ch : S ) { Hash [ ch ] ++ ; } set < string > st ; for ( char i = ' a ' ; i <= ' z ' ; i ++ ) { if ( Hash [ i ] == 2 ) { for ( char j = ' a ' ; j <= ' z ' ; j ++ ) { string s = \" \" ; if ( Hash [ j ] && i != j ) { s += i ; s += j ; s += i ; st . insert ( s ) ; } } } if ( Hash [ i ] >= 3 ) { for ( char j = ' a ' ; j <= ' z ' ; j ++ ) { string s = \" \" ; if ( Hash [ j ] ) { s += i ; s += j ; s += i ; st . insert ( s ) ; } } } } for ( auto ans : st ) { cout << ans << \" STRNEWLINE \" ; } } int main ( ) { string S = \" ddabdac \" ; generatePalindrome ( S ) ; return 0 ; }", "text_ms": "Palindromic Strings of Length 3 mungkin dengan menggunakan aksara rentetan yang diberikan | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencetak semua rentetan palindromik panjang 3 yang boleh dibentuk menggunakan aksara rentetan s; Menyimpan kiraan watak; Melintasi rentetan s; Menyimpan semua rentetan palindromik; Melangkah ke atas charchaters ke atas julat ['a', 'z']; Jika hash [ch] sama dengan 2; Melangkah ke atas watak -watak di atas julat ['a', 'z']; Menyimpan semua rentetan palindromik; Tolak S ke set st; Jika hash [i] lebih besar daripada atau sama dengan 3; Melangkah ke atas charchaters ke atas julat ['a', 'z']; Menyimpan semua rentetan palindromik; Jika hash [j] positif; Tolak s ke set st; Melangkah ke atas set; Kod pemacu"}
{"text": "Count occurrences of substring X before every occurrence of substring Y in a given string | C ++ program for the above approach ; Function to count occurrences of the string Y in the string S for every occurrence of X in S ; Stores the count of occurrences of X ; Stores the lengths of the three strings ; Traverse the string S ; If the current substring is Y , then increment the value of count by 1 ; If the current substring is X , then print the count ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void countOccurrences ( string S , string X , string Y ) { int count = 0 ; int N = S . length ( ) , A = X . length ( ) ; int B = Y . length ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( S . substr ( i , B ) == Y ) count ++ ; if ( S . substr ( i , A ) == X ) cout << count << \" ▁ \" ; } } int main ( ) { string S = \" abcdefdefabc \" ; string X = \" abc \" ; string Y = \" def \" ; countOccurrences ( S , X , Y ) ; return 0 ; }", "text_ms": "Mengira kejadian substring x sebelum setiap kejadian substring y dalam rentetan yang diberikan | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira kejadian rentetan y dalam rentetan s untuk setiap kejadian x dalam s; Menyimpan kiraan kejadian x; Menyimpan panjang tiga rentetan; Melintasi rentetan s; Jika substring semasa adalah y, maka kenaikan nilai kiraan sebanyak 1; Jika substring semasa adalah x, maka cetak kiraan; Kod pemacu"}
{"text": "Program to construct DFA for Regular Expression C ( A + B ) + | C ++ program for the above approach ; Function to find whether the given string is Accepted by the DFA ; If n <= 1 , then print No ; To count the matched characters ; Check if the first character is C ; Traverse the rest of string ; If character is A or B , increment count by 1 ; If the first character is not C , print - 1 ; If all characters matches ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void DFA ( string str , int N ) { if ( N <= 1 ) { cout << \" No \" ; return ; } int count = 0 ; if ( str [ 0 ] == ' C ' ) { count ++ ; for ( int i = 1 ; i < N ; i ++ ) { if ( str [ i ] == ' A ' str [ i ] == ' B ' ) count ++ ; else break ; } } else { cout << \" No \" ; return ; } if ( count == N ) cout << \" Yes \" ; else cout << \" No \" ; } int main ( ) { string str = \" CAABBAAB \" ; int N = str . size ( ) ; DFA ( str , N ) ; return 0 ; }", "text_ms": "Program untuk membina DFA untuk ungkapan biasa C (A + B) + | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari sama ada rentetan yang diberikan diterima oleh DFA; Jika n <= 1, maka cetak tidak; Untuk mengira watak yang dipadankan; Semak jika watak pertama adalah c; Melintasi seluruh rentetan; Jika watak adalah A atau B, kiraan kenaikan sebanyak 1; Jika watak pertama tidak C, cetak - 1; Jika semua watak sepadan; Kod pemacu"}
{"text": "Minimum and maximum number of digits required to be removed to make a given number divisible by 3 | C ++ program for the above approach ; Function to find the maximum and minimum number of digits to be removed to make str divisible by 3 ; Convert the string into array of digits ; Count of 0 s , 1 s , and 2 s ; Traverse the array ; Find the sum of digits % 3 ; Cases to find minimum number of digits to be removed ; Cases to find maximum number of digits to be removed ; Driver Code ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void minMaxDigits ( string str , int N ) { int arr [ N ] ; for ( int i = 0 ; i < N ; i ++ ) arr [ i ] = ( str [ i ] - '0' ) % 3 ; int zero = 0 , one = 0 , two = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) zero ++ ; if ( arr [ i ] == 1 ) one ++ ; if ( arr [ i ] == 2 ) two ++ ; } int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum = ( sum + arr [ i ] ) % 3 ; } if ( sum == 0 ) { cout << 0 << ' ▁ ' ; } if ( sum == 1 ) { if ( one && N > 1 ) cout << 1 << ' ▁ ' ; else if ( two > 1 && N > 2 ) cout << 2 << ' ▁ ' ; else cout << -1 << ' ▁ ' ; } if ( sum == 2 ) { if ( two && N > 1 ) cout << 1 << ' ▁ ' ; else if ( one > 1 && N > 2 ) cout << 2 << ' ▁ ' ; else cout << -1 << ' ▁ ' ; } if ( zero > 0 ) cout << N - 1 << ' ▁ ' ; else if ( one > 0 && two > 0 ) cout << N - 2 << ' ▁ ' ; else if ( one > 2 two > 2 ) cout << N - 3 << ' ▁ ' ; else cout << -1 << ' ▁ ' ; } int main ( ) { string str = \"12345\" ; int N = str . length ( ) ; minMaxDigits ( str , N ) ; return 0 ; }", "text_ms": "Bilangan minimum dan maksimum digit yang diperlukan untuk dikeluarkan untuk membuat nombor tertentu dibahagikan dengan 3 | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari bilangan maksimum dan minimum digit yang akan dikeluarkan untuk menjadikan STR dibahagikan dengan 3; Tukar rentetan ke dalam pelbagai digit; Kiraan 0 s, 1 s, dan 2 s; Melintasi array; Cari jumlah digit % 3; Kes untuk mencari bilangan minimum digit yang akan dikeluarkan; Kes untuk mencari bilangan maksimum digit yang akan dikeluarkan; Kod pemacu; Panggilan fungsi"}
{"text": "Minimum replacements required to obtain a K | C ++ program for the above approach ; Function to find the minimum number of changes to make the string K - periodic and palindrome ; Initialize ans with 0 ; Iterate from 0 to ( K + 1 ) / 2 ; Store frequency of character ; Iterate through all indices , i , i + K , i + 2 k ... . and store the frequency of character ; Increase the frequency of current character ; Iterate through all indices K - i , 2 K - i , 3 K - i ... . and store the frequency of character ; If K is odd & i is samw as K / 2 , break the loop ; Increase the frequency of current character ; Find the maximum frequency of a character among all visited characters ; If K is odd and i is same as K / 2 then , only N / K characters is visited ; Otherwise N / K * 2 characters has visited ; Return the result ; Driver Code ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinimumChanges ( int N , int K , string S ) { int ans = 0 ; for ( int i = 0 ; i < ( K + 1 ) / 2 ; i ++ ) { map < char , int > mp ; for ( int j = i ; j < N ; j += K ) { mp [ S [ j ] ] ++ ; } for ( int j = N - i - 1 ; j >= 0 ; j -= K ) { if ( K & 1 and i == K / 2 ) break ; mp [ S [ j ] ] ++ ; } int curr_max = INT_MIN ; for ( auto p : mp ) curr_max = max ( curr_max , p . second ) ; if ( K & 1 and i == K / 2 ) ans += ( N / K - curr_max ) ; else ans += ( N / K * 2 - curr_max ) ; } return ans ; } int main ( ) { string S = \" aabbcbbcb \" ; int N = S . length ( ) ; int K = 3 ; cout << findMinimumChanges ( N , K , S ) ; return 0 ; }", "text_ms": "Penggantian minimum diperlukan untuk mendapatkan k | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari bilangan minimum perubahan untuk membuat rentetan k - berkala dan palindrome; Memulakan ans dengan 0; Berulang dari 0 hingga (k + 1) / 2; Frekuensi penyimpanan watak; Melewati semua indeks, i, i + k, i + 2 k .... dan menyimpan kekerapan watak; Meningkatkan kekerapan watak semasa; Melewati semua indeks k - i, 2 k - i, 3 ​​k - i .... dan menyimpan kekerapan watak; Jika k adalah ganjil & i adalah samw sebagai k / 2, pecahkan gelung; Meningkatkan kekerapan watak semasa; Cari kekerapan maksimum watak di antara semua watak yang dikunjungi; Jika K adalah ganjil dan saya sama dengan K / 2 maka, hanya aksara N / K yang dikunjungi; Jika tidak, n / k * 2 aksara telah melawat; Mengembalikan hasilnya; Kod pemacu; Panggilan fungsi"}
{"text": "Check if a String contains any index with more than K active characters | C ++ Program to implement the above approach ; Function to check if any index contains more than K active characters ; Store the last occurrence of each character in the map . ; Stores the active characters ; Insert the character ; If the size of set exceeds K ; Remove the character from set if i is the last index of the current character ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string checkString ( string s , int K ) { int n = s . length ( ) ; unordered_map < char , int > mp ; for ( int i = 0 ; i < n ; i ++ ) { mp [ s [ i ] ] = i ; } int cnt = 0 , f = 0 ; unordered_set < int > st ; for ( int i = 0 ; i < n ; i ++ ) { st . insert ( s [ i ] ) ; if ( st . size ( ) > K ) { f = 1 ; break ; } if ( mp [ s [ i ] ] == i ) st . erase ( s [ i ] ) ; } return ( f == 1 ? \" Yes \" : \" No \" ) ; } int main ( ) { string s = \" aabbcdca \" ; int k = 2 ; cout << checkString ( s , k ) ; return 0 ; }", "text_ms": "Semak sama ada rentetan mengandungi sebarang indeks dengan lebih banyak daripada aktif aktif k | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk memeriksa sama ada mana -mana indeks mengandungi lebih banyak daripada ak aktif aktif; Simpan kejadian terakhir setiap watak dalam peta. ; Menyimpan watak aktif; Masukkan watak; Jika saiz set melebihi k; Keluarkan watak dari set jika saya adalah indeks terakhir watak semasa; Kod pemacu"}
{"text": "Count the number of strings in an array whose distinct characters are less than equal to M | C ++ implementation to count the number of strings in the array whose distinct characters is less than or equal to M ; Function to count the strings whose distinct characters count is less than M ; Loop to iterate over all the strings of the array ; Distinct characters in the String with the help of set ; Checking if its less than or equal to M ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE #include <set> NEW_LINE using namespace std ; void distinct ( string S [ ] , int M , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { set < char > set1 ; for ( int j = 0 ; j < S [ i ] . length ( ) ; j ++ ) { if ( set1 . find ( S [ i ] [ j ] ) == set1 . end ( ) ) set1 . insert ( S [ i ] [ j ] ) ; } int c = set1 . size ( ) ; if ( c <= M ) count += 1 ; } cout << ( count ) ; } int main ( ) { string S [ ] = { \" HERBIVORES \" , \" AEROPLANE \" , \" GEEKSFORGEEKS \" } ; int M = 7 ; int n = sizeof ( S ) / sizeof ( S [ 0 ] ) ; distinct ( S , M , n ) ; return 0 ; }", "text_ms": "Kira bilangan rentetan dalam array yang wataknya berbeza kurang daripada m | C ++ pelaksanaan untuk mengira bilangan rentetan dalam array yang wataknya berbeza kurang daripada atau sama dengan m; Fungsi untuk mengira rentetan yang dikira watak -watak yang berbeza kurang daripada m; Gelung untuk melangkah ke atas semua rentetan array; Watak yang berbeza dalam rentetan dengan bantuan set; Memeriksa jika kurang daripada atau sama dengan m; Kod pemacu"}
{"text": "Remove odd frequency characters from the string | C ++ program to remove the characters having odd frequencies in the string ; Function to remove the characters which have odd frequencies in the string ; Create a map to store the frequency of each character ; To store the new string ; Remove the characters which have odd frequencies ; If the character has odd frequency then skip ; Else concatenate the character to the new string ; Return the modified string ; Driver code ; Remove the characters which have odd frequencies", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string removeOddFrequencyCharacters ( string s ) { unordered_map < char , int > m ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { m [ s [ i ] ] ++ ; } string new_string = \" \" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( m [ s [ i ] ] & 1 ) continue ; new_string += s [ i ] ; } return new_string ; } int main ( ) { string str = \" geeksforgeeks \" ; str = removeOddFrequencyCharacters ( str ) ; cout << str << \" STRNEWLINE \" ; return 0 ; }", "text_ms": "Keluarkan aksara frekuensi ganjil dari rentetan | Program C ++ untuk menghapuskan aksara yang mempunyai frekuensi ganjil dalam rentetan; Berfungsi untuk menghapuskan aksara yang mempunyai frekuensi ganjil dalam rentetan; Buat peta untuk menyimpan kekerapan setiap watak; Untuk menyimpan rentetan baru; Keluarkan watak -watak yang mempunyai frekuensi ganjil; Jika watak mempunyai kekerapan ganjil maka langkau; Lain menggabungkan watak ke rentetan baru; Kembalikan rentetan yang diubah suai; Kod pemacu; Keluarkan watak yang mempunyai frekuensi ganjil"}
{"text": "Product of nodes at k | C ++ implementation to find product of elements at k - th level ; Recursive Function to find product of elements at k - th level ; if subtree is null , just like if root == NULL ; Consider only level k node to be part of the product ; Recur for Left Subtree ; Recur for Right Subtree ; Taking care of ' ) ' after left and right subtree ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int productAtKthLevel ( string tree , int k , int & i , int level ) { if ( tree [ i ++ ] == ' ( ' ) { if ( tree [ i ] == ' ) ' ) return 1 ; int product = 1 ; if ( level == k ) product = tree [ i ] - '0' ; int leftproduct = productAtKthLevel ( tree , k , ++ i , level + 1 ) ; int rightproduct = productAtKthLevel ( tree , k , ++ i , level + 1 ) ; ++ i ; return product * leftproduct * rightproduct ; } } int main ( ) { string tree = \" ( 0(5(6 ( ) ( ) ) ( 4 ( ) \" \" ( 9 ( ) ( ) ) ) ) ( 7(1 ( ) ( ) ) ( 3 ( ) ( ) ) ) ) \" ; int k = 2 ; int i = 0 ; cout << productAtKthLevel ( tree , k , i , 0 ) ; return 0 ; }", "text_ms": "Produk nod di k | C ++ pelaksanaan untuk mencari produk unsur -unsur di peringkat k - th; Fungsi rekursif untuk mencari produk unsur -unsur di peringkat k - th; Jika subtree adalah batal, sama seperti jika root == null; Pertimbangkan hanya nod tahap untuk menjadi sebahagian daripada produk; Berulang untuk subtree kiri; Berulang untuk subtree yang betul; Menjaga ')' selepas subtree kiri dan kanan; Kod pemacu"}
{"text": "Print the most occurring character in an array of strings | C ++ program to print the most occurring character in an array of strings ; Function to print the most occurring character ; Creating a hash of size 26 ; For loop to iterate through every string of the array ; For loop to iterate through every character of the string ; Incrementing the count of the character in the hash ; Finding the character with the maximum count ; Driver code ; Declaring Vector of String type", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMostOccurringChar ( vector < string > str ) { int hash [ 26 ] = { 0 } ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) { for ( int j = 0 ; j < str [ i ] . length ( ) ; j ++ ) { hash [ str [ i ] [ j ] ] ++ ; } } int max = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { max = hash [ i ] > hash [ max ] ? i : max ; } cout << ( char ) ( max + 97 ) << endl ; } int main ( ) { vector < string > str ; str . push_back ( \" animal \" ) ; str . push_back ( \" zebra \" ) ; str . push_back ( \" lion \" ) ; str . push_back ( \" giraffe \" ) ; findMostOccurringChar ( str ) ; return 0 ; }", "text_ms": "Cetak watak yang paling berlaku dalam pelbagai rentetan | Program C ++ untuk mencetak watak yang paling banyak berlaku dalam pelbagai rentetan; Berfungsi untuk mencetak watak yang paling banyak berlaku; Mewujudkan hash saiz 26; Untuk gelung untuk melangkah melalui setiap rentetan array; Untuk gelung untuk melangkah melalui setiap watak rentetan; Meningkatkan kiraan watak dalam hash; Mencari watak dengan kiraan maksimum; Kod pemacu; Mengisytiharkan vektor jenis rentetan"}
{"text": "Check whether the given floating point number is a palindrome | C ++ implementation of the approach ; Function that returns true if num is palindrome ; Convert the given floating point number into a string ; Pointers pointing to the first and the last character of the string ; Not a palindrome ; Update the pointers ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalindrome ( float num ) { stringstream ss ; ss << num ; string s ; ss >> s ; int low = 0 ; int high = s . size ( ) - 1 ; while ( low < high ) { if ( s [ low ] != s [ high ] ) return false ; low ++ ; high -- ; } return true ; } int main ( ) { float n = 123.321f ; if ( isPalindrome ( n ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "text_ms": "Semak sama ada nombor titik terapung yang diberikan adalah palindrome | C ++ pelaksanaan pendekatan; Fungsi yang mengembalikan benar jika NUM adalah palindrome; Tukar nombor titik terapung yang diberikan ke dalam rentetan; Penunjuk menunjuk kepada watak pertama dan terakhir rentetan; Bukan palindrome; Mengemas kini petunjuk; Kod pemacu"}
{"text": "Maximum number of times str1 appears as a non | C ++ implementation of the approach ; Function to return the maximum number of times str1 can appear as a non - overlapping substring in str2 ; str1 cannot never be substring of str2 ; Store the frequency of the characters of str1 ; Store the frequency of the characters of str2 ; To store the required count of substrings ; Current character doesn 't appear in str1 ; Frequency of the current character in str1 is greater than its frequency in str2 ; Update the count of possible substrings ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 26 ; int maxSubStr ( string str1 , int len1 , string str2 , int len2 ) { if ( len1 > len2 ) return 0 ; int freq1 [ MAX ] = { 0 } ; for ( int i = 0 ; i < len1 ; i ++ ) freq1 [ str1 [ i ] - ' a ' ] ++ ; int freq2 [ MAX ] = { 0 } ; for ( int i = 0 ; i < len2 ; i ++ ) freq2 [ str2 [ i ] - ' a ' ] ++ ; int minPoss = INT_MAX ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( freq1 [ i ] == 0 ) continue ; if ( freq1 [ i ] > freq2 [ i ] ) return 0 ; minPoss = min ( minPoss , freq2 [ i ] / freq1 [ i ] ) ; } return minPoss ; } int main ( ) { string str1 = \" geeks \" , str2 = \" gskefrgoekees \" ; int len1 = str1 . length ( ) ; int len2 = str2 . length ( ) ; cout << maxSubStr ( str1 , len1 , str2 , len2 ) ; return 0 ; }", "text_ms": "Bilangan maksimum kali str1 muncul sebagai bukan | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan bilangan maksimum kali STR1 boleh muncul sebagai substring yang tidak bertindih dalam STR2; STR1 tidak boleh menjadi substring str2; Simpan kekerapan watak Str1; Simpan kekerapan watak Str2; Untuk menyimpan kiraan substring yang diperlukan; Watak semasa tidak muncul dalam str1; Kekerapan watak semasa dalam Str1 adalah lebih besar daripada kekerapannya dalam Str2; Mengemas kini kiraan substrings yang mungkin; Kod pemacu"}
{"text": "Number of ways to insert two pairs of parentheses into a string of N characters | C ++ implementation of the approach ; Function to return the number of ways to insert the bracket pairs ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntWays ( string str , int n ) { int x = n + 1 ; int ways = x * x * ( x * x - 1 ) / 12 ; return ways ; } int main ( ) { string str = \" ab \" ; int n = str . length ( ) ; cout << cntWays ( str , n ) ; return 0 ; }", "text_ms": "Bilangan cara untuk memasukkan dua pasang kurungan ke dalam rentetan aksara n | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan bilangan cara untuk memasukkan pasangan kurungan; Kod pemacu"}
{"text": "Minimum number of substrings the given string can be splitted into that satisfy the given conditions | C ++ implementation of the approach ; Set to store all the strings from the given array ; To store the required count ; Recursive function to find the count of substrings that can be splitted starting from the index start such that all the substrings are present in the map ; All the chosen substrings are present in the map ; Update the minimum count of substrings ; Starting from the substrings of length 1 that start with the given index ; Get the substring ; If the substring is present in the set ; Recursive call for the rest of the string ; Function that inserts all the strings from the given array in a set and calls the recursive function to find the minimum count of substrings str can be splitted into that satisfy the given condition ; Insert all the strings from the given array in a set ; Find the required count ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; unordered_set < string > uSet ; int minCnt = INT_MAX ; void findSubStr ( string str , int cnt , int start ) { if ( start == str . length ( ) ) { minCnt = min ( cnt , minCnt ) ; } for ( int len = 1 ; len <= ( str . length ( ) - start ) ; len ++ ) { string subStr = str . substr ( start , len ) ; if ( uSet . find ( subStr ) != uSet . end ( ) ) { findSubStr ( str , cnt + 1 , start + len ) ; } } } void findMinSubStr ( string arr [ ] , int n , string str ) { for ( int i = 0 ; i < n ; i ++ ) uSet . insert ( arr [ i ] ) ; findSubStr ( str , 0 , 0 ) ; } int main ( ) { string str = \"123456\" ; string arr [ ] = { \"1\" , \"12345\" , \"2345\" , \"56\" , \"23\" , \"456\" } ; int n = sizeof ( arr ) / sizeof ( string ) ; findMinSubStr ( arr , n , str ) ; cout << minCnt ; return 0 ; }", "text_ms": "Bilangan minimum substrings rentetan yang diberikan boleh dibuang ke dalam yang memenuhi syarat -syarat yang diberikan | C ++ pelaksanaan pendekatan; Tetapkan untuk menyimpan semua rentetan dari array yang diberikan; Untuk menyimpan kiraan yang diperlukan; Fungsi rekursif untuk mencari kiraan substrings yang boleh dibahagikan bermula dari indeks permulaan supaya semua substrings hadir dalam peta; Semua substring yang dipilih hadir dalam peta; Mengemas kini kiraan minimum substring; Bermula dari substrings panjang 1 yang bermula dengan indeks yang diberikan; Dapatkan substring; Jika substring hadir dalam set; Panggilan rekursif untuk sisa rentetan; Fungsi yang memasukkan semua rentetan dari array yang diberikan dalam satu set dan memanggil fungsi rekursif untuk mencari kiraan minimum substrings STR boleh dibuang ke dalam yang memenuhi syarat yang diberikan; Masukkan semua rentetan dari array yang diberikan dalam satu set; Cari kiraan yang diperlukan; Kod pemacu"}
{"text": "Number of substrings that start with \" geeks \" and end with \" for \" | C ++ implementation of the approach ; Function to return the count of required substrings ; For every index of the string ; If the substring starting at the current index is \" geeks \" ; If the substring is \" for \" ; Driver code", "code": "#include <iostream> NEW_LINE using namespace std ; int countSubStr ( string s , int n ) { int c1 = 0 , c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . substr ( i , 5 ) == \" geeks \" ) c1 ++ ; if ( s . substr ( i , 3 ) == \" for \" ) c2 = c2 + c1 ; } return c2 ; } int main ( ) { string s = \" geeksforgeeksisforgeeks \" ; int n = s . size ( ) ; cout << countSubStr ( s , n ) ; return 0 ; }", "text_ms": "Bilangan substring yang bermula dengan \"geeks\" dan berakhir dengan \"untuk\" | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan kiraan substring yang diperlukan; Untuk setiap indeks rentetan; Jika substring bermula pada indeks semasa adalah \"geeks\"; Jika substring adalah \"untuk\"; Kod pemacu"}
{"text": "InfyTQ 2019 : Find the position from where the parenthesis is not balanced | C ++ implementation of the approach ; Defining the string ; Storing opening braces in list lst1 ; Storing closing braces in list lst2 ; Creating an empty list lst ; Creating dictionary to map closing braces to opening ones ; If first position of string contain any closing braces return 1 ; If characters of string are opening braces then append them in a list ; When size of list is 0 and new closing braces is encountered then print its index starting from 1 ; As we encounter closing braces we map them with theircorresponding opening braces using dictionary and check if it is same as last opened braces ( last element in list ) if yes then we delete that element from list ; Otherwise we return the index ( starting from 1 ) at which nesting is found wrong ; At end if the list is empty it means the string is perfectly nested", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int main ( ) { string String = \" { [ ( ) ] } [ ] \" ; vector < char > lst1 = { ' { ' , ' ( ' , ' [ ' } ; vector < char > lst2 = { ' } ' , ' ) ' , ' ] ' } ; vector < char > lst ; int k ; map < char , char > Dict ; Dict . insert ( pair < int , int > ( ' ) ' , ' ( ' ) ) ; Dict . insert ( pair < int , int > ( ' } ' , ' { ' ) ) ; Dict . insert ( pair < int , int > ( ' ] ' , ' [ ' ) ) ; int a = 0 , b = 0 , c = 0 ; if ( count ( lst2 . begin ( ) , lst2 . end ( ) , String [ 0 ] ) ) { cout << 1 << endl ; } else { for ( int i = 0 ; i < String . size ( ) ; i ++ ) { if ( count ( lst1 . begin ( ) , lst1 . end ( ) , String [ i ] ) ) { lst . push_back ( String [ i ] ) ; k = i + 2 ; } else { if ( lst . size ( ) == 0 && ( count ( lst2 . begin ( ) , lst2 . end ( ) , String [ i ] ) ) ) { cout << ( i + 1 ) << endl ; c = 1 ; break ; } else { if ( Dict [ String [ i ] ] == lst [ lst . size ( ) - 1 ] ) { lst . pop_back ( ) ; } else { break ; cout << ( i + 1 ) << endl ; a = 1 ; } } } } if ( lst . size ( ) == 0 && c == 0 ) { cout << 0 << endl ; b = 1 ; } if ( a == 0 && b == 0 && c == 0 ) { cout << k << endl ; } } return 0 ; }", "text_ms": "Infytq 2019: Cari kedudukan dari mana kurungan tidak seimbang | C ++ pelaksanaan pendekatan; Menentukan rentetan; Menyimpan pendakap pembukaan dalam senarai LST1; Menyimpan pendakap penutup dalam senarai LST2; Mewujudkan senarai kosong LST; Mewujudkan kamus untuk memetakan pendakap penutup untuk membuka; Jika kedudukan pertama rentetan mengandungi sebarang pendakap penutup kembali 1; Jika watak -watak rentetan membuka pendakap maka masukkannya ke dalam senarai; Apabila saiz senarai adalah 0 dan pendakap penutup baru ditemui kemudian cetak indeksnya bermula dari 1; Ketika kami menemui pendakap penutup, kami memetakan mereka dengan pendakap pembukaan yang sesuai dengan menggunakan kamus dan periksa sama ada ia sama dengan pendakap yang dibuka terakhir (elemen terakhir dalam senarai) jika ya maka kami memadamkan elemen itu dari senarai; Jika tidak, kami mengembalikan indeks (bermula dari 1) di mana bersarang didapati salah; Pada akhir jika senarai kosong itu bermaksud rentetan bersarang dengan sempurna"}
{"text": "Encrypt the given string with the following operations | C ++ implementation of the above approach : ; Function to return the encrypted string ; Reduce x because rotation of length 26 is unnecessary ; Calculate the frequency of characters ; If the frequency of current character is even then increment it by x ; Else decrement it by x ; Return the count ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE #define MAX  26 NEW_LINE using namespace std ; string encryptStr ( string str , int n , int x ) { x = x % MAX ; int freq [ MAX ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { freq [ str [ i ] - ' a ' ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str [ i ] - ' a ' ] % 2 == 0 ) { int pos = ( str [ i ] - ' a ' + x ) % MAX ; str [ i ] = ( char ) ( pos + ' a ' ) ; } else { int pos = ( str [ i ] - ' a ' - x ) ; if ( pos < 0 ) { pos += MAX ; } str [ i ] = ( char ) ( pos + ' a ' ) ; } } return str ; } int main ( ) { string s = \" abcda \" ; int n = s . size ( ) ; int x = 3 ; cout << encryptStr ( s , n , x ) << endl ; return 0 ; }", "text_ms": "Menyulitkan rentetan yang diberikan dengan operasi berikut | C ++ pelaksanaan pendekatan di atas :; Berfungsi untuk mengembalikan rentetan yang disulitkan; Kurangkan x kerana putaran panjang 26 tidak perlu; Kirakan kekerapan aksara; Jika kekerapan aksara arus bahkan maka kenaikannya dengan x; Lain menurunkannya dengan x; Mengembalikan kiraan; Kod pemacu"}
{"text": "Rearrange characters in a string such that no two adjacent are same using hashing | C ++ implementation of the approach ; Function that returns true if it is possible to rearrange the characters of the string such that no two consecutive characters are same ; To store the frequency of each of the character ; To store the maximum frequency so far ; If possible ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE #include <time.h> NEW_LINE using namespace std ; int isPossible ( string str ) { unordered_map < char , int > freq ; int max_freq = 0 ; for ( int j = 0 ; j < ( str . length ( ) ) ; j ++ ) { freq [ str [ j ] ] ++ ; if ( freq [ str [ j ] ] > max_freq ) max_freq = freq [ str [ j ] ] ; } if ( max_freq <= ( str . length ( ) - max_freq + 1 ) ) return true ; return false ; } int main ( ) { string str = \" geeksforgeeks \" ; if ( isPossible ( str ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "text_ms": "Susun semula aksara dalam rentetan supaya tidak ada dua bersebelahan dengan menggunakan hashing | C ++ pelaksanaan pendekatan; Fungsi yang mengembalikan benar jika mungkin untuk menyusun semula watak -watak rentetan supaya tidak dua aksara berturut -turut adalah sama; Untuk menyimpan kekerapan setiap watak; Untuk menyimpan kekerapan maksimum setakat ini; Jika boleh; Kod pemacu"}
{"text": "Find uncommon characters of the two strings | Set 2 | C ++ implementation of the approach ; Function to print the uncommon characters in the given string in sorted order ; Converting character to ASCII code ; Bit operation ; Converting character to ASCII code ; Bit operation ; XOR operation leaves only uncommon characters in the ans variable ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printUncommon ( string str1 , string str2 ) { int a1 = 0 , a2 = 0 ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { int ch = int ( str1 [ i ] ) - ' a ' ; a1 = a1 | ( 1 << ch ) ; } for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) { int ch = int ( str2 [ i ] ) - ' a ' ; a2 = a2 | ( 1 << ch ) ; } int ans = a1 ^ a2 ; int i = 0 ; while ( i < 26 ) { if ( ans % 2 == 1 ) { cout << char ( ' a ' + i ) ; } ans = ans / 2 ; i ++ ; } } int main ( ) { string str1 = \" geeksforgeeks \" ; string str2 = \" geeksquiz \" ; printUncommon ( str1 , str2 ) ; return 0 ; }", "text_ms": "Cari watak yang tidak biasa dari dua rentetan | Tetapkan 2 | C ++ pelaksanaan pendekatan; Berfungsi untuk mencetak aksara yang tidak biasa dalam rentetan yang diberikan dalam urutan yang disusun; Menukar watak ke kod ASCII; Operasi bit; Menukar watak ke kod ASCII; Operasi bit; Operasi XOR hanya meninggalkan watak -watak yang tidak biasa dalam pembolehubah ANS; Kod pemacu"}
{"text": "Minimum number of bracket reversals needed to make an expression balanced | Set | C ++ program to find minimum number of reversals required to balance an expression ; Returns count of minimum reversals for making expr balanced . Returns - 1 if expr cannot be balanced . ; length of expression must be even to make it balanced by using reversals . ; To store number of reversals required . ; To store number of unbalanced opening brackets . ; To store number of unbalanced closing brackets . ; If current bracket is open then increment open count . ; If current bracket is close , check if it balances opening bracket . If yes then decrement count of unbalanced opening bracket else increment count of closing bracket . ; For the case : \" } { \" or when one closing and one opening bracket remains for pairing , then both need to be reversed . ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countMinReversals ( string expr ) { int len = expr . length ( ) ; if ( len % 2 ) return -1 ; int ans = 0 ; int i ; int open = 0 ; int close = 0 ; for ( i = 0 ; i < len ; i ++ ) { if ( expr [ i ] == ' { ' ) open ++ ; else { if ( ! open ) close ++ ; else open -- ; } } ans = ( close / 2 ) + ( open / 2 ) ; close %= 2 ; open %= 2 ; if ( close ) ans += 2 ; return ans ; } int main ( ) { string expr = \" } } { { \" ; cout << countMinReversals ( expr ) ; return 0 ; }", "text_ms": "Bilangan minimum pembalikan kurungan yang diperlukan untuk membuat ekspresi seimbang | Set | Program C ++ untuk mencari bilangan minimum pembalikan yang diperlukan untuk mengimbangi ungkapan; Mengembalikan kiraan pembalikan minimum untuk membuat expr seimbang. Pulangan - 1 Jika expr tidak boleh seimbang. ; Panjang ekspresi mestilah menjadikannya seimbang dengan menggunakan pembalikan. ; Untuk menyimpan bilangan pembalikan yang diperlukan. ; Untuk menyimpan nombor pendakap pembukaan yang tidak seimbang. ; Untuk menyimpan nombor kurungan penutupan yang tidak seimbang. ; Jika pendakap semasa dibuka maka kenaikan kiraan terbuka. ; Jika pendakap semasa dekat, periksa sama ada mengimbangi pendakap pembukaan. Jika ya maka pengurangan kiraan pendakap pembukaan yang tidak seimbang, lain -lain kenaikan kiraan pendakap penutupan. ; Untuk kes itu: \"} {\" Atau apabila satu penutupan dan satu pendakap pembukaan kekal untuk berpasangan, maka kedua -duanya perlu diterbalikkan. ; Kod pemacu"}
{"text": "Character pairs from two strings with even sum | C ++ implementation of the approach ; Function to return the total number of valid pairs ; Count total number of even and odd ascii values for string s1 ; Count total number of even and odd ascii values for string s2 ; Return total valid pairs ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int totalPairs ( string s1 , string s2 ) { int a1 = 0 , b1 = 0 ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { if ( int ( s1 [ i ] ) % 2 != 0 ) a1 ++ ; else b1 ++ ; } int a2 = 0 , b2 = 0 ; for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { if ( int ( s2 [ i ] ) % 2 != 0 ) a2 ++ ; else b2 ++ ; } return ( ( a1 * a2 ) + ( b1 * b2 ) ) ; } int main ( ) { string s1 = \" geeks \" , s2 = \" for \" ; cout << totalPairs ( s1 , s2 ) ; return 0 ; }", "text_ms": "Pasangan watak dari dua rentetan dengan jumlah keseluruhan | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan jumlah pasangan yang sah; Kira jumlah nilai ASCII yang lebih baik dan ganjil untuk String S1; Kira jumlah nilai ASCII yang lebih baik dan ganjil untuk String S2; Mengembalikan jumlah pasangan yang sah; Kod pemacu"}
{"text": "Maximum occurrence of prefix in the Array | CPP program to find the number of occurrences of prefix which occurs maximum no . of time ; Function to return the count of the required prefix ; Find the frequency of first character of string ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int prefixOccurrences ( string str ) { char c = str [ 0 ] ; int countc = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == c ) countc ++ ; } return countc ; } int main ( ) { string str = \" abbcdabbcd \" ; cout << prefixOccurrences ( str ) ; return 0 ; }", "text_ms": "Kejadian maksimum awalan dalam array | Program CPP untuk mencari bilangan kejadian awalan yang berlaku maksimum no. masa; Berfungsi untuk mengembalikan kiraan awalan yang diperlukan; Cari kekerapan watak pertama rentetan; Kod pemacu"}
{"text": "Minimum number of given operations required to convert a string to another string | C ++ implementation of the approach ; Function to return the minimum operations of the given type required to convert string s to string t ; Characters are already equal ; Increment count of 0 s ; Increment count of 1 s ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( string s , string t , int n ) { int ct0 = 0 , ct1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == t [ i ] ) continue ; if ( s [ i ] == '0' ) ct0 ++ ; else ct1 ++ ; } return max ( ct0 , ct1 ) ; } int main ( ) { string s = \"010\" , t = \"101\" ; int n = s . length ( ) ; cout << minOperations ( s , t , n ) ; return 0 ; }", "text_ms": "Bilangan minimum operasi yang diberikan diperlukan untuk menukar rentetan ke rentetan lain | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan operasi minimum jenis yang diberikan untuk menukar rentetan s ke rentetan t; Watak sudah sama; Kiraan kenaikan 0 s; Kiraan kenaikan 1 s; Kod pemacu"}
{"text": "Decrypt a string encrypted by repeating i | C ++ implementation of the approach ; Function to return the decrypted string ; Initial jump will be 1 ; Increment jump by 1 with every character ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string decryptString ( string str , int n ) { int i = 0 , jump = 1 ; string decryptedStr = \" \" ; while ( i < n ) { decryptedStr += str [ i ] ; i += jump ; jump ++ ; } return decryptedStr ; } int main ( ) { string str = \" geeeeekkkksssss \" ; int n = str . length ( ) ; cout << decryptString ( str , n ) ; return 0 ; }", "text_ms": "Dekripsi rentetan yang disulitkan dengan mengulangi i | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan rentetan yang disahsulit; Lompat awal akan menjadi 1; Lompat kenaikan sebanyak 1 dengan setiap watak; Kod pemacu"}
{"text": "Find Bit whose minimum sequence flips makes all bits same | C ++ program to find which bit sequence to be flipped ; Function to check which bit is to be flipped ; variable to store first and last character of string ; Check if first and last characters are equal , if yes , then return the character which is not at last ; else return last ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; char bitToBeFlipped ( string s ) { char last = s [ s . length ( ) - 1 ] ; char first = s [ 0 ] ; if ( last == first ) { if ( last == '0' ) { return '1' ; } else { return '0' ; } } else if ( last != first ) { return last ; } } int main ( ) { string s = \"1101011000\" ; cout << bitToBeFlipped ( s ) << endl ; return 0 ; }", "text_ms": "Cari bit yang flip urutan minimum menjadikan semua bit sama | Program C ++ untuk mencari urutan bit mana yang akan dibalik; Fungsi untuk memeriksa bit mana yang akan dibalik; pembolehubah untuk menyimpan watak pertama dan terakhir rentetan; Semak sama ada aksara pertama dan terakhir adalah sama, jika ya, kemudian kembalikan watak yang tidak akhirnya; lain kembali terakhir; Kod pemacu"}
{"text": "Sum and Product of Prime Frequencies of Characters in a String | C ++ program to find Sum and product of Prime Frequencies of Characters in a String ; Function to create Sieve to check primes ; false here indicates that it is not prime ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p , set them to non - prime ; Function to find the sum of prime frequencies of the characters of the given string ; map is used to store character frequencies ; Traverse the map ; If the frequency is prime ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void SieveOfEratosthenes ( bool prime [ ] , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } } void sumProdOfPrimeFreq ( string s ) { bool prime [ s . length ( ) + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; SieveOfEratosthenes ( prime , s . length ( ) + 1 ) ; int i , j ; unordered_map < char , int > m ; for ( i = 0 ; i < s . length ( ) ; i ++ ) m [ s [ i ] ] ++ ; int sum = 0 , product = 1 ; for ( auto it = m . begin ( ) ; it != m . end ( ) ; it ++ ) { if ( prime [ it -> second ] ) { sum += it -> second ; product *= it -> second ; } } cout << \" Sum ▁ = ▁ \" << sum ; cout << \" Product = \" } int main ( ) { string s = \" geeksforgeeks \" ; sumProdOfPrimeFreq ( s ) ; return 0 ; }", "text_ms": "Jumlah dan produk frekuensi utama aksara dalam rentetan | Program C ++ untuk mencari jumlah dan produk frekuensi utama aksara dalam rentetan; Berfungsi untuk membuat ayak untuk memeriksa prima; Palsu di sini menunjukkan bahawa ia bukan perdana; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P, tetapkannya kepada bukan perdana; Berfungsi untuk mencari jumlah frekuensi utama watak -watak rentetan yang diberikan; Peta digunakan untuk menyimpan frekuensi watak; Melintasi peta; Jika kekerapan adalah perdana; Kod pemacu"}
{"text": "Check if frequency of character in one string is a factor or multiple of frequency of same character in other string | C ++ implementation of above approach ; Function that checks if the frequency of character are a factor or multiple of each other ; map store frequency of each character ; if any frequency is 0 , then continue as condition is satisfied ; if factor or multiple , then condition satisfied ; if condition not satisfied ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool multipleOrFactor ( string s1 , string s2 ) { map < char , int > m1 , m2 ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) m1 [ s1 [ i ] ] ++ ; for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) m2 [ s2 [ i ] ] ++ ; map < char , int > :: iterator it ; for ( it = m1 . begin ( ) ; it != m1 . end ( ) ; it ++ ) { if ( m2 . find ( ( * it ) . first ) == m2 . end ( ) ) continue ; if ( m2 [ ( * it ) . first ] % ( * it ) . second == 0 || ( * it ) . second % m2 [ ( * it ) . first ] == 0 ) continue ; else return false ; } } int main ( ) { string s1 = \" geeksforgeeks \" ; string s2 = \" geeks \" ; multipleOrFactor ( s1 , s2 ) ? cout << \" YES \" : cout << \" NO \" ; return 0 ; }", "text_ms": "Semak jika kekerapan aksara dalam satu rentetan adalah faktor atau pelbagai kekerapan watak yang sama dalam rentetan lain | C ++ pelaksanaan pendekatan di atas; Fungsi yang memeriksa jika kekerapan watak adalah faktor atau pelbagai antara satu sama lain; kekerapan kedai peta setiap aksara; Jika sebarang kekerapan adalah 0, maka teruskan sebagai keadaan berpuas hati; jika faktor atau berganda, maka keadaan berpuas hati; jika keadaan tidak berpuas hati; Kod pemacu"}
{"text": "Remove even frequency characters from the string | C ++ implementation of the approach ; Function that removes the characters which have even frequencies in the string ; create a map to store the frequency of each character ; to store the new string ; remove the characters which have even frequencies ; if the character has even frequency then skip ; else concatenate the character to the new string ; display the modified string ; Driver code ; remove the characters which have even frequencies", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void solve ( string s ) { unordered_map < char , int > m ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { m [ s [ i ] ] ++ ; } string new_string = \" \" ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( m [ s [ i ] ] % 2 == 0 ) continue ; new_string += s [ i ] ; } cout << new_string << endl ; } int main ( ) { string s = \" aabbbddeeecc \" ; solve ( s ) ; return 0 ; }", "text_ms": "Keluarkan walaupun aksara frekuensi dari rentetan | C ++ pelaksanaan pendekatan; Fungsi yang menghilangkan aksara yang mempunyai frekuensi dalam rentetan; Buat peta untuk menyimpan kekerapan setiap watak; untuk menyimpan rentetan baru; Keluarkan watak -watak yang mempunyai frekuensi; Jika watak mempunyai kekerapan, maka langkau; lain menggabungkan watak ke rentetan baru; Paparkan rentetan yang diubah suai; Kod pemacu; Keluarkan watak yang mempunyai frekuensi bahkan"}
{"text": "Remove all the palindromic words from the given sentence | C ++ implementation to remove all the palindromic words from the given sentence ; function to check if ' str ' is palindrome ; traversing from both the ends ; not palindrome ; palindrome ; function to remove all the palindromic words from the given sentence ; ' final _ str ' to store the final string and ' word ' to one by one store each word of ' str ' ; add space at the end of ' str ' ; traversing ' str ' ; accumulating characters of the current word ; if ' word ' is not palindrome then a add it to ' final _ str ' ; reset ; required final string ; Driver program to test above", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalindrome ( string str ) { int i = 0 , j = str . size ( ) - 1 ; while ( i < j ) if ( str [ i ++ ] != str [ j -- ] ) return false ; return true ; } string removePalinWords ( string str ) { string final_str = \" \" , word = \" \" ; str = str + \" ▁ \" ; int n = str . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] != ' ▁ ' ) word = word + str [ i ] ; else { if ( ! ( isPalindrome ( word ) ) ) final_str += word + \" ▁ \" ; word = \" \" ; } } return final_str ; } int main ( ) { string str = \" Text ▁ contains ▁ malayalam ▁ and ▁ level ▁ words \" ; cout << removePalinWords ( str ) ; return 0 ; }", "text_ms": "Keluarkan semua perkataan palindromik dari ayat yang diberikan | C ++ pelaksanaan untuk menghapuskan semua perkataan palindromik dari ayat yang diberikan; fungsi untuk memeriksa sama ada 'str' adalah palindrome; melintasi kedua -dua hujungnya; bukan palindrome; palindrome; berfungsi untuk menghapuskan semua perkataan palindromik dari ayat yang diberikan; 'akhir _ str' untuk menyimpan rentetan akhir dan 'kata' kepada satu demi satu kedai setiap perkataan 'str'; Tambah ruang pada akhir 'str'; melintasi 'str'; mengumpul watak -watak perkataan semasa; jika 'perkataan' bukan palindrome maka tambahnya ke 'akhir _ str'; menetapkan semula; rentetan akhir yang diperlukan; Program Pemandu untuk diuji di atas"}
{"text": "Sum of all subsequences of a number | CPP program to find the sum of elements present in all subsequences ; Returns numeric value of a subsequence of s . The subsequence to be picked is decided using bit pattern of num ( We pick all thosedigits for which there is a set bit in num ) ; Initialize the result ; till n != 0 ; if i - th bit is set then add this number ; right shift i ; function to find combined sum of all individual subsequence sum ; length of string ; stores the combined ; 2 ^ n - 1 subsequences ; loop for all subsequences ; returns the combined sum ; driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSubSequence ( string s , int num ) { int res = 0 ; int i = 0 ; while ( num ) { if ( num & 1 ) res += s [ i ] - '0' ; i ++ ; num = num >> 1 ; } return res ; } int combinedSum ( string s ) { int n = s . length ( ) ; int c_sum = 0 ; int range = ( 1 << n ) - 1 ; for ( int i = 0 ; i <= range ; i ++ ) c_sum += findSubSequence ( s , i ) ; return c_sum ; } int main ( ) { string s = \"123\" ; cout << combinedSum ( s ) ; return 0 ; }", "text_ms": "Jumlah semua berikutnya nombor | Program CPP untuk mencari jumlah elemen yang terdapat dalam semua berikutnya; Mengembalikan nilai angka berikutnya S. Berikutnya yang akan dipilih diputuskan menggunakan corak bit num (kami memilih semua thedigits yang mana terdapat set bit dalam NUM); Memulakan hasilnya; sehingga n! = 0; Jika saya - bit ditetapkan maka tambahkan nombor ini; Peralihan kanan i; fungsi untuk mencari jumlah gabungan semua jumlah keseluruhan individu; panjang rentetan; menyimpan gabungan; 2 ^ n - 1 berikutnya; gelung untuk semua berikutnya; mengembalikan jumlah gabungan; kod pemacu"}
{"text": "Longest subsequence where each character occurs at least k times | CPP Program to find the subsequence with each character occurring at least k times in string s ; Function to find the subsequence ; Taking an extra array to keep record for character count in s ; Counting occurrences of all characters in str [ ] ; Printing characters with count >= k in same order as they appear in str . ; Driver code", "code": "#include <iostream> NEW_LINE using namespace std ; #define MAX_CHAR  26 NEW_LINE void findSubsequence ( string str , int k ) { int a [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) a [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < l ; i ++ ) if ( a [ str [ i ] - ' a ' ] >= k ) cout << str [ i ] ; } int main ( ) { int k = 2 ; findSubsequence ( \" geeksforgeeks \" , k ) ; return 0 ; }", "text_ms": "Susunan terpanjang di mana setiap watak berlaku sekurang -kurangnya k kali | Program CPP untuk mencari seterusnya dengan setiap watak yang berlaku sekurang -kurangnya k kali dalam rentetan s; Berfungsi untuk mencari berikutnya; Mengambil array tambahan untuk menyimpan rekod untuk kiraan watak dalam s; Mengira kejadian semua aksara dalam STR []; Percetakan aksara dengan kiraan> = k dalam susunan yang sama kerana ia muncul dalam str. ; Kod pemacu"}
{"text": "gOOGLE cASE of a given sentence | C ++ program to convert a sentence to gOOGLE cASE . ; Empty strings ; Convert input string to upper case ; Check if character is not a space and adding it to string w ; Converting first character to lower case and subsequent initial letter of another word to lower case ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string convert ( string str ) { string w = \" \" , z = \" \" ; transform ( str . begin ( ) , str . end ( ) , str . begin ( ) , :: toupper ) ; str += \" ▁ \" ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str [ i ] ; if ( ch != ' ▁ ' ) { w = w + ch ; } else { z = z + char ( tolower ( w [ 0 ] ) ) + w . substr ( 1 ) + \" ▁ \" ; w = \" \" ; } } return z ; } int main ( ) { string str = \" I ▁ got ▁ intern ▁ at ▁ geeksforgeeks \" ; cout << convert ( str ) << endl ; return 0 ; }", "text_ms": "Google Case Of A Sentyen tertentu | Program C ++ untuk menukar ayat ke Google Case. ; Rentetan kosong; Tukar rentetan input ke atas kes; Semak sama ada watak bukan ruang dan menambahkannya ke rentetan w; Menukar watak pertama ke kes yang lebih rendah dan huruf awal berikutnya perkataan lain kepada kes yang lebih rendah; Kod pemacu"}
{"text": "Encrypt string with product of number of vowels and consonants in substring of size k | CPP Program to Encrypt string with product of number of vowels and consonants in substring of size k ; isVowel ( ) is a function that returns true for a vowel and false otherwise . ; function to Encrypt the string ; cv to count vowel cc to count consonants ; Counting prefix count of vowel and prefix count of consonants ; generating the encrypted string . ; Driven Program", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isVowel ( char c ) { return ( c == ' a ' c == ' e ' c == ' i ' c == ' o ' c == ' u ' ) ; } string encryptString ( string s , int n , int k ) { int cv [ n ] , cc [ n ] ; if ( isVowel ( s [ 0 ] ) ) cv [ 0 ] = 1 ; else cc [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { cv [ i ] = cv [ i - 1 ] + isVowel ( s [ i ] ) ; cc [ i ] = cc [ i - 1 ] + ! isVowel ( s [ i ] ) ; } string ans = \" \" ; int prod = 0 ; prod = cc [ k - 1 ] * cv [ k - 1 ] ; ans += to_string ( prod ) ; for ( int i = k ; i < s . length ( ) ; i ++ ) { prod = ( cc [ i ] - cc [ i - k ] ) * ( cv [ i ] - cv [ i - k ] ) ; ans += to_string ( prod ) ; } return ans ; } int main ( ) { string s = \" hello \" ; int n = s . length ( ) ; int k = 2 ; cout << encryptString ( s , n , k ) << endl ; return 0 ; }", "text_ms": "Menyulitkan rentetan dengan produk bilangan vokal dan konsonan dalam substring saiz k | Program CPP untuk menyulitkan rentetan dengan produk bilangan vokal dan konsonan dalam substring saiz K; isvowel () adalah fungsi yang kembali benar untuk vokal dan sebaliknya. ; berfungsi untuk menyulitkan rentetan; CV untuk mengira vokal CC untuk mengira konsonan; Mengira awalan kiraan vokal dan awalan kiraan konsonan; Menjana rentetan yang disulitkan. ; Program yang didorong"}
{"text": "Count occurrences of a word in string | C ++ program to count the number of occurrence of a word in the given string ; split the string by spaces in a ; search for pattern in a ; if match found increase count ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countOccurrences ( char * str , string word ) { char * p ; vector < string > a ; p = strtok ( str , \" ▁ \" ) ; while ( p != NULL ) { a . push_back ( p ) ; p = strtok ( NULL , \" ▁ \" ) ; } int c = 0 ; for ( int i = 0 ; i < a . size ( ) ; i ++ ) if ( word == a [ i ] ) c ++ ; return c ; } int main ( ) { char str [ ] = \" GeeksforGeeks ▁ A ▁ computer ▁ science ▁ portal ▁ for ▁ geeks ▁ \" ; string word = \" portal \" ; cout << countOccurrences ( str , word ) ; return 0 ; }", "text_ms": "Kira kejadian perkataan dalam rentetan | Program C ++ untuk mengira bilangan berlakunya perkataan dalam rentetan yang diberikan; berpecah rentetan dengan ruang dalam A; Cari corak dalam A; jika perlawanan mendapati kenaikan kiraan; Kod pemacu"}
{"text": "Permute a string by changing case | CPP code to print all permutations with respect to cases ; Function to generate permutations ; Number of permutations is 2 ^ n ; Converting string to lower case ; Using all subsequences and permuting them ; If j - th bit is set , we convert it to upper case ; Printing current combination ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void permute ( string input ) { int n = input . length ( ) ; int max = 1 << n ; transform ( input . begin ( ) , input . end ( ) , input . begin ( ) , :: tolower ) ; for ( int i = 0 ; i < max ; i ++ ) { string combination = input ; for ( int j = 0 ; j < n ; j ++ ) if ( ( ( i >> j ) & 1 ) == 1 ) combination [ j ] = toupper ( input . at ( j ) ) ; cout << combination << \" ▁ \" ; } } int main ( ) { permute ( \" ABC \" ) ; return 0 ; }", "text_ms": "Tinggalkan rentetan dengan menukar kes | Kod CPP untuk mencetak semua permutasi berkenaan dengan kes; Berfungsi untuk menjana permutasi; Bilangan permutasi adalah 2 ^ n; Menukar rentetan ke kes yang lebih rendah; Menggunakan semua berikutnya dan membenarkannya; Jika b - th bit ditetapkan, kami menukarnya ke atas kes; Mencetak gabungan semasa; Kod pemacu"}
{"text": "Print the string after the specified character has occurred given no . of times | C ++ program for above implementation ; Function to print the string ; If given count is 0 print the given string and return ; Start traversing the string ; Increment occ if current char is equal to given character ; Break the loop if given character has been occurred given no . of times ; Print the string after the occurrence of given character given no . of times ; Otherwise string is empty ; Drivers code", "code": "#include <iostream> NEW_LINE using namespace std ; void printString ( string str , char ch , int count ) { int occ = 0 , i ; if ( count == 0 ) { cout << str ; return ; } for ( i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == ch ) occ ++ ; if ( occ == count ) break ; } if ( i < str . length ( ) - 1 ) cout << str . substr ( i + 1 , str . length ( ) - ( i + 1 ) ) ; else cout << \" Empty ▁ string \" ; } int main ( ) { string str = \" geeks ▁ for ▁ geeks \" ; printString ( str , ' e ' , 2 ) ; return 0 ; }", "text_ms": "Cetak rentetan selepas watak yang ditentukan telah berlaku diberi tidak. masa | Program C ++ untuk pelaksanaan di atas; Berfungsi untuk mencetak rentetan; Jika diberi kiraan adalah 0 cetak rentetan yang diberikan dan kembali; Mula melintasi rentetan; Kenaikan OCC jika char semasa adalah sama dengan watak yang diberikan; Pecahkan gelung jika watak yang diberikan telah berlaku tidak diberikan. masa; Cetak rentetan selepas berlakunya watak yang diberikan tidak. masa; Jika tidak, rentetan kosong; Kod pemandu"}
{"text": "Reverse vowels in a given string | C ++ program to reverse order of vowels ; utility function to check for vowel ; Function to reverse order of vowels ; Start two indexes from two corners and move toward each other ; swapping ; Driver function", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isVowel ( char c ) { return ( c == ' a ' c == ' A ' c == ' e ' c == ' E ' c == ' i ' c == ' I ' c == ' o ' c == ' O ' c == ' u ' c == ' U ' ) ; } string reverseVowel ( string str ) { int i = 0 ; int j = str . length ( ) - 1 ; while ( i < j ) { if ( ! isVowel ( str [ i ] ) ) { i ++ ; continue ; } if ( ! isVowel ( str [ j ] ) ) { j -- ; continue ; } swap ( str [ i ] , str [ j ] ) ; i ++ ; j -- ; } return str ; } int main ( ) { string str = \" hello ▁ world \" ; cout << reverseVowel ( str ) ; return 0 ; }", "text_ms": "Vokal terbalik dalam rentetan yang diberikan | Program C ++ untuk membalikkan urutan vokal; fungsi utiliti untuk memeriksa vokal; Berfungsi untuk membalikkan urutan vokal; Mulakan dua indeks dari dua sudut dan bergerak ke arah satu sama lain; bertukar; Fungsi pemacu"}
{"text": "Minimum number of palindromic subsequences to be removed to empty a binary string | C ++ program to count minimum palindromic subsequences to be removed to make an string empty . ; A function to check if a string str is palindrome ; Start from leftmost and rightmost corners of str ; Keep comparing characters while they are same ; Returns count of minimum palindromic subseuqnces to be removed to make string empty ; If string is empty ; If string is palindrome ; If string is not palindrome ; Driver code to test above", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalindrome ( const char * str ) { int l = 0 ; int h = strlen ( str ) - 1 ; while ( h > l ) if ( str [ l ++ ] != str [ h -- ] ) return false ; return true ; } int minRemovals ( const char * str ) { if ( str [ 0 ] == ' ' ) return 0 ; if ( isPalindrome ( str ) ) return 1 ; return 2 ; } int main ( ) { cout << minRemovals ( \"010010\" ) << endl ; cout << minRemovals ( \"0100101\" ) << endl ; return 0 ; }", "text_ms": "Bilangan minimum Palindromic selepas dikeluarkan untuk mengosongkan rentetan binari | Program C ++ untuk mengira seterusnya Palindromic Minimum untuk dikeluarkan untuk membuat rentetan kosong. ; Fungsi untuk memeriksa sama ada string str adalah palindrome; Bermula dari sudut paling kiri dan paling kanan Str; Terus membandingkan watak semasa mereka sama; Mengembalikan kiraan minimum palindromic subseuqnces untuk dikeluarkan untuk membuat rentetan kosong; Jika rentetan kosong; Jika rentetan adalah palindrome; Jika rentetan bukan palindrome; Kod pemacu untuk diuji di atas"}
{"text": "Find the value of XXXX ... . . ( N times ) % M where N is large | C ++ implementation of the approach ; Iterative function to calculate ( x ^ y ) % p in O ( log y ) ; Initialize result ; Update x if it is >= p ; If y is odd , multiply x with result ; y must be even now y = y / 2 ; Function to return XXX ... . . ( N times ) % M ; Return the mod by M of smaller numbers ; Creating a string of N X 's ; Converting the string to int and calculating the modulo ; Checking the parity of N ; Dividing the number into equal half ; Utilizing the formula for even N ; Dividing the number into equal half ; Utilizing the formula for odd N ; Driver code ; Print XXX ... ( N times ) % M", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int power ( int x , unsigned int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; } int findModuloByM ( int X , int N , int M ) { if ( N < 6 ) { string temp ( N , ( char ) ( 48 + X ) ) ; int res = stoi ( temp ) % M ; return res ; } if ( N % 2 == 0 ) { int half = findModuloByM ( X , N / 2 , M ) % M ; int res = ( half * power ( 10 , N / 2 , M ) + half ) % M ; return res ; } else { int half = findModuloByM ( X , N / 2 , M ) % M ; int res = ( half * power ( 10 , N / 2 + 1 , M ) + half * 10 + X ) % M ; return res ; } } int main ( ) { int X = 6 , N = 14 , M = 9 ; cout << findModuloByM ( X , N , M ) ; return 0 ; }", "text_ms": "Cari nilai xxxx .... . (N kali) % m di mana n adalah besar | C ++ pelaksanaan pendekatan; Fungsi iteratif untuk mengira (x ^ y) % p dalam o (log y); Memulakan hasil; Kemas kini x jika ia> = p; Jika y adalah ganjil, kalikan x dengan hasil; y mestilah sekarang y = y / 2; Fungsi untuk mengembalikan xxx .... . (N kali) % m; Mengembalikan mod dengan m nombor yang lebih kecil; Mewujudkan rentetan n x 's; Menukar rentetan ke int dan mengira modulo; Memeriksa pariti n; Membahagikan nombor ke separuh yang sama; Menggunakan formula untuk n; Membahagikan nombor ke separuh yang sama; Menggunakan formula untuk ganjil n; Kod pemacu; Cetak xxx ... (n kali) % m"}
{"text": "Check if two circles intersect such that the third circle passes through their points of intersections and centers | C ++ program for the above approach ; Structure of the circle ; Utility function to check if given circles satisfy required criteria ; Stores the distance between the centres of C1 and C2 ; Stores the status if the given given criteria is satisfied or not ; If C1C2 is less than the sum of the radii of the first 2 circles ; If C3 is the midpoint of the centres at C1 and C2 ; Mark flag true ; Return flag ; Function to check if the given circles satisfy required criteria ; Check for the current combination of circles ; Check for the next combination ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; class circle { public : double x ; double y ; double r ; } ; bool check ( circle C [ ] ) { double C1C2 = sqrt ( ( C [ 1 ] . x - C [ 0 ] . x ) * ( C [ 1 ] . x - C [ 0 ] . x ) + ( C [ 1 ] . y - C [ 0 ] . y ) * ( C [ 1 ] . y - C [ 0 ] . y ) ) ; bool flag = 0 ; if ( C1C2 < ( C [ 0 ] . r + C [ 1 ] . r ) ) { if ( ( C [ 0 ] . x + C [ 1 ] . x ) == 2 * C [ 2 ] . x && ( C [ 0 ] . y + C [ 1 ] . y ) == 2 * C [ 2 ] . y ) { flag = 1 ; } } return flag ; } bool IsFairTriplet ( circle c [ ] ) { bool f = false ; f |= check ( c ) ; for ( int i = 0 ; i < 2 ; i ++ ) { swap ( c [ 0 ] , c [ 2 ] ) ; f |= check ( c ) ; } return f ; } int main ( ) { circle C [ 3 ] ; C [ 0 ] = { 0 , 0 , 8 } ; C [ 1 ] = { 0 , 10 , 6 } ; C [ 2 ] = { 0 , 5 , 5 } ; if ( IsFairTriplet ( C ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "text_ms": "Semak jika dua lingkaran bersilang sedemikian rupa sehingga bulatan ketiga melewati titik -titik persimpangan dan pusat mereka | Program C ++ untuk pendekatan di atas; Struktur bulatan; Fungsi utiliti untuk memeriksa sama ada lingkaran yang diberikan memenuhi kriteria yang diperlukan; Menyimpan jarak antara pusat C1 dan C2; Menyimpan status jika kriteria yang diberikan berpuas hati atau tidak; Jika C1C2 kurang daripada jumlah radii 2 lingkaran pertama; Jika C3 adalah titik tengah pusat di C1 dan C2; Tanda bendera benar; Bendera kembali; Fungsi untuk memeriksa sama ada lingkaran yang diberikan memenuhi kriteria yang diperlukan; Semak kombinasi bulatan semasa; Semak kombinasi seterusnya; Kod pemacu"}
{"text": "Program to find the Eccentricity of a Hyperbola | C ++ program for the above approach ; Function to find the eccentricity of a hyperbola ; Stores the squared ratio of major axis to minor axis ; Increment r by 1 ; Return the square root of r ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; double eccHyperbola ( double A , double B ) { double r = ( double ) B * B / A * A ; r += 1 ; return sqrt ( r ) ; } int main ( ) { double A = 3.0 , B = 2.0 ; cout << eccHyperbola ( A , B ) ; return 0 ; }", "text_ms": "Program untuk mencari eksentrik hyperbola | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari eksentrik hiperbola; Menyimpan nisbah kuadrat paksi utama kepada paksi kecil; Kenaikan r oleh 1; Mengembalikan akar kuadrat R; Kod pemacu"}
{"text": "Calculate area of a cyclic quadrilateral with given side lengths | C ++ program for the above approach ; Function to find the area of cyclic quadrilateral ; Stores the value of half of the perimeter ; Stores area of cyclic quadrilateral ; Return the resultant area ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float calculateArea ( float A , float B , float C , float D ) { float S = ( A + B + C + D ) / 2 ; float area = sqrt ( ( S - A ) * ( S - B ) * ( S - C ) * ( S - D ) ) ; return area ; } int main ( ) { float A = 10 ; float B = 15 ; float C = 20 ; float D = 25 ; cout << calculateArea ( A , B , C , D ) ; return 0 ; }", "text_ms": "Kirakan kawasan kuadrilateral kitaran dengan panjang sampingan yang diberikan | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari kawasan kuadrilateral kitaran; Menyimpan nilai separuh perimeter; Kedai kawasan kuadrilateral kitaran; Mengembalikan kawasan yang dihasilkan; Kod pemacu"}
{"text": "Calculate ratio of area of a triangle inscribed in an Ellipse and the triangle formed by corresponding points on auxiliary circle | C ++ program for the above approach ; Function to calculate ratio of a triangle inscribed in an ellipse to the triangle on the auxiliary circle ; Stores the ratio of the semi - major to semi - minor axes ; Print the ratio ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void triangleArea ( int a , int b ) { double ratio = ( double ) b / a ; cout << ratio ; } int main ( ) { int a = 1 , b = 2 ; triangleArea ( a , b ) ; return 0 ; }", "text_ms": "Kirakan nisbah kawasan segitiga yang tertulis dalam elips dan segitiga yang dibentuk oleh titik yang sama pada bulatan tambahan | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira nisbah segitiga yang tertulis dalam elips ke segitiga pada bulatan tambahan; Menyimpan nisbah separuh besar hingga separuh kapak kecil; Cetak nisbah; Kod pemacu"}
{"text": "Program to find the Excenters of a Triangle | C ++ program for the above approach ; Function to calculate the distance between a pair of points ; Function to calculate the coordinates of the excenters of a triangle ; Length of the sides of the triangle ; Stores the coordinates of the excenters of the triangle ; For I1 ; For I2 ; For I3 ; Print the excenters of the triangle ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float distance ( int m , int n , int p , int q ) { return sqrt ( pow ( n - m , 2 ) + pow ( q - p , 2 ) * 1.0 ) ; } void Excenters ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { float a = distance ( x2 , x3 , y2 , y3 ) ; float b = distance ( x3 , x1 , y3 , y1 ) ; float c = distance ( x1 , x2 , y1 , y2 ) ; vector < pair < float , float > > excenter ( 4 ) ; excenter [ 1 ] . first = ( - ( a * x1 ) + ( b * x2 ) + ( c * x3 ) ) / ( - a + b + c ) ; excenter [ 1 ] . second = ( - ( a * y1 ) + ( b * y2 ) + ( c * y3 ) ) / ( - a + b + c ) ; excenter [ 2 ] . first = ( ( a * x1 ) - ( b * x2 ) + ( c * x3 ) ) / ( a - b + c ) ; excenter [ 2 ] . second = ( ( a * y1 ) - ( b * y2 ) + ( c * y3 ) ) / ( a - b + c ) ; excenter [ 3 ] . first = ( ( a * x1 ) + ( b * x2 ) - ( c * x3 ) ) / ( a + b - c ) ; excenter [ 3 ] . second = ( ( a * y1 ) + ( b * y2 ) - ( c * y3 ) ) / ( a + b - c ) ; for ( int i = 1 ; i <= 3 ; i ++ ) { cout << excenter [ i ] . first << \" ▁ \" << excenter [ i ] . second << endl ; } } int main ( ) { float x1 , x2 , x3 , y1 , y2 , y3 ; x1 = 0 ; x2 = 3 ; x3 = 0 ; y1 = 0 ; y2 = 0 ; y3 = 4 ; Excenters ( x1 , y1 , x2 , y2 , x3 , y3 ) ; return 0 ; }", "text_ms": "Program untuk mencari excenters segitiga | Program C ++ untuk pendekatan di atas; Berfungsi untuk mengira jarak antara sepasang mata; Fungsi untuk mengira koordinat excenters segitiga; Panjang sisi segitiga; Menyimpan koordinat excenters segitiga; Untuk i1; Untuk i2; Untuk i3; Cetak excenters segitiga; Kod pemacu"}
{"text": "Program to find height of a Trapezoid | C ++ program for the above approach ; Function to calculate height of the trapezoid ; Apply Heron 's formula ; Calculate the area ; Calculate height of trapezoid ; Print the height ; Driver Code ; Given a , b , p1 and p2", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findHeight ( float p1 , float p2 , float b , float c ) { float a = max ( p1 , p2 ) - min ( p1 , p2 ) ; float s = ( a + b + c ) / 2 ; float area = sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ; float height = ( area * 2 ) / a ; cout << \" Height ▁ is : ▁ \" << height ; } int main ( ) { float p1 = 25 , p2 = 10 ; float a = 14 , b = 13 ; findHeight ( p1 , p2 , a , b ) ; return 0 ; }", "text_ms": "Program untuk mencari ketinggian trapezoid | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira ketinggian trapezoid; Memohon formula Heron; Hitung kawasan; Hitung ketinggian trapezoid; Cetak ketinggian; Kod pemacu; Memandangkan A, B, P1 dan P2"}
{"text": "Icositetragonal Number | C ++ program to find nth Icositetragonal number ; Function to find Icositetragonal number ; Formula to calculate nth Icositetragonal number ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Icositetragonal_num ( int n ) { return ( 22 * n * n - 20 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << Icositetragonal_num ( n ) << endl ; n = 10 ; cout << Icositetragonal_num ( n ) ; return 0 ; }", "text_ms": "Nombor Icositetragonal | Program C ++ untuk mencari nombor icositetragon nth; Berfungsi untuk mencari nombor icositetragonal; Formula untuk mengira nombor icositetragonal nth; Kod pemacu"}
{"text": "Area of circle inscribed in a Isosceles Trapezoid | CPP implementation to find the rea of the circle inscribed in a trapezoid having non - parallel sides m , n ; Function to find area of circle inscribed in a trapezoid having non - parallel sides m , n ; radius of circle by the formula i . e . root ( m * n ) / 2 area of circle = ( 3.141 ) * ( R * * 2 ) ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; double area_of_circle ( int m , int n ) { int square_of_radius = ( m * n ) / 4 ; double area = ( 3.141 * square_of_radius ) ; return area ; } int main ( ) { int n = 10 ; int m = 30 ; cout << ( area_of_circle ( m , n ) ) ; }", "text_ms": "Kawasan bulatan yang ditulis dalam trapezoid isosceles | Pelaksanaan CPP untuk mencari rea dari bulatan yang ditulis dalam trapezoid yang mempunyai sisi bukan selari m, n; Fungsi untuk mencari kawasan bulatan yang ditulis dalam trapezoid yang mempunyai sisi bukan selari m, n; Radius bulatan oleh formula i. e. akar (m * n) / 2 kawasan bulatan = (3.141) * (r * * 2); Kod pemacu"}
{"text": "Area of Equilateral triangle inscribed in a Circle of radius R | C ++ implementation to find the area of the equilateral triangle inscribed in a circle of radius R ; Function to find the area of equilateral triangle inscribed in a circle of radius R ; Base and Height of equilateral triangle ; Area using Base and Height ; Driver Code", "code": "#include <iostream> NEW_LINE using namespace std ; double area ( int R ) { double base = 1.732 * R ; double height = ( 1.5 ) * R ; double area = 0.5 * base * height ; return area ; } int main ( ) { int R = 7 ; cout << ( area ( R ) ) ; return 0 ; }", "text_ms": "Kawasan segitiga sama rata yang tertulis dalam lingkaran radius r | C ++ pelaksanaan untuk mencari kawasan segitiga sama rata yang tertulis dalam lingkaran radius r; Berfungsi untuk mencari kawasan segitiga sama rata yang tertulis dalam lingkaran radius r; Asas dan ketinggian segitiga sama rata; Kawasan menggunakan asas dan ketinggian; Kod pemacu"}
{"text": "Area of largest Circle that can be inscribed in a SemiCircle | C ++ Program to find the biggest circle which can be inscribed within the semicircle ; Function to find the area of the circle ; Radius cannot be negative ; Area of the largest circle ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float circlearea ( float R ) { if ( R < 0 ) return -1 ; float a = 3.14 * R * R / 4 ; return a ; } int main ( ) { float R = 2 ; cout << circlearea ( R ) << endl ; return 0 ; }", "text_ms": "Kawasan bulatan terbesar yang boleh ditulis dalam separuh bulatan | Program C ++ untuk mencari bulatan terbesar yang boleh ditulis dalam separuh bulatan; Berfungsi untuk mencari kawasan bulatan; Radius tidak boleh negatif; Kawasan bulatan terbesar; Kod pemacu"}
{"text": "Number of pairs of lines having integer intersection points | C ++ program to Number of pairs of lines having integer intersection points ; Count number of pairs of lines having integer intersection point ; Initialize arrays to store counts ; Count number of odd and even Pi ; Count number of odd and even Qi ; Return the count of pairs ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int * P , int * Q , int N , int M ) { int A [ 2 ] = { 0 } , B [ 2 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) A [ P [ i ] % 2 ] ++ ; for ( int i = 0 ; i < M ; i ++ ) B [ Q [ i ] % 2 ] ++ ; return ( A [ 0 ] * B [ 0 ] + A [ 1 ] * B [ 1 ] ) ; } int main ( ) { int P [ ] = { 1 , 3 , 2 } , Q [ ] = { 3 , 0 } ; int N = sizeof ( P ) / sizeof ( P [ 0 ] ) ; int M = sizeof ( Q ) / sizeof ( Q [ 0 ] ) ; cout << countPairs ( P , Q , N , M ) ; return 0 ; }", "text_ms": "Bilangan pasang garisan yang mempunyai titik persimpangan integer | Program C ++ kepada bilangan pasang garis yang mempunyai titik persimpangan integer; Mengira bilangan pasang garis yang mempunyai titik persimpangan integer; Memulakan susunan untuk menyimpan tuduhan; Kiraan bilangan ganjil dan bahkan pi; Kiraan bilangan ganjil dan bahkan qi; Mengembalikan kiraan pasangan; Kod pemacu"}
{"text": "Maximum number of line intersections formed through intersection of N planes | C ++ implementation of the above pproach ; Function to count maximum number of intersections possible ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countIntersections ( int n ) { return n * ( n - 1 ) / 2 ; } int main ( ) { int n = 3 ; cout << countIntersections ( n ) ; return 0 ; }", "text_ms": "Bilangan maksimum persimpangan garis yang dibentuk melalui persimpangan pesawat N | C ++ pelaksanaan pProach di atas; Berfungsi untuk mengira bilangan maksimum persimpangan yang mungkin; Kod pemacu"}
{"text": "Area of a Regular Pentagram | C ++ implementation of the approach ; Function to return the area of triangle BCD ; Using Golden ratio ; Calculate area of triangle BCD ; Return area of all 5 triangle are same ; Function to return the area of regular pentagon ; Calculate the area of regular pentagon using above formula ; Return area of regular pentagon ; Function to return the area of pentagram ; Area of a pentagram is equal to the area of regular pentagon and five times the area of Triangle ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE #define PI  3.14159 NEW_LINE using namespace std ; double areaOfTriangle ( float d ) { float c = 1.618 * d ; float s = ( d + c + c ) / 2 ; double area = sqrt ( s * ( s - c ) * ( s - c ) * ( s - d ) ) ; return 5 * area ; } double areaOfRegPentagon ( float d ) { double cal = 4 * tan ( PI / 5 ) ; double area = ( 5 * d * d ) / cal ; return area ; } double areaOfPentagram ( float d ) { return areaOfRegPentagon ( d ) + areaOfTriangle ( d ) ; } int main ( ) { float d = 5 ; cout << areaOfPentagram ( d ) << endl ; return 0 ; }", "text_ms": "Kawasan pentagram biasa | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan kawasan segitiga BCD; Menggunakan nisbah emas; Hitung kawasan segitiga BCD; Kawasan pulangan semua 5 segitiga adalah sama; Berfungsi untuk mengembalikan kawasan pentagon biasa; Kirakan kawasan pentagon biasa menggunakan formula di atas; Kawasan pulangan Pentagon biasa; Berfungsi untuk mengembalikan kawasan pentagram; Kawasan pentagram adalah sama dengan kawasan pentagon biasa dan lima kali kawasan segitiga; Kod pemacu"}
{"text": "Angle subtended by the chord to center of the circle when the angle subtended by the another equal chord of a congruent circle is given | C ++ program to find the angle subtended by the chord to the centre of the circle when the angle subtended by another equal chord of a congruent circle is given ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void anglequichord ( int z ) { cout << \" The ▁ angle ▁ is ▁ \" << z << \" ▁ degrees \" << endl ; } int main ( ) { int z = 48 ; anglequichord ( z ) ; return 0 ; }", "text_ms": "Sudut yang disebarkan oleh kord ke pusat bulatan apabila sudut yang disuntik oleh kord lain yang sama dari lingkaran kongruen diberikan | Program C ++ untuk mencari sudut yang disembur oleh kord ke pusat bulatan apabila sudut yang diselaraskan oleh kord lain yang sama dari lingkaran kongruen diberikan; Kod pemacu"}
{"text": "Program to print ASCII Value of all digits of a given number | C ++ program to convert the digits of a number to its ASCII values ; Function to convert digits of N to respective ASCII values ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int convertToASCII ( int N ) { string num = to_string ( N ) ; for ( char ch : num ) { cout << ch << \" ▁ ( \" << ( int ) ch << \" ) STRNEWLINE \" ; } } int main ( ) { int N = 36 ; convertToASCII ( N ) ; return 0 ; }", "text_ms": "Program untuk mencetak nilai ASCII bagi semua digit nombor tertentu | Program C ++ untuk menukar digit nombor kepada nilai ASCIInya; Berfungsi untuk menukar digit N ke nilai ASCII masing -masing; Kod pemacu"}
{"text": "A Product Array Puzzle | Set 3 | C ++ program for the above approach ; Function to form product array with O ( n ) time and O ( 1 ) space ; Stores the product of array ; Stores the count of zeros ; Traverse the array ; If arr [ i ] is not zero ; If arr [ i ] is zero then increment count of z by 1 ; Stores the absolute value of the product ; If Z is equal to 1 ; If arr [ i ] is not zero ; Else ; If count of 0 s at least 2 ; Assign arr [ i ] = 0 ; Store absolute value of arr [ i ] ; Find the value of a / b ; If arr [ i ] and product both are less than zero ; If arr [ i ] and product both are greater than zero ; Else ; Traverse the array arr [ ] ; Driver Code ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void productExceptSelf ( int arr [ ] , int N ) { int product = 1 ; int z = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] ) product *= arr [ i ] ; z += ( arr [ i ] == 0 ) ; } int a = abs ( product ) , b ; for ( int i = 0 ; i < N ; i ++ ) { if ( z == 1 ) { if ( arr [ i ] ) arr [ i ] = 0 ; else arr [ i ] = product ; continue ; } else if ( z > 1 ) { arr [ i ] = 0 ; continue ; } int b = abs ( arr [ i ] ) ; int curr = round ( exp ( log ( a ) - log ( b ) ) ) ; if ( arr [ i ] < 0 && product < 0 ) arr [ i ] = curr ; else if ( arr [ i ] > 0 && product > 0 ) arr [ i ] = curr ; else arr [ i ] = -1 * curr ; } for ( int i = 0 ; i < N ; i ++ ) { cout << arr [ i ] << \" ▁ \" ; } } int main ( ) { int arr [ ] = { 10 , 3 , 5 , 6 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; productExceptSelf ( arr , N ) ; return 0 ; }", "text_ms": "Teka -teki Arus Produk | Set 3 | Program C ++ untuk pendekatan di atas; Berfungsi untuk membentuk pelbagai produk dengan ruang O (n) dan o (1); Menyimpan produk array; Menyimpan kiraan sifar; Melintasi array; Jika arr [i] tidak sifar; Jika arr [i] adalah sifar maka kiraan kenaikan z oleh 1; Menyimpan nilai mutlak produk; Jika z sama dengan 1; Jika arr [i] tidak sifar; Lain; Jika kiraan 0 s sekurang -kurangnya 2; Berikan arr [i] = 0; Simpan nilai mutlak arr [i]; Cari nilai A / B; Jika arr [i] dan produk kedua -duanya kurang daripada sifar; Jika arr [i] dan produk kedua -duanya lebih besar daripada sifar; Lain; Melintasi array arr []; Kod pemacu; Panggilan fungsi"}
{"text": "Count subarrays made up of single | C ++ program for the above approach ; Function to count of subarrays made up of single digit integers only ; Stores count of subarrays ; Stores the count of consecutive single digit numbers in the array ; Traverse the array ; Increment size of block by 1 ; Increment res by count ; Assign count = 0 ; Driver Code ; Given array ; Size of the array", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int singleDigitSubarrayCount ( int arr [ ] , int N ) { int res = 0 ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] <= 9 ) { count ++ ; res += count ; } else { count = 0 ; } } cout << res ; } int main ( ) { int arr [ ] = { 0 , 1 , 14 , 2 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; singleDigitSubarrayCount ( arr , N ) ; return 0 ; }", "text_ms": "Count Subarrays terdiri daripada single | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira subarrays yang terdiri daripada bilangan bulat tunggal sahaja; Kedai kiraan subarray; Menyimpan kiraan nombor angka tunggal berturut -turut dalam array; Melintasi array; Saiz kenaikan blok sebanyak 1; Peningkatan res mengikut kiraan; Menetapkan kiraan = 0; Kod pemacu; Diberikan array; Saiz array"}
{"text": "Count integers up to N which can be represented as sum of two or more consecutive numbers | C ++ Program to implement the above approach ; Function to check if the number N can be expressed as sum of 2 or more consecutive numbers or not ; Function to count integers in the range [ 1 , N ] that can be expressed as sum of 2 or more consecutive numbers ; Stores the required count ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPossible ( int N ) { return ( ( N & ( N - 1 ) ) && N ) ; } void countElements ( int N ) { int count = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( isPossible ( i ) ) count ++ ; } cout << count ; } int main ( ) { int N = 15 ; countElements ( N ) ; return 0 ; }", "text_ms": "Kira bilangan bulat sehingga n yang boleh diwakili sebagai jumlah dua atau lebih nombor berturut -turut | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk memeriksa sama ada nombor n boleh dinyatakan sebagai jumlah 2 atau lebih nombor berturut -turut atau tidak; Fungsi untuk mengira bilangan bulat dalam julat [1, n] yang boleh dinyatakan sebagai jumlah 2 atau lebih nombor berturut -turut; Menyimpan kiraan yang diperlukan; Kod pemacu"}
{"text": "Count integers up to N which can be represented as sum of two or more consecutive numbers | C ++ implementation of the above approach ; Function to count integers in the range [ 1 , N ] that can be expressed as sum of 2 or more consecutive numbers ; Count powers of 2 up to N ; Increment count ; Update current power of 2 ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void countElements ( int N ) { int Cur_Ele = 1 ; int Count = 0 ; while ( Cur_Ele <= N ) { Count ++ ; Cur_Ele = Cur_Ele * 2 ; } cout << N - Count ; } int main ( ) { int N = 15 ; countElements ( N ) ; return 0 ; }", "text_ms": "Kira bilangan bulat sehingga n yang boleh diwakili sebagai jumlah dua atau lebih nombor berturut -turut | C ++ pelaksanaan pendekatan di atas; Fungsi untuk mengira bilangan bulat dalam julat [1, n] yang boleh dinyatakan sebagai jumlah 2 atau lebih nombor berturut -turut; Mengira kuasa 2 sehingga n; Kiraan kenaikan; Mengemas kini kuasa semasa 2; Kod pemacu"}
{"text": "Maximum difference between a pair of adjacent elements by excluding every element once | C ++ program for the above approach ; Function to calculate maximum difference between adjacent elements excluding every array element once ; Compute maximum adjacent difference for whole array ; Store the maximum between arr_max and curr_max ; Append the result into a vector ; Print the result ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxAdjacent ( int * arr , int N ) { vector < int > res ; int arr_max = INT_MIN ; for ( int i = 1 ; i < N ; i ++ ) { arr_max = max ( arr_max , abs ( arr [ i - 1 ] - arr [ i ] ) ) ; } for ( int i = 1 ; i < N - 1 ; i ++ ) { int curr_max = abs ( arr [ i - 1 ] - arr [ i + 1 ] ) ; int ans = max ( curr_max , arr_max ) ; res . push_back ( ans ) ; } for ( auto x : res ) cout << x << \" ▁ \" ; cout << endl ; } int main ( ) { int arr [ ] = { 1 , 3 , 4 , 7 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; maxAdjacent ( arr , N ) ; }", "text_ms": "Perbezaan maksimum antara sepasang elemen bersebelahan dengan tidak termasuk setiap elemen sekali | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira perbezaan maksimum antara elemen bersebelahan tidak termasuk setiap elemen array sekali; Kirakan perbezaan bersebelahan maksimum untuk keseluruhan array; Simpan maksimum antara arr_max dan curr_max; Tambah hasilnya ke dalam vektor; Cetak hasilnya; Kod pemacu"}
{"text": "Minimize increments required to make count of even and odd array elements equal | C ++ program for the above approach ; Function to find min operations to make even and odd count equal ; Odd size will never make odd and even counts equal ; Stores the count of even numbers in the array arr [ ] ; Stores count of odd numbers in the array arr [ ] ; Traverse the array arr [ ] ; If arr [ i ] is an even number ; Update cntEven ; Odd numbers in arr [ ] ; Return absolute difference divided by 2 ; Driver Code ; Function call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumIncrement ( int arr [ ] , int N ) { if ( N % 2 != 0 ) { cout << \" - 1\" ; exit ( 0 ) ; } int cntEven = 0 ; int cntOdd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { cntEven += 1 ; } } cntOdd = N - cntEven ; return abs ( cntEven - cntOdd ) / 2 ; } int main ( ) { int arr [ ] = { 1 , 3 , 4 , 9 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minimumIncrement ( arr , N ) ; return 0 ; }", "text_ms": "Kurangkan kenaikan yang diperlukan untuk membuat kiraan elemen array yang sama dan ganjil sama | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari operasi min untuk membuat kiraan yang sama dan ganjil sama; Saiz ganjil tidak akan menjadi ganjil dan juga dianggap sama; Menyimpan kiraan nombor walaupun dalam array arr []; Kedai mengira nombor ganjil dalam array arr []; Melintasi array arr []; Jika arr [i] adalah nombor yang sama; Kemas kini cnteven; Nombor ganjil dalam arr []; Kembali perbezaan mutlak dibahagikan dengan 2; Kod pemacu; Panggilan fungsi"}
{"text": "Count ways to construct array with even product from given array such that absolute difference of same indexed elements is at most 1 | C ++ program to implement the above approach ; Function to find count the ways to construct an array , B [ ] such that abs ( A [ i ] - B [ i ] ) <= 1 and product of elements of B [ ] is even ; Stores count of arrays B [ ] such that abs ( A [ i ] - B [ i ] ) <= 1 ; Stores count of arrays B [ ] whose product of elements is not even ; Traverse the array ; Update total ; If A [ i ] is an even number ; Update oddArray ; Print 3 ^ N - 2 ^ X ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void cntWaysConsArray ( int A [ ] , int N ) { int total = 1 ; int oddArray = 1 ; for ( int i = 0 ; i < N ; i ++ ) { total = total * 3 ; if ( A [ i ] % 2 == 0 ) { oddArray *= 2 ; } } cout << total - oddArray << \" STRNEWLINE \" ; } int main ( ) { int A [ ] = { 2 , 4 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cntWaysConsArray ( A , N ) ; return 0 ; }", "text_ms": "Kira cara untuk membina array dengan produk walaupun dari array yang diberikan sedemikian rupa sehingga perbezaan mutlak unsur -unsur yang diindeks sama paling banyak 1 | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk mencari mengira cara untuk membina array, B [] seperti abs (a [i] - b [i]) <= 1 dan produk unsur -unsur B [] adalah walaupun; Kedai kiraan tatasusunan b [] seperti abs (a [i] - b [i]) <= 1; Kedai -kedai Count of Arrays B [] yang produk elemennya tidak; Melintasi array; Jumlah kemas kini; Jika [i] adalah nombor yang sama; Kemas kini Oddarray; Cetak 3 ^ n - 2 ^ x; Kod pemacu"}
{"text": "Count numbers up to N whose rightmost set bit is K | C ++ program for the above approach ; Function to count the numbers in the range [ 1 , N ] whose rightmost set bit is K ; Stores the number whose rightmost set bit is K ; Numbers whose rightmost set bit is i ; Subtracting the number whose rightmost set bit is i , from N ; Since i = k , then the number whose rightmost set bit is K is stored ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countNumberHavingKthBitSet ( int N , int K ) { int numbers_rightmost_setbit_K ; for ( int i = 1 ; i <= K ; i ++ ) { int numbers_rightmost_bit_i = ( N + 1 ) / 2 ; N -= numbers_rightmost_bit_i ; if ( i == K ) { numbers_rightmost_setbit_K = numbers_rightmost_bit_i ; } } cout << numbers_rightmost_setbit_K ; } int main ( ) { int N = 15 ; int K = 2 ; countNumberHavingKthBitSet ( N , K ) ; return 0 ; }", "text_ms": "Kira nombor sehingga n yang paling tepat ditetapkan adalah k | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira nombor dalam julat [1, n] yang paling tepat ditetapkan adalah k; Menyimpan nombor yang paling tepat adalah k; Nombor yang paling tepat adalah i; Mengurangkan nombor yang paling tepat ditetapkan adalah saya, dari n; Oleh kerana i = k, maka nombor yang paling tepat ditetapkan adalah k disimpan; Kod pemacu"}
{"text": "Count odd and even Binomial Coefficients of N | C ++ program for the above approach ; Function to count set bits in binary representation of number N ; Count set bits in N ; Return the final count ; Driver Code ; Print odd Binomial coefficients ; Print even Binomial coefficients", "code": "#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; int countSetBits ( int N ) { int count = 0 ; while ( N ) { N = N & ( N - 1 ) ; count ++ ; } return count ; } int main ( ) { int N = 4 ; int bits = countSetBits ( N ) ; cout << \" Odd ▁ \" << \" : ▁ \" << pow ( 2 , bits ) << \" STRNEWLINE \" ; cout << \" Even ▁ \" << \" : ▁ \" << N + 1 - pow ( 2 , bits ) << \" STRNEWLINE \" ; return 0 ; }", "text_ms": "Kira pekali ganjil dan bahkan binomial N | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira set bit dalam perwakilan binari nombor n; Count set bit dalam n; Mengembalikan kiraan akhir; Kod pemacu; Cetak koefisien binomial ganjil; Cetak walaupun koefisien binomial"}
{"text": "Make all array elements even by replacing any pair of array elements with their sum | C ++ program for the above approach ; Function to find the minimum number of replacements required to make all array elements even ; Stores the count of odd elements ; Traverse the array ; Increase count of odd elements ; Store number of replacements required ; Two extra moves will be required to make the last odd element even ; Print the minimum replacements ; Driver Code ; Function call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void minMoves ( int arr [ ] , int N ) { int odd_element_cnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 != 0 ) { odd_element_cnt ++ ; } } int moves = ( odd_element_cnt ) / 2 ; if ( odd_element_cnt % 2 != 0 ) moves += 2 ; cout << moves ; } int main ( ) { int arr [ ] = { 5 , 6 , 3 , 7 , 20 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; minMoves ( arr , N ) ; return 0 ; }", "text_ms": "Buat semua elemen array walaupun dengan menggantikan mana -mana sepasang elemen array dengan jumlah mereka | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari bilangan minimum penggantian yang diperlukan untuk membuat semua elemen array walaupun; Menyimpan kiraan elemen ganjil; Melintasi array; Meningkatkan kiraan elemen ganjil; Bilangan penggantian yang diperlukan; Dua langkah tambahan diperlukan untuk membuat elemen ganjil yang terakhir walaupun; Cetak penggantian minimum; Kod pemacu; Panggilan fungsi"}
{"text": "Split squares of first N natural numbers into two sets with minimum absolute difference of their sums | C ++ program for the above approach ; Function to partition squares of N natural number in two subset ; Store the count of blocks of size 8 ; Partition of block of 8 element ; Store the minimum subset difference ; Partition of N elements to minimize their subset sum difference ; Store elements of subset A and B ; If element is of type A ; If the element is of type B ; Print the minimum subset difference ; Print the first subset ; Print the second subset ; Driver Code ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void minimumSubsetDifference ( int N ) { int blockOfSize8 = N / 8 ; string str = \" ABBABAAB \" ; int subsetDifference = 0 ; string partition = \" \" ; while ( blockOfSize8 -- ) { partition += str ; } vector < int > A , B ; for ( int i = 0 ; i < N ; i ++ ) { if ( partition [ i ] == ' A ' ) { A . push_back ( ( i + 1 ) * ( i + 1 ) ) ; } else { B . push_back ( ( i + 1 ) * ( i + 1 ) ) ; } } cout << subsetDifference << \" STRNEWLINE \" ; for ( int i = 0 ; i < A . size ( ) ; i ++ ) cout << A [ i ] << \" ▁ \" ; cout << \" STRNEWLINE \" ; for ( int i = 0 ; i < B . size ( ) ; i ++ ) cout << B [ i ] << \" ▁ \" ; } int main ( ) { int N = 8 ; minimumSubsetDifference ( N ) ; return 0 ; }", "text_ms": "Split Squares of First N Natural Numbers menjadi dua set dengan perbezaan mutlak minimum jumlah mereka | Program C ++ untuk pendekatan di atas; Berfungsi untuk partition squares nombor semulajadi dalam dua subset; Simpan kiraan blok saiz 8; Pemisahan blok 8 elemen; Simpan perbezaan subset minimum; Pemisahan elemen N untuk meminimumkan perbezaan jumlah subset mereka; Simpan unsur subset A dan B; Jika elemen adalah jenis A; Jika elemen adalah jenis B; Cetak perbezaan subset minimum; Cetak subset pertama; Cetak subset kedua; Kod pemacu; Panggilan fungsi"}
{"text": "Largest divisor of a number not divisible by another given number | C ++ program to implement the above approach ; Function to find the largest number X such that it divides P but is not divisible by Q ; Stores the frequency count of of all Prime Factors ; Increment the frequency of the current prime factor ; If Q is a prime factor ; Stores the desired result ; Iterate through all divisors of Q ; Stores the frequency count of current prime divisor on dividing P ; Count the frequency of the current prime factor ; If cur is less than frequency then P is the final result ; Iterate to get temporary answer ; Update current answer ; Print the desired result ; Driver Code ; Given P and Q ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findTheGreatestX ( int P , int Q ) { map < int , int > divisiors ; for ( int i = 2 ; i * i <= Q ; i ++ ) { while ( Q % i == 0 and Q > 1 ) { Q /= i ; divisiors [ i ] ++ ; } } if ( Q > 1 ) divisiors [ Q ] ++ ; int ans = 0 ; for ( auto i : divisiors ) { int frequency = i . second ; int temp = P ; int cur = 0 ; while ( temp % i . first == 0 ) { temp /= i . first ; cur ++ ; } if ( cur < frequency ) { ans = P ; break ; } temp = P ; for ( int j = cur ; j >= frequency ; j -- ) { temp /= i . first ; } ans = max ( temp , ans ) ; } cout << ans ; } int main ( ) { int P = 10 , Q = 4 ; findTheGreatestX ( P , Q ) ; return 0 ; }", "text_ms": "Pembahagi terbesar nombor yang tidak dapat dibahagikan dengan nombor yang lain | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari nombor terbesar x supaya ia membahagikan p tetapi tidak dapat dibahagikan dengan q; Menyimpan kiraan kekerapan semua faktor utama; Meningkatkan kekerapan faktor utama semasa; Jika Q adalah faktor utama; Menyimpan hasil yang diingini; Melangkah melalui semua pembahagi Q; Menyimpan kiraan kekerapan pembahagi utama semasa untuk membahagikan p; Mengira kekerapan faktor utama semasa; Jika CUR kurang daripada kekerapan maka p adalah hasil akhir; Berulang untuk mendapatkan jawapan sementara; Mengemas kini jawapan semasa; Cetak hasil yang diinginkan; Kod pemacu; Diberikan p dan q; Panggilan fungsi"}
{"text": "Check if rows of a Matrix can be rearranged to make Bitwise XOR of first column non | C ++ program for the above approach ; Function to check if there is any row where number of unique elements are greater than 1 ; Iterate over the matrix ; Function to check if it is possible to rearrange mat [ ] [ ] such that XOR of its first column is non - zero ; Find bitwise XOR of the first column of mat [ ] [ ] ; If bitwise XOR of the first column of mat [ ] [ ] is non - zero ; Otherwise check rearrangements ; Driver Code ; Given Matrix mat [ ] [ ] ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string checkRearrangements ( vector < vector < int > > mat , int N , int M ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 1 ; j < M ; j ++ ) { if ( mat [ i ] [ 0 ] != mat [ i ] [ j ] ) { return \" Yes \" ; } } } return \" No \" ; } string nonZeroXor ( vector < vector < int > > mat , int N , int M ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { res = res ^ mat [ i ] [ 0 ] ; } if ( res != 0 ) return \" Yes \" ; else return checkRearrangements ( mat , N , M ) ; } int main ( ) { vector < vector < int > > mat = { { 1 , 1 , 2 } , { 2 , 2 , 2 } , { 3 , 3 , 3 } } ; int N = mat . size ( ) ; int M = mat [ 0 ] . size ( ) ; cout << nonZeroXor ( mat , N , M ) ; return 0 ; }", "text_ms": "Semak jika baris matriks boleh disusun semula untuk membuat bitwise xor lajur pertama non | Program C ++ untuk pendekatan di atas; Fungsi untuk memeriksa sama ada ada baris di mana bilangan elemen unik lebih besar daripada 1; Melangkah ke atas matriks; Fungsi untuk memeriksa sama ada mungkin untuk menyusun semula tikar [] [] supaya xor lajur pertamanya bukan sifar; Cari bitwise xor lajur pertama Mat [] []; Jika bitwise xor lajur pertama tikar [] [] bukan sifar; Jika tidak, periksa semula; Kod pemacu; Diberikan matriks mat [] []; Panggilan fungsi"}
{"text": "Maximize Bitwise AND of first element with complement of remaining elements for any permutation of given Array | C ++ Program to implement the above approach ; Function to maximize the value for the given function and the array elements ; Vector array to maintain which bit is set for which integer in the given array by saving index of that integer ; Check if j - th bit is set for i - th integer ; Push the index of that integer in setBit [ j ] ; Find the element having highest significant set bit unset in other elements ; Place that integer at 0 - th index ; Store the maximum AND value ; Return the answer ; Driver Code ; Function call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define size_int  32 NEW_LINE int functionMax ( int arr [ ] , int n ) { vector < int > setBit [ 32 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < size_int ; j ++ ) { if ( arr [ i ] & ( 1 << j ) ) setBit [ j ] . push_back ( i ) ; } } for ( int i = size_int ; i >= 0 ; i -- ) { if ( setBit [ i ] . size ( ) == 1 ) { swap ( arr [ 0 ] , arr [ setBit [ i ] [ 0 ] ] ) ; break ; } } int maxAnd = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { maxAnd = maxAnd & ( ~ arr [ i ] ) ; } return maxAnd ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 8 , 16 } ; int n = sizeof arr / sizeof arr [ 0 ] ; cout << functionMax ( arr , n ) ; return 0 ; }", "text_ms": "Memaksimumkan bitwise dan elemen pertama dengan pelengkap elemen yang tinggal untuk sebarang permutasi array yang diberikan | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk memaksimumkan nilai untuk fungsi yang diberikan dan elemen array; Arahan vektor untuk mengekalkan bit mana yang ditetapkan untuk integer dalam array yang diberikan dengan menyimpan indeks integer itu; Semak jika b - th bit ditetapkan untuk integer i - th; Tolak indeks integer itu dalam setbit [j]; Cari elemen yang mempunyai bit set signifikan tertinggi dalam unsur -unsur lain; Letakkan integer itu pada indeks 0 - th; Simpan maksimum dan nilai; Kembalikan jawapannya; Kod pemacu; Panggilan fungsi"}
{"text": "Sum of all products of the Binomial Coefficients of two numbers up to K | C ++ implementation of the above approach ; Function returns nCr i . e . Binomial Coefficient ; Initialize res with 1 ; Since C ( n , r ) = C ( n , n - r ) ; Evaluating expression ; Function to calculate and return the sum of the products ; Initialize sum to 0 ; Traverse from 0 to k ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int nCr ( int n , int r ) { int res = 1 ; if ( r > n - r ) r = n - r ; for ( int i = 0 ; i < r ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } int solve ( int n , int m , int k ) { int sum = 0 ; for ( int i = 0 ; i <= k ; i ++ ) sum += nCr ( n , i ) * nCr ( m , k - i ) ; return sum ; } int main ( ) { int n = 3 , m = 2 , k = 2 ; cout << solve ( n , m , k ) ; return 0 ; }", "text_ms": "Jumlah semua produk koefisien binomial dua nombor sehingga k | C ++ pelaksanaan pendekatan di atas; Fungsi mengembalikan NCR i. e. Pekali binomial; Memulakan res dengan 1; Kerana c (n, r) = c (n, n - r); Menilai ungkapan; Berfungsi untuk mengira dan mengembalikan jumlah produk; Memulakan jumlah hingga 0; Melintasi 0 hingga k; Kod pemacu"}
{"text": "Fast Exponention using Bit Manipulation | C ++ Program to implement the above approach ; Function to return a ^ n ; Stores final answer ; Check if current LSB is set ; Right shift ; Driver Code", "code": "#include <iostream> NEW_LINE using namespace std ; int powerOptimised ( int a , int n ) { int ans = 1 ; while ( n > 0 ) { int last_bit = ( n & 1 ) ; if ( last_bit ) { ans = ans * a ; } a = a * a ; n = n >> 1 ; } return ans ; } int main ( ) { int a = 3 , n = 5 ; cout << powerOptimised ( a , n ) ; return 0 ; }", "text_ms": "Exponention Cepat Menggunakan Manipulasi Bit | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mengembalikan A ^ n; Kedai Jawapan Akhir; Semak jika LSB semasa ditetapkan; Peralihan kanan; Kod pemacu"}
{"text": "Find M such that GCD of M and given number N is maximum | C ++ program for the above approach ; Function to find the integer M such that gcd ( N , M ) is maximum ; Initialize a variable ; Find all the divisors of N and return the maximum divisor ; Check if i is divisible by N ; Update max_gcd ; Return the maximum value ; Driver Code ; Given Number ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaximumGcd ( int n ) { int max_gcd = 1 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i > max_gcd ) max_gcd = i ; if ( ( n / i != i ) && ( n / i != n ) && ( ( n / i ) > max_gcd ) ) max_gcd = n / i ; } } return max_gcd ; } int main ( ) { int N = 10 ; cout << findMaximumGcd ( N ) ; return 0 ; }", "text_ms": "Cari M sedemikian rupa sehingga GCD M dan Nombor N adalah maksimum | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari integer m sedemikian rupa sehingga GCD (n, m) adalah maksimum; Memulakan pembolehubah; Cari semua pembahagi N dan kembalikan pembahagi maksimum; Semak jika saya boleh dibahagikan dengan n; Kemas kini max_gcd; Mengembalikan nilai maksimum; Kod pemacu; Nombor yang diberikan; Panggilan fungsi"}
{"text": "First element of every K sets having consecutive elements with exactly K prime factors less than N | C ++ program for the above approach ; For storing smallest prime factor ; Function construct smallest prime factor array ; Mark smallest prime factor for every number to be itself . ; separately mark spf for every even number as 2 ; Check if i is prime ; Mark SPF for all numbers divisible by i ; Mark spf [ j ] if it is not previously marked ; Function for counts total number of prime factors ; Function to print elements of sets of K consecutive elements having K prime factors ; To store the result ; Count number of prime factors of number ; If number has exactly K factors push in result [ ] ; Iterate till we get K consecutive elements in result [ ] ; Count sequence until K ; Print the element if count >= K ; Driver Code ; To construct spf [ ] ; Given N and K ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE #define x  2000021 NEW_LINE using namespace std ; long long int v [ x ] ; void sieve ( ) { v [ 1 ] = 1 ; for ( long long int i = 2 ; i < x ; i ++ ) v [ i ] = i ; for ( long long int i = 4 ; i < x ; i += 2 ) v [ i ] = 2 ; for ( long long int i = 3 ; i * i < x ; i ++ ) { if ( v [ i ] == i ) { for ( long long int j = i * i ; j < x ; j += i ) { if ( v [ j ] == j ) { v [ j ] = i ; } } } } } long long int prime_factors ( long long n ) { set < long long int > s ; while ( n != 1 ) { s . insert ( v [ n ] ) ; n = n / v [ n ] ; } return s . size ( ) ; } void distinctPrimes ( long long int m , long long int k ) { vector < long long int > result ; for ( long long int i = 14 ; i < m + k ; i ++ ) { long long count = prime_factors ( i ) ; if ( count == k ) { result . push_back ( i ) ; } } long long int p = result . size ( ) ; for ( long long int index = 0 ; index < p - 1 ; index ++ ) { long long element = result [ index ] ; long long count = 1 , z = index ; while ( z < p - 1 && count <= k && result [ z ] + 1 == result [ z + 1 ] ) { count ++ ; z ++ ; } if ( count >= k ) cout << element << ' ▁ ' ; } } int main ( ) { sieve ( ) ; long long int N = 1000 , K = 3 ; distinctPrimes ( N , K ) ; return 0 ; }", "text_ms": "Elemen pertama setiap set K mempunyai unsur berturut -turut dengan faktor -faktor utama yang kurang daripada n | Program C ++ untuk pendekatan di atas; Untuk menyimpan faktor utama terkecil; Fungsi membina pelbagai faktor utama terkecil; Tandakan faktor utama terkecil untuk setiap nombor menjadi dirinya sendiri. ; Secara berasingan menandakan SPF untuk setiap nombor juga sebagai 2; Semak jika saya adalah Perdana; Mark SPF untuk semua nombor yang boleh dibahagikan oleh i; Mark SPF [J] jika ia tidak ditandakan sebelum ini; Fungsi untuk jumlah jumlah faktor utama; Fungsi untuk mencetak unsur -unsur set un elemen berturut -turut yang mempunyai faktor utama; Untuk menyimpan hasilnya; Mengira bilangan faktor utama nombor; Jika nombor mempunyai faktor yang betul -betul mendorong hasil []; Melangkah sehingga kita mendapat unsur -unsur berturut -turut dalam hasil []; Mengira urutan sehingga k; Cetak elemen jika Count> = k; Kod pemacu; Untuk membina SPF []; Diberikan n dan k; Panggilan fungsi"}
{"text": "Product of Complex Numbers using three Multiplication Operation | C ++ program for the above approach ; Function to multiply Complex Numbers with just three multiplications ; Find value of prod1 , prod2 and prod3 ; Real Part ; Imaginary Part ; Print the result ; Driver Code ; Given four Numbers ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void print_product ( int a , int b , int c , int d ) { int prod1 = a * c ; int prod2 = b * d ; int prod3 = ( a + b ) * ( c + d ) ; int real = prod1 - prod2 ; int imag = prod3 - ( prod1 + prod2 ) ; cout << real << \" ▁ + ▁ \" << imag << \" i \" ; } int main ( ) { int a , b , c , d ; a = 2 ; b = 3 ; c = 4 ; d = 5 ; print_product ( a , b , c , d ) ; return 0 ; }", "text_ms": "Produk nombor kompleks menggunakan tiga operasi pendaraban | Program C ++ untuk pendekatan di atas; Berfungsi untuk membiak nombor kompleks dengan hanya tiga pendaraban; Cari nilai prod1, prod2 dan prod3; Bahagian sebenar; Bahagian khayalan; Cetak hasilnya; Kod pemacu; Diberi empat nombor; Panggilan fungsi"}
{"text": "Insolite Numbers | C ++ implementation for the above approach ; Function to check if a number is an Insolite numbers ; To store sum of squares of digits ; To store product of squares of digits ; extracting digit ; Driver Code ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isInsolite ( int n ) { int N = n ; int sum = 0 ; int product = 1 ; while ( n != 0 ) { int r = n % 10 ; sum = sum + r * r ; product = product * r * r ; n = n / 10 ; } return ( N % sum == 0 ) && ( N % product == 0 ) ; } int main ( ) { int N = 111 ; if ( isInsolite ( N ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "text_ms": "Nombor Insolite | C ++ pelaksanaan untuk pendekatan di atas; Fungsi untuk memeriksa sama ada nombor adalah nombor insolit; Untuk menyimpan jumlah kuadrat digit; Untuk menyimpan produk dataran digit; mengekstrak digit; Kod pemacu; Panggilan fungsi"}
{"text": "Superabundant Numbers | C ++ implementation to check if a number is Superabundant ; Function to calculate the sum of all divisors of a given number ; Sum of divisors ; find all divisors which divides ' num ' ; if ' i ' is divisor of ' n ' ; if both divisors are same then add it once else add both ; Add 1 and n to result as above loop considers proper divisors greater than 1. ; Function to check if N is a superabundant number ; to check all numbers from 1 to N ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int sigma ( int n ) { if ( n == 1 ) return 1 ; int result = 0 ; for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i == ( n / i ) ) result += i ; else result += ( i + n / i ) ; } } return ( result + n + 1 ) ; } bool isSuperabundant ( int N ) { for ( float i = 1 ; i < N ; i ++ ) { float x = sigma ( i ) / i ; float y = sigma ( N ) / ( N * 1.0 ) ; if ( x > y ) return false ; } return true ; } int main ( ) { int N = 4 ; isSuperabundant ( N ) ? cout << \" Yes \" : cout << \" No \" ; return 0 ; }", "text_ms": "Nombor Superabundant | C ++ pelaksanaan untuk memeriksa sama ada nombor adalah superbundant; Fungsi untuk mengira jumlah semua pembahagi nombor tertentu; Jumlah pembahagi; Cari semua pembahagi yang membahagikan 'num'; jika 'saya' adalah pembahagi 'n'; Jika kedua -dua pembahagi adalah sama maka tambahkannya sekali lagi tambah kedua -duanya; Tambah 1 dan N untuk menghasilkan seperti gelung di atas menganggap pembahagi yang betul lebih besar daripada 1; Berfungsi untuk memeriksa sama ada n adalah nombor superbundant; untuk memeriksa semua nombor dari 1 hingga n; Kod pemacu"}
{"text": "D Numbers | C ++ implementation for the above approach ; Function to find the N - th icosikaipentagon number ; number should be greater than 3 ; Check every k in range 2 to n - 1 ; condition for D - Number ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int isDNum ( int n ) { if ( n < 4 ) return false ; int numerator , hcf ; for ( int k = 2 ; k <= n ; k ++ ) { numerator = pow ( k , n - 2 ) - k ; hcf = __gcd ( n , k ) ; } if ( hcf == 1 && ( numerator % n ) != 0 ) return false ; return true ; } int main ( ) { int n = 15 ; int a = isDNum ( n ) ; if ( a ) cout << \" Yes \" ; else cout << \" No \" ; }", "text_ms": "D Nombor | C ++ pelaksanaan untuk pendekatan di atas; Berfungsi untuk mencari nombor N - th icosikaipentagon; Nombor hendaklah lebih besar daripada 3; Semak setiap k dalam julat 2 hingga n - 1; keadaan untuk nombor D; Kod pemacu"}
{"text": "Ruth | C ++ implementation of the above approach ; Function to find prime divisors of all numbers from 1 to N ; if the number is prime ; add this prime to all it 's multiples ; Function to check Ruth - Aaron number ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Sum ( int N ) { int SumOfPrimeDivisors [ N + 1 ] = { 0 } ; for ( int i = 2 ; i <= N ; ++ i ) { if ( ! SumOfPrimeDivisors [ i ] ) { for ( int j = i ; j <= N ; j += i ) { SumOfPrimeDivisors [ j ] += i ; } } } return SumOfPrimeDivisors [ N ] ; } bool RuthAaronNumber ( int n ) { if ( Sum ( n ) == Sum ( n + 1 ) ) return true ; else return false ; } int main ( ) { int N = 714 ; if ( RuthAaronNumber ( N ) ) { cout << \" Yes \" ; } else { cout << \" No \" ; } return 0 ; }", "text_ms": "Ruth | C ++ pelaksanaan pendekatan di atas; Berfungsi untuk mencari pembahagi utama semua nombor dari 1 hingga n; jika nombor itu adalah perdana; Tambah perdana ini kepada semua gandaan itu; Berfungsi untuk memeriksa nombor Ruth - Aaron; Kod pemacu"}
{"text": "Maximize sum of absolute difference between adjacent elements in Array with sum K | C ++ program to maximize the sum of absolute differences between adjacent elements ; Function for maximizing the sum ; Difference is 0 when only one element is present in array ; Difference is K when two elements are present in array ; Otherwise ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxAdjacentDifference ( int N , int K ) { if ( N == 1 ) { return 0 ; } if ( N == 2 ) { return K ; } return 2 * K ; } int main ( ) { int N = 6 ; int K = 11 ; cout << maxAdjacentDifference ( N , K ) ; return 0 ; }", "text_ms": "Memaksimumkan jumlah perbezaan mutlak antara unsur -unsur bersebelahan dalam array dengan jumlah k | Program C ++ untuk memaksimumkan jumlah perbezaan mutlak antara unsur -unsur bersebelahan; Fungsi untuk memaksimumkan jumlah; Perbezaan adalah 0 apabila hanya satu elemen yang terdapat dalam array; Perbezaan adalah k apabila dua elemen hadir dalam pelbagai; Jika tidak; Kod pemacu"}
{"text": "Sum of all divisors from 1 to N | Set 2 | C ++ program for the above approach ; Functions returns sum of numbers from 1 to n ; Functions returns sum of numbers from a + 1 to b ; Function returns total sum of divisors ; Stores total sum ; Finding numbers and its occurence ; Sum of product of each number and its occurence ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int mod = 1000000007 ; int linearSum ( int n ) { return ( n * ( n + 1 ) / 2 ) % mod ; } int rangeSum ( int b , int a ) { return ( linearSum ( b ) - linearSum ( a ) ) % mod ; } int totalSum ( int n ) { int result = 0 ; int i = 1 ; while ( true ) { result += rangeSum ( n / i , n / ( i + 1 ) ) * ( i % mod ) % mod ; result %= mod ; if ( i == n ) break ; i = n / ( n / ( i + 1 ) ) ; } return result ; } int main ( ) { int N = 4 ; cout << totalSum ( N ) << endl ; N = 12 ; cout << totalSum ( N ) << endl ; return 0 ; }", "text_ms": "Jumlah semua pembahagi dari 1 hingga N | Tetapkan 2 | Program C ++ untuk pendekatan di atas; Fungsi mengembalikan jumlah nombor dari 1 hingga n; Fungsi mengembalikan jumlah nombor dari A + 1 hingga B; Fungsi mengembalikan jumlah jumlah pembahagi; Kedai Jumlah Jumlah; Mencari nombor dan kejadiannya; Jumlah produk setiap nombor dan kejadiannya; Kod pemacu"}
{"text": "Nontrivial undulant Numbers | C ++ implementation to check if N is a Nontrivial undulant number ; Function to check if a string is double string or not ; a and b should not be equal ; Condition to check if length is odd make length even ; first half of s ; second half of s ; Double string if first and last half are equal ; Function to check if N is an Nontrivial undulant number ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isDouble ( int num ) { string s = to_string ( num ) ; int l = s . length ( ) ; if ( s [ 0 ] == s [ 1 ] ) return false ; if ( l % 2 == 1 ) { s = s + s [ 1 ] ; l ++ ; } string s1 = s . substr ( 0 , l / 2 ) ; string s2 = s . substr ( l / 2 ) ; return s1 == s2 ; } bool isNontrivialUndulant ( int N ) { return N > 100 && isDouble ( N ) ; } int main ( ) { int n = 121 ; if ( isNontrivialUndulant ( n ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "text_ms": "Nombor undulant nontrivial | Pelaksanaan C ++ untuk memeriksa sama ada N adalah nombor undulant nontrivial; Fungsi untuk memeriksa sama ada rentetan adalah rentetan ganda atau tidak; A dan B tidak sepatutnya sama; Keadaan untuk memeriksa sama ada panjang ganjil membuat panjang walaupun; separuh pertama s; separuh kedua s; Rentetan double jika separuh pertama dan terakhir adalah sama; Fungsi untuk memeriksa sama ada n adalah nombor undulant yang tidak dapat dipulihkan; Kod pemacu"}
{"text": "Megagon number | C ++ implementation for the above approach ; Function to find the nth Megagon Number ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int MegagonNum ( int n ) { return ( 999998 * n * n - 999996 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << MegagonNum ( n ) ; return 0 ; }", "text_ms": "Nombor Megagon | C ++ pelaksanaan untuk pendekatan di atas; Berfungsi untuk mencari nombor megagon nth; Kod pemacu"}
{"text": "Product of all the pairs from the given array | C ++ implementation to find the product of all the pairs from the given array ; Function to return the product of the elements of all possible pairs from the array ; To store the required product ; Nested loop to calculate all possible pairs ; Multiply the product of the elements of the current pair ; Return the final result ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define mod  1000000007 NEW_LINE int productPairs ( int arr [ ] , int n ) { int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { product *= ( arr [ i ] % mod * arr [ j ] % mod ) % mod ; product = product % mod ; } } return product % mod ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << productPairs ( arr , n ) ; return 0 ; }", "text_ms": "Produk semua pasangan dari array yang diberikan | C ++ pelaksanaan untuk mencari produk semua pasangan dari array yang diberikan; Berfungsi untuk mengembalikan produk unsur -unsur semua pasangan yang mungkin dari array; Untuk menyimpan produk yang diperlukan; Gelung bersarang untuk mengira semua pasangan yang mungkin; Melipatgandakan produk unsur -unsur pasangan semasa; Mengembalikan hasil akhir; Kod pemacu"}
{"text": "Product of all the pairs from the given array | C ++ implementation to Find the product of all the pairs from the given array ; Function to calculate ( x ^ y ) % 1000000007 ; Initialize result ; Update x if it is more than or equal to p ; If y is odd , multiply x with result ; Return the final result ; Function to return the product of the elements of all possible pairs from the array ; To store the required product ; Iterate for every element of the array ; Each element appears ( 2 * n ) times ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define mod  1000000007 NEW_LINE #define ll  long long int NEW_LINE int power ( int x , unsigned int y ) { int p = 1000000007 ; int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; } ll productPairs ( ll arr [ ] , ll n ) { ll product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { product = ( product % mod * ( int ) power ( arr [ i ] , ( 2 * n ) ) % mod ) % mod ; } return product % mod ; } int main ( ) { ll arr [ ] = { 1 , 2 , 3 } ; ll n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << productPairs ( arr , n ) ; return 0 ; }", "text_ms": "Produk semua pasangan dari array yang diberikan | C ++ pelaksanaan untuk mencari produk semua pasangan dari array yang diberikan; Fungsi untuk mengira (x ^ y) % 1000000007; Memulakan hasil; Kemas kini X jika lebih daripada atau sama dengan P; Jika y adalah ganjil, kalikan x dengan hasil; Mengembalikan hasil akhir; Berfungsi untuk mengembalikan produk unsur -unsur semua pasangan yang mungkin dari array; Untuk menyimpan produk yang diperlukan; Berulang untuk setiap elemen array; Setiap elemen muncul (2 * n) kali; Kod pemacu"}
{"text": "Construct an Array such that cube sum of all element is a perfect square | C ++ program to construct an array that cube sum of all element is a perfect square ; Function to create and print the array ; initialise the array of size N ; Print the array ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void constructArray ( int N ) { int arr [ N ] ; for ( int i = 1 ; i <= N ; i ++ ) { arr [ i - 1 ] = i ; } for ( int i = 0 ; i < N ; i ++ ) { cout << arr [ i ] << \" , ▁ \" ; } } int main ( ) { int N = 6 ; constructArray ( N ) ; return 0 ; }", "text_ms": "Membina array sedemikian rupa sehingga jumlah kiub semua elemen adalah persegi yang sempurna | Program C ++ untuk membina array bahawa jumlah kiub semua elemen adalah persegi yang sempurna; Berfungsi untuk membuat dan mencetak array; memulakan pelbagai saiz n; Cetak array; Kod pemacu"}
{"text": "Count of all subsequence whose product is a Composite number | C ++ implementation to count all subsequence whose product is Composite number ; Function to check whether a number is prime or not ; Function to find number of subsequences whose product is a composite number ; Find total non empty subsequence ; Find count of prime number and ones ; Calculate the non empty one subsequence ; Find count of composite subsequence ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } int countSubsequences ( int arr [ ] , int n ) { int totalSubsequence = pow ( 2 , n ) - 1 ; int countPrime = 0 , countOnes = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) countOnes ++ ; else if ( isPrime ( arr [ i ] ) ) countPrime ++ ; } int compositeSubsequence ; int onesSequence = pow ( 2 , countOnes ) - 1 ; compositeSubsequence = totalSubsequence - countPrime - onesSequence - onesSequence * countPrime ; return compositeSubsequence ; } int main ( ) { int arr [ ] = { 2 , 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countSubsequences ( arr , n ) ; return 0 ; }", "text_ms": "Kira semua seterusnya yang produknya adalah nombor komposit | C ++ pelaksanaan untuk mengira semua seterusnya yang produknya adalah nombor komposit; Berfungsi untuk memeriksa sama ada nombor adalah perdana atau tidak; Berfungsi untuk mencari bilangan berikutnya yang produknya adalah nombor komposit; Cari jumlah berikutnya yang tidak kosong; Cari kiraan nombor utama dan yang; Kirakan yang tidak kosong; Cari kiraan seterusnya komposit; Kod pemacu"}
{"text": "Find K consecutive integers such that their sum is N | C ++ implementation to check if a number can be expressed as sum of K consecutive integer ; Function to check if a number can be expressed as the sum of k consecutive ; Finding the first term of AP ; Checking if first term is an integer ; Loop to print the K consecutive integers ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void checksum ( int n , int k ) { float first_term = ( ( 2 * n ) / k + ( 1 - k ) ) / 2.0 ; if ( first_term - int ( first_term ) == 0 ) { for ( int i = first_term ; i <= first_term + k - 1 ; i ++ ) { cout << i << \" ▁ \" ; } } else cout << \" - 1\" ; } int main ( ) { int n = 33 , k = 6 ; checksum ( n , k ) ; return 0 ; }", "text_ms": "Cari integer berturut -turut seperti jumlah mereka adalah n | C ++ pelaksanaan untuk memeriksa sama ada nombor boleh dinyatakan sebagai jumlah integer K berturut -turut; Fungsi untuk memeriksa sama ada nombor boleh dinyatakan sebagai jumlah K berturut -turut; Mencari istilah pertama AP; Memeriksa jika istilah pertama adalah integer; Gelung untuk mencetak integer K berturut -turut; Kod pemacu"}
{"text": "Represent N as sum of K even numbers | C ++ implementation to represent N as sum of K even numbers ; Function to print the representation ; N must be greater than equal to 2 * K and must be even ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void sumEvenNumbers ( int N , int K ) { int check = N - 2 * ( K - 1 ) ; if ( check > 0 && check % 2 == 0 ) { for ( int i = 0 ; i < K - 1 ; i ++ ) { cout << \"2 ▁ \" ; } cout << check ; } else { cout << \" - 1\" ; } } int main ( ) { int N = 8 ; int K = 2 ; sumEvenNumbers ( N , K ) ; return 0 ; }", "text_ms": "Mewakili n sebagai jumlah k angka bahu | C ++ pelaksanaan untuk mewakili N sebagai jumlah kalah K walaupun; Berfungsi untuk mencetak perwakilan; N mestilah lebih besar daripada sama dengan 2 * k dan mestilah bahkan; Kod pemacu"}
{"text": "Count of contiguous subarrays possible for every index by including the element at that index | C ++ program to find the number of contiguous subarrays including the element at every index of the array of size N ; Function to find the number of subarrays including the element at every index of the array ; Creating an array of size N ; The loop is iterated till half the length of the array ; Condition to avoid overwriting the middle element for the array with even length . ; Computing the number of subarrays ; The ith element from the beginning and the ending have the same number of possible subarrays ; Function to print the vector ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > calculateWays ( int N ) { int x = 0 ; vector < int > v ; for ( int i = 0 ; i < N ; i ++ ) v . push_back ( 0 ) ; for ( int i = 0 ; i <= N / 2 ; i ++ ) { if ( N % 2 == 0 && i == N / 2 ) break ; x = N * ( i + 1 ) - ( i + 1 ) * i ; v [ i ] = x ; v [ N - i - 1 ] = x ; } return v ; } void printArray ( vector < int > v ) { for ( int i = 0 ; i < v . size ( ) ; i ++ ) cout << v [ i ] << \" ▁ \" ; } int main ( ) { vector < int > v ; v = calculateWays ( 4 ) ; printArray ( v ) ; return 0 ; }", "text_ms": "Count of Subarrays Bersebelahan mungkin untuk setiap indeks dengan memasukkan elemen pada indeks itu | Program C ++ untuk mencari bilangan subarray bersebelahan termasuk elemen pada setiap indeks pelbagai saiz n; Berfungsi untuk mencari bilangan subarray termasuk elemen pada setiap indeks array; Mewujudkan pelbagai saiz n; Gelung itu berulang sehingga separuh panjang array; Keadaan untuk mengelakkan menimpa elemen pertengahan untuk array dengan panjangnya. ; Pengkomputeran bilangan subarray; Unsur ITH dari awal dan berakhir mempunyai bilangan subarray yang sama; Berfungsi untuk mencetak vektor; Kod pemacu"}
{"text": "Smallest number greater than or equal to X whose sum of digits is divisible by Y | C ++ program to find the smallest number greater than or equal to X and divisible by Y ; Function that returns the sum of digits of a number ; Initialize variable to store the sum ; Add the last digit of the number ; Remove the last digit from the number ; Function that returns the smallest number greater than or equal to X and divisible by Y ; Initialize result variable ; Loop through numbers greater than equal to X ; Calculate sum of digits ; Check if sum of digits is divisible by Y ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAXN  10000000 NEW_LINE int sumOfDigits ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += n % 10 ; n /= 10 ; } return sum ; } int smallestNum ( int X , int Y ) { int res = -1 ; for ( int i = X ; i < MAXN ; i ++ ) { int sum_of_digit = sumOfDigits ( i ) ; if ( sum_of_digit % Y == 0 ) { res = i ; break ; } } return res ; } int main ( ) { int X = 5923 , Y = 13 ; cout << smallestNum ( X , Y ) ; return 0 ; }", "text_ms": "Nombor terkecil lebih besar daripada atau sama dengan x yang jumlah digitnya boleh dibahagikan dengan y | Program C ++ untuk mencari bilangan terkecil yang lebih besar daripada atau sama dengan x dan dibahagikan dengan y; Fungsi yang mengembalikan jumlah digit nombor; Memulakan pembolehubah untuk menyimpan jumlah; Tambah digit terakhir nombor; Keluarkan digit terakhir dari nombor; Fungsi yang mengembalikan bilangan terkecil lebih besar daripada atau sama dengan x dan dibahagikan dengan y; Memulakan pemboleh ubah hasil; Gelung melalui nombor yang lebih besar daripada sama dengan x; Hitung jumlah digit; Semak sama ada jumlah digit boleh dibahagikan dengan y; Kod pemacu"}
{"text": "Count the numbers which can convert N to 1 using given operation | C ++ program to count the numbers which can convert N to 1 using the given operation ; Function to count the numbers which can convert N to 1 using the given operation ; Store all the divisors of N ; If i is a divisor ; If i is not equal to N / i ; Iterate through all the divisors of N - 1 and count them in answer ; Check if N - 1 is a divisor or not ; Iterate through all divisors and check for N mod d = 1 or ( N - 1 ) mod d = 0 ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countValues ( int N ) { vector < int > div ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { div . push_back ( i ) ; if ( N != i * i ) { div . push_back ( N / i ) ; } } } int answer = 0 ; for ( int i = 1 ; i * i <= N - 1 ; i ++ ) { if ( ( N - 1 ) % i == 0 ) { if ( i * i == N - 1 ) answer ++ ; else answer += 2 ; } } for ( auto d : div ) { int K = N ; while ( K % d == 0 ) K /= d ; if ( ( K - 1 ) % d == 0 ) answer ++ ; } return answer ; } int main ( ) { int N = 6 ; cout << countValues ( N ) ; return 0 ; }", "text_ms": "Kira nombor yang boleh menukar n hingga 1 menggunakan operasi yang diberikan | Program C ++ untuk mengira nombor yang boleh menukar n hingga 1 menggunakan operasi yang diberikan; Fungsi untuk mengira nombor yang boleh menukar n ke 1 menggunakan operasi yang diberikan; Simpan semua pembahagi n; Jika saya seorang pembahagi; Jika saya tidak sama dengan N / I; Melangkah melalui semua pembahagi n - 1 dan mengira mereka sebagai jawapan; Semak jika N - 1 adalah pembahagi atau tidak; Melangkah melalui semua pembahagi dan semak n Mod D = 1 atau (n - 1) mod d = 0; Kod pemacu"}
{"text": "Maximum possible prime divisors that can exist in numbers having exactly N divisors | C ++ implementation to find the maximum possible prime divisor of a number can have N divisors ; Function to find the maximum possible prime divisors of a number can have with N divisors ; Number of time number divided by 2 ; Divide by other prime numbers ; If the last number of also prime then also include it ; Driver Code ; Function Call", "code": "#include <iostream> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE void findMaxPrimeDivisor ( int n ) { int max_possible_prime = 0 ; while ( n % 2 == 0 ) { max_possible_prime ++ ; n = n / 2 ; } for ( int i = 3 ; i * i <= n ; i = i + 2 ) { while ( n % i == 0 ) { max_possible_prime ++ ; n = n / i ; } } if ( n > 2 ) { max_possible_prime ++ ; } cout << max_possible_prime << \" STRNEWLINE \" ; } int main ( ) { int n = 4 ; findMaxPrimeDivisor ( n ) ; return 0 ; }", "text_ms": "Maksimum mungkin pembahagi utama yang boleh wujud dalam nombor yang mempunyai tepat n pembahagi | C ++ pelaksanaan untuk mencari pembahagi utama maksimum nombor boleh mempunyai pembahagi N; Berfungsi untuk mencari pembahagi utama maksimum nombor yang boleh dimiliki dengan pembahagi N; Bilangan bilangan masa dibahagikan dengan 2; Membahagikan dengan nombor perdana lain; Jika bilangan terakhir juga perdana maka juga memasukkannya; Kod pemacu; Panggilan fungsi"}
{"text": "Count ways to express a number as sum of exactly two numbers | C ++ program to Count ways to express a number as sum of two numbers . ; Function returns the count of ways express a number as sum of two numbers . ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int CountWays ( int n ) { int ans = ( n - 1 ) / 2 ; return ans ; } int main ( ) { int N = 8 ; cout << CountWays ( N ) ; }", "text_ms": "Kira cara untuk menyatakan nombor sebagai jumlah tepat dua nombor | Program C ++ untuk mengira cara untuk menyatakan nombor sebagai jumlah dua nombor. ; Fungsi Mengembalikan kiraan cara menyatakan nombor sebagai jumlah dua nombor. ; Kod pemacu"}
{"text": "Divide array in two maximum equal length arrays of similar and dissimilar elements | C ++ program to find the max - size to which an array can be divided into 2 equal parts such that one part contains unique elements while another contains similar elements ; Function to find the max - size to which an array can be divided into 2 equal parts ; Vector to find the frequency of each element of array ; Find the maximum frequency element present in array arr [ ] ; Find total unique elements present in array arr [ ] ; Find the Max - Size to which an array arr [ ] can be splitted ; Find the first array containing same elements ; Find the second array containing unique elements ; Driver code ; initialise n ; array declaration ; size of array", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void Solve ( int arr [ ] , int size , int n ) { vector < int > v ( n + 1 ) ; for ( int i = 0 ; i < size ; i ++ ) v [ arr [ i ] ] ++ ; int max1 = ( max_element ( v . begin ( ) , v . end ( ) ) - v . begin ( ) ) ; int diff1 = n + 1 - count ( v . begin ( ) , v . end ( ) , 0 ) ; int max_size = max ( min ( v [ max1 ] - 1 , diff1 ) , min ( v [ max1 ] , diff1 - 1 ) ) ; cout << \" Maximum ▁ size ▁ is ▁ : \" << max_size << \" STRNEWLINE \" ; cout << \" The ▁ First ▁ Array ▁ Is ▁ : ▁ STRNEWLINE \" ; for ( int i = 0 ; i < max_size ; i ++ ) { cout << max1 << \" ▁ \" ; v [ max1 ] -= 1 ; } cout << \" STRNEWLINE \" ; cout << \" The ▁ Second ▁ Array ▁ Is ▁ : ▁ STRNEWLINE \" ; for ( int i = 0 ; i < ( n + 1 ) ; i ++ ) { if ( v [ i ] > 0 ) { cout << i << \" ▁ \" ; max_size -- ; } if ( max_size < 1 ) break ; } cout << \" STRNEWLINE \" ; } int main ( ) { int n = 7 ; int arr [ ] = { 1 , 2 , 1 , 5 , 1 , 6 , 7 , 2 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; Solve ( arr , size , n ) ; return 0 ; }", "text_ms": "Bahagikan array dalam dua tatasusunan panjang maksimum yang sama dengan unsur -unsur yang serupa dan berbeza | Program C ++ untuk mencari saiz maksimum yang mana array boleh dibahagikan kepada 2 bahagian yang sama supaya satu bahagian mengandungi unsur -unsur yang unik manakala yang lain mengandungi unsur -unsur yang sama; Berfungsi untuk mencari saiz maksimum yang mana array boleh dibahagikan kepada 2 bahagian yang sama; Vektor untuk mencari kekerapan setiap elemen array; Cari elemen frekuensi maksimum yang terdapat dalam array arr []; Cari jumlah elemen unik yang terdapat dalam array arr []; Cari saiz maksimum yang mana array arr [] boleh dibuang; Cari array pertama yang mengandungi elemen yang sama; Cari array kedua yang mengandungi unsur -unsur yang unik; Kod pemacu; permulaan n; perisytiharan array; saiz array"}
{"text": "Find sum of xor of all unordered triplets of the array | C ++ program to find sum of xor of all unordered triplets of the array ; Iterative Function to calculate ( x ^ y ) % p in O ( log y ) ; Initialize result ; Update x if it is more than or equal to p ; If y is odd , multiply x with result ; y must be even now y = y >> 1 ; y = y / 2 ; Returns n ^ ( - 1 ) mod p ; Returns nCr % p using Fermat 's little theorem. ; Base case ; Fill factorial array so that we can find all factorial of r , n and n - r ; Function returns sum of xor of all unordered triplets of the array ; Iterating over the bits ; Number of elements whith k 'th bit  1 and 0 respectively ; Checking if k 'th bit is 1 ; Adding this bit 's part to the answer ; Drivers code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } int modInverse ( int n , int p ) { return power ( n , p - 2 , p ) ; } int nCrModPFermat ( int n , int r , int p ) { if ( r == 0 ) return 1 ; if ( n < r ) return 0 ; int fac [ n + 1 ] ; fac [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fac [ i ] = fac [ i - 1 ] * i % p ; return ( fac [ n ] * modInverse ( fac [ r ] , p ) % p * modInverse ( fac [ n - r ] , p ) % p ) % p ; } int SumOfXor ( int a [ ] , int n ) { int mod = 10037 ; int answer = 0 ; for ( int k = 0 ; k < 32 ; k ++ ) { int x = 0 , y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] & ( 1 << k ) ) x ++ ; else y ++ ; } answer += ( ( 1 << k ) % mod * ( nCrModPFermat ( x , 3 , mod ) + x * nCrModPFermat ( y , 2 , mod ) ) % mod ) % mod ; } return answer ; } int main ( ) { int n = 5 ; int A [ n ] = { 3 , 5 , 2 , 18 , 7 } ; cout << SumOfXor ( A , n ) ; return 0 ; }", "text_ms": "Cari Jumlah Xor semua tiga kali ganda yang tidak teratur dari array | Program C ++ untuk mencari jumlah XOR dari semua triplet yang tidak teratur dari array; Fungsi iteratif untuk mengira (x ^ y) % p dalam o (log y); Memulakan hasil; Kemas kini X jika lebih daripada atau sama dengan P; Jika y adalah ganjil, kalikan x dengan hasil; y mestilah sekarang y = y >> 1; y = y / 2; Mengembalikan n ^ ( - 1) mod p; Mengembalikan NCR % P menggunakan teorem kecil Fermat. ; Kes asas; Isi pelbagai faktorial supaya kita dapat mencari semua faktorial r, n dan n - r; Fungsi mengembalikan jumlah XOR dari semua triplet yang tidak teratur dari array; Melangkah ke atas bit; Bilangan elemen yang masing -masing 1 dan 0; Memeriksa jika k 'th bit adalah 1; Menambah bahagian bit ini kepada jawapannya; Kod pemandu"}
{"text": "Probability of not getting two consecutive heads together in N tosses of coin | C ++ implementation to find the probability of not getting two consecutive heads together when N coins are tossed ; Function to compute the N - th Fibonacci number in the sequence where a = 2 and b = 3 ; The first two numbers in the sequence are initialized ; Base cases ; Loop to compute the fibonacci sequence based on the first two initialized numbers ; Function to find the probability of not getting two consecutive heads when N coins are tossed ; Computing the number of favourable cases ; Computing the number of all possible outcomes for N tosses ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float round ( float var , int digit ) { float value = ( int ) ( var * pow ( 10 , digit ) + .5 ) ; return ( float ) value / pow ( 10 , digit ) ; } int probability ( int N ) { int a = 2 ; int b = 3 ; if ( N == 1 ) { return a ; } else if ( N == 2 ) { return b ; } else { for ( int i = 3 ; i <= N ; i ++ ) { int c = a + b ; a = b ; b = c ; } return b ; } } float operations ( int N ) { int x = probability ( N ) ; int y = pow ( 2 , N ) ; return round ( ( float ) x / ( float ) y , 2 ) ; } int main ( ) { int N = 10 ; cout << ( operations ( N ) ) ; }", "text_ms": "Kebarangkalian tidak mendapat dua kepala berturut -turut bersama -sama di N melemparkan duit syiling | C ++ pelaksanaan untuk mencari kebarangkalian tidak mendapat dua kepala berturut -turut bersama apabila duit syiling N dibuang; Fungsi untuk mengira nombor Fibonacci N - Th dalam urutan di mana A = 2 dan B = 3; Dua nombor pertama dalam urutan dimulakan; Kes asas; Gelung untuk mengira urutan Fibonacci berdasarkan dua nombor pertama yang diasaskan; Fungsi untuk mencari kebarangkalian tidak mendapat dua kepala berturut -turut apabila duit syiling N dibuang; Mengira bilangan kes yang menggalakkan; Pengkomputeran bilangan semua hasil yang mungkin untuk N TOSses; Kod pemacu"}
{"text": "Check if number formed by joining two Numbers is Perfect Cube | C ++ program to check if the concatenation of two numbers is a perfect cube or not ; Function to check if a number is a perfect Cube or not ; Function to check if concatenation of two numbers is a perfect cube or not ; Convert numbers to string using to_string ( ) ; Concatenate the numbers and convert it into integer ; Check if concatenated value is perfect cube or not ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPerfectCube ( int x ) { long double cr = round ( cbrt ( x ) ) ; return ( cr * cr * cr == x ) ; } void checkCube ( int a , int b ) { string s1 = to_string ( a ) ; string s2 = to_string ( b ) ; int c = stoi ( s1 + s2 ) ; if ( isPerfectCube ( c ) ) { cout << \" Yes \" ; } else { cout << \" No \" ; } } int main ( ) { int a = 6 ; int b = 4 ; checkCube ( a , b ) ; return 0 ; }", "text_ms": "Semak jika nombor dibentuk dengan menyertai dua nombor adalah Cube Perfect | Program C ++ untuk memeriksa sama ada penggabungan dua nombor adalah kiub yang sempurna atau tidak; Berfungsi untuk memeriksa sama ada nombor adalah kiub yang sempurna atau tidak; Fungsi untuk memeriksa sama ada penggabungan dua nombor adalah kiub yang sempurna atau tidak; Menukar nombor ke rentetan menggunakan to_string (); Menggabungkan nombor dan menukarnya menjadi integer; Semak jika nilai yang disatukan adalah kiub sempurna atau tidak; Kod pemacu"}
{"text": "Largest number in given Array formed by repeatedly combining two same elements | C ++ implementation of the above approach ; Function to return the largest sum ; Variable to store the largest sum ; Map to store the frequencies of each element ; Store the Frequencies ; Loop to combine duplicate elements and update the sum in the map ; If j is a duplicate element ; Update the frequency of 2 * j ; If the new sum is greater than maximum value , Update the maximum ; Returns the largest sum ; Driver Code ; Function Calling", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int largest_sum ( int arr [ ] , int n ) { int maximum = -1 ; map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) { m [ arr [ i ] ] ++ ; } for ( auto j : m ) { if ( j . second > 1 ) { m [ 2 * j . first ] = m [ 2 * j . first ] + j . second / 2 ; if ( 2 * j . first > maximum ) maximum = 2 * j . first ; } } return maximum ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 4 , 7 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << largest_sum ( arr , n ) ; return 0 ; }", "text_ms": "Nombor terbesar dalam array yang dibentuk dengan berulang kali menggabungkan dua elemen yang sama | C ++ pelaksanaan pendekatan di atas; Berfungsi untuk mengembalikan jumlah terbesar; Pembolehubah untuk menyimpan jumlah terbesar; Peta untuk menyimpan frekuensi setiap elemen; Menyimpan frekuensi; Gelung untuk menggabungkan elemen pendua dan mengemas kini jumlah dalam peta; Jika J adalah elemen pendua; Kemas kini kekerapan 2 * j; Jika jumlah baru lebih besar daripada nilai maksimum, kemas kini maksimum; Mengembalikan jumlah terbesar; Kod pemacu; Fungsi panggilan"}
{"text": "Check if it is possible to make x and y zero at same time with given operation | C ++ program of the above approach ; Function to check if it is possible to make x and y can become 0 at same time ; Check the given conditions ; Driver Code ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void canBeReduced ( int x , int y ) { int maxi = max ( x , y ) ; int mini = min ( x , y ) ; if ( ( ( x + y ) % 3 ) == 0 && maxi <= 2 * mini ) cout << \" YES \" << endl ; else cout << \" NO \" << endl ; } int main ( ) { int x = 6 , y = 9 ; canBeReduced ( x , y ) ; return 0 ; }", "text_ms": "Semak sama ada mungkin untuk membuat X dan Y Zero pada masa yang sama dengan Operasi yang diberikan | C ++ program pendekatan di atas; Fungsi untuk memeriksa sama ada mungkin untuk membuat X dan Y boleh menjadi 0 pada masa yang sama; Semak syarat yang diberikan; Kod pemacu; Panggilan fungsi"}
{"text": "Wheel Factorization Algorithm | C ++ program to check if the given number is prime using Wheel Factorization Method ; Function to check if a given number x is prime or not ; The Wheel for checking prime number ; Base Case ; Check for the number taken as basis ; Check for Wheel Here i , acts as the layer of the wheel ; Check for the list of Sieve in arr [ ] ; If number is greater than sqrt ( N ) break ; Check if N is a multiple of prime number in the wheel ; If at any iteration isPrime is false , break from the loop ; Driver 's Code ; Function call for primality check", "code": "#include \" bits / stdc + + . h \" NEW_LINE using namespace std ; void isPrime ( int N ) { bool isPrime = true ; int arr [ 8 ] = { 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 } ; if ( N < 2 ) { isPrime = false ; } if ( N % 2 == 0 N % 3 == 0 N % 5 == 0 ) { isPrime = false ; } for ( int i = 0 ; i < sqrt ( N ) ; i += 30 ) { for ( int c : arr ) { if ( c > sqrt ( N ) ) { break ; } else { if ( N % ( c + i ) == 0 ) { isPrime = false ; break ; } } if ( ! isPrime ) break ; } } if ( isPrime ) cout << \" Prime ▁ Number \" ; else cout << \" Not ▁ a ▁ Prime ▁ Number \" ; } int main ( ) { int N = 121 ; isPrime ( N ) ; return 0 ; }", "text_ms": "Algoritma Pemfaktoran Roda | Program C ++ untuk memeriksa sama ada nombor yang diberikan adalah kaedah pemfaktoran roda; Fungsi untuk memeriksa sama ada nombor x yang diberikan adalah perdana atau tidak; Roda untuk memeriksa nombor perdana; Kes asas; Semak nombor yang diambil sebagai asas; Semak roda di sini saya, bertindak sebagai lapisan roda; Semak senarai penapis dalam arr []; Jika nombor lebih besar daripada rehat Sqrt (n); Semak jika n adalah pelbagai nombor utama di roda; Jika di mana -mana lelaran isprime adalah palsu, pecah dari gelung; Kod pemandu; Fungsi panggilan untuk pemeriksaan primal"}
{"text": "Find all Pairs possible from the given Array | C ++ implementation to find all Pairs possible from the given Array ; Function to print all possible pairs from the array ; Nested loop for all possible pairs ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printPairs ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { cout << \" ( \" << arr [ i ] << \" , ▁ \" << arr [ j ] << \" ) \" << \" , ▁ \" ; } } } int main ( ) { int arr [ ] = { 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printPairs ( arr , n ) ; return 0 ; }", "text_ms": "Cari semua pasangan yang mungkin dari array yang diberikan | C ++ pelaksanaan untuk mencari semua pasangan yang mungkin dari array yang diberikan; Berfungsi untuk mencetak semua pasangan yang mungkin dari array; Gelung bersarang untuk semua pasangan yang mungkin; Kod pemacu"}
{"text": "Sum of cubes of all Subsets of given Array | C ++ implementation of the approach ; Function to return ( 2 ^ P % mod ) ; Function to return the sum of cubes of subsets ; cubing the elements and adding it to ans ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int mod = 1e9 + 7 ; long long power ( int p ) { long long res = 1 ; for ( int i = 1 ; i <= p ; ++ i ) { res *= 2 ; res %= mod ; } return res % mod ; } long long subset_cube_sum ( vector < int > & A ) { int n = ( int ) A . size ( ) ; long long ans = 0 ; for ( int i : A ) { ans += ( 1LL * i * i * i ) % mod ; ans %= mod ; } return ( 1LL * ans * power ( n - 1 ) ) % mod ; } int main ( ) { vector < int > A = { 1 , 2 } ; cout << subset_cube_sum ( A ) ; return 0 ; }", "text_ms": "Jumlah kiub semua subset dari array yang diberikan | C ++ pelaksanaan pendekatan; Berfungsi untuk kembali (2 ^ p % mod); Berfungsi untuk mengembalikan jumlah kiub subset; Cubing unsur -unsur dan menambahkannya ke Ans; Kod pemacu"}
{"text": "Least number to be added to or subtracted from N to make it a Perfect Cube | C ++ implementation of the approach ; Function to return the Least number ; Get the perfect cube before and after N ; Check which is nearest to N ; return the result ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int nearest ( int n ) { int prevCube = cbrt ( n ) ; int nextCube = prevCube + 1 ; prevCube = prevCube * prevCube * prevCube ; nextCube = nextCube * nextCube * nextCube ; int ans = ( n - prevCube ) < ( nextCube - n ) ? ( prevCube - n ) : ( nextCube - n ) ; return ans ; } int main ( ) { int n = 25 ; cout << nearest ( n ) << endl ; n = 27 ; cout << nearest ( n ) << endl ; n = 40 ; cout << nearest ( n ) << endl ; return 0 ; }", "text_ms": "Paling kurang nombor yang akan ditambah atau dikurangkan dari n untuk menjadikannya kiub yang sempurna | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan nombor paling sedikit; Dapatkan kiub yang sempurna sebelum dan selepas n; Periksa yang paling dekat dengan n; mengembalikan hasilnya; Kod pemacu"}
{"text": "Check if a circle lies inside another circle or not | C ++ program to check if one circle lies inside another circle or not . ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = sqrt ( ( ( x1 - x2 ) * ( x1 - x2 ) ) + ( ( y1 - y2 ) * ( y1 - y2 ) ) ) ; if ( distSq + r2 == r1 ) cout << \" The ▁ smaller ▁ circle ▁ lies ▁ completely \" << \" ▁ inside ▁ the ▁ bigger ▁ circle ▁ with ▁ \" << \" touching ▁ each ▁ other ▁ \" << \" at ▁ a ▁ point ▁ of ▁ circumference . ▁ \" << endl ; else if ( distSq + r2 < r1 ) cout << \" The ▁ smaller ▁ circle ▁ lies ▁ completely \" << \" ▁ inside ▁ the ▁ bigger ▁ circle ▁ without \" << \" ▁ touching ▁ each ▁ other ▁ \" << \" at ▁ a ▁ point ▁ of ▁ circumference . ▁ \" << endl ; else cout << \" The ▁ smaller ▁ does ▁ not ▁ lies ▁ inside \" << \" ▁ the ▁ bigger ▁ circle ▁ completely . \" << endl ; } int main ( ) { int x1 = 10 , y1 = 8 ; int x2 = 1 , y2 = 2 ; int r1 = 30 , r2 = 10 ; circle ( x1 , y1 , x2 , y2 , r1 , r2 ) ; return 0 ; }", "text_ms": "Semak jika bulatan terletak di dalam bulatan lain atau tidak | Program C ++ untuk memeriksa sama ada satu bulatan terletak di dalam bulatan lain atau tidak. ; Kod pemacu"}
{"text": "Length of direct common tangent between two intersecting Circles | C ++ program to find the length of the direct common tangent between two circles which intersect each other ; Function to find the length of the direct common tangent ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void lengtang ( double r1 , double r2 , double d ) { cout << \" The ▁ length ▁ of ▁ the ▁ direct \" << \" ▁ common ▁ tangent ▁ is ▁ \" << sqrt ( pow ( d , 2 ) - pow ( ( r1 - r2 ) , 2 ) ) << endl ; } int main ( ) { double r1 = 4 , r2 = 6 , d = 3 ; lengtang ( r1 , r2 , d ) ; return 0 ; }", "text_ms": "Panjang tangen biasa langsung antara dua lingkaran bersilang | Program C ++ untuk mencari panjang tangen umum langsung antara dua kalangan yang saling berpotongan; Berfungsi untuk mencari panjang tangen biasa langsung; Kod pemacu"}
{"text": "Radius of the circle when the width and height of an arc is given | C ++ program to find radius of the circle when the width and height of an arc is given ; Function to find the radius ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void rad ( double d , double h ) { cout << \" The ▁ radius ▁ of ▁ the ▁ circle ▁ is ▁ \" << ( ( d * d ) / ( 8 * h ) + h / 2 ) << endl ; } int main ( ) { double d = 4 , h = 1 ; rad ( d , h ) ; return 0 ; }", "text_ms": "Radius bulatan apabila lebar dan ketinggian arka diberikan | Program C ++ untuk mencari jejari bulatan apabila lebar dan ketinggian arka diberikan; Berfungsi untuk mencari jejari; Kod pemacu"}
{"text": "Shortest distance from the centre of a circle to a chord | C ++ program to find the shortest distance from chord to the centre of circle ; Function to find the shortest distance ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void shortdis ( double r , double d ) { cout << \" The ▁ shortest ▁ distance ▁ \" << \" from ▁ the ▁ chord ▁ to ▁ centre ▁ \" << sqrt ( ( r * r ) - ( ( d * d ) / 4 ) ) << endl ; } int main ( ) { double r = 4 , d = 3 ; shortdis ( r , d ) ; return 0 ; }", "text_ms": "Jarak terpendek dari pusat bulatan ke kord | Program C ++ untuk mencari jarak terpendek dari kord ke pusat bulatan; Berfungsi untuk mencari jarak terpendek; Kod pemacu"}
{"text": "Length of direct common tangent between the two non | C ++ program to find the length of the direct common tangent between two circles which donot touch each other ; Function to find the length of the direct common tangent ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void lengtang ( double r1 , double r2 , double d ) { cout << \" The ▁ length ▁ of ▁ the ▁ direct \" << \" ▁ common ▁ tangent ▁ is ▁ \" << sqrt ( pow ( d , 2 ) - pow ( ( r1 - r2 ) , 2 ) ) << endl ; } int main ( ) { double r1 = 4 , r2 = 6 , d = 12 ; lengtang ( r1 , r2 , d ) ; return 0 ; }", "text_ms": "Panjang tangen biasa langsung antara kedua -dua bukan | Program C ++ untuk mencari panjang tangen umum langsung antara dua kalangan yang tidak menyentuh satu sama lain; Berfungsi untuk mencari panjang tangen biasa langsung; Kod pemacu"}
{"text": "Biggest Square that can be inscribed within an Equilateral triangle | C ++ Program to find the biggest square which can be inscribed within the equilateral triangle ; Function to find the side of the square ; the side cannot be negative ; side of the square ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float square ( float a ) { if ( a < 0 ) return -1 ; float x = 0.464 * a ; return x ; } int main ( ) { float a = 5 ; cout << square ( a ) << endl ; return 0 ; }", "text_ms": "Dataran terbesar yang boleh ditulis dalam segitiga sama rata | Program C ++ untuk mencari dataran terbesar yang boleh ditulis dalam segitiga sama rata; Berfungsi untuk mencari sisi dataran; Sisi tidak boleh negatif; sisi dataran; Kod pemacu"}
{"text": "Apothem of a n | C ++ Program to find the apothem of a regular polygon with given side length ; Function to find the apothem of a regular polygon ; Side and side length cannot be negative ; Degree converted to radians ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float polyapothem ( float n , float a ) { if ( a < 0 && n < 0 ) return -1 ; return a / ( 2 * tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; } int main ( ) { float a = 9 , n = 6 ; cout << polyapothem ( n , a ) << endl ; return 0 ; }", "text_ms": "Apothem A N | Program C ++ untuk mencari apothem poligon biasa dengan panjang sampingan yang diberikan; Berfungsi untuk mencari apothem poligon biasa; Panjang sampingan dan sampingan tidak boleh negatif; Ijazah ditukar kepada radian; Kod pemacu"}
{"text": "Area of a n | C ++ Program to find the area of a regular polygon with given side length ; Function to find the area of a regular polygon ; Side and side length cannot be negative ; Area degree converted to radians ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float polyarea ( float n , float a ) { if ( a < 0 && n < 0 ) return -1 ; float A = ( a * a * n ) / ( 4 * tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; return A ; } int main ( ) { float a = 9 , n = 6 ; cout << polyarea ( n , a ) << endl ; return 0 ; }", "text_ms": "Kawasan n | Program C ++ untuk mencari kawasan poligon biasa dengan panjang sampingan yang diberikan; Berfungsi untuk mencari kawasan poligon biasa; Panjang sampingan dan sampingan tidak boleh negatif; Ijazah kawasan ditukar kepada radian; Kod pemacu"}
{"text": "Side of a regular n | C ++ implementation of the approach ; Function to calculate the side of the polygon circumscribed in a circle ; Driver Code ; Total sides of the polygon ; Radius of the circumscribing circle", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float calculateSide ( float n , float r ) { float theta , theta_in_radians ; theta = 360 / n ; theta_in_radians = theta * 3.14 / 180 ; return 2 * r * sin ( theta_in_radians / 2 ) ; } int main ( ) { float n = 3 ; float r = 5 ; cout << calculateSide ( n , r ) ; }", "text_ms": "Sisi biasa n | C ++ pelaksanaan pendekatan; Fungsi untuk mengira sisi poligon yang dilampirkan dalam bulatan; Kod pemacu; Jumlah sisi poligon; Jejari lingkaran lingkungan"}
{"text": "Largest right circular cylinder within a frustum | C ++ Program to find the biggest right circular cylinder that can be fit within a frustum ; Function to find the biggest right circular cylinder ; radii and height cannot be negative ; radius of right circular cylinder ; height of right circular cylinder ; volume of right circular cylinder ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float cyl ( float r , float R , float h ) { if ( h < 0 && r < 0 && R < 0 ) return -1 ; float r1 = r ; float h1 = h ; float V = 3.14 * pow ( r1 , 2 ) * h1 ; return V ; } int main ( ) { float r = 7 , R = 11 , h = 6 ; cout << cyl ( r , R , h ) << endl ; return 0 ; }", "text_ms": "Silinder bulat kanan terbesar dalam frustum | Program C ++ untuk mencari silinder bulat kanan terbesar yang boleh sesuai dalam frustum; Berfungsi untuk mencari silinder bulat kanan terbesar; Radii dan ketinggian tidak boleh negatif; jejari silinder bulat kanan; ketinggian silinder bulat kanan; jumlah silinder bulat kanan; Kod pemacu"}
{"text": "Program to find the Perimeter of a Regular Polygon | C ++ program to find the perimeter of a regular polygon ; Function to calculate the perimeter ; Calculate Perimeter ; driver code ; Get the number of sides ; Get the length of side ; find perimeter", "code": "#include <iostream> NEW_LINE using namespace std ; float Perimeter ( float s , int n ) { float perimeter = 1 ; perimeter = n * s ; return perimeter ; } int main ( ) { int n = 5 ; float s = 2.5 , peri ; peri = Perimeter ( s , n ) ; cout << \" Perimeter ▁ of ▁ Regular ▁ Polygon \" << \" ▁ with ▁ \" << n << \" ▁ sides ▁ of ▁ length ▁ \" << s << \" ▁ = ▁ \" << peri << endl ; return 0 ; }", "text_ms": "Program untuk mencari perimeter poligon biasa | Program C ++ untuk mencari perimeter poligon biasa; Berfungsi untuk mengira perimeter; Hitung perimeter; kod pemacu; Dapatkan bilangan sisi; Dapatkan panjang sisi; Cari perimeter"}
{"text": "Area of the biggest possible rhombus that can be inscribed in a rectangle | C ++ Program to find the biggest rhombus which can be inscribed within the rectangle ; Function to find the area of the biggest rhombus ; the length and breadth cannot be negative ; area of the rhombus ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float rhombusarea ( float l , float b ) { if ( l < 0 b < 0 ) return -1 ; return ( l * b ) / 2 ; } int main ( ) { float l = 16 , b = 6 ; cout << rhombusarea ( l , b ) << endl ; return 0 ; }", "text_ms": "Kawasan rombang terbesar yang boleh ditulis dalam segi empat tepat | Program C ++ untuk mencari rombus terbesar yang boleh ditulis dalam segi empat tepat; Berfungsi untuk mencari kawasan rombus terbesar; Panjang dan keluasan tidak boleh negatif; kawasan rhombus; Kod pemacu"}
{"text": "Check if a point lies inside a rectangle | Set | CPP program to Check if a point lies on or inside a rectangle | Set - 2 ; function to find if given point lies inside a given rectangle or not . ; Driver code ; bottom - left and top - right corners of rectangle ; given point ; function call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool FindPoint ( int x1 , int y1 , int x2 , int y2 , int x , int y ) { if ( x > x1 and x < x2 and y > y1 and y < y2 ) return true ; return false ; } int main ( ) { int x1 = 0 , y1 = 0 , x2 = 10 , y2 = 8 ; int x = 1 , y = 5 ; if ( FindPoint ( x1 , y1 , x2 , y2 , x , y ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "text_ms": "Semak jika titik terletak di dalam segi empat tepat | Set | Program CPP untuk memeriksa sama ada titik terletak pada atau di dalam segi empat tepat | Set - 2; Fungsi untuk mencari jika titik diberikan terletak di dalam segi empat tepat atau tidak. ; Kod pemacu; bawah - kiri dan atas - sudut kanan segi empat tepat; titik yang diberikan; panggilan fungsi"}
{"text": "Distance between a point and a Plane in 3 D | C ++ program to find the Perpendicular ( shortest ) distance between a point and a Plane in 3 D . ; Function to find distance ; Driver Code ; Function call", "code": "#include <bits/stdc++.h> NEW_LINE #include <math.h> NEW_LINE using namespace std ; void shortest_distance ( float x1 , float y1 , float z1 , float a , float b , float c , float d ) { d = fabs ( ( a * x1 + b * y1 + c * z1 + d ) ) ; float e = sqrt ( a * a + b * b + c * c ) ; cout << \" Perpendicular ▁ distance ▁ is ▁ \" << ( d / e ) ; return ; } int main ( ) { float x1 = 4 ; float y1 = -4 ; float z1 = 3 ; float a = 2 ; float b = -2 ; float c = 5 ; float d = 8 ; shortest_distance ( x1 , y1 , z1 , a , b , c , d ) ; }", "text_ms": "Jarak antara satu titik dan satah dalam 3 D | Program C ++ untuk mencari jarak serenjang (terpendek) antara satu titik dan satah dalam 3 d. ; Berfungsi untuk mencari jarak; Kod pemacu; Panggilan fungsi"}
{"text": "Program to find the Volume of a Triangular Prism | CPP program to find the volume of the triangular prism ; function to find the Volume of triangular prism ; formula to find Volume ; Driver Code ; function calling", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float findVolume ( float l , float b , float h ) { float volume = ( l * b * h ) / 2 ; return volume ; } int main ( ) { float l = 18 , b = 12 , h = 9 ; cout << \" Volume ▁ of ▁ triangular ▁ prism : ▁ \" << findVolume ( l , b , h ) ; return 0 ; }", "text_ms": "Program untuk mencari jumlah prisma segi tiga | Program CPP untuk mencari jumlah prisma segitiga; berfungsi untuk mencari jumlah prisma segi tiga; formula untuk mencari kelantangan; Kod pemacu; fungsi panggilan"}
{"text": "Check if given four integers ( or sides ) make rectangle | A simple program to find if given 4 values can represent 4 sides of rectangle ; Function to check if the given integers value make a rectangle ; Square is also a rectangle ; Driver code", "code": "#include <iostream> NEW_LINE using namespace std ; bool isRectangle ( int a , int b , int c , int d ) { if ( a == b == c == d ) return true ; else if ( a == b && c == d ) return true ; else if ( a == d && c == b ) return true ; else if ( a == c && d == b ) return true ; else return false ; } int main ( ) { int a , b , c , d ; a = 1 , b = 2 , c = 3 , d = 4 ; if ( isRectangle ( a , b , c , d ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "text_ms": "Semak jika diberi empat bilangan bulat (atau sisi) membuat segi empat tepat | Program mudah untuk mencari jika diberikan 4 nilai boleh mewakili 4 sisi segi empat tepat; Fungsi untuk memeriksa sama ada nilai integer yang diberikan membuat segi empat tepat; Square juga merupakan segi empat tepat; Kod pemacu"}
{"text": "Program to find the mid | C ++ program to find the midpoint of a line ; function to find the midpoint of a line ; Driver Function to test above", "code": "#include <iostream> NEW_LINE using namespace std ; void midpoint ( int x1 , int x2 , int y1 , int y2 ) { cout << ( float ) ( x1 + x2 ) / 2 << \" ▁ , ▁ \" << ( float ) ( y1 + y2 ) / 2 ; } int main ( ) { int x1 = -1 , y1 = 2 ; int x2 = 3 , y2 = -6 ; midpoint ( x1 , x2 , y1 , y2 ) ; return 0 ; }", "text_ms": "Program untuk mencari pertengahan | Program C ++ untuk mencari titik tengah garis; berfungsi untuk mencari titik tengah garis; Fungsi pemacu untuk diuji di atas"}
{"text": "Arc length from given Angle | C ++ program to calculate length of an arc ; function to calculate arc length ; Driver Code", "code": "#include <iostream> NEW_LINE using namespace std ; double arcLength ( double diameter , double angle ) { double pi = 22.0 / 7.0 ; double arc ; if ( angle >= 360 ) { cout << \" Angle ▁ cannot \" , \" ▁ be ▁ formed \" ; return 0 ; } else { arc = ( pi * diameter ) * ( angle / 360.0 ) ; return arc ; } } int main ( ) { double diameter = 25.0 ; double angle = 45.0 ; double arc_len = arcLength ( diameter , angle ) ; cout << ( arc_len ) ; return 0 ; }", "text_ms": "Panjang arka dari sudut yang diberikan | Program C ++ untuk mengira panjang arka; fungsi untuk mengira panjang arka; Kod pemacu"}
{"text": "Check if a line touches or intersects a circle | CPP program to check if a line touches or intersects or outside a circle . ; Finding the distance of line from center . ; Checking if the distance is less than , greater than or equal to radius . ; Driven Program", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkCollision ( int a , int b , int c , int x , int y , int radius ) { int dist = ( abs ( a * x + b * y + c ) ) / sqrt ( a * a + b * b ) ; if ( radius == dist ) cout << \" Touch \" << endl ; else if ( radius > dist ) cout << \" Intersect \" << endl ; else cout << \" Outside \" << endl ; } int main ( ) { int radius = 5 ; int x = 0 , y = 0 ; int a = 3 , b = 4 , c = 25 ; checkCollision ( a , b , c , x , y , radius ) ; return 0 ; }", "text_ms": "Semak sama ada garis menyentuh atau memotong bulatan | Program CPP untuk memeriksa sama ada garis menyentuh atau bersilang atau di luar bulatan. ; Mencari jarak garis dari pusat. ; Memeriksa jika jarak kurang daripada, lebih besar daripada atau sama dengan radius. ; Program yang didorong"}
{"text": "Program to find Circumcenter of a Triangle | C ++ program to find the CIRCUMCENTER of a triangle ; This pair is used to store the X and Y coordinate of a point respectively ; Function to find the line given two points ; Function which converts the input line to its perpendicular bisector . It also inputs the points whose mid - point lies on the bisector ; c = - bx + ay ; Returns the intersection point of two lines ; The lines are parallel . This is simplified by returning a pair of FLT_MAX ; Line PQ is represented as ax + by = c ; Line QR is represented as ex + fy = g ; Converting lines PQ and QR to perpendicular vbisectors . After this , L = ax + by = c M = ex + fy = g ; The point of intersection of L and M gives the circumcenter ; Driver code .", "code": "#include <iostream> NEW_LINE #include <cfloat> NEW_LINE using namespace std ; #define pdd  pair<double, double> NEW_LINE void lineFromPoints ( pdd P , pdd Q , double & a , double & b , double & c ) { a = Q . second - P . second ; b = P . first - Q . first ; c = a * ( P . first ) + b * ( P . second ) ; } void perpendicularBisectorFromLine ( pdd P , pdd Q , double & a , double & b , double & c ) { pdd mid_point = make_pair ( ( P . first + Q . first ) / 2 , ( P . second + Q . second ) / 2 ) ; c = - b * ( mid_point . first ) + a * ( mid_point . second ) ; double temp = a ; a = - b ; b = temp ; } pdd lineLineIntersection ( double a1 , double b1 , double c1 , double a2 , double b2 , double c2 ) { double determinant = a1 * b2 - a2 * b1 ; if ( determinant == 0 ) { return make_pair ( FLT_MAX , FLT_MAX ) ; } else { double x = ( b2 * c1 - b1 * c2 ) / determinant ; double y = ( a1 * c2 - a2 * c1 ) / determinant ; return make_pair ( x , y ) ; } } void findCircumCenter ( pdd P , pdd Q , pdd R ) { double a , b , c ; lineFromPoints ( P , Q , a , b , c ) ; double e , f , g ; lineFromPoints ( Q , R , e , f , g ) ; perpendicularBisectorFromLine ( P , Q , a , b , c ) ; perpendicularBisectorFromLine ( Q , R , e , f , g ) ; pdd circumcenter = lineLineIntersection ( a , b , c , e , f , g ) ; if ( circumcenter . first == FLT_MAX && circumcenter . second == FLT_MAX ) { cout << \" The ▁ two ▁ perpendicular ▁ bisectors ▁ \" \" found ▁ come ▁ parallel \" << endl ; cout << \" Thus , ▁ the ▁ given ▁ points ▁ do ▁ not ▁ form ▁ \" \" a ▁ triangle ▁ and ▁ are ▁ collinear \" << endl ; } else { cout << \" The ▁ circumcenter ▁ of ▁ the ▁ triangle ▁ PQR ▁ is : ▁ \" ; cout << \" ( \" << circumcenter . first << \" , ▁ \" << circumcenter . second << \" ) \" << endl ; } } int main ( ) { pdd P = make_pair ( 6 , 0 ) ; pdd Q = make_pair ( 0 , 0 ) ; pdd R = make_pair ( 0 , 8 ) ; findCircumCenter ( P , Q , R ) ; return 0 ; }", "text_ms": "Program untuk mencari circumcenter segitiga | Program C ++ untuk mencari lingkaran segitiga; Pasangan ini digunakan untuk menyimpan koordinat X dan Y masing -masing; Fungsi untuk mencari garis yang diberikan dua mata; Fungsi yang menukarkan garis input ke bisektor tegak lurus. Ia juga memasukkan titik -titik yang pertengahannya terletak pada bisektor; c = - bx + ay; Mengembalikan titik persimpangan dua baris; Garis selari. Ini dipermudahkan dengan mengembalikan sepasang flt_max; PQ Line diwakili sebagai AX + BY = C; Line QR diwakili sebagai ex + fy = g; Menukar garis PQ dan QR ke vBisectors tegak lurus. Selepas ini, l = ax + by = c m = ex + fy = g; Titik persimpangan L dan M memberikan lekuk; Kod pemacu."}
{"text": "Program to find area of a triangle | C ++ program to evaluate area of a polygon using shoelace formula ; ( X [ i ] , Y [ i ] ) are coordinates of i 'th point. ; Initialize area ; Calculate value of shoelace formula ; j = i ; j is previous vertex to i ; Return absolute value ; Driver program to test above function", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; double polygonArea ( double X [ ] , double Y [ ] , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; } return abs ( area / 2.0 ) ; } int main ( ) { double X [ ] = { 0 , 2 , 4 } ; double Y [ ] = { 1 , 3 , 7 } ; int n = sizeof ( X ) / sizeof ( X [ 0 ] ) ; cout << polygonArea ( X , Y , n ) ; }", "text_ms": "Program untuk mencari kawasan segitiga | Program C ++ untuk menilai kawasan poligon menggunakan formula kasut; (X [i], y [i]) adalah koordinat titik saya. ; Memulakan kawasan; Hitung nilai formula kasut; j = i; J adalah puncak sebelumnya kepada i; Kembali nilai mutlak; Program pemacu untuk menguji fungsi di atas"}
{"text": "Maximize sum of LSBs of Bitwise OR of all possible N / 2 pairs from given Array | C ++ program for the above approach ; Function top get LSB value of v ; Binary conversion ; Function to find the sum of LSBs of all possible pairs of the given array ; Stores the LSB of array elements ; Storing the LSB values ; Sort the array lab_arr [ ] ; Taking pairwise sum to get the maximum sum of LSB ; Print the result ; Driver Code ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int chk ( int n ) { vector < int > v ; while ( n != 0 ) { v . push_back ( n % 2 ) ; n = n / 2 ; } for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( v [ i ] == 1 ) { return pow ( 2 , i ) ; } } return 0 ; } void sumOfLSB ( int arr [ ] , int N ) { vector < int > lsb_arr ; for ( int i = 0 ; i < N ; i ++ ) { lsb_arr . push_back ( chk ( arr [ i ] ) ) ; } sort ( lsb_arr . begin ( ) , lsb_arr . end ( ) , greater < int > ( ) ) ; int ans = 0 ; for ( int i = 0 ; i < N - 1 ; i += 2 ) { ans += ( lsb_arr [ i + 1 ] ) ; } cout << ( ans ) ; } int main ( ) { int N = 5 ; int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; sumOfLSB ( arr , N ) ; }", "text_ms": "Memaksimumkan jumlah LSB bitwise atau semua mungkin n / 2 pasang dari array yang diberikan | Program C ++ untuk pendekatan di atas; Fungsi atas mendapatkan nilai LSB V; Penukaran binari; Fungsi untuk mencari jumlah LSB semua pasangan yang mungkin dari array yang diberikan; Menyimpan elemen array LSB; Menyimpan nilai LSB; Susun array lab_arr []; Mengambil jumlah pasangan untuk mendapatkan jumlah maksimum LSB; Cetak hasilnya; Kod pemacu; Panggilan fungsi"}
{"text": "Count of subsequences having odd Bitwise AND values in the given array | C ++ program for the above approach ; Function to find count of subsequences having odd bitwise AND value ; Stores count of odd elements ; Traverse the array arr [ ] ; If x is odd increment count ; Return Answer ; Driver Code ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSubsequences ( vector < int > arr ) { int odd = 0 ; for ( int x : arr ) { if ( x & 1 ) odd ++ ; } return ( 1 << odd ) - 1 ; } int main ( ) { vector < int > arr = { 1 , 3 , 3 } ; cout << countSubsequences ( arr ) ; return 0 ; }", "text_ms": "Kira -kira berikutnya yang mempunyai bitwise dan nilai -nilai yang ganjil dalam array yang diberikan | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari kiraan berikutnya yang mempunyai bitwise dan nilai ganjil; Kedai mengira unsur -unsur ganjil; Melintasi array arr []; Jika x adalah kiraan kenaikan ganjil; Jawapan kembali; Kod pemacu; Panggilan fungsi"}
{"text": "Count pairs from an array with absolute difference not less than the minimum element in the pair | C ++ program for the above approach ; Function to find the number of pairs ( i , j ) such that abs ( a [ i ] - a [ j ] ) is at least the minimum of ( a [ i ] , a [ j ] ) ; Stores the resultant count of pairs ; Iterate over the range [ 0 , n ] ; Iterate from arr [ i ] - ( i % arr [ i ] ) till n with an increment of arr [ i ] ; Count the possible pairs ; Return the total count ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int getPairsCount ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = arr [ i ] - ( i % arr [ i ] ) ; j < n ; j += arr [ i ] ) { if ( i < j && abs ( arr [ i ] - arr [ j ] ) >= min ( arr [ i ] , arr [ j ] ) ) { count ++ ; } } } return count ; } int main ( ) { int arr [ ] = { 1 , 2 , 2 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << getPairsCount ( arr , N ) ; return 0 ; }", "text_ms": "Kira pasangan dari array dengan perbezaan mutlak tidak kurang daripada elemen minimum dalam pasangan | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari bilangan pasangan (i, j) seperti abs (a [i] - a [j]) sekurang -kurangnya minimum (a [i], a [j]); Menyimpan kiraan pasangan yang dihasilkan; Melangkah ke atas julat [0, n]; Berulang dari arr [i] - (i % arr [i]) hingga n dengan kenaikan arr [i]; Mengira pasangan yang mungkin; Mengembalikan jumlah jumlah; Kod pemacu"}
{"text": "Minimum steps to change N to 1 by changing it to 2 * N or N / 10 at any step | C ++ program for the above approach ; Function to check if N can be changed to 1 or not . ; Count the number of 2 in the prime factorisation of N ; Count the number of 5 in the prime factorisation of N ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void check ( int N ) { int twos = 0 , fives = 0 ; while ( N % 2 == 0 ) { N /= 2 ; twos ++ ; } while ( N % 5 == 0 ) { N /= 5 ; fives ++ ; } if ( N == 1 && twos <= fives ) { cout << 2 * fives - twos ; } else { cout << -1 ; } } int main ( ) { int N = 50 ; check ( N ) ; return 0 ; }", "text_ms": "Langkah Minimum Untuk Menukar N hingga 1 dengan menukarnya menjadi 2 * n atau n / 10 pada mana -mana langkah | Program C ++ untuk pendekatan di atas; Fungsi untuk memeriksa sama ada n boleh diubah menjadi 1 atau tidak. ; Kira bilangan 2 dalam faktorisasi utama N; Mengira bilangan 5 dalam faktorisasi utama N; Kod pemacu"}
{"text": "Sum of elements in given range from Array formed by infinitely concatenating given array | C ++ program for the above approach ; Function to find the sum of elements in a given range of an infinite array ; Stores the sum of array elements from L to R ; Traverse from L to R ; Print the resultant sum ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void rangeSum ( int arr [ ] , int N , int L , int R ) { int sum = 0 ; for ( int i = L - 1 ; i < R ; i ++ ) { sum += arr [ i % N ] ; } cout << sum ; } int main ( ) { int arr [ ] = { 5 , 2 , 6 , 9 } ; int L = 10 , R = 13 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; rangeSum ( arr , N , L , R ) ; return 0 ; }", "text_ms": "Jumlah elemen dalam julat yang diberikan dari array yang dibentuk oleh array yang diberikan secara tidak terhingga | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari jumlah elemen dalam pelbagai array tak terhingga; Menyimpan jumlah elemen array dari L ke R; Melintasi L ke R; Cetak jumlah yang dihasilkan; Kod pemacu"}
{"text": "Sum of elements in given range from Array formed by infinitely concatenating given array | C ++ program for the above approach ; Function to find the sum of elements in a given range of an infinite array ; Stores the prefix sum ; Calculate the prefix sum ; Stores the sum of elements from 1 to L - 1 ; Stores the sum of elements from 1 to R ; Print the resultant sum ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void rangeSum ( int arr [ ] , int N , int L , int R ) { int prefix [ N + 1 ] ; prefix [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + arr [ i - 1 ] ; } int leftsum = ( ( L - 1 ) / N ) * prefix [ N ] + prefix [ ( L - 1 ) % N ] ; int rightsum = ( R / N ) * prefix [ N ] + prefix [ R % N ] ; cout << rightsum - leftsum ; } int main ( ) { int arr [ ] = { 5 , 2 , 6 , 9 } ; int L = 10 , R = 13 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; rangeSum ( arr , N , L , R ) ; return 0 ; }", "text_ms": "Jumlah elemen dalam julat yang diberikan dari array yang dibentuk oleh array yang diberikan secara tidak terhingga | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari jumlah elemen dalam pelbagai array tak terhingga; Menyimpan jumlah awalan; Kirakan jumlah awalan; Menyimpan jumlah elemen dari 1 hingga l - 1; Menyimpan jumlah elemen dari 1 hingga R; Cetak jumlah yang dihasilkan; Kod pemacu"}
{"text": "Exponential factorial of N | C ++ program for the above approach ; Function to find exponential factorial of a given number ; Stores the exponetial factor of N ; Iterare over the range [ 2 , N ] ; Update res ; Return res ; Driver Code ; Input ; Function call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int ExpoFactorial ( int N ) { int res = 1 ; int mod = 1000000007 ; for ( int i = 2 ; i < N + 1 ; i ++ ) res = ( int ) pow ( i , res ) % mod ; return res ; } int main ( ) { int N = 4 ; cout << ( ExpoFactorial ( N ) ) ;", "text_ms": "Faktorial eksponen n | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari faktorial eksponen nombor tertentu; Menyimpan faktor exponetial N; Iterare ke atas julat [2, n]; Kemas kini res; Kembali res; Kod pemacu; Input; Panggilan fungsi"}
{"text": "Maximum subarray sum in an array created after repeated concatenation | Set | C ++ program for the above approach ; Function to find contiguous subarray with maximum sum if array is repeated K times ; Store the sum of the array arr [ ] ; Traverse the array and find sum ; Store the answer ; If K = 1 ; Apply Kadane algorithm to find sum ; Return the answer ; Stores the twice repeated array ; Traverse the range [ 0 , 2 * N ] ; Stores the maximum suffix sum ; Stores the maximum prefix sum ; Apply Kadane algorithm for 2 repetition of the array ; If the sum of the array is greater than 0 ; Return the answer ; Driver Code ; Given Input ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSubArraySumRepeated ( int arr [ ] , int N , int K ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; int curr = arr [ 0 ] ; int ans = arr [ 0 ] ; if ( K == 1 ) { for ( int i = 1 ; i < N ; i ++ ) { curr = max ( arr [ i ] , curr + arr [ i ] ) ; ans = max ( ans , curr ) ; } return ans ; } vector < int > V ; for ( int i = 0 ; i < 2 * N ; i ++ ) { V . push_back ( arr [ i % N ] ) ; } int maxSuf = V [ 0 ] ; int maxPref = V [ 2 * N - 1 ] ; curr = V [ 0 ] ; for ( int i = 1 ; i < 2 * N ; i ++ ) { curr += V [ i ] ; maxPref = max ( maxPref , curr ) ; } curr = V [ 2 * N - 1 ] ; for ( int i = 2 * N - 2 ; i >= 0 ; i -- ) { curr += V [ i ] ; maxSuf = max ( maxSuf , curr ) ; } curr = V [ 0 ] ; for ( int i = 1 ; i < 2 * N ; i ++ ) { curr = max ( V [ i ] , curr + V [ i ] ) ; ans = max ( ans , curr ) ; } if ( sum > 0 ) { int temp = 1LL * sum * ( K - 2 ) ; ans = max ( ans , max ( temp + maxPref , temp + maxSuf ) ) ; } return ans ; } int main ( ) { int arr [ ] = { 10 , 20 , -30 , -1 , 40 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 10 ; cout << maxSubArraySumRepeated ( arr , N , K ) ; return 0 ; }", "text_ms": "SUM MAXIMUM SUMS DALAM TRADE DALAM SELEPAS CONCATENATION UTAMA | Set | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari subarray bersebelahan dengan jumlah maksimum jika array diulang kali k; Simpan jumlah array arr []; Melintasi array dan cari jumlah; Simpan jawapannya; Jika k = 1; Memohon algoritma Kadane untuk mencari jumlah; Kembalikan jawapannya; Menyimpan array dua kali berulang; Melintasi julat [0, 2 * n]; Menyimpan jumlah akhiran maksimum; Menyimpan jumlah awalan maksimum; Memohon algoritma Kadane untuk 2 pengulangan array; Jika jumlah array lebih besar daripada 0; Kembalikan jawapannya; Kod pemacu; Diberikan input; Panggilan fungsi"}
{"text": "Count of subarrays with largest element at least twice the largest of remaining elements | C ++ program for the above approach ; Function to find count of subarrays which have max element greater than twice maximum of all other elements ; Stores the count of subarrays ; Generate all possible subarrays ; Stores the maximum element of the subarray ; Stores the maximum of all other elements ; Find the maximum element in the subarray [ i , j ] ; Find the maximum of all other elements ; If the maximum of subarray is greater than twice the maximum of other elements ; Print the maximum value obtained ; Driver Code", "code": "#include <iostream> NEW_LINE using namespace std ; void countSubarray ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int mxSubarray = 0 ; int mxOther = 0 ; for ( int k = i ; k <= j ; k ++ ) { mxSubarray = max ( mxSubarray , arr [ k ] ) ; } for ( int k = 0 ; k < i ; k ++ ) { mxOther = max ( mxOther , arr [ k ] ) ; } for ( int k = j + 1 ; k < n ; k ++ ) { mxOther = max ( mxOther , arr [ k ] ) ; } if ( mxSubarray > ( 2 * mxOther ) ) count ++ ; } } cout << count ; } int main ( ) { int arr [ ] = { 1 , 6 , 10 , 9 , 7 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countSubarray ( arr , N ) ; return 0 ; }", "text_ms": "Count of Subarrays Dengan Elemen Terbesar Sekurang -kurangnya dua kali ganda unsur -unsur terbesar | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari kiraan subarray yang mempunyai elemen maksimum lebih besar daripada dua kali maksimum semua elemen lain; Menyimpan kiraan subarray; Menjana semua subarray yang mungkin; Menyimpan elemen maksimum subarray; Menyimpan maksimum semua elemen lain; Cari elemen maksimum dalam subarray [i, j]; Cari maksimum semua elemen lain; Jika maksimum subarray lebih besar daripada dua kali ganda maksimum elemen lain; Cetak nilai maksimum yang diperoleh; Kod pemacu"}
{"text": "Count of subarrays with largest element at least twice the largest of remaining elements | C ++ program for the above approach ; Function to find count of subarrays which have max element greater than twice maximum of all other elements ; Stores the maximum element of the array ; Traverse the given array ; If the value of 2 * arr [ i ] is greater than mx ; Update the value of L and break out of loop ; If the value 2 * arr [ i ] is greater than mx ; Update the value of R and break out of loop ; Print the final answer ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void countSubarray ( int arr [ ] , int n ) { int count = 0 , L = 0 , R = 0 ; int mx = * max_element ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] * 2 > mx ) { L = i ; break ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] * 2 > mx ) { R = i ; break ; } } cout << ( L + 1 ) * ( n - R ) ; } int main ( ) { int arr [ ] = { 1 , 6 , 10 , 9 , 7 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countSubarray ( arr , N ) ; return 0 ; }", "text_ms": "Count of Subarrays Dengan Elemen Terbesar Sekurang -kurangnya dua kali ganda unsur -unsur terbesar | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari kiraan subarray yang mempunyai elemen maksimum lebih besar daripada dua kali maksimum semua elemen lain; Menyimpan elemen maksimum array; Melintasi array yang diberikan; Jika nilai 2 * arr [i] lebih besar daripada MX; Kemas kini nilai l dan keluar dari gelung; Jika nilai 2 * arr [i] lebih besar daripada Mx; Mengemas kini nilai r dan keluar dari gelung; Cetak jawapan terakhir; Kod pemacu"}
{"text": "Find Prime number just less than and just greater each element of given Array | C ++ program for the above approach ; Utility function to check for primality of a number X by checking whether X haACCs any factors other than 1 and itself . ; if ( X % i == 0 ) Factor found ; Function to print primes just less than and just greater than of each element in an array ; Traverse the array ; Traverse for finding prime just less than A [ i ] ; Prime just less than A [ i ] found ; Traverse for finding prime just greater than A [ i ] ; Prime just greater than A [ i ] found ; Driver code ; Input ; Function call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int X ) { for ( int i = 2 ; i * i <= X ; i ++ ) return false ; return true ; } void printPrimes ( int A [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = A [ i ] - 1 ; ; j -- ) { if ( isPrime ( j ) ) { cout << j << \" ▁ \" ; break ; } } for ( int j = A [ i ] + 1 ; ; j ++ ) { if ( isPrime ( j ) ) { cout << j << \" ▁ \" ; break ; } } cout << endl ; } } int main ( ) { int A [ ] = { 17 , 28 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; printPrimes ( A , N ) ; return 0 ; }", "text_ms": "Cari Nombor Perdana hanya kurang daripada dan hanya lebih besar setiap elemen array yang diberikan | Program C ++ untuk pendekatan di atas; Fungsi utiliti untuk memeriksa keunggulan nombor X dengan memeriksa sama ada X HAACCs apa -apa faktor selain daripada 1 dan sendiri. ; jika (x % i == 0) faktor yang dijumpai; Berfungsi untuk mencetak prima hanya kurang daripada dan hanya lebih besar daripada setiap elemen dalam array; Melintasi array; Traverse untuk mencari perdana kurang daripada [i]; Perdana hanya kurang daripada yang dijumpai; Melintasi untuk mencari perdana lebih besar daripada [i]; Perdana hanya lebih besar daripada yang dijumpai; Kod pemacu; Input; Panggilan fungsi"}
{"text": "Kth smallest element in an array that contains A [ i ] exactly B [ i ] times | C ++ program for the above approach ; Function to find the Kth smallest element that contains A [ i ] exactly B [ i ] times ; Traverse the given array ; Stores the frequency of every elements ; Traverse the given array ; Initialize a variable to store the prefix sums ; Iterate over the range [ 0 , M ] ; Increment sum by freq [ i ] ; If sum is greater than or equal to K ; Return the current element as answer ; Return - 1 ; Driver Code ; Given Input ; Function call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int KthSmallest ( int A [ ] , int B [ ] , int N , int K ) { int M = 0 ; for ( int i = 0 ; i < N ; i ++ ) { M = max ( A [ i ] , M ) ; } int freq [ M + 1 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { freq [ A [ i ] ] += B [ i ] ; } int sum = 0 ; for ( int i = 0 ; i <= M ; i ++ ) { sum += freq [ i ] ; if ( sum >= K ) { return i ; } } return -1 ; } int main ( ) { int A [ ] = { 3 , 4 , 5 } ; int B [ ] = { 2 , 1 , 3 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int K = 4 ; cout << KthSmallest ( A , B , N , K ) ; return 0 ; }", "text_ms": "Elemen terkecil kth dalam array yang mengandungi [i] betul -betul b [i] kali | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari elemen terkecil kth yang mengandungi [i] tepat b [i] kali; Melintasi array yang diberikan; Menyimpan kekerapan setiap elemen; Melintasi array yang diberikan; Memulakan pembolehubah untuk menyimpan jumlah awalan; Melangkah ke atas julat [0, M]; Jumlah kenaikan oleh freq [i]; Jika jumlah lebih besar daripada atau sama dengan k; Mengembalikan elemen semasa sebagai jawapan; Kembali - 1; Kod pemacu; Diberikan input; Panggilan fungsi"}
{"text": "Bitwise OR of Bitwise AND of all subarrays of an array | C ++ program for the above approach ; Function to find the Bitwise OR of Bitwise AND of all subarrays ; Stores the required result ; Generate all the subarrays ; Store the current element ; Find the Bitwise OR ; Update the result ; Print the result ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findbitwiseOR ( int * a , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int curr_sub_array = a [ i ] ; res = res | curr_sub_array ; for ( int j = i ; j < n ; j ++ ) { curr_sub_array = curr_sub_array & a [ j ] ; res = res | curr_sub_array ; } } cout << res ; } int main ( ) { int A [ ] = { 1 , 2 , 3 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; findbitwiseOR ( A , N ) ; return 0 ; }", "text_ms": "Bitwise atau bitwise dan semua subarrays array | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari bitwise atau bitwise dan semua subarrays; Menyimpan hasil yang diperlukan; Menjana semua subarray; Simpan elemen semasa; Cari bitwise atau; Mengemas kini hasilnya; Cetak hasilnya; Kod pemacu"}
{"text": "Bitwise OR of Bitwise AND of all subarrays of an array | C ++ program for the above approach ; Function to find the Bitwise OR of Bitwise AND of all consecutive subsets of the array ; Stores the required result ; Traverse the given array ; Print the result ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findbitwiseOR ( int * a , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res = res | a [ i ] ; cout << res ; } int main ( ) { int A [ ] = { 1 , 2 , 3 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; findbitwiseOR ( A , N ) ; return 0 ; }", "text_ms": "Bitwise atau bitwise dan semua subarrays array | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari bitwise atau bitwise dan semua subset berturut -turut dari array; Menyimpan hasil yang diperlukan; Melintasi array yang diberikan; Cetak hasilnya; Kod pemacu"}
{"text": "Check if sum of digits of a number exceeds the product of digits of that number | C ++ program for the above approach ; Function to check if the sum of the digits of N is strictly greater than the product of the digits of N or not ; Stores the sum and the product of the digits of N ; Stores the last digit if N ; Increment the value of sumOfDigits ; Update the prodOfDigit ; Divide N by 10 ; Print the result ; Driver Code", "code": "#include <iostream> NEW_LINE using namespace std ; void check ( int n ) { int sumOfDigit = 0 ; int prodOfDigit = 1 ; while ( n > 0 ) { int rem ; rem = n % 10 ; sumOfDigit += rem ; prodOfDigit *= rem ; n /= 10 ; } if ( sumOfDigit > prodOfDigit ) cout << \" Yes \" ; else cout << \" No \" ; } int main ( ) { int N = 1234 ; check ( N ) ; return 0 ; }", "text_ms": "Semak jika jumlah digit nombor melebihi produk digit nombor itu | Program C ++ untuk pendekatan di atas; Berfungsi untuk memeriksa sama ada jumlah digit N adalah lebih besar daripada produk digit N atau tidak; Menyimpan jumlah dan produk digit N; Menyimpan digit terakhir jika n; Kenaikan nilai sumofdigit; Mengemas kini prodofdigit; Bahagikan n oleh 10; Cetak hasilnya; Kod pemacu"}
{"text": "Print all distinct even and odd prefix Bitwise XORs of first N natural numbers | C ++ program for the above approach ; Print all distinct even & odd prefix Bitwise XORs from 1 to N ; Print the even number ; Print the odd number ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void evenOddBitwiseXOR ( int N ) { cout << \" Even : ▁ \" << 0 << \" ▁ \" ; for ( int i = 4 ; i <= N ; i = i + 4 ) { cout << i << \" ▁ \" ; } cout << \" STRNEWLINE \" ; cout << \" Odd : ▁ \" << 1 << \" ▁ \" ; for ( int i = 4 ; i <= N ; i = i + 4 ) { cout << i - 1 << \" ▁ \" ; } if ( N % 4 == 2 ) cout << N + 1 ; else if ( N % 4 == 3 ) cout << N ; } int main ( ) { int N = 6 ; evenOddBitwiseXOR ( N ) ; return 0 ; }", "text_ms": "Cetak semua awalan yang berbeza dan ganjil bitwise xors pertama n Nombor semula jadi | Program C ++ untuk pendekatan di atas; Cetak semua awalan yang berbeza & ganjil bitwise xors dari 1 hingga n; Cetak nombor juga; Cetak nombor ganjil; Kod pemacu"}
{"text": "Lexicographically largest permutation possible by a swap that is smaller than a given array | C ++ program for the above approach ; Function to lexicographic largest permutation possible by a swap that is smaller than given array ; Find the index of first element such that arr [ i ] > arr [ i + 1 ] ; If the array is sorted in increasing order ; Find the index of first element which is smaller than arr [ i ] ; If arr [ j ] = = arr [ j - 1 ] ; Decrement j ; Swap the element ; Print the array arr [ ] ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPermutation ( vector < int > & arr ) { int N = arr . size ( ) ; int i = N - 2 ; while ( i >= 0 && arr [ i ] <= arr [ i + 1 ] ) i -- ; if ( i == -1 ) { cout << \" - 1\" ; return ; } int j = N - 1 ; while ( j > i && arr [ j ] >= arr [ i ] ) j -- ; while ( j > i && arr [ j ] == arr [ j - 1 ] ) { j -- ; } swap ( arr [ i ] , arr [ j ] ) ; for ( auto & it : arr ) { cout << it << ' ▁ ' ; } } int main ( ) { vector < int > arr = { 1 , 2 , 5 , 3 , 4 , 6 } ; findPermutation ( arr ) ; return 0 ; }", "text_ms": "Permutasi terbesar lexicographically mungkin dengan swap yang lebih kecil daripada array yang diberikan | Program C ++ untuk pendekatan di atas; Berfungsi untuk permutasi terbesar lexicographic mungkin dengan swap yang lebih kecil daripada array yang diberikan; Cari indeks elemen pertama sedemikian rupa sehingga arr [i]> arr [i + 1]; Jika array disusun dalam peningkatan urutan; Cari indeks elemen pertama yang lebih kecil daripada arr [i]; Jika arr [j] = = arr [j - 1]; Pengurangan j; Swap elemen; Cetak array arr []; Kod pemacu"}
{"text": "Absolute difference between the count of odd and even factors of N | C ++ program for the above approach ; Function to find the smallest prime factor of all the numbers using Sieve Of Eratosthenes ; Stores whether any number is prime or not ; Initialize smallest factor as 2 for all the even numbers ; Iterate over the range [ 3 , N ] ; If i is prime ; Iterate all multiples of i ; i is the smallest prime factor of i * j ; Function to find the absolute difference between the count of odd and even factors of N ; Stores the smallest prime factor of i ; Fill values in s [ ] using sieve of eratosthenes ; Stores the total number of factors and the total number of odd and even factors ; Store the current prime factor of the number N ; Store the power of current prime factor ; Loop while N is greater than 1 ; If N also has smallest prime factor as curr , then increment cnt by 1 ; Update only total number of factors if curr is 2 ; Update total number of factors and total number of odd factors ; Update current prime factor as s [ N ] and count as 1 ; Calculate the number of even factors ; Print the difference ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void sieveOfEratosthenes ( int N , int s [ ] ) { vector < bool > prime ( N + 1 , false ) ; for ( int i = 2 ; i <= N ; i += 2 ) s [ i ] = 2 ; for ( int i = 3 ; i <= N ; i += 2 ) { if ( prime [ i ] == false ) { s [ i ] = i ; for ( int j = i ; j * i <= N ; j += 2 ) { if ( ! prime [ i * j ] ) { prime [ i * j ] = true ; s [ i * j ] = i ; } } } } } void findDifference ( int N ) { int s [ N + 1 ] ; sieveOfEratosthenes ( N , s ) ; int total = 1 , odd = 1 , even = 0 ; int curr = s [ N ] ; int cnt = 1 ; while ( N > 1 ) { N /= s [ N ] ; if ( curr == s [ N ] ) { cnt ++ ; continue ; } if ( curr == 2 ) { total = total * ( cnt + 1 ) ; } else { total = total * ( cnt + 1 ) ; odd = odd * ( cnt + 1 ) ; } curr = s [ N ] ; cnt = 1 ; } even = total - odd ; cout << abs ( even - odd ) ; } int main ( ) { int N = 12 ; findDifference ( N ) ; return 0 ; }", "text_ms": "Perbezaan mutlak antara kiraan ganjil dan juga faktor n | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari faktor utama terkecil dari semua nombor menggunakan ayak eratosthenes; Kedai sama ada nombor mana -mana atau tidak; Memulakan faktor terkecil sebagai 2 untuk semua nombor walaupun; Melangkah ke atas julat [3, n]; Sekiranya saya adalah perdana; Melepasi semua gandaan i; Saya adalah faktor utama terkecil i * j; Fungsi untuk mencari perbezaan mutlak antara kiraan ganjil dan juga faktor n; Menyimpan faktor utama terkecil i; Isi nilai dalam S [] menggunakan ayak eratosthenes; Menyimpan jumlah faktor dan jumlah faktor ganjil dan bahkan; Simpan faktor utama semasa nombor n; Simpan kuasa faktor utama semasa; Gelung manakala n lebih besar daripada 1; Jika n juga mempunyai faktor utama terkecil seperti Curr, maka kenaikan CNT oleh 1; Kemas kini hanya jumlah faktor jika curr adalah 2; Mengemas kini jumlah faktor dan jumlah faktor ganjil; Mengemas kini faktor utama semasa S [n] dan dikira sebagai 1; Kirakan bilangan faktor walaupun; Cetak perbezaan; Kod pemacu"}
{"text": "Calculate Median from given values of Mean and Mode | C ++ program for the above approach ; Function to find the median of a group of data with given mean and mode ; Calculate the median ; Print the median ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMedian ( int Mean , int Mode ) { double Median = ( 2 * Mean + Mode ) / 3.0 ; cout << Median ; } int main ( ) { int mode = 6 , mean = 3 ; findMedian ( mean , mode ) ; return 0 ; }", "text_ms": "Kirakan median dari nilai min dan mod yang diberikan | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari median sekumpulan data dengan min dan mod yang diberikan; Kirakan median; Cetak median; Kod pemacu"}
{"text": "Program to find the Magnitude of a Vector | C ++ program for the above approach ; Function to calculate magnitude of a 3 dimensional vector ; Stores the sum of squares of coordinates of a vector ; Return the magnitude ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float vectorMagnitude ( int x , int y , int z ) { int sum = x * x + y * y + z * z ; return sqrt ( sum ) ; } int main ( ) { int x = 1 ; int y = 2 ; int z = 3 ; cout << vectorMagnitude ( x , y , z ) ; return 0 ; }", "text_ms": "Program untuk mencari magnitud vektor | Program C ++ untuk pendekatan di atas; Berfungsi untuk mengira magnitud vektor 3 dimensi; Menyimpan jumlah kuadrat koordinat vektor; Mengembalikan magnitud; Kod pemacu"}
{"text": "Program to find the product of a number with a Mersenne Number | C ++ implementation of above approach ; Function to find prodcut of a Mersenne number with another number ; Stores the power of 2 of integer M + 1 ; Return the product ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long multiplyByMersenne ( long N , long M ) { long x = log2 ( M + 1 ) ; return ( ( N << x ) - N ) ; } int main ( ) { long N = 4 ; long M = 15 ; cout << multiplyByMersenne ( N , M ) ; return 0 ; }", "text_ms": "Program untuk mencari produk nombor dengan nombor Mersenne | C ++ pelaksanaan pendekatan di atas; Berfungsi untuk mencari prodcut nombor Mersenne dengan nombor lain; Menyimpan kuasa 2 integer m + 1; Mengembalikan produk; Kod pemacu"}
{"text": "Nearest power of 2 of nearest perfect squares of non | C ++ program for the above approach ; Function to find nearest perfect square of num ; Calculate square root of num ; Calculate perfect square ; Find the nearest perfect square ; Function to find the power of 2 nearest to the number num ; Calculate log base 2 of num ; Highest power of 2 which is <= num ; Function to find the nearest perfect square and the nearest power of 2 of every array element whose occurrence is 1 ; Stores frequency of array elements ; Traverse the array and update frequency of current array element ; Traverse the map freq ; If the frequency is 1 ; Find nearest perfect square ; Print the nearest power of 2 ; If the any does not contain any non - repeating elements ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int perfectSquare ( int num ) { int sr = sqrt ( num ) ; int a = sr * sr ; int b = ( sr + 1 ) * ( sr + 1 ) ; if ( ( num - a ) < ( b - num ) ) { return a ; } else { return b ; } } int powerOfTwo ( int num ) { int lg = log2 ( num ) ; int p = pow ( 2 , lg ) ; return p ; } void uniqueElement ( int arr [ ] , int N ) { bool ans = true ; unordered_map < int , int > freq ; for ( int i = 0 ; i < N ; i ++ ) { freq [ arr [ i ] ] ++ ; } for ( auto el : freq ) { if ( el . second == 1 ) { ans = false ; int ps = perfectSquare ( el . first ) ; cout << powerOfTwo ( ps ) << ' ▁ ' ; } } if ( ans ) cout << \" - 1\" ; } int main ( ) { int arr [ ] = { 4 , 11 , 4 , 3 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; uniqueElement ( arr , N ) ; return 0 ; }", "text_ms": "Kuasa terdekat 2 dari dataran sempurna terdekat bukan | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari persegi yang paling dekat dengan Num; Kirakan akar kuadrat NUM; Kirakan persegi sempurna; Cari dataran sempurna terdekat; Berfungsi untuk mencari kuasa 2 yang paling dekat dengan nombor nombor; Hitung asas log 2 dari NUM; Kuasa tertinggi 2 iaitu <= num; Berfungsi untuk mencari persegi sempurna yang terdekat dan kuasa terdekat 2 dari setiap elemen array yang kejadiannya adalah 1; Kedai kekerapan elemen array; Melintasi array dan kemas kini kekerapan elemen array semasa; Melintasi peta freq; Jika kekerapan adalah 1; Cari persegi sempurna yang terdekat; Cetak kuasa terdekat 2; Sekiranya mana -mana tidak mengandungi unsur -unsur yang tidak berulang; Kod pemacu"}
{"text": "Partition array into two subarrays with every element in the right subarray strictly greater than every element in left subarray | C ++ program of the above approach ; Function to partition the array into two non - empty subarrays which satisfies the given condition ; Stores the suffix Min array ; Stores the Minimum of a suffix ; Traverse the array in reverse ; Update Minimum ; Store the Minimum ; Stores the Maximum value of a prefix ; Stores the index of the partition ; Update Max ; If Max is less than Min [ i + 1 ] ; Store the index of partition ; break ; If ind is not - 1 ; Print the first subarray ; Print the second subarray ; Otherwise ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void partitionArray ( int * a , int n ) { int * Min = new int [ n ] ; int Mini = INT_MAX ; for ( int i = n - 1 ; i >= 0 ; i -- ) { Mini = min ( Mini , a [ i ] ) ; Min [ i ] = Mini ; } int Maxi = INT_MIN ; int ind = -1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { Maxi = max ( Maxi , a [ i ] ) ; if ( Maxi < Min [ i + 1 ] ) { ind = i ; break ; } } if ( ind != -1 ) { for ( int i = 0 ; i <= ind ; i ++ ) cout << a [ i ] << \" ▁ \" ; cout << endl ; for ( int i = ind + 1 ; i < n ; i ++ ) cout << a [ i ] << \" ▁ \" ; } else cout << \" Impossible \" ; } int main ( ) { int arr [ ] = { 5 , 3 , 2 , 7 , 9 } ; int N = 5 ; partitionArray ( arr , N ) ; return 0 ; }", "text_ms": "Arahan partition menjadi dua subarray dengan setiap elemen di subarray kanan dengan ketat daripada setiap elemen di subarray kiri | C ++ program pendekatan di atas; Berfungsi untuk memisahkan array menjadi dua subarrays bukan kosong yang memenuhi syarat yang diberikan; Menyimpan array akhiran min; Menyimpan minimum akhiran; Melintasi array secara terbalik; Mengemas kini minimum; Simpan minimum; Menyimpan nilai maksimum awalan; Menyimpan indeks partition; Kemas kini Max; Jika max kurang daripada min [i + 1]; Simpan indeks partition; rehat; Jika Ind tidak - 1; Cetak subarray pertama; Cetak subarray kedua; Jika tidak; Kod pemacu"}
{"text": "Check if a number can be represented as sum of K positive integers out of which at least K | C ++ program for the above approach ; Function to count all prime factors of a given number ; Count the number of 2 s that divides n ; Since n is odd at this point , skip one element ; While i divides n , count i and divide n ; If n is a prime number greater than 2 ; Function to find the sum of first n nearly prime numbers ; Store the required sum ; Add this number if it is satisfies the condition ; Increment count of nearly prime numbers ; Function to check if N can be represented as sum of K different positive integers out of which at least K - 1 of them are nearly prime ; Store the sum of first K - 1 nearly prime numbers ; If sum is greater than or equal to n ; Otherwise , print Yes ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPrimeFactors ( int n ) { int count = 0 ; while ( n % 2 == 0 ) { n = n / 2 ; count ++ ; } for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { n = n / i ; count ++ ; } } if ( n > 2 ) count ++ ; return ( count ) ; } int findSum ( int n ) { int sum = 0 ; for ( int i = 1 , num = 2 ; i <= n ; num ++ ) { if ( countPrimeFactors ( num ) == 2 ) { sum += num ; i ++ ; } } return sum ; } void check ( int n , int k ) { int s = findSum ( k - 1 ) ; if ( s >= n ) cout << \" No \" ; else cout << \" Yes \" ; } int main ( ) { int n = 100 , k = 6 ; check ( n , k ) ; return 0 ; }", "text_ms": "Semak sama ada nombor boleh diwakili sebagai jumlah integer positif k di mana sekurang -kurangnya k | Program C ++ untuk pendekatan di atas; Berfungsi untuk mengira semua faktor utama nombor tertentu; Kira bilangan 2 s yang membahagikan n; Oleh kerana N adalah ganjil pada ketika ini, langkau satu elemen; Walaupun saya membahagikan n, kiraan saya dan membahagikan n; Jika n adalah nombor perdana yang lebih besar daripada 2; Berfungsi untuk mencari jumlah nombor pertama N hampir utama; Simpan jumlah yang diperlukan; Tambah nombor ini jika ia memenuhi syarat; Kiraan kenaikan hampir nombor utama; Fungsi untuk memeriksa sama ada n boleh diwakili sebagai jumlah k antara bilangan bulat positif yang berbeza di mana sekurang -kurangnya k - 1 daripadanya adalah hampir perdana; Simpan jumlah pertama k - 1 hampir nombor utama; Jika jumlah lebih besar daripada atau sama dengan n; Jika tidak, cetak ya; Kod pemacu"}
{"text": "Count ways to represent an integer as an exponent | C ++ program for the above approach ; Function to calculate GCD of a and b using Euclidean Algorithm ; Iterate until b is non - zero ; Return the GCD ; Function to count the number of ways N can be expressed as x ^ y ; Base Case ; Stores the gcd of powers ; Calculate the degree of 2 in N ; Calculate the degree of prime numbers in N ; Calculate the degree of prime ' i ' in N ; If N is a prime , g becomes 1. ; Stores the number of ways to represent N as x ^ y ; Find the number of Factors of g ; Update the count of ways ; Iterate to find rest of the prime numbers ; Find the power of i ; Update the count of ways ; If g is prime ; Return the total number of ways ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int gcd ( long long int a , long long int b ) { while ( b > 0 ) { long long int rem = a % b ; a = b ; b = rem ; } return a ; } int countNumberOfWays ( long long int n ) { if ( n == 1 ) return -1 ; long long int g = 0 ; int power = 0 ; while ( n % 2 == 0 ) { power ++ ; n /= 2 ; } g = gcd ( g , power ) ; for ( int i = 3 ; i <= sqrt ( n ) ; i += 2 ) { power = 0 ; while ( n % i == 0 ) { power ++ ; n /= i ; } g = gcd ( g , power ) ; } if ( n > 2 ) g = gcd ( g , 1 ) ; int ways = 1 ; power = 0 ; while ( g % 2 == 0 ) { g /= 2 ; power ++ ; } ways *= ( power + 1 ) ; for ( int i = 3 ; i <= sqrt ( g ) ; i += 2 ) { power = 0 ; while ( g % i == 0 ) { power ++ ; g /= i ; } ways *= ( power + 1 ) ; } if ( g > 2 ) ways *= 2 ; return ways ; } int main ( ) { int N = 64 ; cout << countNumberOfWays ( N ) ; return 0 ; }", "text_ms": "Kira cara untuk mewakili integer sebagai eksponen | Program C ++ untuk pendekatan di atas; Berfungsi untuk mengira GCD A dan B menggunakan algoritma Euclidean; Iterat sehingga B bukan sifar; Mengembalikan GCD; Fungsi untuk mengira bilangan cara n boleh dinyatakan sebagai x ^ y; Kes asas; Menyimpan GCD kuasa; Kirakan tahap 2 dalam n; Kirakan tahap nombor utama dalam n; Kirakan tahap perdana 'i' dalam n; Jika n adalah perdana, G menjadi 1 .; Menyimpan bilangan cara untuk mewakili n sebagai x ^ y; Cari bilangan faktor G; Mengemas kini kiraan cara; Berulang untuk mencari bilangan nombor perdana; Cari kuasa i; Mengemas kini kiraan cara; Jika G adalah Perdana; Mengembalikan jumlah cara; Kod pemacu"}
{"text": "Highest power of 2 less than or equal to given Integer | C ++ implementation of the above approach ; Function to return the lowest power of 2 close to given positive number ; Floor function is used to determine the value close to the number ; Function to return the lowest power of 2 close to given negative number ; Ceil function is used for negative numbers as - 1 > - 4. It would be opposite to positive numbers where 1 < 4 ; Function to find the highest power of 2 ; To check if the given number is positive or negative ; If the number is negative , then the ceil of the positive number is calculated and negative sign is added ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int powOfPositive ( int n ) { int pos = floor ( log2 ( n ) ) ; return pow ( 2 , pos ) ; } int powOfNegative ( int n ) { int pos = ceil ( log2 ( n ) ) ; return ( -1 * pow ( 2 , pos ) ) ; } void highestPowerOf2 ( int n ) { if ( n > 0 ) { cout << powOfPositive ( n ) ; } else { n = - n ; cout << powOfNegative ( n ) ; } } int main ( ) { int n = -24 ; highestPowerOf2 ( n ) ; return 0 ; }", "text_ms": "Kuasa tertinggi 2 kurang daripada atau sama dengan integer yang diberikan | C ++ pelaksanaan pendekatan di atas; Berfungsi untuk mengembalikan kuasa terendah 2 dekat dengan nombor positif yang diberikan; Fungsi lantai digunakan untuk menentukan nilai yang dekat dengan nombor; Berfungsi untuk mengembalikan kuasa terendah 2 dekat dengan nombor negatif yang diberikan; Fungsi Ceil digunakan untuk nombor negatif sebagai - 1> - 4. Ia akan bertentangan dengan nombor positif di mana 1 <4; Berfungsi untuk mencari kuasa tertinggi 2; Untuk memeriksa sama ada nombor yang diberikan positif atau negatif; Jika nombor itu negatif, maka siling nombor positif dikira dan tanda negatif ditambah; Kod pemacu"}
{"text": "Number of cards needed build a House of Cards of a given level N | C ++ implementation of the above approach ; Function to find number of cards needed ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int noOfCards ( int n ) { return n * ( 3 * n + 1 ) / 2 ; } int main ( ) { int n = 3 ; cout << noOfCards ( n ) << \" , ▁ \" ; return 0 ; }", "text_ms": "Bilangan kad yang diperlukan membina rumah kad tahap n | C ++ pelaksanaan pendekatan di atas; Berfungsi untuk mencari bilangan kad yang diperlukan; Kod pemacu"}
{"text": "Find smallest possible Number from a given large Number with same count of digits | C ++ implementation of the above approach ; Function for finding the smallest possible number after swapping the digits any number of times ; Variable to store the final answer ; Array to store the count of occurrence of each digit ; Loop to calculate the number of occurrences of every digit ; Loop to get smallest number ; Returning the answer ; Driver code", "code": "#include <iostream> NEW_LINE using namespace std ; string smallestPoss ( string s , int n ) { string ans = \" \" ; int arr [ 10 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { arr [ s [ i ] - 48 ] ++ ; } for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < arr [ i ] ; j ++ ) ans = ans + to_string ( i ) ; } return ans ; } int main ( ) { int N = 15 ; string K = \"325343273113434\" ; cout << smallestPoss ( K , N ) ; return 0 ; }", "text_ms": "Cari nombor terkecil dari sejumlah besar yang diberikan dengan kiraan digit yang sama | C ++ pelaksanaan pendekatan di atas; Fungsi untuk mencari nombor yang paling kecil selepas menukar digit beberapa kali; Pembolehubah untuk menyimpan jawapan terakhir; Array untuk menyimpan kiraan kejadian setiap digit; Gelung untuk mengira bilangan kejadian setiap digit; Gelung untuk mendapatkan nombor terkecil; Mengembalikan jawapannya; Kod pemacu"}
{"text": "Count the subarray with sum strictly greater than the sum of remaining elements | C ++ implementation of the above approach ; Function to count the number of sub - arrays with sum strictly greater than the remaining elements of array ; For loop for beginning point of a subarray ; For loop for ending point of the subarray ; Initialise subarray_sum and remaining_sum to 0 ; For loop to calculate the sum of generated subarray ; For loop to calculate the sum remaining array element ; Checking for condition when subarray sum is strictly greater than remaining sum of array element ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Count_subarray ( int arr [ ] , int n ) { int subarray_sum , remaining_sum , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { subarray_sum = 0 ; remaining_sum = 0 ; for ( int k = i ; k <= j ; k ++ ) { subarray_sum += arr [ k ] ; } for ( int l = 0 ; l < i ; l ++ ) { remaining_sum += arr [ l ] ; } for ( int l = j + 1 ; l < n ; l ++ ) { remaining_sum += arr [ l ] ; } if ( subarray_sum > remaining_sum ) { count += 1 ; } } } return count ; } int main ( ) { int arr [ ] = { 10 , 9 , 12 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << Count_subarray ( arr , n ) ; return 0 ; }", "text_ms": "Kira subarray dengan jumlah yang lebih besar daripada jumlah elemen yang tinggal | C ++ pelaksanaan pendekatan di atas; Berfungsi untuk mengira bilangan sub -tatasusunan dengan jumlah yang lebih besar daripada unsur -unsur array yang tinggal; Untuk gelung untuk titik permulaan subarray; Untuk gelung untuk titik akhir subarray; Permulaan subarray_sum dan sisa_sum ke 0; Untuk gelung untuk mengira jumlah subarray yang dihasilkan; Untuk gelung untuk mengira unsur array sisa jumlah; Memeriksa keadaan apabila jumlah Subarray adalah lebih besar daripada jumlah unsur array yang tinggal; Kod pemacu"}
{"text": "Count the subarray with sum strictly greater than the sum of remaining elements | C ++ implementation of the above approach ; Calculating total sum of given array ; For loop for beginning point of a subarray ; initialise subarray_sum to 0 ; For loop for calculating subarray_sum and remaining_sum ; Calculating subarray_sum and corresponding remaining_sum ; Checking for the condition when subarray sum is strictly greater than the remaining sum of the array element ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Count_subarray ( int arr [ ] , int n ) { int total_sum = 0 , subarray_sum , remaining_sum , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { total_sum += arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { subarray_sum = 0 ; for ( int j = i ; j < n ; j ++ ) { subarray_sum += arr [ j ] ; remaining_sum = total_sum - subarray_sum ; if ( subarray_sum > remaining_sum ) { count += 1 ; } } } return count ; } int main ( ) { int arr [ ] = { 10 , 9 , 12 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << Count_subarray ( arr , n ) ; return 0 ; }", "text_ms": "Kira subarray dengan jumlah yang lebih besar daripada jumlah elemen yang tinggal | C ++ pelaksanaan pendekatan di atas; Mengira jumlah jumlah array yang diberikan; Untuk gelung untuk titik permulaan subarray; permulaan subarray_sum hingga 0; Untuk gelung untuk mengira subarray_sum dan sisa_sum; Mengira subarray_sum dan sisa yang sama; Memeriksa keadaan apabila jumlah Subarray adalah lebih besar daripada jumlah baki elemen array; Kod pemacu"}
{"text": "Remove one element to get maximum XOR | C ++ implementation of the approach ; Function to return the maximized XOR after removing an element from the array ; Find XOR of the complete array ; To store the final answer ; Iterating through the array to find the final answer ; Return the final answer ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxXOR ( int * arr , int n ) { int xorArr = 0 ; for ( int i = 0 ; i < n ; i ++ ) xorArr ^= arr [ i ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans = max ( ans , ( xorArr ^ arr [ i ] ) ) ; return ans ; } int main ( ) { int arr [ ] = { 1 , 1 , 3 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << maxXOR ( arr , n ) ; return 0 ; }", "text_ms": "Keluarkan satu elemen untuk mendapatkan XOR maksimum | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan XOR yang dimaksimumkan selepas mengeluarkan elemen dari array; Cari xor array lengkap; Untuk menyimpan jawapan terakhir; Melangkah melalui array untuk mencari jawapan terakhir; Kembalikan jawapan terakhir; Kod pemacu"}
{"text": "Count of numbers from the range [ L , R ] which contains at least one digit that divides K | C ++ implementation of the approach ; Function that returns true if num contains at least one digit that divides k ; Get the last digit ; If the digit is non - zero and it divides k ; Remove the last digit ; There is no digit in num that divides k ; Function to return the required count of elements from the given range which contain at least one digit that divides k ; To store the result ; For every number from the range ; If any digit of the current number divides k ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool digitDividesK ( int num , int k ) { while ( num ) { int d = num % 10 ; if ( d != 0 and k % d == 0 ) return true ; num = num / 10 ; } return false ; } int findCount ( int l , int r , int k ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( digitDividesK ( i , k ) ) count ++ ; } return count ; } int main ( ) { int l = 20 , r = 35 ; int k = 45 ; cout << findCount ( l , r , k ) ; return 0 ; }", "text_ms": "Kira nombor dari julat [l, r] yang mengandungi sekurang -kurangnya satu digit yang membahagikan k | C ++ pelaksanaan pendekatan; Fungsi yang mengembalikan benar jika NUM mengandungi sekurang -kurangnya satu digit yang membahagikan k; Dapatkan digit terakhir; Jika digit bukan sifar dan ia membahagikan k; Keluarkan digit terakhir; Tiada digit dalam num yang membahagikan k; Fungsi untuk mengembalikan kiraan unsur -unsur yang diperlukan dari julat yang diberikan yang mengandungi sekurang -kurangnya satu digit yang membahagikan k; Untuk menyimpan hasilnya; Untuk setiap nombor dari julat; Jika mana -mana digit nombor semasa membahagikan k; Kod pemacu"}
{"text": "Check if a given number is factorial of any number | C ++ implementation for the above approach ; Function to check if the given number is a factorial of any number ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isFactorial ( int n ) { for ( int i = 1 ; ; i ++ ) { if ( n % i == 0 ) { n /= i ; } else { break ; } } if ( n == 1 ) { return true ; } else { return false ; } } int main ( ) { int n = 24 ; bool ans = isFactorial ( n ) ; if ( ans == 1 ) { cout << \" Yes STRNEWLINE \" ; } else { cout << \" No STRNEWLINE \" ; } return 0 ; }", "text_ms": "Semak jika nombor tertentu adalah faktorial mana -mana nombor | C ++ pelaksanaan untuk pendekatan di atas; Fungsi untuk memeriksa sama ada nombor yang diberikan adalah faktorial bagi mana -mana nombor; Kod pemacu"}
{"text": "Remove an element to minimize the LCM of the given array | C ++ implementation of the above approach ; Function to return the LCM of two numbers ; Function to return the minimum LCM after removing a single element from the given array ; Prefix and Suffix arrays ; Single state dynamic programming relation for storing LCM of first i elements from the left in Prefix [ i ] ; Initializing Suffix array ; Single state dynamic programming relation for storing LCM of all the elements having index greater than or equal to i in Suffix [ i ] ; If first or last element of the array has to be removed ; If any other element is replaced ; Return the minimum LCM ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int lcm ( int a , int b ) { int GCD = __gcd ( a , b ) ; return ( a * b ) / GCD ; } int MinLCM ( int a [ ] , int n ) { int Prefix [ n + 2 ] ; int Suffix [ n + 2 ] ; Prefix [ 1 ] = a [ 0 ] ; for ( int i = 2 ; i <= n ; i += 1 ) { Prefix [ i ] = lcm ( Prefix [ i - 1 ] , a [ i - 1 ] ) ; } Suffix [ n ] = a [ n - 1 ] ; for ( int i = n - 1 ; i >= 1 ; i -= 1 ) { Suffix [ i ] = lcm ( Suffix [ i + 1 ] , a [ i - 1 ] ) ; } int ans = min ( Suffix [ 2 ] , Prefix [ n - 1 ] ) ; for ( int i = 2 ; i < n ; i += 1 ) { ans = min ( ans , lcm ( Prefix [ i - 1 ] , Suffix [ i + 1 ] ) ) ; } return ans ; } int main ( ) { int a [ ] = { 5 , 15 , 9 , 36 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << MinLCM ( a , n ) ; return 0 ; }", "text_ms": "Keluarkan elemen untuk meminimumkan LCM array yang diberikan | C ++ pelaksanaan pendekatan di atas; Berfungsi untuk mengembalikan LCM dua nombor; Berfungsi untuk mengembalikan LCM minimum selepas mengeluarkan satu elemen dari array yang diberikan; Awalan dan akhiran tatasusunan; Hubungan pengaturcaraan dinamik negara tunggal untuk menyimpan LCM unsur -unsur pertama saya dari kiri dalam awalan [i]; Memulakan array akhiran; Hubungan pengaturcaraan dinamik tunggal untuk menyimpan LCM dari semua elemen yang mempunyai indeks lebih besar daripada atau sama dengan saya dalam akhiran [i]; Jika elemen pertama atau terakhir array perlu dikeluarkan; Jika elemen lain diganti; Mengembalikan LCM minimum; Kod pemacu"}
{"text": "Number of coloured 0 's in an N | C ++ implementation of the approach ; Function to return the count of coloured 0 s in an n - level hexagon ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int count ( int n ) { return n * ( 3 * n - 1 ) / 2 ; } int main ( ) { int n = 3 ; cout << count ( n ) ; return 0 ; }", "text_ms": "Bilangan berwarna 0 dalam n | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan kiraan berwarna 0 s dalam segi enam tahap n; Kod pemacu"}
{"text": "Minimum value to be assigned to the elements so that sum becomes greater than initial sum | C ++ implementation of the approach ; Function to return the minimum required value ; Find the sum of the array elements ; Return the required value ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinValue ( int arr [ ] , int n ) { long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return ( ( sum / n ) + 1 ) ; } int main ( ) { int arr [ ] = { 4 , 2 , 1 , 10 , 6 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << findMinValue ( arr , n ) ; return 0 ; }", "text_ms": "Nilai minimum yang akan diberikan kepada unsur -unsur supaya jumlahnya menjadi lebih besar daripada jumlah awal | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan nilai minimum yang diperlukan; Cari jumlah elemen array; Mengembalikan nilai yang diperlukan; Kod pemacu"}
{"text": "Color all boxes in line such that every M consecutive boxes are unique | C ++ implementation of the approach ; Function to return ( m ! % MOD ) ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MOD  1000000007 NEW_LINE int modFact ( int n , int m ) { int result = 1 ; for ( int i = 1 ; i <= m ; i ++ ) result = ( result * i ) % MOD ; return result ; } int main ( ) { int n = 3 , m = 2 ; cout << modFact ( n , m ) ; return 0 ; }", "text_ms": "Warna semua kotak sejajar supaya setiap kotak berturut -turut m adalah unik | C ++ pelaksanaan pendekatan; Fungsi untuk kembali (M! % Mod); Kod pemacu"}
{"text": "Sum of squares of all Subsets of given Array | C ++ implementation of the approach ; Function to return ( 2 ^ P % mod ) ; Function to return the sum of squares of subsets ; Sqauaring the elements and adding it to ans ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int mod = 1e9 + 7 ; long long power ( int p ) { long long res = 1 ; for ( int i = 1 ; i <= p ; ++ i ) { res *= 2 ; res %= mod ; } return res % mod ; } long long subset_square_sum ( vector < int > & A ) { int n = ( int ) A . size ( ) ; long long ans = 0 ; for ( int i : A ) { ans += ( 1LL * i * i ) % mod ; ans %= mod ; } return ( 1LL * ans * power ( n - 1 ) ) % mod ; } int main ( ) { vector < int > A = { 3 , 7 } ; cout << subset_square_sum ( A ) ; return 0 ; }", "text_ms": "Jumlah kuadrat semua subset dari array yang diberikan | C ++ pelaksanaan pendekatan; Berfungsi untuk kembali (2 ^ p % mod); Berfungsi untuk mengembalikan jumlah kuadrat subset; Squuaring unsur -unsur dan menambahkannya ke Ans; Kod pemacu"}
{"text": "Find the number of pairs such that their gcd is equals to 1 | CPP program to find the number of pairs such that gcd equals to 1 ; Function to calculate least prime factor of each number ; If it is a prime number ; For all multiples which are not visited yet . ; Function to find the value of Mobius function for all the numbers from 1 to n ; If number is one ; If number has a squared prime factor ; Multiply - 1 with the previous number ; Function to find the number of pairs such that gcd equals to 1 ; To store maximum number ; To store frequency of each number ; Find frequency and maximum number ; To store number of pairs with gcd equals to 1 ; Traverse through the all possible elements ; Return the number of pairs ; Driver code ; Function call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100050 NEW_LINE int lpf [ N ] , mobius [ N ] ; void least_prime_factor ( ) { for ( int i = 2 ; i < N ; i ++ ) if ( ! lpf [ i ] ) for ( int j = i ; j < N ; j += i ) if ( ! lpf [ j ] ) lpf [ j ] = i ; } void Mobius ( ) { for ( int i = 1 ; i < N ; i ++ ) { if ( i == 1 ) mobius [ i ] = 1 ; else { if ( lpf [ i / lpf [ i ] ] == lpf [ i ] ) mobius [ i ] = 0 ; else mobius [ i ] = -1 * mobius [ i / lpf [ i ] ] ; } } } int gcd_pairs ( int a [ ] , int n ) { int maxi = 0 ; int fre [ N ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { fre [ a [ i ] ] ++ ; maxi = max ( a [ i ] , maxi ) ; } least_prime_factor ( ) ; Mobius ( ) ; int ans = 0 ; for ( int i = 1 ; i <= maxi ; i ++ ) { if ( ! mobius [ i ] ) continue ; int temp = 0 ; for ( int j = i ; j <= maxi ; j += i ) temp += fre [ j ] ; ans += temp * ( temp - 1 ) / 2 * mobius [ i ] ; } return ans ; } int main ( ) { int a [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << gcd_pairs ( a , n ) ; return 0 ; }", "text_ms": "Cari bilangan pasangan supaya GCD mereka sama dengan 1 | Program CPP untuk mencari bilangan pasangan seperti yang GCD sama dengan 1; Berfungsi untuk mengira faktor utama paling kurang setiap nombor; Jika ia adalah nombor utama; Untuk semua gandaan yang belum dikunjungi. ; Berfungsi untuk mencari nilai fungsi Mobius untuk semua nombor dari 1 hingga n; Jika nombor adalah satu; Jika nombor mempunyai faktor utama kuasa; Multiply - 1 dengan nombor sebelumnya; Berfungsi untuk mencari bilangan pasangan seperti yang GCD sama dengan 1; Untuk menyimpan nombor maksimum; Untuk menyimpan kekerapan setiap nombor; Cari kekerapan dan nombor maksimum; Untuk menyimpan nombor pasangan dengan GCD sama dengan 1; Melintasi semua elemen yang mungkin; Mengembalikan bilangan pasangan; Kod pemacu; Panggilan fungsi"}
{"text": "Comparing X ^ Y and Y ^ X for very large values of X and Y | C ++ implementation of the approach ; Function to compare x ^ y and y ^ x ; Storing values OF x ^ y AND y ^ x ; Comparing values ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void compareVal ( int x , int y ) { long double a = y * log ( x ) ; long double b = x * log ( y ) ; if ( a > b ) cout << x << \" ^ \" << y << \" ▁ > ▁ \" << y << \" ^ \" << x ; else if ( a < b ) cout << x << \" ^ \" << y << \" ▁ < ▁ \" << y << \" ^ \" << x ; else if ( a == b ) cout << x << \" ^ \" << y << \" ▁ = ▁ \" << y << \" ^ \" << x ; } int main ( ) { long double x = 4 , y = 5 ; compareVal ( x , y ) ; return 0 ; }", "text_ms": "Membandingkan x ^ y dan y ^ x untuk nilai -nilai yang sangat besar x dan y | C ++ pelaksanaan pendekatan; Fungsi untuk membandingkan x ^ y dan y ^ x; Menyimpan nilai x ^ y dan y ^ x; Membandingkan nilai; Kod pemacu"}
{"text": "Euler zigzag numbers ( Alternating Permutation ) | CPP program to find zigzag sequence ; Function to print first n zigzag numbers ; To store factorial and n 'th zig zag number ; Initialize factorial upto n ; Set first two zig zag numbers ; Print first two zig zag number ; Print the rest zig zag numbers ; Binomial ( n , k ) * a ( k ) * a ( n - k ) ; Store the value ; Print the number ; Driver code ; Function call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void ZigZag ( int n ) { long long fact [ n + 1 ] , zig [ n + 1 ] = { 0 } ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; zig [ 0 ] = 1 ; zig [ 1 ] = 1 ; cout << \" zig ▁ zag ▁ numbers : ▁ \" ; cout << zig [ 0 ] << \" ▁ \" << zig [ 1 ] << \" ▁ \" ; for ( int i = 2 ; i < n ; i ++ ) { long long sum = 0 ; for ( int k = 0 ; k <= i - 1 ; k ++ ) { sum += ( fact [ i - 1 ] / ( fact [ i - 1 - k ] * fact [ k ] ) ) * zig [ k ] * zig [ i - 1 - k ] ; } zig [ i ] = sum / 2 ; cout << sum / 2 << \" ▁ \" ; } } int main ( ) { int n = 10 ; ZigZag ( n ) ; return 0 ; }", "text_ms": "Nombor Euler Zigzag (Permutasi Ganti) | Program CPP untuk mencari urutan zigzag; Berfungsi untuk mencetak nombor zigzag pertama; Untuk menyimpan nombor factorial dan n 'th zig zag; Memulakan factorial sehingga n; Tetapkan dua nombor Zig Zag pertama; Cetak dua nombor zig zag pertama; Cetak nombor zig zag selebihnya; Binomial (n, k) * a (k) * a (n - k); Simpan nilai; Cetak nombor; Kod pemacu; Panggilan fungsi"}
{"text": "Gijswijt 's Sequence | C ++ program to demonstrate Gijswijt 's sequence ; if the sequence is a ( 1 ) a ( 2 ) a ( 3 ) . . a ( n - 1 ) check if the sequence can be represented as x * ( y ^ k ) find the largest value of k ; count ; pattern of elements of size i from the end of sequence ; count ; extract the pattern in a reverse order ; check how many times the pattern is repeated ; if the element dosent match ; if the end of pattern is reached set value of k = 0 and increase the count ; return the max count ; print first n terms of Gijswijt 's sequence ; set the count ; stoes the element ; print the first n terms of the sequence ; push the element ; find the count for next number ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int find_count ( vector < int > ele ) { int count = 0 ; for ( int i = 0 ; i < ele . size ( ) ; i ++ ) { vector < int > p ; int c = 0 ; for ( int j = ele . size ( ) - 1 ; j >= ( ele . size ( ) - 1 - i ) && j >= 0 ; j -- ) p . push_back ( ele [ j ] ) ; int j = ele . size ( ) - 1 , k = 0 ; while ( j >= 0 ) { if ( ele [ j ] != p [ k ] ) break ; j -- ; k ++ ; if ( k == p . size ( ) ) { c ++ ; k = 0 ; } } count = max ( count , c ) ; } return count ; } void solve ( int n ) { int count = 1 ; vector < int > ele ; for ( int i = 0 ; i < n ; i ++ ) { cout << count << \" , ▁ \" ; ele . push_back ( count ) ; count = find_count ( ele ) ; } } int main ( ) { int n = 10 ; solve ( n ) ; return 0 ; }", "text_ms": "Urutan Gijswijt | Program C ++ untuk menunjukkan urutan Gijswijt; Jika urutan adalah (1) a (2) a (3). . A (n - 1) Periksa jika urutan boleh diwakili sebagai x * (y ^ k) mencari nilai terbesar k; kiraan; Corak unsur -unsur saiz I dari akhir urutan; kiraan; ekstrak corak dalam urutan terbalik; Semak berapa kali corak diulang; jika perlawanan dosis elemen; Jika akhir corak dicapai nilai set k = 0 dan tingkatkan kiraan; mengembalikan kiraan maksimum; cetak pertama n terma urutan Gijswijt; Tetapkan kiraan; membongkok elemen; Cetak istilah N pertama urutan; tolak elemen; Cari kiraan untuk nombor seterusnya; Kod pemacu"}
{"text": "Wedderburn – Etherington number | CPP program to find N terms of the sequence ; Stores the Wedderburn Etherington numbers ; Function to return the nth Wedderburn Etherington numbers ; Base case ; If n is even n = 2 x ; get x ; a ( 2 x ) = a ( 1 ) a ( 2 x - 1 ) + a ( 2 ) a ( 2 x - 2 ) + ... + a ( x - 1 ) a ( x + 1 ) ; a ( x ) ( a ( x ) + 1 ) / 2 ; Store the ans ; Return the required answer ; If n is odd ; a ( 2 x - 1 ) = a ( 1 ) a ( 2 x - 2 ) + a ( 2 ) a ( 2 x - 3 ) + ... + a ( x - 1 ) a ( x ) , ; Store the ans ; Return the required answer ; Function to print first N Wedderburn Etherington numbers ; Store first 3 numbers ; Print N terms ; Driver code ; function call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; map < int , int > store ; int Wedderburn ( int n ) { if ( n <= 2 ) return store [ n ] ; else if ( n % 2 == 0 ) { int x = n / 2 , ans = 0 ; for ( int i = 1 ; i < x ; i ++ ) { ans += store [ i ] * store [ n - i ] ; } ans += ( store [ x ] * ( store [ x ] + 1 ) ) / 2 ; store [ n ] = ans ; return ans ; } else { int x = ( n + 1 ) / 2 , ans = 0 ; for ( int i = 1 ; i < x ; i ++ ) { ans += store [ i ] * store [ n - i ] ; } store [ n ] = ans ; return ans ; } } void Wedderburn_Etherington ( int n ) { store [ 0 ] = 0 ; store [ 1 ] = 1 ; store [ 2 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { cout << Wedderburn ( i ) ; if ( i != n - 1 ) cout << \" , ▁ \" ; } } int main ( ) { int n = 10 ; Wedderburn_Etherington ( n ) ; return 0 ; }", "text_ms": "Wedderburn - Nombor Etherington | Program CPP untuk mencari istilah urutan; Menyimpan nombor Wedderburn Etherington; Berfungsi untuk mengembalikan nombor Nth Wedderburn Etherington; Kes asas; Jika n adalah n = 2 x; Dapatkan x; A (2 x) = A (1) A (2 x - 1) + A (2) A (2 x - 2) + ... + A (x - 1) A (x + 1); a (x) (a (x) + 1) / 2; Simpan Ans; Mengembalikan jawapan yang diperlukan; Jika n adalah ganjil; a (2 x - 1) = a (1) a (2 x - 2) + a (2) a (2 x - 3) + ... + a (x - 1) a (x) ,; Simpan Ans; Mengembalikan jawapan yang diperlukan; Berfungsi untuk mencetak nombor N First N Wedderburn Etherington; Simpan nombor 3 pertama; Cetak n terma; Kod pemacu; panggilan fungsi"}
{"text": "Maximum value after merging all elements in the array | CPP program to maximum value after merging all elements in the array ; Function to maximum value after merging all elements in the array ; To check if positive and negative elements present or not ; Check for positive integer ; Check for negative integer ; If both positive and negative elements are present ; To store maximum value possible ; To find minimum value ; Remove minimum element ; Replace with absolute values ; To find minimum value ; Remove minimum element ; Return the required sum ; Driver code ; Function call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Max_sum ( int a [ ] , int n ) { int pos = 0 , neg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > 0 ) pos = 1 ; else if ( a [ i ] < 0 ) neg = 1 ; if ( pos == 1 and neg == 1 ) break ; } int sum = 0 ; if ( pos == 1 and neg == 1 ) { for ( int i = 0 ; i < n ; i ++ ) sum += abs ( a [ i ] ) ; } else if ( pos == 1 ) { int mini = a [ 0 ] ; sum = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { mini = min ( mini , a [ i ] ) ; sum += a [ i ] ; } sum -= 2 * mini ; } else if ( neg == 1 ) { for ( int i = 0 ; i < n ; i ++ ) a [ i ] = abs ( a [ i ] ) ; int mini = a [ 0 ] ; sum = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { mini = min ( mini , a [ i ] ) ; sum += a [ i ] ; } sum -= 2 * mini ; } return sum ; } int main ( ) { int a [ ] = { 1 , 3 , 5 , -2 , -6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << Max_sum ( a , n ) ; return 0 ; }", "text_ms": "Nilai maksimum selepas menggabungkan semua elemen dalam array | Program CPP ke nilai maksimum selepas menggabungkan semua elemen dalam array; Berfungsi dengan nilai maksimum selepas menggabungkan semua elemen dalam array; Untuk memeriksa sama ada elemen positif dan negatif hadir atau tidak; Semak integer positif; Semak integer negatif; Jika kedua -dua unsur positif dan negatif hadir; Untuk menyimpan nilai maksimum yang mungkin; Untuk mencari nilai minimum; Keluarkan elemen minimum; Menggantikan dengan nilai mutlak; Untuk mencari nilai minimum; Keluarkan elemen minimum; Mengembalikan jumlah yang diperlukan; Kod pemacu; Panggilan fungsi"}
{"text": "Decimal to Binary using recursion and without using power operator | C ++ implementation of the approach ; Recursive function to convert n to its binary equivalent ; Base case ; Recursive call ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void decimalToBinary ( int n ) { if ( n == 0 ) { cout << \"0\" ; return ; } decimalToBinary ( n / 2 ) ; cout << n % 2 ; } int main ( ) { int n = 13 ; decimalToBinary ( n ) ; return 0 ; }", "text_ms": "Perpuluhan untuk binari menggunakan rekursi dan tanpa menggunakan pengendali kuasa | C ++ pelaksanaan pendekatan; Fungsi rekursif untuk menukar n kepada bersamaan binari; Kes asas; Panggilan rekursif; Kod pemacu"}
{"text": "Find minimum possible values of A , B and C when two of the ( A + B ) , ( A + C ) and ( B + C ) are given | C ++ implementation of the approach ; Function to find A , B and C ; Keep minimum number in x ; Find the numbers ; Driver code ; Function call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void MinimumValue ( int x , int y ) { if ( x > y ) swap ( x , y ) ; int a = 1 ; int b = x - 1 ; int c = y - b ; cout << a << \" ▁ \" << b << \" ▁ \" << c ; } int main ( ) { int x = 123 , y = 13 ; MinimumValue ( x , y ) ; return 0 ; }", "text_ms": "Cari nilai minimum a, b dan c apabila dua (a + b), (a + c) dan (b + c) diberikan | C ++ pelaksanaan pendekatan; Berfungsi untuk mencari A, B dan C; Simpan nombor minimum dalam x; Cari nombor; Kod pemacu; Panggilan fungsi"}
{"text": "Check whether it is possible to convert A into B | C ++ implementation of the approach ; Function that returns true if A can be converted to B with the given operations ; If the current number ends with 1 ; If the current number is divisible by 2 ; If above two conditions fail ; If it is possible to convert A to B ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool canConvert ( int a , int b ) { while ( b > a ) { if ( b % 10 == 1 ) { b /= 10 ; continue ; } if ( b % 2 == 0 ) { b /= 2 ; continue ; } return false ; } if ( b == a ) return true ; return false ; } int main ( ) { int A = 2 , B = 82 ; if ( canConvert ( A , B ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "text_ms": "Semak sama ada mungkin untuk menukar A ke B | C ++ pelaksanaan pendekatan; Fungsi yang mengembalikan benar jika A boleh ditukar kepada B dengan operasi yang diberikan; Jika nombor semasa berakhir dengan 1; Jika nombor semasa boleh dibahagikan dengan 2; Jika di atas dua keadaan gagal; Sekiranya mungkin untuk menukar A ke B; Kod pemacu"}
{"text": "Count Distinct Rectangles in N * N Chessboard | C ++ code to count distinct rectangle in a chessboard ; Function to return the count of distinct rectangles ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int count ( int N ) { int a = 0 ; a = ( N * ( N + 1 ) ) / 2 ; return a ; } int main ( ) { int N = 4 ; cout << count ( N ) ; }", "text_ms": "Count Rectangles yang berbeza dalam N * N Chessboard | C ++ kod untuk mengira segi empat tepat yang berbeza dalam papan catur; Berfungsi untuk mengembalikan kiraan segi empat tepat; Kod pemacu"}
{"text": "Total number of days taken to complete the task if after certain days one person leaves | C ++ implementation of the approach ; Function to return the number of days required ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberOfDays ( int a , int b , int n ) { int Days = b * ( n + a ) / ( a + b ) ; return Days ; } int main ( ) { int a = 10 , b = 20 , n = 5 ; cout << numberOfDays ( a , b , n ) ; return 0 ; }", "text_ms": "Jumlah hari yang diambil untuk menyelesaikan tugas jika selepas hari -hari tertentu seseorang meninggalkan | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan bilangan hari yang diperlukan; Kod pemacu"}
{"text": "Find average of two numbers using bit operation | C ++ implementation of the approach ; Function to return the average of x and y using bit operations ; Calculate the average Floor value of ( x + y ) / 2 ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int getAverage ( int x , int y ) { int avg = ( x & y ) + ( ( x ^ y ) >> 1 ) ; return avg ; } int main ( ) { int x = 10 , y = 9 ; cout << getAverage ( x , y ) ; return 0 ; }", "text_ms": "Cari purata dua nombor menggunakan operasi bit | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan purata x dan y menggunakan operasi bit; Kirakan nilai lantai purata (x + y) / 2; Kod pemacu"}
{"text": "Smallest index such that there are no 0 or 1 to its right | C ++ program to implement the above approach ; Function to find the smallest index such that there are no 0 or 1 to its right ; Initially ; Traverse in the array ; Check if array element is 1 ; a [ i ] = 0 ; Return minimum of both ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int smallestIndex ( int a [ ] , int n ) { int right1 = 0 , right0 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) right1 = i ; else right0 = i ; } return min ( right1 , right0 ) ; } int main ( ) { int a [ ] = { 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << smallestIndex ( a , n ) ; return 0 ; }", "text_ms": "Indeks terkecil sedemikian rupa sehingga tidak ada 0 atau 1 di sebelah kanannya | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari indeks terkecil sedemikian rupa sehingga tidak ada 0 atau 1 di sebelah kanannya; Pada mulanya; Melintasi array; Semak jika elemen array adalah 1; a [i] = 0; Kembali minimum kedua -duanya; Kod pemacu"}
{"text": "Total position where king can reach on a chessboard in exactly M moves | Set 2 | C ++ implementation of the approach ; Function to return the count of squares that can be visited by king in m moves ; To store the count of squares ; Check all squares of the chessboard ; Check if square ( i , j ) is at a distance <= m units from king 's current position ; Return count of squares ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSquares ( int r , int c , int m ) { int squares = 0 ; for ( int i = 1 ; i <= 8 ; i ++ ) { for ( int j = 1 ; j <= 8 ; j ++ ) { if ( max ( abs ( i - r ) , abs ( j - c ) ) <= m ) squares ++ ; } } return squares ; } int main ( ) { int r = 4 , c = 4 , m = 1 ; cout << countSquares ( r , c , m ) << endl ; return 0 ; }", "text_ms": "Jumlah kedudukan di mana raja boleh sampai di papan catur dengan tepat m bergerak | Tetapkan 2 | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan kiraan dataran yang boleh dikunjungi oleh raja dalam gerakan; Untuk menyimpan kiraan dataran; Semak semua dataran papan catur; Semak jika persegi (i, j) berada pada jarak <= m unit dari kedudukan semasa Raja; Kembali kiraan kuadrat; Kod pemacu"}
{"text": "Number of quadruples where the first three terms are in AP and last three terms are in GP | C ++ implementation of the approach ; Function to return the count of quadruples ; Hash table to count the number of occurrences ; Traverse and increment the count ; Run two nested loop for second and third element ; If they are same ; Initially decrease the count ; Find the first element using common difference ; Find the fourth element using GP y ^ 2 = x * z property ; If it is an integer ; If not equal ; Same elements ; Later increase the value for future calculations ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countQuadruples ( int a [ ] , int n ) { unordered_map < int , int > mpp ; for ( int i = 0 ; i < n ; i ++ ) mpp [ a [ i ] ] ++ ; int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( j == k ) continue ; mpp [ a [ j ] ] -- ; mpp [ a [ k ] ] -- ; int first = a [ j ] - ( a [ k ] - a [ j ] ) ; int fourth = ( a [ k ] * a [ k ] ) / a [ j ] ; if ( ( a [ k ] * a [ k ] ) % a [ j ] == 0 ) { if ( a [ j ] != a [ k ] ) count += mpp [ first ] * mpp [ fourth ] ; else count += mpp [ first ] * ( mpp [ fourth ] - 1 ) ; } mpp [ a [ j ] ] ++ ; mpp [ a [ k ] ] ++ ; } } return count ; } int main ( ) { int a [ ] = { 2 , 6 , 4 , 9 , 2 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << countQuadruples ( a , n ) ; return 0 ; }", "text_ms": "Bilangan kuadrup di mana tiga syarat pertama berada dalam AP dan tiga istilah terakhir adalah dalam gp | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan kiraan kuadrup; Jadual Hash untuk mengira bilangan kejadian; Melintasi dan meningkatkan kiraan; Jalankan dua gelung bersarang untuk elemen kedua dan ketiga; Jika mereka sama; Pada mulanya mengurangkan kiraan; Cari elemen pertama menggunakan perbezaan bersama; Cari elemen keempat menggunakan gp y ^ 2 = x * z harta; Jika ia adalah integer; Jika tidak sama; Unsur yang sama; Kemudian meningkatkan nilai untuk pengiraan masa depan; Kod pemacu"}
{"text": "Numbers in a Range with given Digital Root | C ++ implementation of the approach ; Function to return the count of required numbers ; Count of numbers present in given range ; Number of groups of 9 elements starting from L ; Left over elements not covered in factor 9 ; One Number in each group of 9 ; To check if any number in rem satisfy the property ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; int countNumbers ( int L , int R , int K ) { if ( K == 9 ) K = 0 ; int totalnumbers = R - L + 1 ; int factor9 = totalnumbers / 9 ; int rem = totalnumbers % 9 ; int ans = factor9 ; for ( int i = R ; i > R - rem ; i -- ) { int rem1 = i % 9 ; if ( rem1 == K ) ans ++ ; } return ans ; } int main ( ) { int L = 10 ; int R = 22 ; int K = 3 ; cout << countNumbers ( L , R , K ) ; return 0 ; }", "text_ms": "Nombor dalam julat dengan akar digital yang diberikan | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan kiraan nombor yang diperlukan; Kiraan nombor yang ada dalam julat yang diberikan; Bilangan kumpulan 9 elemen bermula dari L; Meninggalkan unsur -unsur yang tidak diliputi dalam Faktor 9; Satu nombor dalam setiap kumpulan 9; Untuk memeriksa sama ada nombor dalam REM memenuhi harta itu; Kod pemacu"}
{"text": "Sum of even values and update queries on an array | C ++ implementation of the approach ; Function to return the sum of even elements after updating value at given index ; Add given value to A [ index ] ; To store the sum of even elements ; If current element is even ; Function to print the result for every query ; Resultant vector that stores the result for every query ; Get sum of even elements after updating value at given index ; Store sum for each query ; Print the result for every query ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int EvenSum ( vector < int > & A , int index , int value ) { A [ index ] = A [ index ] + value ; int sum = 0 ; for ( int i = 0 ; i < A . size ( ) ; i ++ ) if ( A [ i ] % 2 == 0 ) sum = sum + A [ i ] ; return sum ; } void BalanceArray ( vector < int > & A , vector < vector < int > > & Q ) { vector < int > ANS ; int i , sum ; for ( i = 0 ; i < Q . size ( ) ; i ++ ) { int index = Q [ i ] [ 0 ] ; int value = Q [ i ] [ 1 ] ; sum = EvenSum ( A , index , value ) ; ANS . push_back ( sum ) ; } for ( i = 0 ; i < ANS . size ( ) ; i ++ ) cout << ANS [ i ] << \" ▁ \" ; } int main ( ) { vector < int > A = { 1 , 2 , 3 , 4 } ; vector < vector < int > > Q = { { 0 , 1 } , { 1 , -3 } , { 0 , -4 } , { 3 , 2 } } ; BalanceArray ( A , Q ) ; return 0 ; }", "text_ms": "Jumlah nilai dan kemas kini pertanyaan pada array | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan jumlah elemen walaupun selepas mengemas kini nilai pada indeks yang diberikan; Tambah nilai yang diberikan kepada [indeks]; Untuk menyimpan jumlah elemen walaupun; Jika elemen semasa adalah walaupun; Berfungsi untuk mencetak hasil untuk setiap pertanyaan; Vektor yang dihasilkan yang menyimpan hasil untuk setiap pertanyaan; Dapatkan jumlah elemen walaupun selepas mengemas kini nilai pada indeks yang diberikan; Simpan jumlah untuk setiap pertanyaan; Cetak hasil untuk setiap pertanyaan; Kod pemacu"}
{"text": "Sum of even values and update queries on an array | C ++ implementation of the approach ; Function to print the result for every query ; If current element is even ; If element is even then remove it from sum ; If the value becomes even after updating ; Store sum for each query ; Print the result for every query ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void BalanceArray ( vector < int > & A , vector < vector < int > > & Q ) { vector < int > ANS ; int i , sum = 0 ; for ( i = 0 ; i < A . size ( ) ; i ++ ) if ( A [ i ] % 2 == 0 ) sum = sum + A [ i ] ; for ( i = 0 ; i < Q . size ( ) ; i ++ ) { int index = Q [ i ] [ 0 ] ; int value = Q [ i ] [ 1 ] ; if ( A [ index ] % 2 == 0 ) sum = sum - A [ index ] ; A [ index ] = A [ index ] + value ; if ( A [ index ] % 2 == 0 ) sum = sum + A [ index ] ; ANS . push_back ( sum ) ; } for ( i = 0 ; i < ANS . size ( ) ; i ++ ) cout << ANS [ i ] << \" ▁ \" ; } int main ( ) { vector < int > A = { 1 , 2 , 3 , 4 } ; vector < vector < int > > Q = { { 0 , 1 } , { 1 , -3 } , { 0 , -4 } , { 3 , 2 } } ; BalanceArray ( A , Q ) ; return 0 ; }", "text_ms": "Jumlah nilai dan kemas kini pertanyaan pada array | C ++ pelaksanaan pendekatan; Berfungsi untuk mencetak hasil untuk setiap pertanyaan; Jika elemen semasa adalah walaupun; Jika elemen bahkan kemudian keluarkannya dari jumlah; Jika nilai menjadi walaupun selepas mengemas kini; Simpan jumlah untuk setiap pertanyaan; Cetak hasil untuk setiap pertanyaan; Kod pemacu"}
{"text": "Number of Hamiltonian cycle | C ++ program for implementation of the above program ; Function that calculates number of Hamiltonian cycle ; Calculating factorial ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Cycles ( int N ) { int fact = 1 , result = 0 ; result = N - 1 ; int i = result ; while ( i > 0 ) { fact = fact * i ; i -- ; } return fact / 2 ; } int main ( ) { int N = 5 ; int Number = Cycles ( N ) ; cout << \" Hamiltonian ▁ cycles ▁ = ▁ \" << Number ; return 0 ; }", "text_ms": "Bilangan Siklus Hamiltonian | Program C ++ untuk pelaksanaan program di atas; Fungsi yang mengira bilangan kitaran Hamiltonian; Mengira faktorial; Kod pemacu"}
{"text": "Smallest integer greater than n such that it consists of digit m exactly k times | C ++ implementation of the approach ; Function that returns true if n contains digit m exactly k times ; Function to return the smallest integer > n with digit m occurring exactly k times ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool digitWell ( int n , int m , int k ) { int cnt = 0 ; while ( n > 0 ) { if ( n % 10 == m ) ++ cnt ; n /= 10 ; } return cnt == k ; } int findInt ( int n , int m , int k ) { int i = n + 1 ; while ( true ) { if ( digitWell ( i , m , k ) ) return i ; i ++ ; } } int main ( ) { int n = 111 , m = 2 , k = 2 ; cout << findInt ( n , m , k ) ; return 0 ; }", "text_ms": "Integer terkecil lebih besar daripada n sedemikian rupa sehingga ia terdiri daripada digit m tepat kali K | C ++ pelaksanaan pendekatan; Fungsi yang pulih benar jika n mengandungi digit m tepat k kali; Berfungsi untuk mengembalikan integer terkecil> n dengan digit m yang berlaku tepat kali K; Kod pemacu"}
{"text": "Composite XOR and Coprime AND | C ++ implementation of the approach ; Function to return the count of odd numbers in the array ; Variable to count odd numbers ; Odd number ; Function to return the count of valid pairs ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countOdd ( int arr [ ] , int n ) { int odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) odd ++ ; } return odd ; } int countValidPairs ( int arr [ ] , int n ) { int odd = countOdd ( arr , n ) ; return ( odd * ( odd - 1 ) ) / 2 ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countValidPairs ( arr , n ) ; return 0 ; }", "text_ms": "KOMPOSITE XOR DAN COPRIME DAN | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan kiraan nombor ganjil dalam array; Pembolehubah untuk mengira nombor ganjil; Nombor ganjil; Berfungsi untuk mengembalikan kiraan pasangan yang sah; Kod pemacu"}
{"text": "Smallest perfect Cube divisible by all elements of an array | C ++ implementation of the approach ; Function to return the gcd of two numbers ; Function to return the lcm of all the elements of the array ; To calculate lcm of two numbers multiply them and divide the result by gcd of both the numbers ; Return the LCM of the array elements ; Function to return the smallest perfect cube divisible by all the elements of arr [ ] ; LCM of all the elements of arr [ ] ; If 2 divides lcm cnt number of times ; Check all the numbers that divide lcm ; Return the answer ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE ll gcd ( ll a , ll b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; } ll lcmOfArray ( int arr [ ] , int n ) { if ( n < 1 ) return 0 ; ll lcm = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) lcm = ( lcm * arr [ i ] ) / gcd ( lcm , arr [ i ] ) ; return lcm ; } int minPerfectCube ( int arr [ ] , int n ) { ll minPerfectCube ; ll lcm = lcmOfArray ( arr , n ) ; minPerfectCube = ( long long ) lcm ; int cnt = 0 ; while ( lcm > 1 && lcm % 2 == 0 ) { cnt ++ ; lcm /= 2 ; } if ( cnt % 3 == 2 ) minPerfectCube *= 2 ; else if ( cnt % 3 == 1 ) minPerfectCube *= 4 ; int i = 3 ; while ( lcm > 1 ) { cnt = 0 ; while ( lcm % i == 0 ) { cnt ++ ; lcm /= i ; } if ( cnt % 3 == 1 ) minPerfectCube *= i * i ; else if ( cnt % 3 == 2 ) minPerfectCube *= i ; i += 2 ; } return minPerfectCube ; } int main ( ) { int arr [ ] = { 10 , 125 , 14 , 42 , 100 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minPerfectCube ( arr , n ) ; return 0 ; }", "text_ms": "Cube sempurna terkecil dibahagi dengan semua elemen array | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan GCD dua nombor; Berfungsi untuk mengembalikan LCM semua elemen array; Untuk mengira LCM dua nombor melipatgandakan mereka dan membahagikan hasilnya dengan GCD kedua -dua nombor; Mengembalikan LCM unsur -unsur array; Berfungsi untuk mengembalikan kiub sempurna yang paling kecil yang boleh dibahagikan dengan semua elemen arr []; LCM semua elemen ARR []; Jika 2 membahagikan bilangan kali LCM CNT; Semak semua nombor yang membahagikan LCM; Kembalikan jawapannya; Kod pemacu"}
{"text": "Check if N is Strong Prime | C ++ program to check if given number is strong prime ; Utility function to check if a number is prime or not ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Function that returns true if n is a strong prime ; If n is not a prime number or n is the first prime then return false ; Initialize previous_prime to n - 1 and next_prime to n + 1 ; Find next prime number ; Find previous prime number ; Arithmetic mean ; If n is a strong prime ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static bool isStrongPrime ( int n ) { if ( ! isPrime ( n ) n == 2 ) return false ; int previous_prime = n - 1 ; int next_prime = n + 1 ; while ( ! isPrime ( next_prime ) ) next_prime ++ ; while ( ! isPrime ( previous_prime ) ) previous_prime -- ; int mean = ( previous_prime + next_prime ) / 2 ; if ( n > mean ) return true ; else return false ; } int main ( ) { int n = 11 ; if ( isStrongPrime ( n ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "text_ms": "Semak jika n adalah Perdana yang kuat | Program C ++ untuk memeriksa sama ada nombor yang diberikan adalah perdana yang kuat; Fungsi utiliti untuk memeriksa sama ada nombor adalah perdana atau tidak; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; Fungsi yang kembali benar jika n adalah perdana yang kuat; Jika n bukan nombor perdana atau n adalah perdana pertama maka kembali palsu; Inisialisasi sebelumnya_prime ke n - 1 dan next_prime ke n + 1; Cari nombor perdana seterusnya; Cari nombor perdana sebelumnya; Min aritmetik; Jika n adalah perdana yang kuat; Kod pemacu"}
{"text": "Minimum removals in a number to be divisible by 10 power raised to K | CPP Program to count the number of digits that can be removed such that number is divisible by 10 ^ K ; function to return the required number of digits to be removed ; Converting the given number into string ; variable to store number of digits to be removed ; variable to denote if atleast one zero has been found ; zero found ; return size - 1 if K is not zero and atleast one zero is present , otherwise result ; Driver Code to test above function", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countDigitsToBeRemoved ( int N , int K ) { string s = to_string ( N ) ; int res = 0 ; int f_zero = 0 ; for ( int i = s . size ( ) - 1 ; i >= 0 ; i -- ) { if ( K == 0 ) return res ; if ( s [ i ] == '0' ) { f_zero = 1 ; K -- ; } else res ++ ; } if ( ! K ) return res ; else if ( f_zero ) return s . size ( ) - 1 ; return -1 ; } int main ( ) { int N = 10904025 , K = 2 ; cout << countDigitsToBeRemoved ( N , K ) << endl ; N = 1000 , K = 5 ; cout << countDigitsToBeRemoved ( N , K ) << endl ; N = 23985 , K = 2 ; cout << countDigitsToBeRemoved ( N , K ) << endl ; return 0 ; }", "text_ms": "Penyingkiran minimum dalam nombor yang boleh dibahagikan dengan 10 kuasa yang dibangkitkan kepada k | Program CPP untuk mengira bilangan digit yang boleh dikeluarkan sedemikian rupa sehingga nombor itu boleh dibahagikan dengan 10 ^ k; berfungsi untuk mengembalikan bilangan digit yang diperlukan untuk dikeluarkan; Menukar nombor yang diberikan ke dalam rentetan; pembolehubah untuk menyimpan nombor digit yang akan dikeluarkan; Pembolehubah untuk menunjukkan jika sekurang -kurangnya satu sifar telah dijumpai; sifar dijumpai; saiz pulangan - 1 jika k tidak sifar dan atleast satu sifar hadir, jika tidak hasilnya; Kod pemacu untuk menguji fungsi di atas"}
{"text": "Program to find the sum of the series ( 1 / a + 2 / a ^ 2 + 3 / a ^ 3 + ... + n / a ^ n ) | C ++ program to find the sum of the given series ; Function to return the sum of the series ; variable to store the answer ; Math . pow ( x , y ) returns x ^ y ; Driver code ; Print the sum of the series", "code": "#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE #include <iostream> NEW_LINE using namespace std ; float getSum ( int a , int n ) { float sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { sum += ( i / pow ( a , i ) ) ; } return sum ; } int main ( ) { int a = 3 , n = 3 ; cout << ( getSum ( a , n ) ) ; return 0 ; }", "text_ms": "Program untuk mencari jumlah siri (1 / a + 2 / a ^ 2 + 3 / a ^ 3 + ... + n / a ^ n) | Program C ++ untuk mencari jumlah siri yang diberikan; Berfungsi untuk mengembalikan jumlah siri; pembolehubah untuk menyimpan jawapannya; Matematik. pow (x, y) mengembalikan x ^ y; Kod pemacu; Cetak jumlah siri"}
{"text": "Check if a number is an Unusual Number or not | C ++ Program to check Unusual number ; Utility function to find largest prime factor of a number ; Initialize the maximum prime factor variable with the lowest one ; Print the number of 2 s that divide n ; n >>= 1 ; equivalent to n /= 2 ; n must be odd at this point , thus skip the even numbers and iterate only for odd integers ; This condition is to handle the case when n is a prime number greater than 2 ; Function to check Unusual number ; Get the largest Prime Factor of the number ; Check if largest prime factor is greater than sqrt ( n ) ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int largestPrimeFactor ( int n ) { int max = -1 ; while ( n % 2 == 0 ) { max = 2 ; } for ( int i = 3 ; i <= sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { max = i ; n = n / i ; } } if ( n > 2 ) max = n ; return max ; } bool checkUnusual ( int n ) { int factor = largestPrimeFactor ( n ) ; if ( factor > sqrt ( n ) ) { return true ; } else { return false ; } } int main ( ) { int n = 14 ; if ( checkUnusual ( n ) ) { cout << \" YES \" << \" STRNEWLINE \" ; } else { cout << \" NO \" << \" STRNEWLINE \" ; } return 0 ; }", "text_ms": "Semak sama ada nombor adalah nombor yang tidak biasa atau tidak | Program C ++ untuk memeriksa nombor yang tidak biasa; Fungsi utiliti untuk mencari faktor utama terbesar bagi nombor; Memulakan pemboleh ubah faktor utama maksimum dengan yang paling rendah; Cetak bilangan 2 s yang membahagikan n; n >> = 1; bersamaan dengan n /= 2; n mesti ganjil pada ketika ini, dengan itu melangkau nombor -nombor bahkan dan berulang hanya untuk bilangan bulat yang ganjil; Keadaan ini adalah untuk mengendalikan kes apabila n adalah nombor utama lebih besar daripada 2; Berfungsi untuk memeriksa nombor yang tidak biasa; Dapatkan faktor utama terbesar nombor; Semak jika faktor utama terbesar adalah lebih besar daripada sqrt (n); Kod pemacu"}
{"text": "Check if at least half array is reducible to zero by performing some operations | C ++ program to find whether half - array reducible to 0 ; Function to print the desired result after computation ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void isHalfReducible ( int arr [ ] , int n , int m ) { int frequencyHash [ m + 1 ] ; int i ; memset ( frequencyHash , 0 , sizeof ( frequencyHash ) ) ; for ( i = 0 ; i < n ; i ++ ) { frequencyHash [ arr [ i ] % ( m + 1 ) ] ++ ; } for ( i = 0 ; i <= m ; i ++ ) { if ( frequencyHash [ i ] >= n / 2 ) break ; } if ( i <= m ) cout << \" Yes \" << endl ; else cout << \" No \" << endl ; } int main ( ) { int arr [ ] = { 8 , 16 , 32 , 3 , 12 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int m = 7 ; isHalfReducible ( arr , n , m ) ; return 0 ; }", "text_ms": "Semak jika sekurang -kurangnya separuh array boleh diturunkan kepada sifar dengan melakukan beberapa operasi | Program C ++ untuk mencari sama ada separuh - array boleh diturunkan kepada 0; Berfungsi untuk mencetak hasil yang diingini selepas pengiraan; Kod pemacu"}
{"text": "Check if the given number is Ore number or not | CPP program to check if the given number is Ore number ; Function that returns harmonic mean ; Note that this loop runs till square root ; If divisors are equal , store ' i ' ; else Otherwise store ' i ' and ' n / i ' both ; Utility function to calculate harmonic mean of the divisors ; Declare sum variables and initialize with zero . ; calculate denominator ; Calculate harmonic mean and return ; Function to check if a number is ore number ; Calculate Harmonic mean of divisors of n ; Check if harmonic mean is an integer or not ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > arr ; void generateDivisors ( int n ) { for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) arr . push_back ( i ) ; { arr . push_back ( i ) ; arr . push_back ( n / i ) ; } } } } double harmonicMean ( int n ) { generateDivisors ( n ) ; double sum = 0.0 ; int len = arr . size ( ) ; for ( int i = 0 ; i < len ; i ++ ) sum = sum + double ( n / arr [ i ] ) ; sum = double ( sum / n ) ; return double ( arr . size ( ) / sum ) ; } bool isOreNumber ( int n ) { double mean = harmonicMean ( n ) ; if ( mean - int ( mean ) == 0 ) return true ; else return false ; } int main ( ) { int n = 28 ; if ( isOreNumber ( n ) ) cout << \" YES \" ; else cout << \" NO \" ; return 0 ; }", "text_ms": "Semak jika nombor yang diberikan adalah nombor bijih atau tidak | Program CPP untuk memeriksa sama ada nombor yang diberikan adalah nombor bijih; Fungsi yang mengembalikan min harmonik; Perhatikan bahawa gelung ini berjalan sehingga akar persegi; Jika pembahagi sama, simpan 'i'; lain sebaliknya menyimpan 'i' dan 'n / i' kedua -duanya; Fungsi utiliti untuk mengira min harmonik pembahagi; Mengisytiharkan pembolehubah jumlah dan permulaan dengan sifar. ; hitung penyebut; Mengira min dan pulangan harmonik; Berfungsi untuk memeriksa sama ada nombor adalah nombor bijih; Kirakan min harmonik pembahagi n; Semak jika min harmonik adalah integer atau tidak; Kod pemacu"}
{"text": "Check whether the given number is Euclid Number or not | CPP program to check Euclid Number ; Function to generate the Prime numbers and store their products ; Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; store prefix product of prime numbers to unordered_set ' s ' ; update product by multiplying next prime ; insert ' produc + 1' to set ; Function to check the number for Euclid Number ; Check if number exist in unordered set or not If exist , return true ; Driver code ; Get the prime numbers ; Get n ; Check if n is Euclid Number ; Get n ; Check if n is Euclid Number", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  10000 NEW_LINE unordered_set < long long int > s ; void SieveOfEratosthenes ( ) { bool prime [ MAX ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } long long int product = 1 ; for ( int p = 2 ; p < MAX ; p ++ ) { if ( prime [ p ] ) { product = product * p ; s . insert ( product + 1 ) ; } } } bool isEuclid ( long n ) { if ( s . find ( n ) != s . end ( ) ) return true ; else return false ; } int main ( ) { SieveOfEratosthenes ( ) ; long n = 31 ; if ( isEuclid ( n ) ) cout << \" YES STRNEWLINE \" ; else cout << \" NO STRNEWLINE \" ; n = 42 ; if ( isEuclid ( n ) ) cout << \" YES STRNEWLINE \" ; else cout << \" NO STRNEWLINE \" ; return 0 ; }", "text_ms": "Semak sama ada nombor yang diberikan adalah nombor Euclid atau tidak | Program CPP untuk memeriksa nombor Euclid; Berfungsi untuk menjana nombor utama dan menyimpan produk mereka; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; kedai awalan produk nombor utama ke unordered_set 's'; mengemas kini produk dengan mendarabkan Perdana Seterusnya; Masukkan 'Produce + 1' untuk ditetapkan; Berfungsi untuk memeriksa nombor untuk nombor Euclid; Periksa sama ada nombor wujud dalam set yang tidak teratur atau tidak jika ada, kembali benar; Kod pemacu; Dapatkan nombor utama; Dapatkan n; Semak jika n adalah nombor euclid; Dapatkan n; Periksa sama ada n adalah nombor euclid"}
{"text": "Check whether the given number is Wagstaff prime or not | CPP program to check if a number is Wagstaff prime or not ; Function to check if a number is prime or not ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Utility function to check power of two ; Driver Program ; Check if number is prime and of the form ( 2 ^ q + 1 ) / 3", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; } bool isPowerOfTwo ( int n ) { return ( n && ! ( n & ( n - 1 ) ) ) ; } int main ( ) { int n = 43 ; if ( isPrime ( n ) && ( isPowerOfTwo ( n * 3 - 1 ) ) ) { cout << \" YES STRNEWLINE \" ; } else { cout << \" NO STRNEWLINE \" ; } return 0 ; }", "text_ms": "Semak sama ada nombor yang diberikan ialah Wagstaff Prime atau tidak | Program CPP untuk memeriksa sama ada nombor adalah Wagstaff Prime atau tidak; Berfungsi untuk memeriksa sama ada nombor adalah perdana atau tidak; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; Fungsi utiliti untuk memeriksa kuasa dua; Program pemacu; Semak jika nombor adalah perdana dan borang (2 ^ q + 1) / 3"}
{"text": "Area of a square inscribed in a circle which is inscribed in a hexagon | C ++ Program to find the area of the square inscribed within the circle which in turn is inscribed in a hexagon ; Function to find the area of the square ; side of hexagon cannot be negative ; area of the square ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float area ( float a ) { if ( a < 0 ) return -1 ; float area = pow ( ( a * sqrt ( 3 ) ) / ( sqrt ( 2 ) ) , 2 ) ; return area ; } int main ( ) { float a = 5 ; cout << area ( a ) << endl ; return 0 ; }", "text_ms": "Kawasan persegi yang tertulis dalam bulatan yang tertulis dalam segi enam | Program C ++ untuk mencari kawasan persegi yang tertulis dalam bulatan yang seterusnya ditulis dalam segi enam; Berfungsi untuk mencari kawasan dataran; sisi segi enam tidak boleh negatif; kawasan dataran; Kod pemacu"}
{"text": "Program to find Nth term of series 1 , 6 , 17 , 34 , 56 , 86 , 121 , 162 , ... ... . | C ++ program to find the N - th term of the series : 1 , 6 , 17 , 34 , 56 , 86 , 121 , 162 , ... . . ; calculate Nth term of series ; Driver code", "code": "#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; int nthTerm ( int n ) { return 3 * pow ( n , 2 ) - 4 * n + 2 ; } int main ( ) { int N = 4 ; cout << nthTerm ( N ) << endl ; return 0 ; }", "text_ms": "Program untuk mencari istilah n Siri 1, 6, 17, 34, 56, 86, 121, 162, ... .... | C ++ Program untuk mencari istilah n siri: 1, 6, 17, 34, 56, 86, 121, 162, .... . ; mengira istilah siri nth; Kod pemacu"}
{"text": "Sum of the first N terms of the series 2 , 10 , 30 , 68 , ... . | C ++ program to find sum of first n terms ; Function to calculate the sum ; Driver code ; number of terms to be included in the sum ; find the Sum", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculateSum ( int n ) { return n * ( n + 1 ) / 2 + pow ( ( n * ( n + 1 ) / 2 ) , 2 ) ; } int main ( ) { int n = 3 ; cout << \" Sum ▁ = ▁ \" << calculateSum ( n ) ; return 0 ; }", "text_ms": "Jumlah terma pertama N Siri 2, 10, 30, 68, .... | Program C ++ untuk mencari jumlah terma pertama N; Berfungsi untuk mengira jumlah; Kod pemacu; bilangan syarat yang akan dimasukkan dalam jumlah; Cari jumlahnya"}
{"text": "Check if two arrays are permutations of each other using Mathematical Operation | CPP code to check if arrays are permutations of eah other ; Function to check if arrays are permutations of each other . ; Calculating sum and multiply of first array ; Calculating sum and multiply of second array ; If sum and mul of both arrays are equal , return true , else return false . ; Driver code", "code": "#include <iostream> NEW_LINE using namespace std ; bool arePermutations ( int a [ ] , int b [ ] , int n , int m ) { int sum1 = 0 , sum2 = 0 , mul1 = 1 , mul2 = 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 += a [ i ] ; mul1 *= a [ i ] ; } for ( int i = 0 ; i < m ; i ++ ) { sum2 += b [ i ] ; mul2 *= b [ i ] ; } return ( ( sum1 == sum2 ) && ( mul1 == mul2 ) ) ; } int main ( ) { int a [ ] = { 1 , 3 , 2 } ; int b [ ] = { 3 , 1 , 2 } ; int n = sizeof ( a ) / sizeof ( int ) ; int m = sizeof ( b ) / sizeof ( int ) ; if ( arePermutations ( a , b , n , m ) ) cout << \" Yes \" << endl ; else cout << \" No \" << endl ; return 0 ; }", "text_ms": "Semak jika dua tatasusunan adalah permutasi antara satu sama lain menggunakan operasi matematik | Kod CPP untuk memeriksa sama ada array adalah permutasi EAH yang lain; Fungsi untuk memeriksa sama ada tatasusunan adalah permutasi antara satu sama lain. ; Mengira jumlah dan kalikan array pertama; Mengira jumlah dan kalikan array kedua; Jika jumlah dan Mul kedua -dua tatasusunan adalah sama, kembali benar, lain kembali palsu. ; Kod pemacu"}
{"text": "Program to find the head start in a race | C ++ implementation of above approach ; Function to find the B start to C ; When B completed it 's 100 meter  then Completed meters by C is ; Driver Code . ; When A completed it 's 100 meter  Then completed meters of B and C is", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Race ( int B , int C ) { int result = 0 ; result = ( ( C * 100 ) / B ) ; return 100 - result ; } int main ( ) { int B = 10 , C = 28 ; B = 100 - B ; C = 100 - C ; cout << Race ( B , C ) << \" ▁ meters \" ; return 0 ; }", "text_ms": "Program untuk mencari permulaan dalam perlumbaan | C ++ pelaksanaan pendekatan di atas; Fungsi untuk mencari B mula c; Apabila B menyelesaikannya 100 meter kemudian selesai meter dengan C adalah; Kod pemacu. ; Apabila ia menyelesaikannya 100 meter kemudian selesai meter b dan c adalah"}
{"text": "Minimum time required to fill a cistern using N pipes | C ++ implementation of above approach ; Function to calculate the time ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float Time ( float arr [ ] , int n , int Emptypipe ) { float fill = 0 ; for ( int i = 0 ; i < n ; i ++ ) fill += 1 / arr [ i ] ; fill = fill - ( 1 / ( float ) Emptypipe ) ; return 1 / fill ; } int main ( ) { float arr [ ] = { 12 , 14 } ; float Emptypipe = 30 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << floor ( Time ( arr , n , Emptypipe ) ) << \" ▁ Hours \" ; return 0 ; }", "text_ms": "Masa minimum diperlukan untuk mengisi tangki menggunakan paip n | C ++ pelaksanaan pendekatan di atas; Berfungsi untuk mengira masa; Kod pemacu"}
{"text": "Check if Decimal representation of an Octal number is divisible by 7 | CPP program to check if Decimal representation of an Octal number is divisible by 7 or not ; Function to check Divisibility ; Sum of all individual digits ; Condition ; Driver Code ; Octal number", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int check ( int n ) { int sum = 0 ; while ( n != 0 ) { sum += n % 10 ; n = n / 10 ; } if ( sum % 7 == 0 ) return 1 ; else return 0 ; } int main ( ) { int n = 25 ; ( check ( n ) == 1 ) ? cout << \" YES \" : cout << \" NO \" ; return 0 ; }", "text_ms": "Semak jika perwakilan perpuluhan nombor oktal boleh dibahagikan dengan 7 | Program CPP untuk memeriksa sama ada perwakilan perpuluhan nombor oktal boleh dibahagikan dengan 7 atau tidak; Berfungsi untuk memeriksa kebolehpasaran; Jumlah semua digit individu; Keadaan; Kod pemacu; Nombor oktal"}
{"text": "Sum of all the prime divisors of a number | CPP program to find sum of prime divisors of N ; Function to check if the number is prime or not . ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; function to find sum of prime divisors of N ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  1000005 NEW_LINE bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } int SumOfPrimeDivisors ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( n % i == 0 ) { if ( isPrime ( i ) ) sum += i ; } } return sum ; } int main ( ) { int n = 60 ; cout << \" Sum ▁ of ▁ prime ▁ divisors ▁ of ▁ 60 ▁ is ▁ \" << SumOfPrimeDivisors ( n ) << endl ; }", "text_ms": "Jumlah semua pembahagi utama nombor | Program CPP untuk mencari jumlah pembahagi utama N; Fungsi untuk memeriksa sama ada nombor itu adalah perdana atau tidak. ; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; berfungsi untuk mencari jumlah pembahagi utama N; Kod pemacu"}
{"text": "Sum of all the prime divisors of a number | CPP program to find prime divisors of all numbers from 1 to n ; function to find prime divisors of all numbers from 1 to n ; if the number is prime ; add this prime to all it 's multiples ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Sum ( int N ) { int SumOfPrimeDivisors [ N + 1 ] = { 0 } ; for ( int i = 2 ; i <= N ; ++ i ) { if ( ! SumOfPrimeDivisors [ i ] ) { for ( int j = i ; j <= N ; j += i ) { SumOfPrimeDivisors [ j ] += i ; } } } return SumOfPrimeDivisors [ N ] ; } int main ( ) { int N = 60 ; cout << \" Sum ▁ of ▁ prime ▁ divisors ▁ of ▁ 60 ▁ is ▁ \" << Sum ( N ) << endl ; }", "text_ms": "Jumlah semua pembahagi utama nombor | Program CPP untuk mencari pembahagi utama semua nombor dari 1 hingga n; berfungsi untuk mencari pembahagi utama semua nombor dari 1 hingga n; jika nombor itu adalah perdana; Tambah perdana ini kepada semua gandaan itu; Kod pemacu"}
{"text": "Find ( a ^ b ) % m where ' b ' is very large | C ++ program to find ( a ^ b ) % m for b very large . ; Function to find power ; Update x if it is more than or equal to p ; If y is odd , multiply x with the result ; y must be even now y = y >> 1 ; y = y / 2 ; Driver Code ; String input as b is very large ; Reduce the number B to a small number using Fermat Little", "code": "#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; ll power ( ll x , ll y , ll p ) { x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } int main ( ) { ll a = 3 ; string b = \"100000000000000000000000000\" ; ll remainderB = 0 ; ll MOD = 1000000007 ; for ( int i = 0 ; i < b . length ( ) ; i ++ ) remainderB = ( remainderB * 10 + b [ i ] - '0' ) % ( MOD - 1 ) ; cout << power ( a , remainderB , MOD ) << endl ; return 0 ; }", "text_ms": "Cari (a ^ b) % m di mana 'b' sangat besar | Program C ++ untuk mencari (a ^ b) % m untuk b sangat besar. ; Berfungsi untuk mencari kuasa; Kemas kini X jika lebih daripada atau sama dengan P; Jika y adalah ganjil, kalikan x dengan hasilnya; y mestilah sekarang y = y >> 1; y = y / 2; Kod pemacu; Input rentetan sebagai B sangat besar; Kurangkan bilangan B ke bilangan kecil menggunakan fermat kecil"}
{"text": "Squares of numbers with repeated single digits | Set 1 ( 3 , 6 and 9 ) | C ++ program to find square of these large numbers ; Function to find the square of 333. . .333 , 666. . .666 and 999. . .999 ; if the number is 333. . .333 ; if the number is 666. . .666 ; if the number is 999. . .999 ; variable for hold result ; find the no of digit ; add size - 1 time a in result ; add one time b in result ; add size - 1 time c in result ; add one time d in result ; return result ; Drivers code ; find square of 33. .33 ; find square of 66. .66 ; find square of 66. .66", "code": "#include <iostream> NEW_LINE using namespace std ; string find_Square_369 ( string num ) { char a , b , c , d ; if ( num [ 0 ] == '3' ) a = '1' , b = '0' , c = '8' , d = '9' ; else if ( num [ 0 ] == '6' ) a = '4' , b = '3' , c = '5' , d = '6' ; else a = '9' , b = '8' , c = '0' , d = '1' ; string result = \" \" ; int size = num . size ( ) ; for ( int i = 1 ; i < num . size ( ) ; i ++ ) result += a ; result += b ; for ( int i = 1 ; i < num . size ( ) ; i ++ ) result += c ; result += d ; return result ; } int main ( ) { string num_3 , num_6 , num_9 ; num_3 = \"3333\" ; num_6 = \"6666\" ; num_9 = \"9999\" ; string result = \" \" ; result = find_Square_369 ( num_3 ) ; cout << \" Square ▁ of ▁ \" << num_3 << \" ▁ is ▁ : ▁ \" << result << endl ; result = find_Square_369 ( num_6 ) ; cout << \" Square ▁ of ▁ \" << num_6 << \" ▁ is ▁ : ▁ \" << result << endl ; result = find_Square_369 ( num_9 ) ; cout << \" Square ▁ of ▁ \" << num_9 << \" ▁ is ▁ : ▁ \" << result << endl ; return 0 ; }", "text_ms": "Kuadrat nombor dengan digit tunggal berulang | Tetapkan 1 (3, 6 dan 9) | Program C ++ untuk mencari persegi nombor besar ini; Fungsi untuk mencari persegi 333. .. .333, 666. .666 dan 999.. .999; Sekiranya nombornya adalah 333. .. .333; Jika nombor itu 666. .. .666; Jika nombor itu 999 .. .999; pembolehubah untuk hasil pegangan; Cari tidak digit; tambah saiz - 1 kali dalam hasil; Tambah satu kali B hasil; tambah saiz - 1 kali c dalam hasil; tambah satu kali d hasil; hasil pulangan; Kod pemacu; Cari persegi 33. .33; cari persegi 66. .66; cari persegi 66. .66"}
{"text": "Trick for modular division ( ( x1 * x2 ... . xn ) / b ) mod ( m ) | To run this code , we need to copy modular inverse from below post . https : www . geeksforgeeks . org / multiplicative - inverse - under - modulo - m / ; naive method - calculating the result in a single line ; modular_inverse ( ) is a user defined function that calculates inverse of a number ; it will use extended Eucledian algorithm or Fermats Little Theorem for calculation . MMI of 120 under division by 1000000007 will be 808333339", "code": "int main ( ) { long int naive_answer = ( ( long int ) ( 55555 * 55554 * 55553 * 55552 * 55551 ) / 120 ) % 1000000007 ; long int ans = 1 ; long int i = modular_inverse ( 120 , 10000007 ) ; for ( int i = 0 ; i < 5 ; i ++ ) ans = ( ans * ( 55555 - i ) ) % 1000000007 ; ans = ( ans * i ) % 1000000007 ; cout << \" Answer ▁ using ▁ naive ▁ method : ▁ \" << naive_answer << endl ; cout << \" Answer ▁ using ▁ multiplicative \" << \" ▁ modular ▁ inverse ▁ concept : ▁ \" << ans ; return 0 ; }", "text_ms": "Trick for Modular Bahagian ((x1 * x2 .... Xn) / b) Mod (M) | Untuk menjalankan kod ini, kita perlu menyalin modular songsang dari pos di bawah. HTTPS: www. Geeksforgeeks. org / multiplicative - songsang - bawah - modulo - m /; Kaedah naif - mengira hasil dalam satu baris; modular_inverse () adalah fungsi yang ditetapkan pengguna yang mengira songsang nombor; Ia akan menggunakan algoritma Eucledian yang dilanjutkan atau fermats sedikit teorem untuk pengiraan. MMI dari 120 di bawah Bahagian oleh 1000000007 akan menjadi 8083333339"}
{"text": "Trick for modular division ( ( x1 * x2 ... . xn ) / b ) mod ( m ) |", "code": "#include <iostream> NEW_LINE using namespace std ; int main ( ) { long int ans = 1 ; long int mod = ( long int ) 1000000007 * 120 ; for ( int i = 0 ; i < 5 ; i ++ ) ans = ( ans * ( 55555 - i ) ) % mod ; ans = ans / 120 ; cout << \" Answer ▁ using ▁ shortcut : ▁ \" << ans ; return 0 ; }", "text_ms": "Trick for Modular Bahagian ((x1 * x2 .... Xn) / b) Mod (M) |"}
{"text": "Ways to multiply n elements with an associative operation | C ++ code to find number of ways to multiply n elements with an associative operation ; Function to find the required factorial ; Function to find nCr ; function to find the number of ways ; Driver code", "code": "# include <bits/stdc++.h> NEW_LINE using namespace std ; int fact ( int n ) { if ( n == 0 n == 1 ) return 1 ; int ans = 1 ; for ( int i = 1 ; i <= n ; i ++ ) ans = ans * i ; return ans ; } int nCr ( int n , int r ) { int Nr = n , Dr = 1 , ans = 1 ; for ( int i = 1 ; i <= r ; i ++ ) { ans = ( ans * Nr ) / ( Dr ) ; Nr -- ; Dr ++ ; } return ans ; } int solve ( int n ) { int N = 2 * n - 2 ; int R = n - 1 ; return nCr ( N , R ) * fact ( n - 1 ) ; } int main ( ) { int n = 6 ; cout << solve ( n ) ; return 0 ; }", "text_ms": "Cara untuk membiak elemen dengan operasi bersekutu | C ++ kod untuk mencari bilangan cara untuk membiak elemen dengan operasi bersekutu; Fungsi untuk mencari faktorial yang diperlukan; Berfungsi untuk mencari NCR; berfungsi untuk mencari bilangan cara; Kod pemacu"}
{"text": "Pythagorean Triplet with given sum | C ++ program to find Pythagorean Triplet of given sum . ; Considering triplets in sorted order . The value of first element in sorted triplet can be at - most n / 3. ; The value of second element must be less than equal to n / 2 ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void pythagoreanTriplet ( int n ) { for ( int i = 1 ; i <= n / 3 ; i ++ ) { for ( int j = i + 1 ; j <= n / 2 ; j ++ ) { int k = n - i - j ; if ( i * i + j * j == k * k ) { cout << i << \" , ▁ \" << j << \" , ▁ \" << k ; return ; } } } cout << \" No ▁ Triplet \" ; } int main ( ) { int n = 12 ; pythagoreanTriplet ( n ) ; return 0 ; }", "text_ms": "Triplet Pythagorean dengan jumlah yang diberikan | Program C ++ untuk mencari triplet Pythagorean yang diberikan. ; Memandangkan tiga kali ganda dalam urutan yang disusun. Nilai elemen pertama dalam triplet yang disusun boleh diadakan - kebanyakan n / 3 .; Nilai elemen kedua mestilah kurang daripada sama dengan n / 2; Kod pemacu"}
{"text": "Program to print binomial expansion series | CPP program to print terms of binomial series and also calculate sum of series . ; function to calculate factorial of a number ; function to print the series ; calculating the value of n ! ; loop to display the series ; For calculating the value of nCr ; calculating the value of A to the power k and X to the power k ; display the series ; main function started", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int factorial ( int n ) { int f = 1 ; for ( int i = 2 ; i <= n ; i ++ ) f *= i ; return f ; } void series ( int A , int X , int n ) { int nFact = factorial ( n ) ; for ( int i = 0 ; i < n + 1 ; i ++ ) { int niFact = factorial ( n - i ) ; int iFact = factorial ( i ) ; int aPow = pow ( A , n - i ) ; int xPow = pow ( X , i ) ; cout << ( nFact * aPow * xPow ) / ( niFact * iFact ) << \" ▁ \" ; } } int main ( ) { int A = 3 , X = 4 , n = 5 ; series ( A , X , n ) ; return 0 ; }", "text_ms": "Program untuk mencetak Siri Pengembangan Binomial | Program CPP untuk mencetak istilah siri binomial dan juga mengira jumlah siri. ; berfungsi untuk mengira faktorial nombor; berfungsi untuk mencetak siri; Mengira nilai n! ; gelung untuk memaparkan siri; Untuk mengira nilai NCR; mengira nilai A ke kuasa k dan x ke kuasa k; Paparkan siri; Fungsi utama bermula"}
{"text": "Sum of series with alternate signed squares of AP | CPP program to find sum of series with alternate signed square AP sums . ; function to calculate series sum ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int seiresSum ( int n , int a [ ] ) { int res = 0 ; for ( int i = 0 ; i < 2 * n ; i ++ ) { if ( i % 2 == 0 ) res += a [ i ] * a [ i ] ; else res -= a [ i ] * a [ i ] ; } return res ; } int main ( ) { int n = 2 ; int a [ ] = { 1 , 2 , 3 , 4 } ; cout << seiresSum ( n , a ) ; return 0 ; }", "text_ms": "Jumlah siri dengan dataran yang ditandatangani alternatif AP | Program CPP untuk mencari jumlah siri dengan jumlah AP Square yang ditandatangani alternatif. ; fungsi untuk mengira jumlah siri; Kod pemacu"}
{"text": "Power of a prime number ‘ r ’ in n ! | C ++ program to find power of a prime number r in n ! ; Function to return power of a no . ' r ' in factorial of n ; Keep dividing n by powers of ' r ' and update count ; Driver program to test above function", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int power ( int n , int r ) { int count = 0 ; for ( int i = r ; ( n / i ) >= 1 ; i = i * r ) count += n / i ; return count ; } int main ( ) { int n = 6 , r = 3 ; printf ( \" ▁ % d ▁ \" , power ( n , r ) ) ; return 0 ; }", "text_ms": "Kuasa nombor utama 'r' dalam n! | Program C ++ untuk mencari kuasa nombor utama R dalam N! ; Berfungsi untuk mengembalikan kuasa no. 'r' dalam faktorial n; Terus membahagikan n dengan kuasa 'r' dan mengemaskini kiraan; Program pemacu untuk menguji fungsi di atas"}
{"text": "Average of first n odd naturals numbers | A C ++ program to find average of sum of first n odd natural numbers . ; Returns the Avg of first n odd numbers ; sum of first n odd number ; Average of first n odd numbers ; Driver Code", "code": "#include <iostream> NEW_LINE using namespace std ; int avg_of_odd_num ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( 2 * i + 1 ) ; return sum / n ; } int main ( ) { int n = 20 ; cout << avg_of_odd_num ( n ) ; return 0 ; }", "text_ms": "Purata nombor natural natur pertama | Program C ++ untuk mencari purata jumlah nombor semulajadi yang pertama. ; Mengembalikan AVG nombor n pertama; Jumlah nombor pertama yang pertama; Purata nombor pertama yang ganjil; Kod pemacu"}
{"text": "Average of first n odd naturals numbers | CPP Program to find the average of sum of first n odd numbers ; Return the average of sum of first n odd numbers ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int avg_of_odd_num ( int n ) { return n ; } int main ( ) { int n = 8 ; cout << avg_of_odd_num ( n ) ; return 0 ; }", "text_ms": "Purata nombor natural natur pertama | Program CPP untuk mencari purata jumlah nombor n pertama yang pertama; Kembalikan purata jumlah nombor pertama yang ganjil; Kod pemacu"}
{"text": "Program to print Fibonacci Triangle | C ++ Implementation for Fibonacci triangle ; function to fill Fibonacci Numbers in f [ ] ; 1 st and 2 nd number of the series are 1 and 1 ; Add the previous 2 numbers in the series and store it ; Fill Fibonacci numbers in f [ ] using fib ( ) . We need N = n * ( n + 1 ) / 2 Fibonacci numbers to make a triangle of height n ; To store next Fibonacci Number to print ; for loop to keep track of number of lines ; For loop to keep track of numbers in each line ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void fib ( int f [ ] , int N ) { f [ 1 ] = 1 ; f [ 2 ] = 1 ; for ( int i = 3 ; i <= N ; i ++ ) f [ i ] = f [ i - 1 ] + f [ i - 2 ] ; } void fiboTriangle ( int n ) { int N = n * ( n + 1 ) / 2 ; int f [ N + 1 ] ; fib ( f , N ) ; int fiboNum = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) cout << f [ fiboNum ++ ] << \" ▁ \" ; cout << endl ; } } int main ( ) { int n = 5 ; fiboTriangle ( n ) ; return 0 ; }", "text_ms": "Program untuk mencetak segitiga Fibonacci | C ++ pelaksanaan untuk segitiga Fibonacci; berfungsi untuk mengisi nombor fibonacci dalam f []; 1 ST dan 2 ND nombor siri adalah 1 dan 1; Tambah nombor 2 sebelumnya dalam siri ini dan simpannya; Isi nombor Fibonacci dalam f [] menggunakan Fib (). Kami memerlukan n = n * (n + 1) / 2 nombor fibonacci untuk membuat segitiga ketinggian n; Untuk menyimpan nombor Fibonacci seterusnya untuk dicetak; untuk gelung untuk menjejaki bilangan baris; Untuk gelung untuk menjejaki nombor dalam setiap baris; Kod pemacu"}
{"text": "Average of odd numbers till a given odd number | Program to find average of odd numbers till a given odd number . ; Function to calculate the average of odd numbers ; count odd numbers ; store the sum of odd numbers ; driver function", "code": "#include <stdio.h> NEW_LINE int averageOdd ( int n ) { if ( n % 2 == 0 ) { printf ( \" Invalid ▁ Input \" ) ; return -1 ; } int sum = 0 , count = 0 ; while ( n >= 1 ) { count ++ ; sum += n ; n = n - 2 ; } return sum / count ; } int main ( ) { int n = 15 ; printf ( \" % d \" , averageOdd ( n ) ) ; return 0 ; }", "text_ms": "Rata -rata nombor ganjil sehingga nombor ganjil yang diberikan | Program untuk mencari purata nombor ganjil sehingga nombor ganjil yang diberikan. ; Fungsi untuk mengira purata nombor ganjil; mengira nombor ganjil; Simpan jumlah nombor ganjil; fungsi pemacu"}
{"text": "Find max of two Rational numbers | CPP program to find max between two Rational numbers ; Get lcm of two number 's ; Get max rational number ; Find the LCM of first -> denominator and sec -> denominator ; Declare nume1 and nume2 for get the value of first numerator and second numerator ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Rational { int nume , deno ; } ; int lcm ( int a , int b ) { return ( a * b ) / ( __gcd ( a , b ) ) ; } Rational maxRational ( Rational first , Rational sec ) { int k = lcm ( first . deno , sec . deno ) ; int nume1 = first . nume ; int nume2 = sec . nume ; nume1 *= k / ( first . deno ) ; nume2 *= k / ( sec . deno ) ; return ( nume2 < nume1 ) ? first : sec ; } int main ( ) { Rational first = { 3 , 2 } ; Rational sec = { 3 , 4 } ; Rational res = maxRational ( first , sec ) ; cout << res . nume << \" / \" << res . deno ; return 0 ; }", "text_ms": "Cari Max Dua Nombor Rasional | Program CPP untuk mencari Max antara dua nombor rasional; Dapatkan LCM dua nombor; Dapatkan nombor rasional maksimum; Cari LCM pertama -> penyebut dan SEC -> penyebut; Mengisytiharkan NUME1 dan NUME2 untuk mendapatkan nilai pengangka pertama dan pengangka kedua; Kod pemacu"}
{"text": "Trinomial Triangle | CPP Program to print trinomial triangle . ; Function to find the trinomial triangle value . ; base case ; base case ; recursive step . ; Function to print Trinomial Triangle of height n . ; printing n rows . ; printing first half of triangle ; printing second half of triangle . ; Driven Program", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int TrinomialValue ( int n , int k ) { if ( n == 0 && k == 0 ) return 1 ; if ( k < - n k > n ) return 0 ; return TrinomialValue ( n - 1 , k - 1 ) + TrinomialValue ( n - 1 , k ) + TrinomialValue ( n - 1 , k + 1 ) ; } void printTrinomial ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = - i ; j <= 0 ; j ++ ) cout << TrinomialValue ( i , j ) << \" ▁ \" ; for ( int j = 1 ; j <= i ; j ++ ) cout << TrinomialValue ( i , j ) << \" ▁ \" ; cout << endl ; } } int main ( ) { int n = 4 ; printTrinomial ( n ) ; return 0 ; }", "text_ms": "Trinomial Triangle | Program CPP untuk mencetak segitiga trinomial. ; Fungsi untuk mencari nilai segitiga trinomial. ; Kes asas; Kes asas; langkah rekursif. ; Berfungsi untuk mencetak segitiga trinomial ketinggian n. ; Percetakan n baris. ; percetakan separuh pertama segitiga; Percetakan separuh kedua segitiga. ; Program yang didorong"}
{"text": "Sum of largest prime factor of each number less than equal to n | C ++ implementation to find sum of largest prime factor of each number less than equal to n ; function to find sum of largest prime factor of each number less than equal to n ; Create an integer array \" prime [ 0 . . n ] \" and initialize all entries of it as 0. A value in prime [ i ] will finally be 0 if ' i ' is a prime , else it will contain the largest prime factor of ' i ' . ; If prime [ p ] is '0' , then it is a prime number ; Update all multiples of p ; Sum up the largest prime factor of all the numbers ; if ' p ' is a non - prime number then prime [ p ] gives its largesr prime factor ; ' p ' is a prime number ; required sum ; Driver program to test above", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumOfLargePrimeFactor ( int n ) { int prime [ n + 1 ] , sum = 0 ; memset ( prime , 0 , sizeof ( prime ) ) ; int max = n / 2 ; for ( int p = 2 ; p <= max ; p ++ ) { if ( prime [ p ] == 0 ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = p ; } } for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] ) sum += prime [ p ] ; else sum += p ; } return sum ; } int main ( ) { int n = 12 ; cout << \" Sum ▁ = ▁ \" << sumOfLargePrimeFactor ( n ) ; return 0 ; }", "text_ms": "Jumlah faktor utama terbesar bagi setiap nombor kurang daripada sama dengan N | C ++ pelaksanaan untuk mencari jumlah faktor utama terbesar bagi setiap nombor kurang daripada sama dengan N; fungsi untuk mencari jumlah faktor utama terbesar bagi setiap nombor kurang daripada sama dengan n; Buat array Integer \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai 0. Nilai dalam Perdana [i] akhirnya akan menjadi 0 jika 'I' adalah perdana, jika tidak, ia akan mengandungi faktor utama terbesar 'I'. ; Jika Perdana [P] adalah '0', maka ia adalah nombor utama; Kemas kini semua gandaan P; Merangkumi faktor utama terbesar bagi semua nombor; jika 'p' adalah nombor bukan utama maka perdana [p] memberikan faktor utama largesr; 'P' adalah nombor utama; Jumlah yang diperlukan; Program Pemandu untuk diuji di atas"}
{"text": "Sum of multiples of a number up to N | C ++ program to find sum of multiples of a number up to N efficiently ; Function for calculating sum of multiples of a upto N ; Number of multiples ; sum of first m natural numbers ; sum of multiples ; Driver code", "code": "#include <iostream> NEW_LINE using namespace std ; int calculate_sum ( int a , int N ) { int m = N / a ; int sum = m * ( m + 1 ) / 2 ; int ans = a * sum ; return ans ; } int main ( ) { int a = 7 , N = 49 ; cout << \" Sum ▁ of ▁ multiples ▁ of ▁ \" << a << \" ▁ up ▁ to ▁ \" << N << \" ▁ = ▁ \" << calculate_sum ( a , N ) << endl ; return 0 ; }", "text_ms": "Jumlah gandaan nombor sehingga n | Program C ++ untuk mencari jumlah gandaan nombor sehingga n dengan cekap; Berfungsi untuk mengira jumlah gandaan sehingga n; Bilangan gandaan; jumlah nombor semulajadi pertama; jumlah gandaan; Kod pemacu"}
{"text": "Given a HUGE number check if it 's a power of two. | C ++ program to find whether a number is power of 2 or not ; Function to check whether a number is power of 2 or not ; Driver function", "code": "#include <bits/stdc++.h> NEW_LINE #include <boost/multiprecision/cpp_int.hpp> NEW_LINE using namespace std ; using namespace boost :: multiprecision ; bool ispowerof2 ( cpp_int num ) { if ( ( num & ( num - 1 ) ) == 0 ) return 1 ; return 0 ; } int main ( ) { cpp_int num = 549755813888 ; cout << ispowerof2 ( num ) << endl ; return 0 ; }", "text_ms": "Memandangkan jumlah besar semak jika ia adalah kuasa dua. | Program C ++ untuk mencari sama ada nombor adalah kuasa 2 atau tidak; Berfungsi untuk memeriksa sama ada nombor adalah kuasa 2 atau tidak; Fungsi pemacu"}
{"text": "Count divisors of array multiplication | A simple C ++ program to count divisors in array multiplication . ; To count number of factors in a number ; Initialize count with 0 ; Increment count for every factor of the given number X . ; Return number of factors ; Returns number of divisors in array multiplication ; Multipliying all elements of the given array . ; Calling function which count number of factors of the number ; Driver code", "code": "#include <iostream> NEW_LINE using namespace std ; int counDivisors ( int X ) { int count = 0 ; for ( int i = 1 ; i <= X ; ++ i ) { if ( X % i == 0 ) { count ++ ; } } return count ; } int countDivisorsMult ( int arr [ ] , int n ) { int mul = 1 ; for ( int i = 0 ; i < n ; ++ i ) mul *= arr [ i ] ; return counDivisors ( mul ) ; } int main ( ) { int arr [ ] = { 2 , 4 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countDivisorsMult ( arr , n ) << endl ; return 0 ; }", "text_ms": "Pengiraan Pembahagi Array Multiplikasi | Program C ++ mudah untuk mengira pembahagi dalam pendaraban array. ; Untuk mengira bilangan faktor dalam nombor; Inisialisasi kiraan dengan 0; Kiraan kenaikan untuk setiap faktor nombor x yang diberikan. ; Pulangan bilangan faktor; Mengembalikan bilangan pembahagi dalam pendaraban array; Mengumpulkan semua elemen array yang diberikan. ; Fungsi panggilan yang mengira bilangan faktor nombor; Kod pemacu"}
{"text": "Count divisors of array multiplication | C ++ program to count divisors in array multiplication . ; Create a boolean array \" isPrime [ 0 . . n ] \" and initialize all entries it as true . A value in isPrime [ i ] will finally be false if i is Not a isPrime , else true . ; If isPrime [ p ] is not changed , then it is a isPrime ; Update all multiples of p ; Print all isPrime numbers ; Returns number of divisors in array multiplication ; Find all prime numbers smaller than the largest element . ; Find counts of occurrences of each prime factor ; Compute count of all divisors using counts prime factors . ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void SieveOfEratosthenes ( int largest , vector < int > & prime ) { bool isPrime [ largest + 1 ] ; memset ( isPrime , true , sizeof ( isPrime ) ) ; for ( int p = 2 ; p * p <= largest ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i <= largest ; i += p ) isPrime [ i ] = false ; } } for ( int p = 2 ; p <= largest ; p ++ ) if ( isPrime [ p ] ) prime . push_back ( p ) ; } int countDivisorsMult ( int arr [ ] , int n ) { int largest = * max_element ( arr , arr + n ) ; vector < int > prime ; SieveOfEratosthenes ( largest , prime ) ; unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < prime . size ( ) ; j ++ ) { while ( arr [ i ] > 1 && arr [ i ] % prime [ j ] == 0 ) { arr [ i ] /= prime [ j ] ; mp [ prime [ j ] ] ++ ; } } if ( arr [ i ] != 1 ) mp [ arr [ i ] ] ++ ; } long long int res = 1 ; for ( auto it : mp ) res *= ( it . second + 1L ) ; return res ; } int main ( ) { int arr [ ] = { 2 , 4 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countDivisorsMult ( arr , n ) << endl ; return 0 ; }", "text_ms": "Pengiraan Pembahagi Array Multiplikasi | Program C ++ untuk mengira pembahagi dalam pendaraban array. ; Buat array Boolean \"Isprime [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Isprime [i] akhirnya akan menjadi palsu jika saya bukannya Isprime, yang lain benar. ; Jika Isprime [p] tidak berubah, maka ia adalah isprime; Kemas kini semua gandaan P; Cetak semua nombor isprime; Mengembalikan bilangan pembahagi dalam pendaraban array; Cari semua nombor perdana yang lebih kecil daripada elemen terbesar. ; Cari tuduhan kejadian setiap faktor utama; Mengira kiraan semua pembahagi menggunakan kiraan faktor utama. ; Kod pemacu"}
{"text": "K distant prime pairs in a given range | C ++ program for the above approach ; Function to generate prime numbers in the given range [ L , R ] ; Store all value in the range ; Erase 1 as its non - prime ; Perform Sieve of Eratosthenes ; Find current multiple ; Erase as it is a non - prime ; Increment multiple ; Function to print all the prime pairs in the given range that differs by K ; Generate all prime number ; Traverse the Map M ; If it . first & ( it . first + K ) is prime then print this pair ; Driver Code ; Given range ; Given K ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPrimeNos ( int L , int R , unordered_map < int , int > & M ) { for ( int i = L ; i <= R ; i ++ ) { M [ i ] ++ ; } if ( M . find ( 1 ) != M . end ( ) ) { M . erase ( 1 ) ; } for ( int i = 2 ; i <= sqrt ( R ) ; i ++ ) { int multiple = 2 ; while ( ( i * multiple ) <= R ) { if ( M . find ( i * multiple ) != M . end ( ) ) { M . erase ( i * multiple ) ; } multiple ++ ; } } } void getPrimePairs ( int L , int R , int K ) { unordered_map < int , int > M ; findPrimeNos ( L , R , M ) ; for ( auto & it : M ) { if ( M . find ( it . first + K ) != M . end ( ) ) { cout << \" ( \" << it . first << \" , ▁ \" << it . first + K << \" ) ▁ \" ; } } } int main ( ) { int L = 1 , R = 19 ; int K = 6 ; getPrimePairs ( L , R , K ) ; return 0 ; }", "text_ms": "K pasangan perdana jauh dalam julat yang diberikan | Program C ++ untuk pendekatan di atas; Berfungsi untuk menjana nombor perdana dalam julat yang diberikan [l, r]; Simpan semua nilai dalam julat; Padam 1 sebagai bukan perdana; Melakukan penapis eratosthenes; Cari pelbagai semasa; Padam kerana ia bukan perdana; Kenaikan berganda; Berfungsi untuk mencetak semua pasangan utama dalam julat yang diberikan oleh k; Menjana semua nombor perdana; Melintasi peta m; Jika ia. Pertama & (ia pertama + k) adalah perdana kemudian cetak pasangan ini; Kod pemacu; Julat yang diberikan; Diberikan k; Panggilan fungsi"}
{"text": "Enneacontahexagon numbers | C ++ implementation for above approach ; Function to find the Nth Enneacontahexagon Number ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int EnneacontahexagonNum ( int n ) { return ( 94 * n * n - 92 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << EnneacontahexagonNum ( n ) ; return 0 ; }", "text_ms": "Nombor EnneAcontahExagon | C ++ pelaksanaan untuk pendekatan di atas; Berfungsi untuk mencari nombor enneacontahexagon nth; Kod pemacu"}
{"text": "Find two Composite Numbers such that there difference is N | C ++ code to Find two Composite Numbers such that there difference is N ; Function to find the two composite numbers ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void find_composite_nos ( int n ) { cout << 9 * n << \" ▁ \" << 8 * n ; } int main ( ) { int n = 4 ; find_composite_nos ( n ) ; return 0 ; }", "text_ms": "Cari dua nombor komposit supaya terdapat perbezaan adalah n | C ++ kod untuk mencari dua nombor komposit supaya terdapat perbezaan adalah n; Berfungsi untuk mencari dua nombor komposit; Kod pemacu"}
{"text": "Count the number of pairs ( i , j ) such that either arr [ i ] is divisible by arr [ j ] or arr [ j ] is divisible by arr [ i ] | C ++ implementation of the approach ; Function to find number of unordered pairs ; Maximum element from the array ; Array to store the frequency of each element ; Stores the number of unordered pairs ; Store the frequency of each element ; Find the number of unordered pairs ; If the number j divisible by ith element is present in the array ; If the ith element of the array has frequency more than one ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int freqPairs ( int arr [ ] , int n ) { int max = * ( std :: max_element ( arr , arr + n ) ) ; int freq [ max + 1 ] = { 0 } ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 2 * arr [ i ] ; j <= max ; j += arr [ i ] ) { if ( freq [ j ] >= 1 ) count += freq [ j ] ; } if ( freq [ arr [ i ] ] > 1 ) { count += freq [ arr [ i ] ] - 1 ; freq [ arr [ i ] ] -- ; } } return count ; } int main ( ) { int arr [ ] = { 3 , 2 , 4 , 2 , 6 } ; int n = ( sizeof ( arr ) / sizeof ( arr [ 0 ] ) ) ; cout << freqPairs ( arr , n ) ; return 0 ; }", "text_ms": "Kira bilangan pasangan (i, j) supaya sama ada arr [i] boleh dibahagikan dengan arr [j] atau arr [j] boleh dibahagikan dengan arr [i] | C ++ pelaksanaan pendekatan; Berfungsi untuk mencari bilangan pasangan yang tidak teratur; Elemen maksimum dari array; Array untuk menyimpan kekerapan setiap elemen; Menyimpan bilangan pasangan yang tidak teratur; Simpan kekerapan setiap elemen; Cari bilangan pasangan yang tidak teratur; Jika nombor j dibahagi dengan elemen ith hadir dalam array; Jika elemen ith array mempunyai kekerapan lebih daripada satu; Kod pemacu"}
{"text": "Find the Nth term of the series 1 + 2 + 6 + 15 + 31 + 56 + ... | C ++ program to find Nth term of the series : 1 + 2 + 6 + 15 + 31 + 56 + ... ; calculate Nth term of given series ; Driver code", "code": "#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; int Nth_Term ( int n ) { return ( 2 * pow ( n , 3 ) - 3 * pow ( n , 2 ) + n + 6 ) / 6 ; } int main ( ) { int N = 8 ; cout << Nth_Term ( N ) ; }", "text_ms": "Cari istilah n Siri 1 + 2 + 6 + 15 + 31 + 56 + ... | Program C ++ untuk mencari istilah n siri: 1 + 2 + 6 + 15 + 31 + 56 + ...; Hitung istilah n siri yang diberikan; Kod pemacu"}
{"text": "Program to find N | C ++ program to find n - th number in a series made of digits 3 and 5 ; Function to find n - th number in series made of 3 and 5 ; create an array of size ( n + 1 ) ; If i is odd ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int printNthElement ( int n ) { int arr [ n + 1 ] ; arr [ 1 ] = 3 ; arr [ 2 ] = 5 ; for ( int i = 3 ; i <= n ; i ++ ) { if ( i % 2 != 0 ) arr [ i ] = arr [ i / 2 ] * 10 + 3 ; else arr [ i ] = arr [ ( i / 2 ) - 1 ] * 10 + 5 ; } return arr [ n ] ; } int main ( ) { int n = 6 ; cout << printNthElement ( n ) ; return 0 ; }", "text_ms": "Program untuk mencari n | Program C ++ untuk mencari nombor N dalam siri yang diperbuat daripada digit 3 dan 5; Fungsi untuk mencari nombor n - th dalam siri yang diperbuat daripada 3 dan 5; Buat pelbagai saiz (n + 1); Sekiranya saya ganjil; Kod pemacu"}
{"text": "Program to find Nth term of the series 3 , 6 , 18 , 24 , ... | CPP program to find N - th term of the series : 3 , 6 , 18 , 24 , 45 , 54. . . ; function to calculate Nth term of series ; By using above formula ; Driver Function ; get the value of N ; Calculate and print the Nth term", "code": "#include <iostream> NEW_LINE using namespace std ; int nthTerm ( int N ) { return ( N * ( ( N / 2 ) + ( ( N % 2 ) * 2 ) + N ) ) ; } int main ( ) { int N = 5 ; cout << \" Nth ▁ term ▁ for ▁ N ▁ = ▁ \" << N << \" ▁ : ▁ \" << nthTerm ( N ) ; return 0 ; }", "text_ms": "Program untuk mencari istilah n Siri 3, 6, 18, 24, ... | Program CPP untuk mencari istilah siri: 3, 6, 18, 24, 45, 54. . ; fungsi untuk mengira istilah siri nth; Dengan menggunakan formula di atas; Fungsi pemacu; Dapatkan nilai n; Hitung dan cetak istilah n"}
{"text": "Program to print binomial expansion series | CPP program to print terms of binomial series and also calculate sum of series . ; function to print the series ; Calculating and printing first term ; Computing and printing remaining terms ; Find current term using previous terms We increment power of X by 1 , decrement power of A by 1 and compute nCi using previous term by multiplying previous term with ( n - i + 1 ) / i ; main function started", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void series ( int A , int X , int n ) { int term = pow ( A , n ) ; cout << term << \" ▁ \" ; for ( int i = 1 ; i <= n ; i ++ ) { term = term * X * ( n - i + 1 ) / ( i * A ) ; cout << term << \" ▁ \" ; } } int main ( ) { int A = 3 , X = 4 , n = 5 ; series ( A , X , n ) ; return 0 ; }", "text_ms": "Program untuk mencetak Siri Pengembangan Binomial | Program CPP untuk mencetak istilah siri binomial dan juga mengira jumlah siri. ; berfungsi untuk mencetak siri; Mengira dan mencetak istilah pertama; Pengkomputeran dan percetakan yang tersisa; Cari istilah semasa menggunakan terma sebelumnya kita meningkatkan kuasa x oleh 1, kuasa pengurangan sebanyak 1 dan mengira NCI menggunakan istilah sebelumnya dengan mengalikan istilah sebelumnya dengan (n - i + 1) / i; Fungsi utama bermula"}
{"text": "Check if a number is divisible by 8 using bitwise operators | C ++ program to check whether the number is divisible by 8 or not using bitwise operator ; function to check number is div by 8 or not using bitwise operator ; Driver program", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int Div_by_8 ( int n ) { return ( ( ( n >> 3 ) << 3 ) == n ) ; } int main ( ) { int n = 16 ; if ( Div_by_8 ( n ) ) cout << \" YES \" << endl ; else cout << \" NO \" << endl ; return 0 ; }", "text_ms": "Semak jika nombor dibahagikan dengan 8 menggunakan pengendali bitwise | Program C ++ untuk memeriksa sama ada nombor itu boleh dibahagikan dengan 8 atau tidak menggunakan pengendali Bitwise; Fungsi untuk memeriksa nombor div oleh 8 atau tidak menggunakan pengendali bitwise; Program Pemandu"}
{"text": "Average of even numbers till a given even number | Program to find average of even numbers till a given even number . ; Function to calculate the average of even numbers ; count even numbers ; store the sum of even numbers ; driver function", "code": "#include <stdio.h> NEW_LINE int averageEven ( int n ) { if ( n % 2 != 0 ) { printf ( \" Invalid ▁ Input \" ) ; return -1 ; } int sum = 0 , count = 0 ; while ( n >= 2 ) { count ++ ; sum += n ; n = n - 2 ; } return sum / count ; } int main ( ) { int n = 16 ; printf ( \" % d \" , averageEven ( n ) ) ; return 0 ; }", "text_ms": "Rata -rata nombor juga sehingga nombor yang diberikan | Program untuk mencari purata nombor walaupun sehingga nombor yang diberikan. ; Fungsi untuk mengira purata nombor walaupun; mengira nombor walaupun; Simpan jumlah nombor walaupun; fungsi pemacu"}
{"text": "Average of even numbers till a given even number | Program to find average of even numbers till a given even nend umber . ; Function to calculate the average of even numbers ; driver function", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int averageEven ( int n ) { if ( n % 2 != 0 ) { cout << \" Invalid ▁ Input \" ; return -1 ; } return ( n + 2 ) / 2 ; } int main ( ) { int n = 16 ; cout << averageEven ( n ) << endl ; return 0 ; }", "text_ms": "Rata -rata nombor juga sehingga nombor yang diberikan | Program untuk mencari purata nombor walaupun sehingga nend umber yang diberikan. ; Fungsi untuk mengira purata nombor walaupun; fungsi pemacu"}
{"text": "Largest number that divides x and is co | CPP program to find the Largest Coprime Divisor ; Recursive function to return gcd of a and b ; Everything divides 0 ; base case ; a is greater ; function to find largest coprime divisor ; divisor code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( a == 0 b == 0 ) return 0 ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; } int cpFact ( int x , int y ) { while ( gcd ( x , y ) != 1 ) { x = x / gcd ( x , y ) ; } return x ; } int main ( ) { int x = 15 ; int y = 3 ; cout << cpFact ( x , y ) << endl ; x = 14 ; y = 28 ; cout << cpFact ( x , y ) << endl ; x = 7 ; y = 3 ; cout << cpFact ( x , y ) ; return 0 ; }", "text_ms": "Nombor terbesar yang membahagikan x dan co | Program CPP untuk mencari pembahagi Coprime terbesar; Fungsi rekursif untuk mengembalikan GCD A dan B; Semuanya membahagikan 0; Kes asas; A lebih besar; berfungsi untuk mencari pembahagi coprime terbesar; kod pembahagi"}
{"text": "Count numbers with unit digit k in given range | Simple CPP program to count numbers with last digit as k in given range . ; Returns count of numbers with k as last digit . ; Driver Program", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int counLastDigitK ( int low , int high , int k ) { int count = 0 ; for ( int i = low ; i <= high ; i ++ ) if ( i % 10 == k ) count ++ ; return count ; } int main ( ) { int low = 3 , high = 35 , k = 3 ; cout << counLastDigitK ( low , high , k ) ; return 0 ; }", "text_ms": "Kira nombor dengan unit digit k dalam julat yang diberikan | Program CPP mudah untuk mengira nombor dengan digit terakhir sebagai k dalam julat yang diberikan. ; Mengembalikan kiraan nombor dengan k sebagai digit terakhir. ; Program Pemandu"}
{"text": "Taxicab Numbers | C ++ implementation to print first N Taxicab ( 2 ) numbers : ; Starting from 1 , check every number if it is Taxicab until count reaches N . ; Try all possible pairs ( j , k ) whose cube sums can be i . ; Taxicab ( 2 ) found ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printTaxicab2 ( int N ) { int i = 1 , count = 0 ; while ( count < N ) { int int_count = 0 ; for ( int j = 1 ; j <= pow ( i , 1.0 / 3 ) ; j ++ ) for ( int k = j + 1 ; k <= pow ( i , 1.0 / 3 ) ; k ++ ) if ( j * j * j + k * k * k == i ) int_count ++ ; if ( int_count == 2 ) { count ++ ; cout << count << \" ▁ \" << i << endl ; } i ++ ; } } int main ( ) { int N = 5 ; printTaxicab2 ( N ) ; return 0 ; }", "text_ms": "Nombor Taxicab | C ++ pelaksanaan untuk mencetak nombor pertama N Taxicab (2) :; Bermula dari 1, periksa setiap nombor jika ia adalah Taxicab sehingga Count mencapai n. ; Cuba semua pasangan yang mungkin (j, k) yang jumlah kiubnya boleh saya. ; Taxicab (2) dijumpai; Kod pemacu"}
{"text": "Composite Number | A optimized school method based C ++ program to check if a number is composite . ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Driver Program to test above function", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isComposite ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return false ; if ( n % 2 == 0 n % 3 == 0 ) return true ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; return false ; } int main ( ) { isComposite ( 11 ) ? cout << \" ▁ true STRNEWLINE \" : cout << \" ▁ false STRNEWLINE \" ; isComposite ( 15 ) ? cout << \" ▁ true STRNEWLINE \" : cout << \" ▁ false STRNEWLINE \" ; return 0 ; }", "text_ms": "Nombor Komposit | Kaedah sekolah yang dioptimumkan berdasarkan program C ++ untuk memeriksa sama ada nombor adalah komposit. ; Kes sudut; Ini diperiksa supaya kita dapat melangkau lima nombor di bawah gelung; Program pemacu untuk menguji fungsi di atas"}
{"text": "Insert minimum number in array so that sum of array becomes prime | C ++ program to find minimum number to insert in array so their sum is prime ; function to check if a number is prime or not ; Corner case ; Check from 2 to n - 1 ; Find prime number greater than a number ; find prime greater than n ; check if num is prime ; increment num ; To find number to be added so sum of array is prime ; To find sum of array elements ; if sum is already prime return 0 ; To find prime number greater than sum ; Return difference of sum and num ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } int findPrime ( int n ) { int num = n + 1 ; while ( num ) { if ( isPrime ( num ) ) return num ; num = num + 1 ; } return 0 ; } int minNumber ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( isPrime ( sum ) ) return 0 ; int num = findPrime ( sum ) ; return num - sum ; } int main ( ) { int arr [ ] = { 2 , 4 , 6 , 8 , 12 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minNumber ( arr , n ) ; return 0 ; }", "text_ms": "Masukkan nombor minimum dalam array supaya jumlah array menjadi perdana | Program C ++ untuk mencari nombor minimum untuk memasukkan dalam array supaya jumlahnya adalah perdana; berfungsi untuk memeriksa sama ada nombor adalah perdana atau tidak; Kes sudut; Semak dari 2 hingga n - 1; Cari nombor perdana lebih besar daripada nombor; Cari perdana lebih besar daripada n; Semak jika Num adalah Perdana; kenaikan num; Untuk mencari nombor yang akan ditambah sehingga jumlah array adalah perdana; Untuk mencari jumlah elemen array; jika jumlah sudah menjadi pulangan utama 0; Untuk mencari nombor perdana lebih besar daripada jumlah; Mengembalikan perbezaan jumlah dan num; Kod pemacu"}
{"text": "Sum of divisors of factorial of a number | C ++ program to find sum of proper divisor of factorial of a number ; function to calculate factorial ; function to calculate sum of divisor ; Returns sum of divisors of n ! ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int fact ( int n ) { if ( n == 0 ) return 1 ; return n * fact ( n - 1 ) ; } int div ( int x ) { int ans = 0 ; for ( int i = 1 ; i <= x ; i ++ ) if ( x % i == 0 ) ans += i ; return ans ; } int sumFactDiv ( int n ) { return div ( fact ( n ) ) ; } int main ( ) { int n = 4 ; cout << sumFactDiv ( n ) ; }", "text_ms": "Jumlah pembahagi faktorial nombor | Program C ++ untuk mencari jumlah pembahagi yang betul dari faktorial nombor; fungsi untuk mengira faktorial; berfungsi untuk mengira jumlah pembahagi; Mengembalikan jumlah pembahagi N! ; Kod pemacu"}
{"text": "Sum of divisors of factorial of a number | C ++ program to find sum of divisors in n ! ; allPrimes [ ] stores all prime numbers less than or equal to n . ; Fills above vector allPrimes [ ] for a given n ; Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is not a prime , else true . ; Loop to update prime [ ] ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Store primes in the vector allPrimes ; Function to find all result of factorial number ; Initialize result ; find exponents of all primes which divides n and less than n ; Current divisor ; Find the highest power ( stored in exp ) ' ▁ ▁ of ▁ allPrimes [ i ] ▁ that ▁ divides ▁ n ▁ using ▁ ▁ Legendre ' s formula . ; Using the divisor function to calculate the sum ; return total divisors ; Driver program to run the cases", "code": "#include <bits/stdc++.h> NEW_LINE #include <math.h> NEW_LINE using namespace std ; vector < int > allPrimes ; void sieve ( int n ) { vector < bool > prime ( n + 1 , true ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) allPrimes . push_back ( p ) ; } int factorialDivisors ( int n ) { int result = 1 ; for ( int i = 0 ; i < allPrimes . size ( ) ; i ++ ) { int p = allPrimes [ i ] ; int exp = 0 ; while ( p <= n ) { exp = exp + ( n / p ) ; p = p * allPrimes [ i ] ; } result = result * ( pow ( allPrimes [ i ] , exp + 1 ) - 1 ) / ( allPrimes [ i ] - 1 ) ; } return result ; } int main ( ) { cout << factorialDivisors ( 4 ) ; return 0 ; }", "text_ms": "Jumlah pembahagi faktorial nombor | Program C ++ untuk mencari jumlah pembahagi di N! ; AllPrimes [] menyimpan semua nombor utama kurang daripada atau sama dengan n. ; Mengisi di atas vektor allprimes [] untuk n yang diberikan; Buat array Boolean \"Perdana [0 ... N]\" dan memulakan semua penyertaannya sebagai benar. Nilai dalam Perdana [i] akhirnya akan palsu jika saya bukan perdana, yang lain benar. ; Gelung untuk mengemas kini perdana []; Jika Perdana [P] tidak berubah, maka ia adalah perdana; Kemas kini semua gandaan P; Menyimpan prima dalam vektor AllPrimes; Fungsi untuk mencari semua hasil nombor faktorial; Memulakan hasil; Cari eksponen semua prima yang membahagikan n dan kurang daripada n; Pembahagi semasa; Cari kuasa tertinggi (disimpan dalam exp) '' using ; Menggunakan fungsi pembahagi untuk mengira jumlah; mengembalikan jumlah pembahagi; Program pemacu untuk menjalankan kes -kes"}
{"text": "Pandigital number in a given base | C ++ program to check if a number is pandigital in given base . ; Return true if n is pandigit else return false . ; Checking length is less than base ; Traversing each digit of the number . ; If digit is integer ; If digit is alphabet ; Checking hash array , if any index is unmarked . ; Driver Program", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkPandigital ( int b , char n [ ] ) { if ( strlen ( n ) < b ) return false ; bool hash [ b ] ; memset ( hash , false , sizeof ( hash ) ) ; for ( int i = 0 ; i < strlen ( n ) ; i ++ ) { if ( n [ i ] >= '0' && n [ i ] <= '9' ) hash [ n [ i ] - '0' ] = true ; else if ( n [ i ] - ' A ' <= b - 11 ) hash [ n [ i ] - ' A ' + 10 ] = true ; } for ( int i = 0 ; i < b ; i ++ ) if ( hash [ i ] == false ) return false ; return true ; } int main ( ) { int b = 13 ; char n [ ] = \"1298450376ABC \" ; ( checkPandigital ( b , n ) ) ? ( cout << \" Yes \" << endl ) : ( cout << \" No \" << endl ) ; return 0 ; }", "text_ms": "Nombor Pandigital dalam pangkalan yang diberikan | Program C ++ untuk memeriksa sama ada nombor adalah pandigital dalam asas yang diberikan. ; Kembali benar jika n adalah pandigit lain kembali palsu. ; Panjang pemeriksaan kurang daripada asas; Melintasi setiap digit nombor. ; Jika digit adalah integer; Jika digit adalah abjad; Memeriksa array hash, jika mana -mana indeks tidak ditandakan. ; Program Pemandu"}
{"text": "Convert a number m to n using minimum number of given operations | C ++ implementation to convert a number m to n using minimum number of given operations ; Function to find minimum number of given operations to convert m to n ; only way is to do - 1 ( m - n ) times ; not possible ; n is greater and n is odd ; perform ' - 1' on m ( or + 1 on n ) ; n is even ; perform ' * 2' on m ( or n / 2 on n ) ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int convert ( int m , int n ) { if ( m == n ) return 0 ; if ( m > n ) return m - n ; if ( m <= 0 && n > 0 ) return -1 ; if ( n % 2 == 1 ) return 1 + convert ( m , n + 1 ) ; else return 1 + convert ( m , n / 2 ) ; } int main ( ) { int m = 3 , n = 11 ; cout << \" Minimum ▁ number ▁ of ▁ operations ▁ : ▁ \" << convert ( m , n ) ; return 0 ; }", "text_ms": "Tukar nombor m ke n menggunakan bilangan minimum operasi yang diberikan | Pelaksanaan C ++ untuk menukar nombor m ke n menggunakan bilangan minimum operasi yang diberikan; Berfungsi untuk mencari bilangan minimum operasi yang diberikan untuk menukar m ke n; Hanya cara yang perlu dilakukan - 1 (m - n) kali; tidak mungkin; N lebih besar dan n adalah ganjil; lakukan ' - 1' pada m (atau + 1 pada n); n adalah juga; lakukan ' * 2' pada m (atau n / 2 pada n); Kod pemacu"}
{"text": "Seeds ( Or Seed Roots ) of a number | C ++ program to find Seed of a number ; Stores product of digits of x in prodDig [ x ] ; If x has single digit ; If digit product is already computed ; If digit product is not computed before . ; Prints all seeds of n ; Find all seeds using prodDig [ ] ; If there was no seed ; Print seeds ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 10000 ; int prodDig [ MAX ] ; int getDigitProduct ( int x ) { if ( x < 10 ) return x ; if ( prodDig [ x ] != 0 ) return prodDig [ x ] ; int prod = ( x % 10 ) * getDigitProduct ( x / 10 ) ; return ( prodDig [ x ] = prod ) ; } void findSeed ( int n ) { vector < int > res ; for ( int i = 1 ; i <= n / 2 ; i ++ ) if ( i * getDigitProduct ( i ) == n ) res . push_back ( i ) ; if ( res . size ( ) == 0 ) { cout << \" NO ▁ seed ▁ exists STRNEWLINE \" ; return ; } for ( int i = 0 ; i < res . size ( ) ; i ++ ) cout << res [ i ] << \" ▁ \" ; } int main ( ) { long long int n = 138 ; findSeed ( n ) ; return 0 ; }", "text_ms": "Biji (atau akar benih) nombor | Program C ++ untuk mencari benih nombor; Kedai produk digit x dalam proddig [x]; Jika x mempunyai angka tunggal; Jika produk digit sudah dikira; Jika produk digit tidak dikira sebelum ini. ; Mencetak semua benih n; Cari semua biji menggunakan proddig []; Sekiranya tidak ada benih; Cetak biji; Kod pemacu"}
{"text": "Number with maximum number of prime factors | C ++ program to find integer having maximum number of prime factor in first N natural numbers . ; Return smallest number having maximum prime factors . ; Sieve of eratosthenes method to count number of prime factors . ; Finding number having maximum number of prime factor . ; Driven Program", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxPrimefactorNum ( int N ) { int arr [ N + 5 ] ; memset ( arr , 0 , sizeof ( arr ) ) ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( ! arr [ i ] ) for ( int j = 2 * i ; j <= N ; j += i ) arr [ j ] ++ ; arr [ i ] = 1 ; } int maxval = 0 , maxint = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( arr [ i ] > maxval ) { maxval = arr [ i ] ; maxint = i ; } } return maxint ; } int main ( ) { int N = 40 ; cout << maxPrimefactorNum ( N ) << endl ; return 0 ; }", "text_ms": "Nombor dengan bilangan maksimum faktor utama | Program C ++ untuk mencari integer yang mempunyai bilangan maksimum faktor utama dalam nombor semulajadi n pertama. ; Kembalikan nombor terkecil yang mempunyai faktor utama maksimum. ; Sieve kaedah Eratosthenes untuk mengira bilangan faktor utama. ; Mencari nombor yang mempunyai jumlah maksimum faktor utama. ; Program yang didorong"}
{"text": "Sum of all Subarrays | Set 1 | Efficient C ++ program to compute sum of subarray elements ; function compute sum all sub - array ; computing sum of subarray using formula ; return all subarray sum ; driver program to test above function", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long int SubArraySum ( int arr [ ] , int n ) { long int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += ( arr [ i ] * ( i + 1 ) * ( n - i ) ) ; return result ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << \" Sum ▁ of ▁ SubArray ▁ : ▁ \" << SubArraySum ( arr , n ) << endl ; return 0 ; }", "text_ms": "Jumlah semua subarray | Tetapkan 1 | Program C ++ yang cekap untuk mengira jumlah elemen subarray; fungsi mengira jumlah semua sub - array; jumlah pengkomputeran subarray menggunakan formula; kembali semua jumlah subarray; program pemacu untuk menguji fungsi di atas"}
{"text": "Highest power of 2 less than or equal to given number | C ++ program to find highest power of 2 smaller than or equal to n . ; If i is a power of 2 ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int highestPowerof2 ( int n ) { int res = 0 ; for ( int i = n ; i >= 1 ; i -- ) { if ( ( i & ( i - 1 ) ) == 0 ) { res = i ; break ; } } return res ; } int main ( ) { int n = 10 ; cout << highestPowerof2 ( n ) ; return 0 ; }", "text_ms": "Kuasa tertinggi 2 kurang daripada atau sama dengan nombor yang diberikan | Program C ++ untuk mencari kuasa tertinggi 2 lebih kecil daripada atau sama dengan n. ; Jika saya adalah kuasa 2; Kod pemacu"}
{"text": "Find Cube Pairs | Set 2 ( A n ^ ( 1 / 3 ) Solution ) | C ++ program to find pairs that can represent the given number as sum of two cubes ; Function to find pairs that can represent the given number as sum of two cubes ; find cube root of n ; create a array of size of size ' cubeRoot ' ; for index i , cube [ i ] will contain i ^ 3 ; Find all pairs in above sorted array cube [ ] whose sum is equal to n ; Driver function", "code": "#include <iostream> NEW_LINE #include <cmath> NEW_LINE using namespace std ; void findPairs ( int n ) { int cubeRoot = pow ( n , 1.0 / 3.0 ) ; int cube [ cubeRoot + 1 ] ; for ( int i = 1 ; i <= cubeRoot ; i ++ ) cube [ i ] = i * i * i ; int l = 1 ; int r = cubeRoot ; while ( l < r ) { if ( cube [ l ] + cube [ r ] < n ) l ++ ; else if ( cube [ l ] + cube [ r ] > n ) r -- ; else { cout << \" ( \" << l << \" , ▁ \" << r << \" ) \" << endl ; l ++ ; r -- ; } } } int main ( ) { int n = 20683 ; findPairs ( n ) ; return 0 ; }", "text_ms": "Cari Pasangan Cube | Tetapkan 2 (A N ^ (1/3) Penyelesaian) | Program C ++ untuk mencari pasangan yang boleh mewakili nombor yang diberikan sebagai jumlah dua kiub; Fungsi untuk mencari pasangan yang boleh mewakili nombor yang diberikan sebagai jumlah dua kiub; Cari akar kiub n; Buat pelbagai saiz saiz 'cuberoot'; Untuk indeks i, kiub [i] akan mengandungi i ^ 3; Cari semua pasangan di atas Array Cube di atas [] yang jumlahnya sama dengan N; Fungsi pemacu"}
{"text": "Find Cube Pairs | Set 1 ( A n ^ ( 2 / 3 ) Solution ) | C ++ program to find pairs that can represent the given number as sum of two cubes ; Function to find pairs that can represent the given number as sum of two cubes ; find cube root of n ; create an empty map ; Consider all pairs such with values less than cuberoot ; find sum of current pair ( x , y ) ; do nothing if sum is not equal to given number ; if sum is seen before , we found two pairs ; if sum is seen for the first time ; Driver function", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPairs ( int n ) { int cubeRoot = pow ( n , 1.0 / 3.0 ) ; unordered_map < int , pair < int , int > > s ; for ( int x = 1 ; x < cubeRoot ; x ++ ) { for ( int y = x + 1 ; y <= cubeRoot ; y ++ ) { int sum = x * x * x + y * y * y ; if ( sum != n ) continue ; if ( s . find ( sum ) != s . end ( ) ) { cout << \" ( \" << s [ sum ] . first << \" , ▁ \" << s [ sum ] . second << \" ) ▁ and ▁ ( \" << x << \" , ▁ \" << y << \" ) \" << endl ; } else s [ sum ] = make_pair ( x , y ) ; } } } int main ( ) { int n = 13832 ; findPairs ( n ) ; return 0 ; }", "text_ms": "Cari Pasangan Cube | Tetapkan 1 (A N ^ (2/3) Penyelesaian) | Program C ++ untuk mencari pasangan yang boleh mewakili nombor yang diberikan sebagai jumlah dua kiub; Fungsi untuk mencari pasangan yang boleh mewakili nombor yang diberikan sebagai jumlah dua kiub; Cari akar kiub n; Buat peta kosong; Pertimbangkan semua pasangan seperti nilai kurang daripada cuberoot; Cari jumlah pasangan semasa (x, y); Jangan lakukan apa -apa jika jumlah tidak sama dengan nombor yang diberikan; Jika jumlahnya dilihat sebelum ini, kami mendapati dua pasang; Jika jumlahnya dilihat buat kali pertama; Fungsi pemacu"}
{"text": "Find the minimum difference between Shifted tables of two numbers | C ++ program to find the minimum difference between any two terms of two tables ; Utility function to find GCD of a and b ; Returns minimum difference between any two terms of shifted tables of ' a ' and ' b ' . ' x ' is shift in table of ' a ' and ' y ' is shift in table of ' b ' . ; Calculate gcd of a nd b ; Calculate difference between x and y ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { while ( b != 0 ) { int t = b ; b = a % b ; a = t ; } return a ; } int findMinDiff ( int a , int b , int x , int y ) { int g = gcd ( a , b ) ; int diff = abs ( x - y ) % g ; return min ( diff , g - diff ) ; } int main ( ) { int a = 20 , b = 52 , x = 5 , y = 7 ; cout << findMinDiff ( a , b , x , y ) << endl ; return 0 ; }", "text_ms": "Cari perbezaan minimum antara jadual beralih dua nombor | Program C ++ untuk mencari perbezaan minimum antara dua syarat dua jadual; Fungsi utiliti untuk mencari GCD A dan B; Mengembalikan perbezaan minimum antara dua terma jadual beralih 'A' dan 'B'. 'X' adalah peralihan dalam jadual 'a' dan 'y' adalah peralihan dalam jadual 'b'. ; Hitung GCD Nd B; Kirakan perbezaan antara x dan y; Kod pemacu"}
{"text": "Find all divisors of a natural number | Set 2 | A O ( sqrt ( n ) ) program that prints all divisors in sorted order ; function to print the divisors ; Vector to store half of the divisors ; check if divisors are equal ; push the second divisor in the vector ; The vector will be printed in reverse ; Driver program to test above function", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printDivisors ( int n ) { vector < int > v ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) printf ( \" % d ▁ \" , i ) ; else { printf ( \" % d ▁ \" , i ) ; v . push_back ( n / i ) ; } } } for ( int i = v . size ( ) - 1 ; i >= 0 ; i -- ) printf ( \" % d ▁ \" , v [ i ] ) ; } int main ( ) { printf ( \" The ▁ divisors ▁ of ▁ 100 ▁ are : ▁ n \" ) ; printDivisors ( 100 ) ; return 0 ; }", "text_ms": "Cari semua pembahagi nombor semulajadi | Tetapkan 2 | Program O (sqrt (n)) yang mencetak semua pembahagi dalam urutan yang disusun; berfungsi untuk mencetak pembahagi; Vektor untuk menyimpan separuh daripada pembahagi; Semak jika pembahagi adalah sama; Tolak pembahagi kedua dalam vektor; Vektor akan dicetak secara terbalik; Program pemacu untuk menguji fungsi di atas"}
{"text": "Find all divisors of a natural number | Set 2 | A O ( sqrt ( n ) ) program that prints all divisors in sorted order ; Function to print the divisors ; Driver code", "code": "#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; void printDivisors ( int n ) { int i ; for ( i = 1 ; i * i < n ; i ++ ) { if ( n % i == 0 ) cout << i << \" ▁ \" ; } if ( i - ( n / i ) == 1 ) { i -- ; } for ( ; i >= 1 ; i -- ) { if ( n % i == 0 ) cout << n / i << \" ▁ \" ; } } int main ( ) { cout << \" The ▁ divisors ▁ of ▁ 100 ▁ are : ▁ STRNEWLINE \" ; printDivisors ( 100 ) ; return 0 ; }", "text_ms": "Cari semua pembahagi nombor semulajadi | Tetapkan 2 | Program O (sqrt (n)) yang mencetak semua pembahagi dalam urutan yang disusun; Berfungsi untuk mencetak pembahagi; Kod pemacu"}
{"text": "Find all factors of a natural number | Set 1 | C ++ implementation of Naive method to print all divisors ; function to print the divisors ; Driver program to test above function", "code": "#include <iostream> NEW_LINE using namespace std ; void printDivisors ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) if ( n % i == 0 ) cout << \" ▁ \" << i ; } int main ( ) { cout << \" The ▁ divisors ▁ of ▁ 100 ▁ are : ▁ STRNEWLINE \" ; printDivisors ( 100 ) ; return 0 ; }", "text_ms": "Cari semua faktor nombor semula jadi | Tetapkan 1 | C ++ pelaksanaan kaedah naif untuk mencetak semua pembahagi; berfungsi untuk mencetak pembahagi; Program pemacu untuk menguji fungsi di atas"}
{"text": "Find all factors of a natural number | Set 1 | A Better ( than Naive ) Solution to find all divisiors ; Function to print the divisors ; Note that this loop runs till square root ; If divisors are equal , print only one ; else Otherwise print both ; Driver program to test above function", "code": "#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; void printDivisors ( int n ) { for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) cout << \" ▁ \" << i ; cout << \" ▁ \" << i << \" ▁ \" << n / i ; } } } int main ( ) { cout << \" The ▁ divisors ▁ of ▁ 100 ▁ are : ▁ STRNEWLINE \" ; printDivisors ( 100 ) ; return 0 ; }", "text_ms": "Cari semua faktor nombor semula jadi | Tetapkan 1 | Penyelesaian yang lebih baik (daripada naif) untuk mencari semua divisior; Berfungsi untuk mencetak pembahagi; Perhatikan bahawa gelung ini berjalan sehingga akar persegi; Jika pembahagi adalah sama, cetak hanya satu; lain sebaliknya mencetak kedua -duanya; Program pemacu untuk menguji fungsi di atas"}
{"text": "Sieve of Atkin | C ++ program for implementation of Sieve of Atkin ; 2 and 3 are known to be prime ; Initialise the sieve array with false values ; Mark sieve [ n ] is true if one of the following is true : a ) n = ( 4 * x * x ) + ( y * y ) has odd number of solutions , i . e . , there exist odd number of distinct pairs ( x , y ) that satisfy the equation and n % 12 = 1 or n % 12 = 5. b ) n = ( 3 * x * x ) + ( y * y ) has odd number of solutions and n % 12 = 7 c ) n = ( 3 * x * x ) - ( y * y ) has odd number of solutions , x > y and n % 12 = 11 ; Main part of Sieve of Atkin ; Mark all multiples of squares as non - prime ; Print primes using sieve [ ] ; Driver program", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int SieveOfAtkin ( int limit ) { if ( limit > 2 ) cout << 2 << \" ▁ \" ; if ( limit > 3 ) cout << 3 << \" ▁ \" ; bool sieve [ limit ] ; for ( int i = 0 ; i < limit ; i ++ ) sieve [ i ] = false ; for ( int x = 1 ; x * x < limit ; x ++ ) { for ( int y = 1 ; y * y < limit ; y ++ ) { int n = ( 4 * x * x ) + ( y * y ) ; if ( n <= limit && ( n % 12 == 1 n % 12 == 5 ) ) sieve [ n ] ^= true ; n = ( 3 * x * x ) + ( y * y ) ; if ( n <= limit && n % 12 == 7 ) sieve [ n ] ^= true ; n = ( 3 * x * x ) - ( y * y ) ; if ( x > y && n <= limit && n % 12 == 11 ) sieve [ n ] ^= true ; } } for ( int r = 5 ; r * r < limit ; r ++ ) { if ( sieve [ r ] ) { for ( int i = r * r ; i < limit ; i += r * r ) sieve [ i ] = false ; } } for ( int a = 5 ; a < limit ; a ++ ) if ( sieve [ a ] ) cout << a << \" ▁ \" ; } int main ( void ) { int limit = 20 ; SieveOfAtkin ( limit ) ; return 0 ; }", "text_ms": "Sieve of Atkin | Program C ++ untuk pelaksanaan SIEVE OF ATKIN; 2 dan 3 dikenali sebagai Perdana; Memulakan array penapis dengan nilai palsu; Mark Sieve [n] adalah benar jika salah satu daripada yang berikut adalah benar: a) n = (4 * x * x) + (y * y) mempunyai bilangan penyelesaian yang ganjil, i. e. , terdapat bilangan pasangan yang berbeza (x, y) yang memenuhi persamaan dan n % 12 = 1 atau n % 12 = 5. b) n = (3 * x * x) + (y * y) Bahagian utama SIEVE OF ATKIN; Tandakan semua gandaan dataran sebagai bukan perdana; Cetak prima menggunakan ayak []; Program Pemandu"}
{"text": "Find if a point lies inside a Circle | C ++ program to check if a point lies inside a circle or not ; Compare radius of circle with distance of its center from given point ; Driver function", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isInside ( int circle_x , int circle_y , int rad , int x , int y ) { if ( ( x - circle_x ) * ( x - circle_x ) + ( y - circle_y ) * ( y - circle_y ) <= rad * rad ) return true ; else return false ; } int main ( ) { int x = 1 , y = 1 ; int circle_x = 0 , circle_y = 1 , rad = 2 ; isInside ( circle_x , circle_y , rad , x , y ) ? cout << \" Inside \" : cout << \" Outside \" ; }", "text_ms": "Cari jika titik terletak di dalam bulatan | Program C ++ untuk memeriksa sama ada titik terletak di dalam bulatan atau tidak; Bandingkan jejari bulatan dengan jarak pusatnya dari titik yang diberikan; Fungsi pemacu"}
{"text": "Find all possible outcomes of a given expression | C ++ program to evaluate all possible values of a expression ; Utility function to evaluate a simple expression with one operator only . ; This function evaluates all possible values and returns a list of evaluated values . ; To store result ( all possible evaluations of given expression ' expr ' ) ; If there is only one character , it must be a digit ( or operand ) , return it . ; If there are only three characters , middle one must be operator and corner ones must be operand ; every i refers to an operator ; l refers to all the possible values in the left of operator ' expr [ i ] ' ; r refers to all the possible values in the right of operator ' expr [ i ] ' ; Take above evaluated all possible values in left side of ' i ' ; Take above evaluated all possible values in right side of ' i ' ; Calculate value for every pair and add the value to result . ; Driver program", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int eval ( int a , char op , int b ) { if ( op == ' + ' ) return a + b ; if ( op == ' - ' ) return a - b ; if ( op == ' * ' ) return a * b ; } vector < int > evaluateAll ( string expr , int low , int high ) { vector < int > res ; if ( low == high ) { res . push_back ( expr [ low ] - '0' ) ; return res ; } if ( low == ( high - 2 ) ) { int num = eval ( expr [ low ] - '0' , expr [ low + 1 ] , expr [ low + 2 ] - '0' ) ; res . push_back ( num ) ; return res ; } for ( int i = low + 1 ; i <= high ; i += 2 ) { vector < int > l = evaluateAll ( expr , low , i - 1 ) ; vector < int > r = evaluateAll ( expr , i + 1 , high ) ; for ( int s1 = 0 ; s1 < l . size ( ) ; s1 ++ ) { for ( int s2 = 0 ; s2 < r . size ( ) ; s2 ++ ) { int val = eval ( l [ s1 ] , expr [ i ] , r [ s2 ] ) ; res . push_back ( val ) ; } } } return res ; } int main ( ) { string expr = \"1*2 + 3*4\" ; int len = expr . length ( ) ; vector < int > ans = evaluateAll ( expr , 0 , len - 1 ) ; for ( int i = 0 ; i < ans . size ( ) ; i ++ ) cout << ans [ i ] << endl ; return 0 ; }", "text_ms": "Cari semua kemungkinan hasil ekspresi yang diberikan | Program C ++ untuk menilai semua nilai ekspresi yang mungkin; Fungsi utiliti untuk menilai ungkapan mudah dengan satu pengendali sahaja. ; Fungsi ini menilai semua nilai yang mungkin dan mengembalikan senarai nilai yang dinilai. ; Untuk menyimpan hasil (semua kemungkinan penilaian ekspresi 'expr'); Sekiranya terdapat hanya satu watak, ia mestilah digit (atau operan), kembalikannya. ; Sekiranya terdapat hanya tiga aksara, pertengahan mestilah pengendali dan sudut mesti beroperasi; Setiap saya merujuk kepada pengendali; l merujuk kepada semua nilai yang mungkin di sebelah kiri pengendali 'expr [i]'; r merujuk kepada semua nilai yang mungkin di sebelah kanan pengendali 'expr [i]'; Ambil di atas menilai semua nilai yang mungkin di sebelah kiri 'I'; Ambil di atas menilai semua nilai yang mungkin di sebelah kanan 'I'; Kirakan nilai untuk setiap pasangan dan tambahkan nilai yang dihasilkan. ; Program Pemandu"}
{"text": "Program to check if a given number is Lucky ( all digits are different ) | C ++ program to check if a given number is lucky ; This function returns true if n is lucky ; Create an array of size 10 and initialize all elements as false . This array is used to check if a digit is already seen or not . ; Traverse through all digits of given number ; Find the last digit ; If digit is already seen , return false ; Mark this digit as seen ; REmove the last digit from number ; Driver program to test above function .", "code": "#include <iostream> NEW_LINE using namespace std ; bool isLucky ( int n ) { bool arr [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) arr [ i ] = false ; while ( n > 0 ) { int digit = n % 10 ; if ( arr [ digit ] ) return false ; arr [ digit ] = true ; n = n / 10 ; } return true ; } int main ( ) { int arr [ ] = { 1291 , 897 , 4566 , 1232 , 80 , 700 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; for ( int i = 0 ; i < n ; i ++ ) isLucky ( arr [ i ] ) ? cout << arr [ i ] << \" ▁ is ▁ Lucky ▁ STRNEWLINE \" : cout << arr [ i ] << \" ▁ is ▁ not ▁ Lucky ▁ STRNEWLINE \" ; return 0 ; }", "text_ms": "Program untuk memeriksa sama ada nombor tertentu bernasib baik (semua digit adalah berbeza) | Program C ++ untuk memeriksa sama ada nombor tertentu bernasib baik; Fungsi ini kembali benar jika n bernasib baik; Buat pelbagai saiz 10 dan mulakan semua elemen sebagai palsu. Arahan ini digunakan untuk memeriksa sama ada digit sudah dilihat atau tidak. ; Melintasi semua digit nombor yang diberikan; Cari digit terakhir; Jika digit sudah dilihat, kembali palsu; Tandakan digit ini seperti yang dilihat; Keluarkan digit terakhir dari nombor; Program pemacu untuk menguji fungsi di atas."}
{"text": "Print squares of first n natural numbers without using * , / and | C ++ program to print squares of first ' n ' natural numbers wothout using * , / and - ; Initialize ' square ' and first odd number ; Calculate and print squares ; Print square ; Update ' square ' and ' odd ' ; Driver program to test above function", "code": "#include <iostream> NEW_LINE using namespace std ; void printSquares ( int n ) { int square = 0 , odd = 1 ; for ( int x = 0 ; x < n ; x ++ ) { cout << square << \" ▁ \" ; square = square + odd ; odd = odd + 2 ; } } int main ( ) { int n = 5 ; printSquares ( n ) ; }", "text_ms": "Cetak kotak pertama N Nombor Semulajadi tanpa menggunakan *, / dan | Program C ++ untuk mencetak dataran nombor pertama 'n' Nombor semulajadi menggunakan *, / dan -; Memulakan 'persegi' dan nombor ganjil pertama; Mengira dan mencetak kotak; Cetak dataran; Kemas kini 'persegi' dan 'ganjil'; Program pemacu untuk menguji fungsi di atas"}
{"text": "Write a program to reverse digits of a number | C ++ program to reverse digits of a number ; Recursive function to reverse digits of num ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int reversDigits ( int num ) { static int rev_num = 0 ; static int base_pos = 1 ; if ( num > 0 ) { reversDigits ( num / 10 ) ; rev_num += ( num % 10 ) * base_pos ; base_pos *= 10 ; } return rev_num ; } int main ( ) { int num = 4562 ; cout << \" Reverse ▁ of ▁ no . ▁ is ▁ \" << reversDigits ( num ) ; return 0 ; }", "text_ms": "Tulis program untuk membalikkan digit nombor | Program C ++ untuk membalikkan digit nombor; Fungsi rekursif untuk membalikkan digit NUM; Kod pemacu"}
{"text": "Find a number such that maximum in array is minimum possible after XOR | C ++ program that find the minimum possible maximum ; Recursive function that find the minimum value after exclusive - OR ; Condition if ref size is zero or bit is negative then return 0 ; Condition if current bit is off then push current value in curr_off vector ; Condition if current bit is on then push current value in curr_on vector ; Condition if curr_off is empty then call recursive function on curr_on vector ; Condition if curr_on is empty then call recursive function on curr_off vector ; Return the minimum of curr_off and curr_on and add power of 2 of current bit ; Function that print the minimum value after exclusive - OR ; Pushing values in vector ; Printing answer ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int RecursiveFunction ( vector < int > ref , int bit ) { if ( ref . size ( ) == 0 bit < 0 ) return 0 ; vector < int > curr_on , curr_off ; for ( int i = 0 ; i < ref . size ( ) ; i ++ ) { if ( ( ( ref [ i ] >> bit ) & 1 ) == 0 ) curr_off . push_back ( ref [ i ] ) ; else curr_on . push_back ( ref [ i ] ) ; } if ( curr_off . size ( ) == 0 ) return RecursiveFunction ( curr_on , bit - 1 ) ; if ( curr_on . size ( ) == 0 ) return RecursiveFunction ( curr_off , bit - 1 ) ; return min ( RecursiveFunction ( curr_off , bit - 1 ) , RecursiveFunction ( curr_on , bit - 1 ) ) + ( 1 << bit ) ; } void PrintMinimum ( int a [ ] , int n ) { vector < int > v ; for ( int i = 0 ; i < n ; i ++ ) v . push_back ( a [ i ] ) ; cout << RecursiveFunction ( v , 30 ) << \" STRNEWLINE \" ; } int main ( ) { int arr [ ] = { 3 , 2 , 1 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; PrintMinimum ( arr , size ) ; return 0 ; }", "text_ms": "Cari nombor sedemikian rupa sehingga maksimum dalam array adalah minimum mungkin selepas xor | Program C ++ yang mendapati maksimum maksimum minimum; Fungsi rekursif yang mencari nilai minimum selepas eksklusif - atau; Keadaan jika saiz ref adalah sifar atau bit adalah negatif maka kembali 0; Keadaan jika bit semasa dimatikan kemudian tolak nilai semasa dalam vektor curr_off; Keadaan jika bit semasa berada di kemudian tolak nilai semasa dalam vektor curr_on; Keadaan jika curr_off kosong maka hubungi fungsi rekursif pada vektor curr_on; Keadaan jika curr_on kosong maka hubungi fungsi rekursif pada vektor curr_off; Kembalikan minimum curr_off dan curr_on dan tambah kuasa 2 bit semasa; Fungsi yang mencetak nilai minimum selepas eksklusif - atau; Menolak nilai dalam vektor; Jawapan percetakan; Kod pemacu"}
{"text": "Count of elements which are equal to the XOR of the next two elements | C ++ implementation of the approach ; Function to return the count of elements which are equal to the XOR of the next two elements ; To store the required count ; For every element of the array such that it has at least two elements appearing after it in the array ; If current element is equal to the XOR of the next two elements in the array ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntElements ( int arr [ ] , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( arr [ i ] == ( arr [ i + 1 ] ^ arr [ i + 2 ] ) ) { cnt ++ ; } } return cnt ; } int main ( ) { int arr [ ] = { 4 , 2 , 1 , 3 , 7 , 8 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << cntElements ( arr , n ) ; return 0 ; }", "text_ms": "Count of Elements yang sama dengan XOR dari dua elemen berikutnya | C ++ pelaksanaan pendekatan; Fungsi untuk mengembalikan kiraan elemen yang sama dengan XOR dari dua elemen berikutnya; Untuk menyimpan kiraan yang diperlukan; Untuk setiap elemen array supaya ia mempunyai sekurang -kurangnya dua elemen yang muncul selepas itu dalam array; Jika elemen semasa adalah sama dengan XOR dari dua elemen seterusnya dalam array; Kod pemacu"}
{"text": "Number of triplets in array having subarray xor equal | A simple C ++ program to find Number of triplets in array having subarray xor equal ; Function to return the count ; Initialise result ; Pick 1 st element of the triplet ; Pick 2 nd element of the triplet ; Pick 3 rd element of the triplet ; Taking xor in the first subarray ; Taking xor in the second subarray ; If both xor is equal ; Driver Code ; Function Calling", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int xor_triplet ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j ; k < n ; k ++ ) { int xor1 = 0 , xor2 = 0 ; for ( int x = i ; x < j ; x ++ ) { xor1 ^= arr [ x ] ; } for ( int x = j ; x <= k ; x ++ ) { xor2 ^= arr [ x ] ; } if ( xor1 == xor2 ) { ans ++ ; } } } } return ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << xor_triplet ( arr , n ) ; return 0 ; }", "text_ms": "Bilangan tiga kali ganda dalam array yang mempunyai subarray xor sama | Program C ++ yang mudah untuk mencari bilangan tiga kali ganda dalam array yang mempunyai subarray xor sama; Berfungsi untuk mengembalikan kiraan; Hasil permulaan; Pilih unsur 1 triplet; Pilih elemen 2 nd triplet; Pilih 3 elemen triplet; Mengambil XOR dalam subarray pertama; Mengambil XOR dalam subarray kedua; Jika kedua -dua XOR adalah sama; Kod pemacu; Fungsi panggilan"}
{"text": "Number of triplets in array having subarray xor equal | C ++ trie based program to find the Number of triplets in array having subarray xor equal ; maximum number of bits in an integer <= 1e9 ; Structure of a Trie Node ; [ 0 ] index is bit 0 and [ 1 ] index is bit 1 ; Sum of indexes inserted at at a node ; Number of indexes inserted at a node ; Constructor to initialize a newly created node ; Function to insert curr_xor into the trie ; Iterate from the 31 st bit to the 0 th bit of curr_xor number ; Check if the current bit is set or not ; If this node isn 't already  present in the trie structure  insert it into the trie. ; Increase the sum of indexes by the current index value ; Increase the number of indexes by 1 ; Function to check if curr_xor is present in trie or not ; Iterate from the 31 st bit to the 0 th bit of curr_xor number ; Check if the current bit is set or not ; If this node isn 't already  present in the trie structure  that means no sub array till  current index has 0 xor so  return 0 ; Calculate the number of index inserted at final node ; Calculate the sum of index inserted at final node ; Function to return the count of valid triplets ; To store cumulative xor ; The root of the trie ; Insert the curr_xor in the trie ; Update the cumulative xor ; Check if the cumulative xor is present in the trie or not if present then add ( sz * index ) - sum ; Driver Code ; Given array", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define lg  31 NEW_LINE struct TrieNode { TrieNode * children [ 2 ] ; int sum_of_indexes ; int number_of_indexes ; TrieNode ( ) { this -> children [ 0 ] = nullptr ; this -> children [ 1 ] = nullptr ; this -> sum_of_indexes = 0 ; this -> number_of_indexes = 0 ; } } ; void insert ( TrieNode * node , int num , int index ) { for ( int bits = lg ; bits >= 0 ; bits -- ) { int curr_bit = ( num >> bits ) & 1 ; if ( node -> children [ curr_bit ] == nullptr ) { node -> children [ curr_bit ] = new TrieNode ( ) ; } node = node -> children [ curr_bit ] ; } node -> sum_of_indexes += index ; node -> number_of_indexes ++ ; } int query ( TrieNode * node , int num , int index ) { for ( int bits = lg ; bits >= 0 ; bits -- ) { int curr_bit = ( num >> bits ) & 1 ; if ( node -> children [ curr_bit ] == nullptr ) { return 0 ; } node = node -> children [ curr_bit ] ; } int sz = node -> number_of_indexes ; int sum = node -> sum_of_indexes ; int ans = ( sz * index ) - ( sum ) ; return ans ; } int no_of_triplets ( int arr [ ] , int n ) { int curr_xor = 0 ; int number_of_triplets = 0 ; TrieNode * root = new TrieNode ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ; insert ( root , curr_xor , i ) ; curr_xor ^= x ; number_of_triplets += query ( root , curr_xor , i ) ; } return number_of_triplets ; } int main ( ) { int arr [ ] = { 5 , 2 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << no_of_triplets ( arr , n ) ; return 0 ; }", "text_ms": "Bilangan tiga kali ganda dalam array yang mempunyai subarray xor sama | C ++ trie berasaskan program untuk mencari bilangan tiga kali ganda dalam array yang mempunyai subarray xor sama; bilangan maksimum bit dalam integer <= 1E9; Struktur nod trie; [0] Indeks adalah bit 0 dan [1] indeks adalah bit 1; Jumlah indeks yang dimasukkan pada nod; Bilangan indeks yang dimasukkan pada nod; Pembina untuk memulakan nod yang baru dibuat; Berfungsi untuk memasukkan curr_xor ke dalam trie; Melangkah dari bit 31 ke bit ke -0 bit curr_xor; Semak sama ada bit semasa ditetapkan atau tidak; Sekiranya nod ini tidak ada dalam struktur trie masukkannya ke dalam trie. ; Meningkatkan jumlah indeks dengan nilai indeks semasa; Meningkatkan bilangan indeks sebanyak 1; Fungsi untuk memeriksa sama ada curr_xor hadir dalam trie atau tidak; Melangkah dari bit 31 ke bit ke -0 bit curr_xor; Semak sama ada bit semasa ditetapkan atau tidak; Sekiranya nod ini tidak ada dalam struktur trie yang bermaksud tidak ada sub array sehingga indeks semasa mempunyai 0 xor jadi pulangan 0; Kirakan bilangan indeks yang dimasukkan pada nod akhir; Kirakan jumlah indeks yang dimasukkan pada nod akhir; Berfungsi untuk mengembalikan kiraan tiga kali ganda yang sah; Untuk menyimpan XOR kumulatif; Akar trie; Masukkan curr_xor dalam trie; Kemas kini XOR kumulatif; Semak sama ada XOR kumulatif hadir dalam trie atau tidak jika hadir kemudian tambah (SZ * index) - jumlah; Kod pemacu; Diberikan array"}
{"text": "Find the number of pair of Ideal nodes in a given tree | C ++ implementation of the approach ; Adjacency list ; bit : bit array i and j are starting and ending index INCLUSIVE ; bit : bit array n : size of bit array i is the index to be updated diff is ( new_val - old_val ) ; DFS function to find ideal pairs ; Function for initialisation ; Function to add an edge ; Function to find number of ideal pairs ; Find root of the tree ; Driver code ; Add edges ; Function call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100005 NEW_LINE int n , k ; vector < int > al [ N ] ; long long Ideal_pair ; long long bit [ N ] ; bool root_node [ N ] ; long long bit_q ( int i , int j ) { long long sum = 0ll ; while ( j > 0 ) { sum += bit [ j ] ; j -= ( j & ( j * -1 ) ) ; } i -- ; while ( i > 0 ) { sum -= bit [ i ] ; i -= ( i & ( i * -1 ) ) ; } return sum ; } void bit_up ( int i , long long diff ) { while ( i <= n ) { bit [ i ] += diff ; i += i & - i ; } } void dfs ( int node ) { Ideal_pair += bit_q ( max ( 1 , node - k ) , min ( n , node + k ) ) ; bit_up ( node , 1 ) ; for ( int i = 0 ; i < al [ node ] . size ( ) ; i ++ ) dfs ( al [ node ] [ i ] ) ; bit_up ( node , -1 ) ; } void initialise ( ) { Ideal_pair = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { root_node [ i ] = true ; bit [ i ] = 0LL ; } } void Add_Edge ( int x , int y ) { al [ x ] . push_back ( y ) ; root_node [ y ] = false ; } long long Idealpairs ( ) { int r = -1 ; for ( int i = 1 ; i <= n ; i ++ ) if ( root_node [ i ] ) { r = i ; break ; } dfs ( r ) ; return Ideal_pair ; } int main ( ) { n = 6 , k = 3 ; initialise ( ) ; Add_Edge ( 1 , 2 ) ; Add_Edge ( 1 , 3 ) ; Add_Edge ( 3 , 4 ) ; Add_Edge ( 3 , 5 ) ; Add_Edge ( 3 , 6 ) ; cout << Idealpairs ( ) ; return 0 ; }", "text_ms": "Cari bilangan sepasang nod yang ideal di pokok tertentu | C ++ pelaksanaan pendekatan; Senarai Adjacency; Bit: Bit Array I dan J memulakan dan menamatkan indeks termasuk; bit: array bit n: saiz array bit i adalah indeks yang akan dikemas kini diff adalah (new_val - old_val); Fungsi DFS untuk mencari pasangan yang ideal; Fungsi untuk inisialisasi; Berfungsi untuk menambah kelebihan; Berfungsi untuk mencari bilangan pasangan yang ideal; Cari akar pokok; Kod pemacu; Tambah tepi; Panggilan fungsi"}
{"text": "Print bitwise AND set of a number N | CPP program to print all bitwise subsets of N ( Efficient approach ) ; function to find bitwise subsets Efficient approach ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printSubsets ( int n ) { for ( int i = n ; i > 0 ; i = ( i - 1 ) & n ) cout << i << \" ▁ \" ; cout << 0 ; } int main ( ) { int n = 9 ; printSubsets ( n ) ; return 0 ; }", "text_ms": "Cetak bitwise dan set nombor n | Program CPP untuk mencetak semua subset bitwise N (pendekatan yang cekap); berfungsi untuk mencari pendekatan yang cekap subset bitwise; Kod pemacu"}
{"text": "Check if a number is divisible by 17 using bitwise operators | CPP program to check if a number is divisible by 17 or not using bitwise operator . ; function to check recursively if the number is divisible by 17 or not ; if n = 0 or n = 17 then yes ; if n is less then 17 , not divisible by 17 ; reducing the number by floor ( n / 16 ) - n % 16 ; driver code to check the above function", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isDivisibleby17 ( int n ) { if ( n == 0 n == 17 ) return true ; if ( n < 17 ) return false ; return isDivisibleby17 ( ( int ) ( n >> 4 ) - ( int ) ( n & 15 ) ) ; } int main ( ) { int n = 35 ; if ( isDivisibleby17 ( n ) ) cout << n << \" ▁ is ▁ divisible ▁ by ▁ 17\" ; else cout << n << \" ▁ is ▁ not ▁ divisible ▁ by ▁ 17\" ; return 0 ; }", "text_ms": "Semak jika nombor dibahagikan dengan 17 menggunakan pengendali bitwise | Program CPP untuk memeriksa sama ada nombor dibahagikan dengan 17 atau tidak menggunakan pengendali Bitwise. ; fungsi untuk memeriksa secara rekursif jika nombor itu boleh dibahagikan dengan 17 atau tidak; jika n = 0 atau n = 17 maka ya; jika n kurang dari 17, tidak boleh dibahagikan dengan 17; mengurangkan nombor mengikut lantai (n / 16) - n % 16; kod pemacu untuk memeriksa fungsi di atas"}
{"text": "Largest number with binary representation is m 1 's and m | CPP program to find largest number smaller than equal to n with m set bits then m - 1 0 bits . ; Returns largest number with m set bits then m - 1 0 bits . ; Start with 2 bits . ; initial answer is 1 which meets the given condition ; check for all numbers ; compute the number ; if less then N ; increment m to get the next number ; driver code to check the above condition", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long long answer ( long long n ) { long m = 2 ; long long ans = 1 ; long long r = 1 ; while ( r < n ) { r = ( int ) ( pow ( 2 , m ) - 1 ) * ( pow ( 2 , m - 1 ) ) ; if ( r < n ) ans = r ; m ++ ; } return ans ; } int main ( ) { long long n = 7 ; cout << answer ( n ) ; return 0 ; }", "text_ms": "Nombor terbesar dengan perwakilan binari ialah M 1 dan M | Program CPP untuk mencari bilangan terbesar yang lebih kecil daripada sama dengan n dengan m set bit kemudian m - 1 0 bit. ; Mengembalikan nombor terbesar dengan bit set M kemudian m - 1 0 bit. ; Mulakan dengan 2 bit. ; Jawapan awal adalah 1 yang memenuhi syarat yang diberikan; Semak semua nombor; mengira nombor; jika kurang kemudian n; kenaikan m untuk mendapatkan nombor seterusnya; kod pemacu untuk memeriksa keadaan di atas"}
{"text": "Find most significant set bit of a number | Simple CPP program to find MSB number for given n . ; Driver code", "code": "#include <iostream> NEW_LINE using namespace std ; int setBitNumber ( int n ) { if ( n == 0 ) return 0 ; int msb = 0 ; n = n / 2 ; while ( n != 0 ) { n = n / 2 ; msb ++ ; } return ( 1 << msb ) ; } int main ( ) { int n = 0 ; cout << setBitNumber ( n ) ; return 0 ; }", "text_ms": "Cari bit set yang paling ketara | Program CPP mudah untuk mencari nombor MSB untuk diberikan n. ; Kod pemacu"}
{"text": "Find most significant set bit of a number | CPP program to find MSB number for given n . ; Suppose n is 273 ( binary is 100010001 ) . It does following 100010001 | 010001000 = 110011001 ; This makes sure 4 bits ( From MSB and including MSB ) are set . It does following 110011001 | 001100110 = 111111111 ; Increment n by 1 so that there is only one set bit which is just before original MSB . n now becomes 1000000000 ; Return original MSB after shifting . n now becomes 100000000 ; Driver code", "code": "#include <iostream> NEW_LINE using namespace std ; int setBitNumber ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n = n + 1 ; return ( n >> 1 ) ; } int main ( ) { int n = 273 ; cout << setBitNumber ( n ) ; return 0 ; }", "text_ms": "Cari bit set yang paling ketara | Program CPP untuk mencari nombor MSB untuk diberikan n. ; Katakan N ialah 273 (binari ialah 100010001). Ia mengikuti 100010001 | 010001000 = 110011001; Ini memastikan 4 bit (dari MSB dan termasuk MSB) ditetapkan. Ia mengikuti 110011001 | 001100110 = 111111111; Kenaikan n oleh 1 supaya hanya ada satu set bit yang hanya sebelum MSB asal. n kini menjadi 1000000000; Kembalikan MSB asal selepas beralih. n kini menjadi 100000000; Kod pemacu"}
{"text": "Count trailing zero bits using lookup table | Simple C ++ code for counting trailing zeros in binary representation of a number ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countTrailingZero ( int x ) { int count = 0 ; while ( ( x & 1 ) == 0 ) { x = x >> 1 ; count ++ ; } return count ; } int main ( ) { cout << countTrailingZero ( 11 ) << endl ; return 0 ; }", "text_ms": "Count Trailing Zero Bits Menggunakan Table Lookup | Kod C ++ mudah untuk mengira sifar trailing dalam perwakilan binari nombor; Kod pemacu"}
{"text": "Count trailing zero bits using lookup table | C ++ code for counting trailing zeros in binary representation of a number ; Map a bit value mod 37 to its position ; Only difference between ( x and - x ) is the value of signed magnitude ( leftmostbit ) negative numbers signed bit is 1 ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countTrailingZero ( int x ) { static const int lookup [ ] = { 32 , 0 , 1 , 26 , 2 , 23 , 27 , 0 , 3 , 16 , 24 , 30 , 28 , 11 , 0 , 13 , 4 , 7 , 17 , 0 , 25 , 22 , 31 , 15 , 29 , 10 , 12 , 6 , 0 , 21 , 14 , 9 , 5 , 20 , 8 , 19 , 18 } ; return lookup [ ( - x & x ) % 37 ] ; } int main ( ) { cout << countTrailingZero ( 48 ) << endl ; return 0 ; }", "text_ms": "Count Trailing Zero Bits Menggunakan Table Lookup | C ++ kod untuk mengira sifar trailing dalam perwakilan binari nombor; Peta sedikit nilai mod 37 ke kedudukannya; Hanya perbezaan antara (x dan - x) ialah nilai magnitud yang ditandatangani (leftmostbit) nombor negatif yang ditandatangani adalah 1; Kod pemacu"}
{"text": "Calculate 7 n / 8 without using division and multiplication operators | C ++ program to evaluate ceil ( 7 n / 8 ) without using * and / ; Note the inner bracket here . This is needed because precedence of ' - ' operator is higher than ' < < ' ; Driver code", "code": "#include <iostream> NEW_LINE using namespace std ; int multiplyBySevenByEight ( int n ) { return ( n - ( n >> 3 ) ) ; } int main ( ) { int n = 9 ; cout << multiplyBySevenByEight ( n ) ; return 0 ; }", "text_ms": "Kirakan 7 N / 8 tanpa menggunakan pembahagian dan pengendali pendaraban | Program C ++ untuk menilai Ceil (7 n / 8) tanpa menggunakan * dan /; Perhatikan pendakap dalaman di sini. Ini diperlukan kerana keutamaan pengendali ' -' lebih tinggi daripada '<'; Kod pemacu"}
{"text": "Longest set of Palindrome Numbers from the range [ L , R ] with at most K difference between its maximum and minimum | C ++ program for the above approach ; Function to search the rightmost index of given number ; Store the rightmost index ; Calculate the mid ; If given number <= num ; Assign ans = mid ; Update low ; Update high ; return ans ; Function to check if the given number is palindrome or not ; Generate reverse of the given number ; If n is a palindrome ; Function to find the maximum size of group of palindrome numbers having difference between maximum and minimum element at most K ; Stores the all the palindromic numbers in the range [ L , R ] ; Traverse over the range [ L , R ] ; If i is a palindrome ; Append the number in the list ; Stores count of maximum palindromic numbers ; Iterate each element in the list ; Calculate rightmost index in the list < current element + K ; Check if there is rightmost index from the current index ; Return the count ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; static int search ( vector < int > list , int num ) { int low = 0 , high = list . size ( ) - 1 ; int ans = -1 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( list [ mid ] <= num ) { ans = mid ; low = mid + 1 ; } else high = mid - 1 ; } return ans ; } bool isPalindrome ( int n ) { int rev = 0 ; int temp = n ; while ( n > 0 ) { rev = rev * 10 + n % 10 ; n /= 10 ; } return rev == temp ; } int countNumbers ( int L , int R , int K ) { vector < int > list ; for ( int i = L ; i <= R ; i ++ ) { if ( isPalindrome ( i ) ) { list . push_back ( i ) ; } } int count = 0 ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { int right_index = search ( list , list [ i ] + K - 1 ) ; if ( right_index != -1 ) count = max ( count , right_index - i + 1 ) ; } return count ; } int main ( ) { int L = 98 , R = 112 ; int K = 13 ; cout << countNumbers ( L , R , K ) ; }", "text_ms": "Set nombor palindrome terpanjang dari julat [l, r] dengan kebanyakan perbezaan k antara maksimum dan minimum | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari indeks paling kanan nombor yang diberikan; Simpan indeks paling kanan; Hitung pertengahan; Jika diberi nombor <= num; Berikan Ans = Mid; Mengemas kini rendah; Mengemas kini tinggi; kembali Ans; Fungsi untuk memeriksa sama ada nombor yang diberikan adalah palindrome atau tidak; Menjana terbalik nombor yang diberikan; Jika n adalah palindrome; Berfungsi untuk mencari saiz maksimum kumpulan nombor palindrome yang mempunyai perbezaan antara elemen maksimum dan minimum paling banyak k; Menyimpan semua nombor palindromik dalam julat [l, r]; Melintasi julat [l, r]; Jika saya adalah palindrome; Tambah nombor dalam senarai; Kedai kiraan nombor palindromik maksimum; Melelehkan setiap elemen dalam senarai; Kirakan indeks paling kanan dalam senarai <elemen semasa + k; Semak jika terdapat indeks paling kanan dari indeks semasa; Mengembalikan kiraan; Kod pemacu"}
{"text": "Maximize Sum possible by subtracting same value from all elements of a Subarray of the given Array | C ++ program to implement the above approach ; Function to generate previous smaller element for each array element ; The first element has no previous smaller ; Stack to keep track of elements that have occurred previously ; Push the first index ; Pop all the elements until the previous element is smaller than current element ; Store the previous smaller element ; Push the index of the current element ; Return the array ; Function to generate next smaller element for each array element ; Stack to keep track of elements that have occurring next ; Iterate in reverse order for calculating next smaller ; Pop all the elements until the next element is smaller than current element ; Store the next smaller element ; Push the index of the current element ; Return the array ; Function to find the maximum sum by subtracting same value from all elements of a Subarray ; Stores previous smaller element ; Stores next smaller element ; Calculate contribution of each element ; Return answer ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > findPrevious ( vector < int > a , int n ) { vector < int > ps ( n ) ; ps [ 0 ] = -1 ; stack < int > Stack ; Stack . push ( 0 ) ; for ( int i = 1 ; i < n ; i ++ ) { while ( Stack . size ( ) > 0 && a [ Stack . top ( ) ] >= a [ i ] ) Stack . pop ( ) ; ps [ i ] = Stack . size ( ) > 0 ? Stack . top ( ) : -1 ; Stack . push ( i ) ; } return ps ; } vector < int > findNext ( vector < int > a , int n ) { vector < int > ns ( n ) ; ns [ n - 1 ] = n ; stack < int > Stack ; Stack . push ( n - 1 ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { while ( Stack . size ( ) > 0 && a [ Stack . top ( ) ] >= a [ i ] ) Stack . pop ( ) ; ns [ i ] = Stack . size ( ) > 0 ? Stack . top ( ) : n ; Stack . push ( i ) ; } return ns ; } int findMaximumSum ( vector < int > a , int n ) { vector < int > prev_smaller = findPrevious ( a , n ) ; vector < int > next_smaller = findNext ( a , n ) ; int max_value = 0 ; for ( int i = 0 ; i < n ; i ++ ) { max_value = max ( max_value , a [ i ] * ( next_smaller [ i ] - prev_smaller [ i ] - 1 ) ) ; } return max_value ; } int main ( ) { int n = 3 ; vector < int > a { 80 , 48 , 82 } ; cout << findMaximumSum ( a , n ) ; return 0 ; }", "text_ms": "Memaksimumkan jumlah yang mungkin dengan menolak nilai yang sama dari semua elemen subarray array yang diberikan | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk menjana elemen yang lebih kecil sebelumnya untuk setiap elemen array; Unsur pertama tidak mempunyai lebih kecil sebelumnya; Tumpukan untuk menjejaki unsur -unsur yang telah berlaku sebelum ini; Tolak indeks pertama; Pop semua elemen sehingga elemen sebelumnya lebih kecil daripada elemen semasa; Simpan elemen yang lebih kecil sebelumnya; Tolak indeks elemen semasa; Mengembalikan array; Berfungsi untuk menjana elemen yang lebih kecil seterusnya untuk setiap elemen array; Tumpukan untuk menjejaki unsur -unsur yang telah berlaku seterusnya; Melangkah dalam urutan terbalik untuk mengira lebih kecil seterusnya; Pop semua elemen sehingga elemen seterusnya lebih kecil daripada elemen semasa; Simpan elemen yang lebih kecil seterusnya; Tolak indeks elemen semasa; Mengembalikan array; Berfungsi untuk mencari jumlah maksimum dengan menolak nilai yang sama dari semua elemen subarray; Kedai elemen yang lebih kecil sebelumnya; Kedai elemen yang lebih kecil seterusnya; Mengira sumbangan setiap elemen; Jawapan kembali; Kod pemacu"}
{"text": "Check if the given string is shuffled substring of another string | This function returns true if contents of arr1 [ ] and arr2 [ ] are same , otherwise false . ; This function search for all permutations of pat [ ] in txt [ ] ; countP [ ] : Store count of all characters of pattern countTW [ ] : Store count of current window of text ; Traverse through remaining characters of pattern ; Compare counts of current window of text with counts of pattern [ ] ; Add current character to current window ; Remove the first character of previous window ; Check for the last window in text ; Driver program to test above function", "code": "#include <iostream> NEW_LINE #include <cstring> NEW_LINE #define MAX  256 NEW_LINE using namespace std ; bool compare ( char arr1 [ ] , char arr2 [ ] ) { for ( int i = 0 ; i < MAX ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return false ; return true ; } bool search ( char * pat , char * txt ) { int M = strlen ( pat ) , N = strlen ( txt ) ; char countP [ MAX ] = { 0 } , countTW [ MAX ] = { 0 } ; for ( int i = 0 ; i < M ; i ++ ) { ( countP [ pat [ i ] ] ) ++ ; ( countTW [ txt [ i ] ] ) ++ ; } for ( int i = M ; i < N ; i ++ ) { if ( compare ( countP , countTW ) ) return true ; ( countTW [ txt [ i ] ] ) ++ ; countTW [ txt [ i - M ] ] -- ; } if ( compare ( countP , countTW ) ) return true ; return false ; } int main ( ) { char txt [ ] = \" BACDGABCDA \" ; char pat [ ] = \" ABCD \" ; if ( search ( pat , txt ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "text_ms": "Semak jika rentetan yang diberikan disalurkan substring rentetan lain | Fungsi ini kembali benar jika kandungan ARR1 [] dan ARR2 [] sama, jika tidak palsu. ; Fungsi ini mencari semua permutasi pat [] dalam txt []; Countp []: Simpan kiraan semua aksara corak counttw []: kiraan kiraan tetingkap semasa teks; Melintasi watak corak yang tersisa; Bandingkan tuduhan tetingkap semasa teks dengan tuduhan corak []; Tambah aksara semasa ke tetingkap semasa; Keluarkan watak pertama tetingkap sebelumnya; Periksa tetingkap terakhir dalam teks; Program pemacu untuk menguji fungsi di atas"}
{"text": "Maximize the median of the given array after adding K elements to the same array | C ++ implementation of the approach ; Function to return the maximized median ; Sort the array ; If size is even ; If size is odd ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float getMaxMedian ( int arr [ ] , int n , int k ) { int size = n + k ; sort ( arr , arr + n ) ; if ( size % 2 == 0 ) { float median = ( float ) ( arr [ ( size / 2 ) - 1 ] + arr [ size / 2 ] ) / 2 ; return median ; } float median = arr [ size / 2 ] ; return median ; } int main ( ) { int arr [ ] = { 3 , 2 , 3 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; cout << getMaxMedian ( arr , n , k ) ; return 0 ; }", "text_ms": "Memaksimumkan median array yang diberikan selepas menambahkan elemen K ke array yang sama | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan median yang dimaksimumkan; Susun array; Jika saiznya juga; Jika saiz ganjil; Kod pemacu"}
{"text": "Sort 3 Integers without using if condition or using only max ( ) function | C ++ program to print three numbers in sorted order using max function ; Find maximum element ; Find minimum element ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printSorted ( int a , int b , int c ) { int get_max = max ( a , max ( b , c ) ) ; int get_min = - max ( - a , max ( - b , - c ) ) ; int get_mid = ( a + b + c ) - ( get_max + get_min ) ; cout << get_min << \" ▁ \" << get_mid << \" ▁ \" << get_max ; } int main ( ) { int a = 4 , b = 1 , c = 9 ; printSorted ( a , b , c ) ; return 0 ; }", "text_ms": "Susun 3 Integer Tanpa Menggunakan Keadaan atau Menggunakan Hanya Maksimum () Fungsi | Program C ++ untuk mencetak tiga nombor dalam susunan yang disusun menggunakan fungsi max; Cari elemen maksimum; Cari elemen minimum; Kod pemacu"}
{"text": "Binary Insertion Sort | iterative implementation ; Function to sort an array a [ ] of size ' n ' ; find location where selected should be inseretd ; Move all elements after location to create space ; Driver Code", "code": "#include <iostream> NEW_LINE using namespace std ; int binarySearch ( int a [ ] , int item , int low , int high ) { while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( item == a [ mid ] ) return mid + 1 ; else if ( item > a [ mid ] ) low = mid + 1 ; else high = mid - 1 ; } return low ; } void insertionSort ( int a [ ] , int n ) { int i , loc , j , k , selected ; for ( i = 1 ; i < n ; ++ i ) { j = i - 1 ; selected = a [ i ] ; loc = binarySearch ( a , selected , 0 , j ) ; while ( j >= loc ) { a [ j + 1 ] = a [ j ] ; j -- ; } a [ j + 1 ] = selected ; } } int main ( ) { int a [ ] = { 37 , 23 , 0 , 17 , 12 , 72 , 31 , 46 , 100 , 88 , 54 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) , i ; insertionSort ( a , n ) ; cout << \" Sorted ▁ array : ▁ STRNEWLINE \" ; for ( i = 0 ; i < n ; i ++ ) cout << \" ▁ \" << a [ i ] ; return 0 ; }", "text_ms": "Jenis penyisipan binari | pelaksanaan berulang; Berfungsi untuk menyusun array [] saiz 'n'; Cari lokasi di mana dipilih haruslah inseretd; Gerakkan semua elemen selepas lokasi untuk mewujudkan ruang; Kod pemacu"}
{"text": "Insertion Sort | C ++ program for insertion sort ; Function to sort an array using insertion sort ; Move elements of arr [ 0. . i - 1 ] , that are greater than key , to one position ahead of their current position ; A utility function to print an array of size n ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void insertionSort ( int arr [ ] , int n ) { int i , key , j ; for ( i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; j = i - 1 ; while ( j >= 0 && arr [ j ] > key ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } arr [ j + 1 ] = key ; } } void printArray ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) cout << arr [ i ] << \" ▁ \" ; cout << endl ; } int main ( ) { int arr [ ] = { 12 , 11 , 13 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; insertionSort ( arr , n ) ; printArray ( arr , n ) ; return 0 ; }", "text_ms": "SENARAI SENSI | Program C ++ untuk jenis penyisipan; Berfungsi untuk menyusun array menggunakan jenis penyisipan; Gerakkan unsur -unsur ARR [0 .. i - 1], yang lebih besar daripada kunci, ke satu kedudukan di hadapan kedudukan semasa mereka; Fungsi utiliti untuk mencetak pelbagai saiz n; Kod pemacu"}
{"text": "Count of distinct permutation of a String obtained by swapping only unequal characters | C ++ program for the above approach ; Function to calculate total number of valid permutations ; Creating count which is equal to the Total number of characters present and ans that will store the number of unique permutations ; Storing frequency of each character present in the string ; Adding count of characters by excluding characters equal to current char ; Reduce the frequency of the current character and count by 1 , so that it cannot interfere with the calculations of the same elements present to the right of it . ; Return ans + 1 ( Because the given string is also a unique permutation ) ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int validPermutations ( string str ) { unordered_map < char , int > m ; int count = str . length ( ) , ans = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { m [ str [ i ] ] ++ ; } for ( int i = 0 ; i < str . length ( ) ; i ++ ) { ans += count - m [ str [ i ] ] ; m [ str [ i ] ] -- ; count -- ; } return ans + 1 ; } int main ( ) { string str = \" sstt \" ; cout << validPermutations ( str ) ; return 0 ; }", "text_ms": "Count Permutasi yang berbeza dari rentetan yang diperoleh dengan menukar hanya aksara yang tidak sama rata | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira jumlah bilangan permutasi yang sah; Mewujudkan kiraan yang sama dengan jumlah aksara yang hadir dan ANS yang akan menyimpan bilangan permutasi yang unik; Menyimpan kekerapan setiap watak yang ada dalam rentetan; Menambah kiraan aksara dengan tidak termasuk aksara sama dengan char semasa; Kurangkan kekerapan aksara semasa dan dikira sebanyak 1, supaya ia tidak dapat mengganggu pengiraan unsur -unsur yang sama ada di sebelah kanannya. ; Kembali Ans + 1 (kerana rentetan yang diberikan juga merupakan permutasi yang unik); Kod pemacu"}
{"text": "Counts paths from a point to reach Origin | C ++ program to count total number of paths from a point to origin ; DP based function to count number of paths ; Fill entries in bottommost row and leftmost columns ; Fill DP in bottom up manner ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPaths ( int n , int m ) { int dp [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; return dp [ n ] [ m ] ; } int main ( ) { int n = 3 , m = 2 ; cout << \" ▁ Number ▁ of ▁ Paths ▁ \" << countPaths ( n , m ) ; return 0 ; }", "text_ms": "Mengira laluan dari titik untuk mencapai asal | Program C ++ untuk mengira jumlah laluan dari titik ke asal; Fungsi berasaskan DP untuk mengira bilangan laluan; Isi penyertaan dalam Bottommost Row dan lajur paling kiri; Isi DP dengan cara bawah; Kod pemacu"}
{"text": "Coin Change | DP | Recursive C ++ program for coin change problem . ; Returns the count of ways we can sum S [ 0. . . m - 1 ] coins to get sum n ; If n is 0 then there is 1 solution ( do not include any coin ) ; If n is less than 0 then no solution exists ; If there are no coins and n is greater than 0 , then no solution exist ; count is sum of solutions ( i ) including S [ m - 1 ] ( ii ) excluding S [ m - 1 ] ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int count ( int S [ ] , int m , int n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 0 ; if ( m <= 0 && n >= 1 ) return 0 ; return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; } int main ( ) { int i , j ; int arr [ ] = { 1 , 2 , 3 } ; int m = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << \" ▁ \" << count ( arr , m , 4 ) ; return 0 ; }", "text_ms": "Perubahan duit syiling | DP | Program C ++ Rekursif untuk masalah perubahan duit syiling. ; Mengembalikan kiraan cara kita dapat jumlah s [0. . m - 1] syiling untuk mendapatkan jumlah n; Jika n adalah 0 maka terdapat 1 penyelesaian (jangan termasuk mana -mana duit syiling); Jika n kurang daripada 0 maka tiada penyelesaian wujud; Sekiranya tidak ada duit syiling dan N lebih besar daripada 0, maka tiada penyelesaian wujud; Count adalah jumlah penyelesaian (i) termasuk S [m - 1] (ii) tidak termasuk S [m - 1]; Kod pemacu"}
{"text": "Coin Change | DP | Either Pick this coin or not ; else We have no option but to leave this coin ; cin >> tc ;", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int coinchange ( vector < int > & a , int v , int n , vector < vector < int > > & dp ) { if ( v == 0 ) return dp [ n ] [ v ] = 1 ; if ( n == 0 ) return 0 ; if ( dp [ n ] [ v ] != -1 ) return dp [ n ] [ v ] ; if ( a [ n - 1 ] <= v ) { return dp [ n ] [ v ] = coinchange ( a , v - a [ n - 1 ] , n , dp ) + coinchange ( a , v , n - 1 , dp ) ; } return dp [ n ] [ v ] = coinchange ( a , v , n - 1 , dp ) ; } int32_t main ( ) { int tc = 1 ; while ( tc -- ) { int n , v ; n = 3 , v = 4 ; vector < int > a = { 1 , 2 , 3 } ; vector < vector < int > > dp ( n + 1 , vector < int > ( v + 1 , -1 ) ) ; int res = coinchange ( a , v , n , dp ) ; cout << res << endl ; } }", "text_ms": "Perubahan duit syiling | DP | Sama ada memilih duit syiling ini atau tidak; lain kita tidak mempunyai pilihan tetapi meninggalkan duit syiling ini; cin >> tc;"}
{"text": "Check if two strings are same ignoring their cases | Function to compare two strings ignoring their cases ; Convert to uppercase using transform ( ) function and :: toupper in STL ; Comparing both using inbuilt function ; if strings are equal , return true otherwise false ; Function to print the same or not same if strings are equal or not equal ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool equalIgnoreCase ( string str1 , string str2 ) { int i = 0 ; transform ( str1 . begin ( ) , str1 . end ( ) , str1 . begin ( ) , :: toupper ) ; transform ( str2 . begin ( ) , str2 . end ( ) , str2 . begin ( ) , :: toupper ) ; int x = str1 . compare ( str2 ) ; if ( x != 0 ) return false ; else return true ; } void equalIgnoreCaseUtil ( string str1 , string str2 ) { bool res = equalIgnoreCase ( str1 , str2 ) ; if ( res == true ) cout << \" Same \" << endl ; else cout << \" Not ▁ Same \" << endl ; } int main ( ) { string str1 , str2 ; str1 = \" Geeks \" ; str2 = \" geeks \" ; equalIgnoreCaseUtil ( str1 , str2 ) ; str1 = \" Geek \" ; str2 = \" geeksforgeeks \" ; equalIgnoreCaseUtil ( str1 , str2 ) ; return 0 ; }", "text_ms": "Semak jika dua rentetan sama mengabaikan kes mereka | Fungsi untuk membandingkan dua rentetan mengabaikan kes mereka; Tukar ke huruf besar menggunakan fungsi transform () dan :: toupper di STL; Membandingkan kedua -dua menggunakan fungsi terbina; Jika rentetan adalah sama, kembali benar sebaliknya palsu; Berfungsi untuk mencetak sama atau tidak sama jika rentetan sama atau tidak sama; Kod pemacu"}
{"text": "Replace every consonant sequence with its length in the given string | C ++ implementation of the approach ; Function to return the converted string after replacing every consonant sequence with its length ; To store the resultant string ; Checking each character for consonant sequence ; Count the length of consonants sequence ; Add the length in the string ; Add the vowel ; Check for the last consonant sequence in the string ; Return the resultant string ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string replaceConsonants ( string str ) { string res = \" \" ; int i = 0 , count = 0 ; while ( i < str . length ( ) ) { if ( str [ i ] != ' a ' && str [ i ] != ' e ' && str [ i ] != ' i ' && str [ i ] != ' o ' && str [ i ] != ' u ' ) { i ++ ; count ++ ; } else { if ( count > 0 ) res += to_string ( count ) ; res += str [ i ] ; i ++ ; count = 0 ; } } if ( count > 0 ) res += to_string ( count ) ; return res ; } int main ( ) { string str = \" abcdeiop \" ; cout << replaceConsonants ( str ) ; return 0 ; }", "text_ms": "Gantikan setiap urutan konsonan dengan panjangnya dalam rentetan yang diberikan | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan rentetan yang ditukar selepas menggantikan setiap urutan konsonan dengan panjangnya; Untuk menyimpan rentetan yang dihasilkan; Memeriksa setiap watak untuk urutan konsonan; Hitung panjang urutan konsonan; Tambah panjang dalam rentetan; Tambah vokal; Semak urutan konsonan terakhir dalam rentetan; Kembali rentetan yang dihasilkan; Kod pemacu"}
{"text": "Encrypt string with product of number of vowels and consonants in substring of size k | CPP Program to Encrypt string with product of number of vowels and consonants in every substring of size k ; isVowel ( ) is a function that returns true for a vowel and false otherwise . ; function to Encrypt the dtring ; for each substring ; substring of size k ; counting number of vowels and consonants ; append product to answer . ; Driven Program", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isVowel ( char c ) { return ( c == ' a ' c == ' e ' c == ' i ' c == ' o ' c == ' u ' ) ; } string encryptString ( string s , int n , int k ) { int countVowels = 0 ; int countConsonants = 0 ; string ans = \" \" ; for ( int l = 0 ; l <= n - k ; l ++ ) { countVowels = 0 ; countConsonants = 0 ; for ( int r = l ; r <= l + k - 1 ; r ++ ) { if ( isVowel ( s [ r ] ) == true ) countVowels ++ ; else countConsonants ++ ; } ans += to_string ( countVowels * countConsonants ) ; } return ans ; } int main ( ) { string s = \" hello \" ; int n = s . length ( ) ; int k = 2 ; cout << encryptString ( s , n , k ) << endl ; return 0 ; }", "text_ms": "Menyulitkan rentetan dengan produk bilangan vokal dan konsonan dalam substring saiz k | Program CPP untuk menyulitkan rentetan dengan produk bilangan vokal dan konsonan dalam setiap substring saiz K; isvowel () adalah fungsi yang kembali benar untuk vokal dan sebaliknya. ; berfungsi untuk menyulitkan dtring; untuk setiap substring; substring saiz k; mengira bilangan vokal dan konsonan; tambah produk untuk dijawab. ; Program yang didorong"}
{"text": "String containing first letter of every word in a given string with spaces | C ++ implementation of the above approach ; we are splitting the input based on spaces ( s ) + : this regular expression will handle scenarios where we have words separated by multiple spaces ; charAt ( 0 ) will pick only the first character from the string and append to buffer ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string processWords ( char * input ) { char * p ; vector < string > s ; p = strtok ( input , \" ▁ \" ) ; while ( p != NULL ) { s . push_back ( p ) ; p = strtok ( NULL , \" ▁ \" ) ; } string charBuffer ; for ( string values : s ) charBuffer += values [ 0 ] ; return charBuffer ; } int main ( ) { char input [ ] = \" geeks ▁ for ▁ geeks \" ; cout << processWords ( input ) ; return 0 ; }", "text_ms": "String yang mengandungi huruf pertama setiap perkataan dalam rentetan yang diberikan dengan ruang | C ++ pelaksanaan pendekatan di atas; Kami memisahkan input berdasarkan ruang (s) +: ungkapan biasa ini akan mengendalikan senario di mana kami mempunyai kata -kata yang dipisahkan oleh pelbagai ruang; Charat (0) hanya akan memilih watak pertama dari rentetan dan tambahan ke penampan; Kod pemacu"}
{"text": "Generate all binary strings without consecutive 1 's | C ++ program to Generate all binary string without consecutive 1 's of size K ; A utility function generate all string without consecutive 1 'sof size K ; Print binary string without consecutive 1 's ; Terminate binary string ; If previous character is '1' then we put only 0 at end of string example str = \"01\" then new string be \"010\" ; If previous character is '0' than we put both '1' and '0' at end of string example str = \"00\" then new string \"001\" and \"000\" ; Function generate all binary string without consecutive 1 's ; Base case ; One by one stores every binary string of length K ; Generate all Binary string starts with '0' ; Generate all Binary string starts with '1' ; Driver program to test above function", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void generateAllStringsUtil ( int K , char str [ ] , int n ) { if ( n == K ) { str [ n ] = ' \\0' ; cout << str << \" ▁ \" ; return ; } if ( str [ n - 1 ] == '1' ) { str [ n ] = '0' ; generateAllStringsUtil ( K , str , n + 1 ) ; } if ( str [ n - 1 ] == '0' ) { str [ n ] = '0' ; generateAllStringsUtil ( K , str , n + 1 ) ; str [ n ] = '1' ; generateAllStringsUtil ( K , str , n + 1 ) ; } } void generateAllStrings ( int K ) { if ( K <= 0 ) return ; char str [ K ] ; str [ 0 ] = '0' ; generateAllStringsUtil ( K , str , 1 ) ; str [ 0 ] = '1' ; generateAllStringsUtil ( K , str , 1 ) ; } int main ( ) { int K = 3 ; generateAllStrings ( K ) ; return 0 ; }", "text_ms": "Menjana semua rentetan binari tanpa berturut -turut 1 's | Program C ++ untuk menjana semua rentetan binari tanpa saiz Kekekulasi 1 K; Fungsi utiliti menjana semua rentetan tanpa berturut -turut 1 'sof saiz k; Cetak rentetan binari tanpa berturut -turut 1 's; Menamatkan rentetan binari; Jika watak sebelumnya adalah '1' maka kami hanya meletakkan 0 pada akhir rentetan contoh str = \"01\" maka rentetan baru menjadi \"010\"; Jika watak sebelumnya adalah '0' daripada kami meletakkan kedua -dua '1' dan '0' pada akhir rentetan contoh str = \"00\" kemudian rentetan baru \"001\" dan \"000\"; Fungsi menjana semua rentetan binari tanpa berturut -turut 1; Kes asas; Satu demi satu kedai setiap rentetan panjang binari k; Menjana semua rentetan binari bermula dengan '0'; Menjana semua rentetan binari bermula dengan '1'; Program pemacu untuk menguji fungsi di atas"}
{"text": "Largest right circular cylinder within a cube | C ++ Program to find the biggest right circular cylinder that can be fit within a cube ; Function to find the biggest right circular cylinder ; side cannot be negative ; radius of right circular cylinder ; height of right circular cylinder ; volume of right circular cylinder ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float findVolume ( float a ) { if ( a < 0 ) return -1 ; float r = a / 2 ; float h = a ; float V = 3.14 * pow ( r , 2 ) * h ; return V ; } int main ( ) { float a = 5 ; cout << findVolume ( a ) << endl ; return 0 ; }", "text_ms": "Silinder bulat kanan terbesar dalam kiub | Program C ++ untuk mencari silinder bulat kanan terbesar yang boleh sesuai dalam kiub; Berfungsi untuk mencari silinder bulat kanan terbesar; sisi tidak boleh negatif; jejari silinder bulat kanan; ketinggian silinder bulat kanan; jumlah silinder bulat kanan; Kod pemacu"}
{"text": "Program for volume of Pyramid | CPP program to find the volume . ; Function to find the volume of triangular pyramid ; Function to find the volume of square pyramid ; Function to find the volume of pentagonal pyramid ; Function to find the volume of hexagonal pyramid ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; float volumeTriangular ( int a , int b , int h ) { float vol = ( 0.1666 ) * a * b * h ; return vol ; } float volumeSquare ( int b , int h ) { float vol = ( 0.33 ) * b * b * h ; return vol ; } float volumePentagonal ( int a , int b , int h ) { float vol = ( 0.83 ) * a * b * h ; return vol ; } float volumeHexagonal ( int a , int b , int h ) { float vol = a * b * h ; return vol ; } int main ( ) { int b = 4 , h = 9 , a = 4 ; cout << \" Volume ▁ of ▁ triangular \" << \" ▁ base ▁ pyramid ▁ is ▁ \" << volumeTriangular ( a , b , h ) << endl ; cout << \" Volume ▁ of ▁ square ▁ \" << \" ▁ base ▁ pyramid ▁ is ▁ \" << volumeSquare ( b , h ) << endl ; cout << \" Volume ▁ of ▁ pentagonal \" << \" ▁ base ▁ pyramid ▁ is ▁ \" << volumePentagonal ( a , b , h ) << endl ; cout << \" Volume ▁ of ▁ Hexagonal \" << \" ▁ base ▁ pyramid ▁ is ▁ \" << volumeHexagonal ( a , b , h ) ; return 0 ; }", "text_ms": "Program untuk jumlah piramid | Program CPP untuk mencari kelantangan. ; Berfungsi untuk mencari jumlah piramid segi tiga; Berfungsi untuk mencari jumlah piramid persegi; Berfungsi untuk mencari jumlah piramid pentagonal; Berfungsi untuk mencari jumlah piramid heksagon; Kod pemacu"}
{"text": "Program to find area of a Trapezoid | C ++ program to calculate area of a trapezoid ; Function for the area ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; double Area ( int b1 , int b2 , int h ) { return ( ( b1 + b2 ) / 2 ) * h ; } int main ( ) { int base1 = 8 , base2 = 10 , height = 6 ; double area = Area ( base1 , base2 , height ) ; cout << \" Area ▁ is : ▁ \" << area ; return 0 ; }", "text_ms": "Program untuk mencari kawasan trapezoid | Program C ++ untuk mengira kawasan trapezoid; Fungsi untuk kawasan tersebut; Kod pemacu"}
{"text": "Find number of diagonals in n sided convex polygon | C ++ function to find number of diagonals in n sided convex polygon ; driver code to test above function", "code": "#include <iostream> NEW_LINE using namespace std ; int numberOfDiagonals ( int n ) { return n * ( n - 3 ) / 2 ; } int main ( ) { int n = 5 ; cout << n << \" ▁ sided ▁ convex ▁ polygon ▁ have ▁ \" ; cout << numberOfDiagonals ( n ) << \" ▁ diagonals \" ; return 0 ; }", "text_ms": "Cari bilangan pepenjuru dalam polygon cembung N sisi | C ++ Fungsi untuk mencari bilangan pepenjuru dalam poligon cembung N); kod pemacu untuk menguji fungsi di atas"}
{"text": "Area of the largest Rectangle without a given point | C ++ implementation to find area of largest Rectangle without hole within a given Rectangle ; Function to find the maximum area such that it does not contains any hole ; Area for all the possible positions of the cut ; Find the maximum area among the above rectangles ; Driver Code ; Function call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void maximumArea ( int l , int b , int x , int y ) { int left , right , above , below ; left = x * b ; right = ( l - x - 1 ) * b ; above = l * y ; below = ( b - y - 1 ) * l ; cout << max ( max ( left , right ) , max ( above , below ) ) ; } int main ( ) { int L = 8 , B = 8 ; int X = 0 , Y = 0 ; maximumArea ( l , b , x , y ) ; return 0 ; }", "text_ms": "Kawasan segi empat tepat terbesar tanpa titik tertentu | C ++ pelaksanaan untuk mencari kawasan segi empat tepat terbesar tanpa lubang dalam segi empat tepat; Berfungsi untuk mencari kawasan maksimum supaya ia tidak mengandungi sebarang lubang; Kawasan untuk semua kedudukan yang mungkin dipotong; Cari kawasan maksimum di antara segi empat tepat di atas; Kod pemacu; Panggilan fungsi"}
{"text": "Minimize cost of removals required to make all remaining characters of the string unique | C ++ program for the above approach ; Function to find the minimum cost of removing characters to make the string unique ; Store the minimum cost required ; Create a dictionary to store the maximum cost of removal a character ; Create a dictionary to store the total deletion cost of a character ; Traverse the string , S ; Keep track of maximum cost of each character ; Update the maximum deletion cost ; Keep track of the total cost of each character ; Update the total deletion cost ; Traverse through all the unique characters ; Keep the maximum cost character and delete the rest ; Return the answer ; Driver code ; Given string ; Given cost array ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int delCost ( string s , int cost [ ] ) { int ans = 0 ; map < char , int > forMax ; map < char , int > forTot ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ! forMax [ s [ i ] ] ) { forMax [ s [ i ] ] = cost [ i ] ; } else { forMax [ s [ i ] ] = max ( cost [ i ] , forMax [ s [ i ] ] ) ; } if ( ! forTot [ s [ i ] ] ) { forTot [ s [ i ] ] = cost [ i ] ; } else { forTot [ s [ i ] ] = forTot [ s [ i ] ] + cost [ i ] ; } } for ( auto i : forMax ) { ans += forTot [ i . first ] - i . second ; } return ans ; } int main ( ) { string s = \" AAABBB \" ; int cost [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; cout << ( delCost ( s , cost ) ) ; }", "text_ms": "Kurangkan kos penyingkiran yang diperlukan untuk menjadikan semua watak yang tersisa dari rentetan unik | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari kos minimum untuk mengeluarkan aksara untuk membuat rentetan unik; Simpan kos minimum yang diperlukan; Buat kamus untuk menyimpan kos maksimum penyingkiran watak; Buat kamus untuk menyimpan jumlah kos penghapusan watak; Melintasi rentetan, s; Jejaki kos maksimum setiap watak; Mengemas kini kos penghapusan maksimum; Jejaki jumlah kos setiap watak; Mengemas kini jumlah kos penghapusan; Melintasi semua watak yang unik; Simpan watak kos maksimum dan padamkan selebihnya; Kembalikan jawapannya; Kod pemacu; Diberikan rentetan; Diberikan pelbagai kos; Panggilan fungsi"}
{"text": "Smallest divisor of N closest to X | C ++ program for the above approach ; Define macros ; Stores divisors for all numbers in the vector divisors ; i is the divisor and j is the multiple ; Function to compare the closeness of the given target ; Function to find the element closest to target in divisors vector ; Corner cases ; Perform binary search ; Check if target is less than the array element then search in left half ; Check if target is greater than previous to mid , return closest of two ; Repeat for left half ; Check if target is greater than mid ; Update i ; Only single element left after search ; Function to print the divisor of N closest to X ; Function call to calculate and stores divisors of all numbers in a vector ; Stores the closest value to target ; Print the answer ; Driver Code ; Given N & X ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  10000 NEW_LINE vector < vector < int > > divisors ( MAX + 1 ) ; void computeDivisors ( ) { for ( int i = 1 ; i <= MAX ; i ++ ) { for ( int j = i ; j <= MAX ; j += i ) { divisors [ j ] . push_back ( i ) ; } } } int getClosest ( int val1 , int val2 , int target ) { if ( target - val1 >= val2 - target ) return val2 ; else return val1 ; } int findClosest ( vector < int > & arr , int n , int target ) { if ( target <= arr [ 0 ] ) return arr [ 0 ] ; if ( target >= arr [ n - 1 ] ) return arr [ n - 1 ] ; int i = 0 , j = n , mid = 0 ; while ( i < j ) { mid = ( i + j ) / 2 ; if ( arr [ mid ] == target ) return arr [ mid ] ; if ( target < arr [ mid ] ) { if ( mid > 0 && target > arr [ mid - 1 ] ) return getClosest ( arr [ mid - 1 ] , arr [ mid ] , target ) ; j = mid ; } else { if ( mid < n - 1 && target < arr [ mid + 1 ] ) return getClosest ( arr [ mid ] , arr [ mid + 1 ] , target ) ; i = mid + 1 ; } } return arr [ mid ] ; } void printClosest ( int N , int X ) { computeDivisors ( ) ; int ans = findClosest ( divisors [ N ] , divisors [ N ] . size ( ) , X ) ; cout << ans ; } int main ( ) { int N = 16 , X = 5 ; printClosest ( N , X ) ; }", "text_ms": "Pembahagi terkecil n paling dekat dengan x | Program C ++ untuk pendekatan di atas; Tentukan makro; Kedai pembahagi untuk semua nombor dalam pembahagi vektor; Saya adalah pembahagi dan j adalah pelbagai; Fungsi untuk membandingkan kedekatan sasaran yang diberikan; Berfungsi untuk mencari elemen yang paling dekat dengan sasaran dalam vektor pembahagi; Kes sudut; Melakukan carian binari; Semak sama ada sasaran kurang daripada elemen array kemudian cari di separuh kiri; Semak sama ada sasaran lebih besar daripada sebelumnya hingga pertengahan, kembali paling dekat dengan dua; Ulangi separuh kiri; Semak sama ada sasaran lebih besar daripada pertengahan; Kemas kini i; Hanya elemen tunggal yang tersisa selepas carian; Berfungsi untuk mencetak pembahagi n paling dekat dengan x; Fungsi panggilan untuk mengira dan menyimpan pembahagi semua nombor dalam vektor; Menyimpan nilai terdekat untuk sasaran; Cetak jawapannya; Kod pemacu; Diberikan N & X; Panggilan fungsi"}
{"text": "Count elements of same value placed at same indices of two given arrays | C ++ program for the above approach ; Function to count maximum matched elements from the arrays A [ ] and B [ ] ; Stores position of elements of array A [ ] in the array B [ ] ; Keep track of difference between the indices ; Traverse the array A [ ] ; Traverse the array B [ ] ; If difference is negative , add N to it ; Keep track of the number of shifts required to place elements at same indices ; Return the max matches ; Driver code ; Returns the count of matched elements", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxMatch ( int A [ ] , int B [ ] , int M , int N ) { map < int , int > Aindex ; map < int , int > diff ; for ( int i = 0 ; i < M ; i ++ ) { Aindex [ A [ i ] ] = i ; } for ( int i = 0 ; i < N ; i ++ ) { if ( i - Aindex [ B [ i ] ] < 0 ) { diff [ M + i - Aindex [ B [ i ] ] ] += 1 ; } else { diff [ i - Aindex [ B [ i ] ] ] += 1 ; } } int max = 0 ; for ( auto ele = diff . begin ( ) ; ele != diff . end ( ) ; ele ++ ) { if ( ele -> second > max ) { max = ele -> second ; } } return max ; } int main ( ) { int A [ ] = { 5 , 3 , 7 , 9 , 8 } ; int B [ ] = { 8 , 7 , 3 , 5 , 9 } ; int M = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int N = sizeof ( B ) / sizeof ( B [ 0 ] ) ; cout << maxMatch ( A , B , M , N ) ; return 0 ; }", "text_ms": "Mengira elemen nilai yang sama diletakkan pada indeks yang sama dengan dua array yang diberikan | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira elemen yang dipadankan maksimum dari array A [] dan B []; Kedai kedudukan unsur -unsur array a [] dalam array b []; Jejaki perbezaan antara indeks; Melintasi array a []; Melintasi array b []; Jika perbezaan negatif, tambahkan n kepadanya; Jejaki bilangan peralihan yang diperlukan untuk meletakkan elemen pada indeks yang sama; Mengembalikan perlawanan maksimum; Kod pemacu; Mengembalikan kiraan elemen yang dipadankan"}
{"text": "Check if given Sudoku solution is valid or not | C ++ program to implement the above approach ; Function to check if all elements of the board [ ] [ ] array store value in the range [ 1 , 9 ] ; Traverse board [ ] [ ] array ; Check if board [ i ] [ j ] lies in the range ; Function to check if the solution of sudoku puzzle is valid or not ; Check if all elements of board [ ] [ ] stores value in the range [ 1 , 9 ] ; Stores unique value from 1 to N ; Traverse each row of the given array ; Initialize unique [ ] array to false ; Traverse each column of current row ; Stores the value of board [ i ] [ j ] ; Check if current row stores duplicate value ; Traverse each column of the given array ; Initialize unique [ ] array to false ; Traverse each row of current column ; Stores the value of board [ j ] [ i ] ; Check if current column stores duplicate value ; Traverse each block of size 3 * 3 in board [ ] [ ] array ; j stores first column of each 3 * 3 block ; Initialize unique [ ] array to false ; Traverse current block ; Stores row number of current block ; Stores column number of current block ; Stores the value of board [ X ] [ Y ] ; Check if current block stores duplicate value ; If all conditions satisfied ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  9 NEW_LINE bool isinRange ( int board [ ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( board [ i ] [ j ] <= 0 board [ i ] [ j ] > 9 ) { return false ; } } } return true ; } bool isValidSudoku ( int board [ ] [ N ] ) { if ( isinRange ( board ) == false ) { return false ; } bool unique [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { memset ( unique , false , sizeof ( unique ) ) ; for ( int j = 0 ; j < N ; j ++ ) { int Z = board [ i ] [ j ] ; if ( unique [ Z ] ) { return false ; } unique [ Z ] = true ; } } for ( int i = 0 ; i < N ; i ++ ) { memset ( unique , false , sizeof ( unique ) ) ; for ( int j = 0 ; j < N ; j ++ ) { int Z = board [ j ] [ i ] ; if ( unique [ Z ] ) { return false ; } unique [ Z ] = true ; } } for ( int i = 0 ; i < N - 2 ; i += 3 ) { for ( int j = 0 ; j < N - 2 ; j += 3 ) { memset ( unique , false , sizeof ( unique ) ) ; for ( int k = 0 ; k < 3 ; k ++ ) { for ( int l = 0 ; l < 3 ; l ++ ) { int X = i + k ; int Y = j + l ; int Z = board [ X ] [ Y ] ; if ( unique [ Z ] ) { return false ; } unique [ Z ] = true ; } } } } return true ; } int main ( ) { int board [ N ] [ N ] = { { 7 , 9 , 2 , 1 , 5 , 4 , 3 , 8 , 6 } , { 6 , 4 , 3 , 8 , 2 , 7 , 1 , 5 , 9 } , { 8 , 5 , 1 , 3 , 9 , 6 , 7 , 2 , 4 } , { 2 , 6 , 5 , 9 , 7 , 3 , 8 , 4 , 1 } , { 4 , 8 , 9 , 5 , 6 , 1 , 2 , 7 , 3 } , { 3 , 1 , 7 , 4 , 8 , 2 , 9 , 6 , 5 } , { 1 , 3 , 6 , 7 , 4 , 8 , 5 , 9 , 2 } , { 9 , 7 , 4 , 2 , 1 , 5 , 6 , 3 , 8 } , { 5 , 2 , 8 , 6 , 3 , 9 , 4 , 1 , 7 } } ; if ( isValidSudoku ( board ) ) { cout << \" Valid \" ; } else { cout << \" Not ▁ Valid \" ; } }", "text_ms": "Semak jika diberi penyelesaian Sudoku adalah sah atau tidak | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk memeriksa sama ada semua elemen lembaga [] [] nilai kedai array dalam julat [1, 9]; Traverse Board [] [] array; Semak jika papan [i] [j] terletak dalam julat; Fungsi untuk memeriksa sama ada penyelesaian teka -teki sudoku sah atau tidak; Semak sama ada semua elemen papan [] [] menyimpan nilai dalam julat [1, 9]; Kedai nilai unik dari 1 hingga n; Melintasi setiap baris array yang diberikan; Memulakan array unik [] kepada palsu; Melintasi setiap lajur baris semasa; Menyimpan nilai papan [i] [j]; Semak jika baris semasa menyimpan nilai pendua; Melintasi setiap lajur array yang diberikan; Memulakan array unik [] kepada palsu; Melintasi setiap baris lajur semasa; Menyimpan nilai papan [j] [i]; Semak jika lajur semasa menyimpan nilai pendua; Melintasi setiap blok saiz 3 * 3 di papan [] [] array; J menyimpan lajur pertama setiap 3 * 3 blok; Memulakan array unik [] kepada palsu; Melintasi blok semasa; Kedai baris nombor blok semasa; Menyimpan nombor lajur blok semasa; Menyimpan nilai papan [x] [y]; Semak jika blok semasa menyimpan nilai pendua; Jika semua keadaan berpuas hati; Kod pemacu"}
{"text": "Subarray of length K whose concatenation forms a palindrome | C ++ program for the above approach ; Function to check if a number is Palindrome or not here i is the starting index and j is the last index of the subarray ; If the integer at i is not equal to j then the subarray is not palindrome ; Otherwise ; all a [ i ] is equal to a [ j ] then the subarray is palindrome ; Function to find a subarray whose concatenation forms a palindrome and return its starting index ; Iterating over subarray of length k and checking if that subarray is palindrome ; If no subarray is palindrome ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool palindrome ( vector < int > a , int i , int j ) { while ( i < j ) { if ( a [ i ] != a [ j ] ) return false ; i ++ ; j -- ; } return true ; } int findSubArray ( vector < int > arr , int k ) { int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; for ( int i = 0 ; i <= n - k ; i ++ ) { if ( palindrome ( arr , i , i + k - 1 ) ) return i ; } return -1 ; } int main ( ) { vector < int > arr = { 2 , 3 , 5 , 1 , 3 } ; int k = 4 ; int ans = findSubArray ( arr , k ) ; if ( ans == -1 ) cout << -1 << \" STRNEWLINE \" ; else { for ( int i = ans ; i < ans + k ; i ++ ) cout << arr [ i ] << \" ▁ \" ; cout << \" STRNEWLINE \" ; } return 0 ; }", "text_ms": "Subarray panjang k yang penggabungannya membentuk palindrome | Program C ++ untuk pendekatan di atas; Fungsi untuk memeriksa sama ada nombor adalah palindrome atau tidak di sini saya adalah indeks permulaan dan j adalah indeks terakhir subarray; Jika integer di saya tidak sama dengan j maka subarray bukan palindrome; Jika tidak; Semua [i] adalah sama dengan [j] maka subarray adalah palindrome; Berfungsi untuk mencari subarray yang penggabungannya membentuk palindrome dan mengembalikan indeks permulaannya; Melangkah ke atas subarray panjang k dan memeriksa jika subarray itu adalah palindrome; Jika tiada subarray adalah palindrome; Kod pemacu"}
{"text": "Check if a sequence of path visits any coordinate twice or not | C ++ program for the above approach ; Function to check if the man crosses previous visited coordinate or not ; Stores the count of crossed vertex ; Stores ( x , y ) coordinates ; The coordinates for the origin ; Iterate over the string ; Condition to increment X or Y co - ordinates respectively ; Check if ( x , y ) is already visited ; Print the result ; Driver Code ; Given string ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isCrossed ( string path ) { if ( path . size ( ) == 0 ) return false ; bool ans = false ; set < pair < int , int > > set ; int x = 0 , y = 0 ; set . insert ( { x , y } ) ; for ( int i = 0 ; i < path . size ( ) ; i ++ ) { if ( path [ i ] == ' N ' ) set . insert ( { x , y ++ } ) ; if ( path [ i ] == ' S ' ) set . insert ( { x , y -- } ) ; if ( path [ i ] == ' E ' ) set . insert ( { x ++ , y } ) ; if ( path [ i ] == ' W ' ) set . insert ( { x -- , y } ) ; if ( set . find ( { x , y } ) != set . end ( ) ) { ans = true ; break ; } } if ( ans ) cout << \" Crossed \" ; else cout << \" Not ▁ Crossed \" ; } int main ( ) { string path = \" NESW \" ; isCrossed ( path ) ; return 0 ; }", "text_ms": "Semak sama ada urutan laluan melawat sebarang koordinat dua kali atau tidak | Program C ++ untuk pendekatan di atas; Berfungsi untuk memeriksa sama ada lelaki itu melintasi koordinat sebelumnya atau tidak; Menyimpan kiraan puncak silang; Kedai (x, y) koordinat; Koordinat untuk asal; Melangkah ke atas rentetan; Keadaan kepada kenaikan x atau y co - masing -masing; Semak jika (x, y) sudah dilawati; Cetak hasilnya; Kod pemacu; Diberikan rentetan; Panggilan fungsi"}
{"text": "Maximum width of an N | C ++ program to implement the above approach ; Function to find the maximum width of the tree using level order traversal ; Store the edges of the tree ; Stores maximum width of the tree ; Stores the nodes of each level ; Insert root node ; Perform level order traversal on the tree ; Stores the size of the queue ; Update maximum width ; Push the nodes of the next level and pop the elements of the current level ; Get element from the front the Queue ; Push all nodes of the next level . ; Return the result . ; Driver Code ; Constructed tree is : 1 / | \\ 2 - 1 3 / \\ \\ 4 5 8 / / | \\ 2 6 12 7", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxWidth ( int N , int M , vector < int > cost , vector < vector < int > > s ) { vector < int > adj [ N ] ; for ( int i = 0 ; i < M ; i ++ ) { adj [ s [ i ] [ 0 ] ] . push_back ( s [ i ] [ 1 ] ) ; } int result = 0 ; queue < int > q ; q . push ( 0 ) ; while ( ! q . empty ( ) ) { int count = q . size ( ) ; result = max ( count , result ) ; while ( count -- ) { int temp = q . front ( ) ; q . pop ( ) ; for ( int i = 0 ; i < adj [ temp ] . size ( ) ; i ++ ) { q . push ( adj [ temp ] [ i ] ) ; } } } return result ; } int main ( ) { int N = 11 , M = 10 ; vector < vector < int > > edges ; edges . push_back ( { 0 , 1 } ) ; edges . push_back ( { 0 , 2 } ) ; edges . push_back ( { 0 , 3 } ) ; edges . push_back ( { 1 , 4 } ) ; edges . push_back ( { 1 , 5 } ) ; edges . push_back ( { 3 , 6 } ) ; edges . push_back ( { 4 , 7 } ) ; edges . push_back ( { 6 , 10 } ) ; edges . push_back ( { 6 , 8 } ) ; edges . push_back ( { 6 , 9 } ) ; vector < int > cost = { 1 , 2 , -1 , 3 , 4 , 5 , 8 , 2 , 6 , 12 , 7 } ; cout << maxWidth ( N , M , cost , edges ) ; return 0 ; }", "text_ms": "Lebar maksimum n | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari lebar maksimum pokok menggunakan traversal urutan tahap; Simpan tepi pokok; Menyimpan lebar maksimum pokok; Menyimpan nod setiap peringkat; Masukkan nod akar; Melakukan perintah level traversal di atas pokok; Menyimpan saiz barisan; Kemas kini lebar maksimum; Tolak nod tahap seterusnya dan popkan unsur -unsur tahap semasa; Dapatkan elemen dari depan barisan; Tolak semua nod peringkat seterusnya. ; Kembalikan hasilnya. ; Kod pemacu; Pokok yang dibina ialah: 1 / | \\ 2 - 1 3 / \\ \\ 4 5 8 / / | \\ 2 6 12 7"}
{"text": "Minimize sum of prime numbers added to make an array non | C ++ Program to implement the above approach ; Stores if an index is a prime / non - prime value ; Stores the prime ; Function to generate all prime numbers ; If current element is prime ; Set all its multiples non - prime ; Store all prime numbers ; Function to find the closest prime to a particular number ; Applying binary search on primes vector ; If the prime added makes the elements equal ; Return this as the closest prime ; If the array remains non - decreasing ; Search for a bigger prime number ; Otherwise ; Check if a smaller prime can make array non - decreasing or not ; Return closest number ; Function to find the minimum cost ; Find all primes ; Store the result ; Iterate over the array ; Current element is less than the previous element ; Find the closest prime which makes the array non decreasing ; Add to overall cost ; Update current element ; Return the minimum cost ; Driver Code ; Given array ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  10000000 NEW_LINE bool isPrime [ MAX ] ; vector < int > primes ; void SieveOfEratosthenes ( ) { memset ( isPrime , true , sizeof ( isPrime ) ) ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * p ; i <= MAX ; i += p ) isPrime [ i ] = false ; } } for ( int p = 2 ; p <= MAX ; p ++ ) if ( isPrime [ p ] ) primes . push_back ( p ) ; } int prime_search ( vector < int > primes , int diff ) { int low = 0 ; int high = primes . size ( ) - 1 ; int res ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( primes [ mid ] == diff ) { return primes [ mid ] ; } else if ( primes [ mid ] < diff ) { low = mid + 1 ; } else { res = primes [ mid ] ; high = mid - 1 ; } } return res ; } int minCost ( int arr [ ] , int n ) { SieveOfEratosthenes ( ) ; int res = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { int diff = arr [ i - 1 ] - arr [ i ] ; int closest_prime = prime_search ( primes , diff ) ; res += closest_prime ; arr [ i ] += closest_prime ; } } return res ; } int main ( ) { int arr [ ] = { 2 , 1 , 5 , 4 , 3 } ; int n = 5 ; cout << minCost ( arr , n ) ; return 0 ; }", "text_ms": "Kurangkan jumlah nombor perdana yang ditambah untuk membuat array bukan | Program C ++ untuk melaksanakan pendekatan di atas; Kedai jika indeks adalah nilai utama / bukan utama; Menyimpan perdana; Berfungsi untuk menjana semua nombor perdana; Jika elemen semasa adalah perdana; Tetapkan semua gandaannya bukan perdana; Simpan semua nombor utama; Berfungsi untuk mencari perdana terdekat dengan nombor tertentu; Memohon carian binari pada vektor prima; Jika perdana ditambah menjadikan unsur -unsur sama; Kembali ini sebagai perdana terdekat; Jika array kekal tidak menurun; Cari nombor perdana yang lebih besar; Jika tidak; Periksa sama ada perdana yang lebih kecil boleh membuat array tidak berkurangan atau tidak; Mengembalikan nombor terdekat; Berfungsi untuk mencari kos minimum; Cari semua prima; Simpan hasilnya; Melangkah ke atas array; Elemen semasa adalah kurang daripada elemen sebelumnya; Cari perdana terdekat yang membuat array tidak berkurangan; Tambah kepada kos keseluruhan; Mengemas kini elemen semasa; Mengembalikan kos minimum; Kod pemacu; Diberikan array; Panggilan fungsi"}
{"text": "Count ways to split a Binary String into three substrings having equal count of zeros | C ++ implementation for the above approach ; Function to return ways to split a string into three parts with the equal number of 0 ; Store total count of 0 s ; Count total no . of 0 s character in given string ; If total count of 0 character is not divisible by 3 ; Initialize mp to store frequency of k ; Traverse string to find ways to split string ; Increment count if 0 appears ; Increment result if sum equal to 2 * k and k exists in mp ; Insert sum in mp ; Return result ; Driver Code ; Given string ; Function call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int count ( string s ) { int cnt = 0 ; for ( char c : s ) { cnt += c == '0' ? 1 : 0 ; } if ( cnt % 3 != 0 ) return 0 ; int res = 0 , k = cnt / 3 , sum = 0 ; map < int , int > mp ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { sum += s [ i ] == '0' ? 1 : 0 ; if ( sum == 2 * k && mp . find ( k ) != mp . end ( ) && i < s . length ( ) - 1 && i > 0 ) { res += mp [ k ] ; } mp [ sum ] ++ ; } return res ; } int main ( ) { string str = \"01010\" ; cout << count ( str ) ; }", "text_ms": "Kira cara untuk memecah rentetan binari ke dalam tiga substring yang mempunyai kiraan sifar yang sama | C ++ pelaksanaan untuk pendekatan di atas; Berfungsi untuk mengembalikan cara untuk memecah rentetan ke dalam tiga bahagian dengan bilangan yang sama 0; Simpan jumlah kiraan 0 s; Kira Jumlah No. daripada 0 s watak dalam rentetan yang diberikan; Jika jumlah kiraan 0 watak tidak boleh dibahagikan dengan 3; Memulakan MP untuk menyimpan kekerapan k; Traverse String untuk mencari cara untuk memecah rentetan; Kiraan kenaikan jika 0 muncul; Hasil kenaikan jika jumlah sama dengan 2 * k dan k ada dalam MP; Masukkan jumlah dalam MP; Hasil pulangan; Kod pemacu; Diberikan rentetan; Panggilan fungsi"}
{"text": "Count ways to split a Binary String into three substrings having equal count of zeros | C ++ program for above approach ; Function to calculate the number of ways to split ; Calculating the total number of zeros ; Case1 If total count of zeros is not divisible by 3 ; Case2 if total count of zeros is zero ; Number of zeros in each substring ; Initialising zero to the number of ways for first and second cut ; Initializing the count ; Traversing from the beginning ; Incrementing the count if the element is '0' ; Incrementing the ways for the 1 st cut if count is equal to zeros required in each substring ; Incrementing the ways for the 2 nd cut if count is equal to 2 * ( zeros required in each substring ) ; Total number of ways to split is multiplication of ways for the 1 st and 2 nd cut ; Driver Code ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int splitstring ( string s ) { int n = s . length ( ) ; int zeros = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( s [ i ] == '0' ) zeros ++ ; if ( zeros % 3 != 0 ) return 0 ; if ( zeros == 0 ) return ( ( n - 1 ) * ( n - 2 ) ) / 2 ; int zerosInEachSubstring = zeros / 3 ; int waysOfFirstCut = 0 , waysOfSecondCut = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '0' ) count ++ ; if ( count == zerosInEachSubstring ) waysOfFirstCut ++ ; else if ( count == 2 * zerosInEachSubstring ) waysOfSecondCut ++ ; } return waysOfFirstCut * waysOfSecondCut ; } int main ( ) { string s = \"01010\" ; cout << \" The ▁ number ▁ of ▁ ways ▁ to ▁ split ▁ is ▁ \" << splitstring ( s ) << endl ; }", "text_ms": "Kira cara untuk memecah rentetan binari ke dalam tiga substring yang mempunyai kiraan sifar yang sama | Program C ++ untuk pendekatan di atas; Berfungsi untuk mengira bilangan cara untuk berpecah; Mengira jumlah sifar; Kes1 jika jumlah kiraan sifar tidak boleh dibahagikan dengan 3; Case2 Jika jumlah kiraan sifar adalah sifar; Bilangan sifar dalam setiap substring; Memulakan sifar kepada bilangan cara untuk potongan pertama dan kedua; Memulakan kiraan; Melintasi dari awal; Meningkatkan kiraan jika elemen adalah '0'; Meningkatkan cara untuk pemotongan 1 jika kiraan adalah sama dengan sifar yang diperlukan dalam setiap substring; Meningkatkan cara untuk pemotongan 2 nd jika kiraan adalah sama dengan 2 * (sifar yang diperlukan dalam setiap substring); Jumlah cara untuk berpecah adalah pendaraban cara untuk potongan 1 dan 2; Kod pemacu; Panggilan fungsi"}
{"text": "Check if a string can be converted to another by swapping of adjacent characters of given type | C ++ program for the above approach ; Function to check if it is possible to transform start to end ; Check the sequence of A , B in both strings str1 and str2 ; If both the strings are not equal ; Traverse the strings ; Check for indexes of A and B ; Driver Code ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool canTransform ( string str1 , string str2 ) { string s1 = \" \" ; string s2 = \" \" ; for ( char c : str1 ) { if ( c != ' C ' ) { s1 += c ; } } for ( char c : str2 ) { if ( c != ' C ' ) { s2 += c ; } } if ( s1 != s2 ) return false ; int i = 0 ; int j = 0 ; int n = str1 . length ( ) ; while ( i < n and j < n ) { if ( str1 [ i ] == ' C ' ) { i ++ ; } else if ( str2 [ j ] == ' C ' ) { j ++ ; } else { if ( ( str1 [ i ] == ' A ' and i < j ) or ( str1 [ i ] == ' B ' and i > j ) ) { return false ; } i ++ ; j ++ ; } } return true ; } int main ( ) { string str1 = \" BCCABCBCA \" ; string str2 = \" CBACCBBAC \" ; if ( canTransform ( str1 , str2 ) ) { cout << \" Yes \" ; } else { cout << \" No \" ; } return 0 ; }", "text_ms": "Semak jika rentetan boleh ditukar kepada yang lain dengan menukar watak bersebelahan jenis yang diberikan | Program C ++ untuk pendekatan di atas; Berfungsi untuk memeriksa sama ada mungkin untuk mengubah mula berakhir; Semak urutan A, B dalam kedua -dua String Str1 dan Str2; Jika kedua -dua rentetan tidak sama; Melintasi rentetan; Semak indeks A dan B; Kod pemacu; Panggilan fungsi"}
{"text": "Longest Substring having equal count of Vowels and Consonants | C ++ Program to implement the above approach ; Function to return the length of the longest substring having equal number of vowel and consonant ; Generate the array ; Initialize variable to store result ; Stores the sum of subarray ; Map to store indices of the sum ; Loop through the array ; If sum is 0 ; Count of vowels and consonants are equal ; Update the maximum length of substring in HashMap ; Store the index of the sum ; Return the maximum length of required substring ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxsubstringLength ( string S , int N ) { int arr [ N ] ; for ( int i = 0 ; i < N ; i ++ ) if ( S [ i ] == ' a ' S [ i ] == ' e ' S [ i ] == ' i ' S [ i ] == ' o ' S [ i ] == ' u ' ) arr [ i ] = 1 ; else arr [ i ] = -1 ; int maxLen = 0 ; int curr_sum = 0 ; unordered_map < int , int > hash ; for ( int i = 0 ; i < N ; i ++ ) { curr_sum += arr [ i ] ; if ( curr_sum == 0 ) maxLen = max ( maxLen , i + 1 ) ; if ( hash . find ( curr_sum ) != hash . end ( ) ) maxLen = max ( maxLen , i - hash [ curr_sum ] ) ; else hash [ curr_sum ] = i ; } return maxLen ; } int main ( ) { string S = \" geeksforgeeks \" ; int n = sizeof ( S ) / sizeof ( S [ 0 ] ) ; cout << maxsubstringLength ( S , n ) ; return 0 ; }", "text_ms": "Substring terpanjang yang mempunyai kiraan vokal dan konsonan yang sama | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mengembalikan panjang substring terpanjang yang mempunyai bilangan vokal dan konsonan yang sama; Menjana array; Memulakan pembolehubah untuk menyimpan hasil; Menyimpan jumlah subarray; Peta untuk menyimpan indeks jumlah; Gelung melalui array; Jika jumlah adalah 0; Count vokal dan konsonan adalah sama; Mengemas kini panjang maksimum substring dalam hashmap; Simpan indeks jumlah; Mengembalikan panjang maksimum substring yang diperlukan; Kod pemacu"}
{"text": "Minimum Distance from a given Cell to all other Cells of a Matrix | C ++ Program to implement the above approach ; Stores the accessible directions ; Function to find the minimum distance from a given cell to all other cells in the matrix ; Stores the accessible cells from current cell ; Insert pair ( x , y ) ; Iterate untill queue is empty ; Extract the pair ; Pop them ; Checking boundary condition ; If the cell is not visited ; Assign the minimum distance ; Insert the traversed neighbour into the queue ; Driver Code ; Print the required distances", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int mat [ 1001 ] [ 1001 ] ; int r , c , x , y ; int dx [ ] = { 0 , -1 , -1 , -1 , 0 , 1 , 1 , 1 } ; int dy [ ] = { 1 , 1 , 0 , -1 , -1 , -1 , 0 , 1 } ; void FindMinimumDistance ( ) { queue < pair < int , int > > q ; q . push ( { x , y } ) ; mat [ x ] [ y ] = 0 ; while ( ! q . empty ( ) ) { x = q . front ( ) . first ; y = q . front ( ) . second ; q . pop ( ) ; for ( int i = 0 ; i < 8 ; i ++ ) { int a = x + dx [ i ] ; int b = y + dy [ i ] ; if ( a < 0 a > = r b >= c b < 0 ) continue ; if ( mat [ a ] [ b ] == 0 ) { mat [ a ] [ b ] = mat [ x ] [ y ] + 1 ; q . push ( { a , b } ) ; } } } } int main ( ) { r = 5 , c = 5 , x = 1 , y = 1 ; int t = x ; int l = y ; mat [ x ] [ y ] = 0 ; FindMinimumDistance ( ) ; mat [ t ] [ l ] = 0 ; for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { cout << mat [ i ] [ j ] << \" ▁ \" ; } cout << endl ; } }", "text_ms": "Jarak minimum dari sel tertentu ke semua sel lain dari matriks | Program C ++ untuk melaksanakan pendekatan di atas; Menyimpan arahan yang boleh diakses; Fungsi untuk mencari jarak minimum dari sel tertentu ke semua sel lain dalam matriks; Menyimpan sel -sel yang boleh diakses dari sel semasa; Masukkan pasangan (x, y); Melangkah ke barisan adalah kosong; Ekstrak pasangan; Pop mereka; Memeriksa keadaan sempadan; Jika sel tidak dikunjungi; Menetapkan jarak minimum; Masukkan jiran yang dilalui ke dalam barisan; Kod pemacu; Cetak jarak yang diperlukan"}
{"text": "Minimum flips required to convert given string into concatenation of equal substrings of length K | C ++ Program to implement the above approach ; Function that returns the minimum number of flips to convert the s into a concatenation of K - length sub - string ; Stores the result ; Iterate through string index ; Stores count of 0 s & 1 s ; Iterate making K jumps ; Count 0 's ; Count 1 's ; Add minimum flips for index i ; Return minimum number of flips ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( string S , int K ) { int ans = 0 ; for ( int i = 0 ; i < K ; i ++ ) { int zero = 0 , one = 0 ; for ( int j = i ; j < S . size ( ) ; j += K ) { if ( S [ j ] == '0' ) zero ++ ; else one ++ ; } ans += min ( zero , one ) ; } return ans ; } int main ( ) { string S = \"110100101\" ; int K = 3 ; cout << minOperations ( S , K ) ; return 0 ; }", "text_ms": "Kelebihan minimum yang diperlukan untuk menukar rentetan yang diberikan menjadi penyambungan substrings yang sama panjang k | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi yang mengembalikan bilangan minimum flip untuk menukar s ke dalam penyambungan sub -panjang sub -rentetan; Menyimpan hasilnya; Melangkah melalui indeks rentetan; Kedai kiraan 0 S & 1 S; ITERATE MEMBUAT K JUMPS; Kiraan 0 's; Kiraan 1 's; Tambah flip minimum untuk Indeks I; Mengembalikan bilangan minimum; Kod pemacu"}
{"text": "Find the missing number in unordered Arithmetic Progression | C ++ program for the above approach ; Function to get the missing element ; For maximum Element in the array ; For minimum Element in the array ; For xor of all elements ; Common difference of AP series ; find maximum and minimum element ; Calculating common difference ; Calculate the XOR of all elements ; Perform XOR with actual AP series resultant x will be the ans ; Return the missing element ; Driver Code ; Given array ; Function Call ; Print the missing element", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int missingElement ( int arr [ ] , int n ) { int max_ele = arr [ 0 ] ; int min_ele = arr [ 0 ] ; int x = 0 ; int d ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; if ( arr [ i ] < min_ele ) min_ele = arr [ i ] ; } d = ( max_ele - min_ele ) / n ; for ( int i = 0 ; i < n ; i ++ ) { x = x ^ arr [ i ] ; } for ( int i = 0 ; i <= n ; i ++ ) { x = x ^ ( min_ele + ( i * d ) ) ; } return x ; } int main ( ) { int arr [ ] = { 12 , 3 , 6 , 15 , 18 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int element = missingElement ( arr , n ) ; cout << element ; }", "text_ms": "Cari nombor yang hilang dalam perkembangan aritmetik yang tidak teratur | Program C ++ untuk pendekatan di atas; Berfungsi untuk mendapatkan elemen yang hilang; Untuk elemen maksimum dalam array; Untuk elemen minimum dalam array; Untuk XOR semua elemen; Perbezaan umum siri AP; Cari elemen maksimum dan minimum; Mengira perbezaan biasa; Kirakan XOR semua elemen; Lakukan XOR dengan siri AP sebenar yang dihasilkan X akan menjadi ANS; Mengembalikan elemen yang hilang; Kod pemacu; Diberikan array; Panggilan fungsi; Cetak elemen yang hilang"}
{"text": "Given a string and an integer k , find the kth sub | C ++ implementation of the approach ; Function to prints kth sub - string ; Total sub - strings possible ; If k is greater than total number of sub - strings ; To store number of sub - strings starting with ith character of the string ; Compute the values ; substring [ i - 1 ] is added to store the cumulative sum ; Binary search to find the starting index of the kth sub - string ; To store the ending index of the kth sub - string ; Print the sub - string ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void Printksubstring ( string str , int n , int k ) { int total = ( n * ( n + 1 ) ) / 2 ; if ( k > total ) { printf ( \" - 1 STRNEWLINE \" ) ; return ; } int substring [ n + 1 ] ; substring [ 0 ] = 0 ; int temp = n ; for ( int i = 1 ; i <= n ; i ++ ) { substring [ i ] = substring [ i - 1 ] + temp ; temp -- ; } int l = 1 ; int h = n ; int start = 0 ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( substring [ m ] > k ) { start = m ; h = m - 1 ; } else if ( substring [ m ] < k ) l = m + 1 ; else { start = m ; break ; } } int end = n - ( substring [ start ] - k ) ; for ( int i = start - 1 ; i < end ; i ++ ) cout << str [ i ] ; } int main ( ) { string str = \" abc \" ; int k = 4 ; int n = str . length ( ) ; Printksubstring ( str , n , k ) ; return 0 ; }", "text_ms": "Memandangkan rentetan dan integer k, cari sub sub | C ++ pelaksanaan pendekatan; Berfungsi untuk mencetak sub -sub - string; Jumlah sub - rentetan mungkin; Jika k lebih besar daripada jumlah sub -rentetan; Untuk menyimpan nombor sub -rentetan bermula dengan watak rentetan; Mengira nilai -nilai; Substring [i - 1] ditambah untuk menyimpan jumlah kumulatif; Carian binari untuk mencari indeks permulaan sub -rentetan KTH; Untuk menyimpan indeks akhir sub -rentetan KTH; Cetak sub -rentetan; Kod pemacu"}
{"text": "Lower Insertion Point | C ++ program to find the lower insertion point of an element in a sorted array ; Function to return the lower insertion point of an element in a sorted array ; Base cases ; Final check for the remaining elements which are < X ; Driver code", "code": "#include <iostream> NEW_LINE using namespace std ; int LowerInsertionPoint ( int arr [ ] , int n , int X ) { if ( X < arr [ 0 ] ) return 0 ; else if ( X > arr [ n - 1 ] ) return n ; int lowerPnt = 0 ; int i = 1 ; while ( i < n && arr [ i ] < X ) { lowerPnt = i ; i = i * 2 ; } while ( lowerPnt < n && arr [ lowerPnt ] < X ) lowerPnt ++ ; return lowerPnt ; } int main ( ) { int arr [ ] = { 2 , 3 , 4 , 4 , 5 , 6 , 7 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int X = 4 ; cout << LowerInsertionPoint ( arr , n , X ) ; return 0 ; }", "text_ms": "Titik penyisipan yang lebih rendah | Program C ++ untuk mencari titik penyisipan yang lebih rendah dari elemen dalam array yang disusun; Berfungsi untuk mengembalikan titik penyisipan yang lebih rendah dari elemen dalam array yang disusun; Kes asas; Pemeriksaan akhir untuk unsur -unsur yang tersisa yang <x; Kod pemacu"}
{"text": "Number of positions with Same address in row major and column major order | CPP Program to count the number of positions with same address in row major and column major order ; Returns count of required positions ; horizontal 1D array ; vertical 1D array ; iterating for all possible i ; checking if j is integer ; checking if j lies b / w 1 to N ; iterating for all possible j ; checking if i is integer ; checking if i lies b / w 1 to M ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int getCount ( int M , int N ) { int count = 0 ; if ( M == 1 ) return N ; if ( N == 1 ) return M ; if ( N > M ) { for ( int i = 1 ; i <= M ; i ++ ) { int numerator = N * i - N + M - i ; int denominator = M - 1 ; if ( numerator % denominator == 0 ) { int j = numerator / denominator ; if ( j >= 1 && j <= N ) count ++ ; } } } else { for ( int j = 1 ; j <= N ; j ++ ) { int numerator = M * j - M + N - j ; int denominator = N - 1 ; if ( numerator % denominator == 0 ) { int i = numerator / denominator ; if ( i >= 1 && i <= M ) count ++ ; } } } return count ; } int main ( ) { int M = 3 , N = 5 ; cout << getCount ( M , N ) << endl ; return 0 ; }", "text_ms": "Bilangan jawatan dengan alamat yang sama dalam baris utama dan lajur utama urutan | Program CPP untuk mengira bilangan kedudukan dengan alamat yang sama dalam perintah utama utama dan lajur; Mengembalikan kiraan kedudukan yang diperlukan; array 1D mendatar; array 1D menegak; melangkah untuk semua yang mungkin saya; Memeriksa jika J adalah integer; Memeriksa jika J terletak b / w 1 hingga n; melangkah untuk semua kemungkinan j; Memeriksa jika saya adalah integer; Memeriksa jika saya terletak b / w 1 hingga m; Kod pemacu"}
{"text": "Maximum in an array that can make another array sorted | C ++ program to make array sorted ; Function to check whether there is any swappable element present to make the first array sorted ; wrongIdx is the index of the element which is making the first array unsorted ; Find the maximum element which satisfies the the above mentioned neighboring conditions ; if res is true then swap the element and make the first array sorted ; Function to print the sorted array if elements are swapped . ; Drivers code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool swapElement ( int arr1 [ ] , int arr2 [ ] , int n ) { int wrongIdx = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr1 [ i ] < arr1 [ i - 1 ] ) wrongIdx = i ; int maximum = INT_MIN ; int maxIdx = -1 ; bool res = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr2 [ i ] > maximum && arr2 [ i ] >= arr1 [ wrongIdx - 1 ] ) { if ( wrongIdx + 1 <= n - 1 && arr2 [ i ] <= arr1 [ wrongIdx + 1 ] ) { maximum = arr2 [ i ] ; maxIdx = i ; res = true ; } } } if ( res ) swap ( arr1 [ wrongIdx ] , arr2 [ maxIdx ] ) ; return res ; } void getSortedArray ( int arr1 [ ] , int arr2 [ ] , int n ) { if ( swapElement ( arr1 , arr2 , n ) ) for ( int i = 0 ; i < n ; i ++ ) cout << arr1 [ i ] << \" ▁ \" ; else cout << \" Not ▁ Possible \" << endl ; } int main ( ) { int arr1 [ ] = { 1 , 3 , 7 , 4 , 10 } ; int arr2 [ ] = { 2 , 1 , 6 , 8 , 9 } ; int n = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; getSortedArray ( arr1 , arr2 , n ) ; }", "text_ms": "Maksimum dalam pelbagai yang boleh membuat array lain disusun | Program C ++ untuk membuat array disusun; Fungsi untuk memeriksa sama ada terdapat unsur swappable yang hadir untuk membuat array pertama disusun; WrongIdx adalah indeks elemen yang membuat array pertama tidak disusun; Cari elemen maksimum yang memenuhi syarat -syarat jiran yang disebutkan di atas; Jika res adalah benar maka swap elemen dan buat array pertama disusun; Fungsi untuk mencetak array yang disusun jika elemen ditukar. ; Kod pemandu"}
{"text": "Middle of three using minimum comparisons | CPP program to find middle of three distinct numbers ; Function to find the middle of three numbers ; Compare each three number to find middle number . Enter only if a > b ; Decided a is not greater than b . ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int middleOfThree ( int a , int b , int c ) { if ( a > b ) { if ( b > c ) return b ; else if ( a > c ) return c ; else return a ; } else { if ( a > c ) return a ; else if ( b > c ) return c ; else return b ; } } int main ( ) { int a = 20 , b = 30 , c = 40 ; cout << middleOfThree ( a , b , c ) ; return 0 ; }", "text_ms": "Pertengahan tiga menggunakan perbandingan minimum | Program CPP untuk mencari pertengahan tiga nombor yang berbeza; Berfungsi untuk mencari pertengahan tiga nombor; Bandingkan setiap tiga nombor untuk mencari nombor tengah. Masukkan hanya jika A> B; Memutuskan A tidak lebih besar daripada b. ; Kod pemacu"}
{"text": "Sort the matrix column | C ++ program for the above approach ; Function to find the transpose of the matrix mat [ ] ; Stores the transpose of matrix mat [ ] [ ] ; Traverse each row of the matrix ; Traverse each column of the matrix ; Transpose matrix elements ; Function to sort the given matrix in row wise manner ; Traverse the row ; Row - Wise Sorting ; Function to print the matrix in column wise sorted manner ; Function call to find transpose of the the matrix mat [ ] [ ] ; Sorting the matrix row - wise ; Calculate transpose of B [ ] [ ] ; Print the matrix mat [ ] [ ] ; Driver Code ; Input ; Function call to print the matrix in column wise sorted manner", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < vector < int > > transpose ( vector < vector < int > > mat , int row , int col ) { vector < vector < int > > tr ( col , vector < int > ( row ) ) ; for ( int i = 0 ; i < row ; i ++ ) { for ( int j = 0 ; j < col ; j ++ ) { tr [ j ] [ i ] = mat [ i ] [ j ] ; } } return tr ; } void RowWiseSort ( vector < vector < int > > & B ) { for ( int i = 0 ; i < ( int ) B . size ( ) ; i ++ ) { sort ( B [ i ] . begin ( ) , B [ i ] . end ( ) ) ; } } void sortCol ( vector < vector < int > > mat , int N , int M ) { vector < vector < int > > B = transpose ( mat , N , M ) ; RowWiseSort ( B ) ; mat = transpose ( B , M , N ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { cout << mat [ i ] [ j ] << \" ▁ \" ; } cout << ' ' ; } } int main ( ) { vector < vector < int > > mat = { { 1 , 6 , 10 } , { 8 , 5 , 9 } , { 9 , 4 , 15 } , { 7 , 3 , 60 } } ; int N = mat . size ( ) ; int M = mat [ 0 ] . size ( ) ; sortCol ( mat , N , M ) ; return 0 ; }", "text_ms": "Susun Lajur Matriks | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari transpose matriks mat []; Menyimpan transpose matriks mat [] []; Melintasi setiap baris matriks; Melintasi setiap lajur matriks; Elemen matriks transpose; Berfungsi untuk menyusun matriks yang diberikan dengan cara yang bijak; Melintasi baris; Baris - penyortiran bijak; Berfungsi untuk mencetak matriks dalam lajur yang disusun dengan bijak; Fungsi panggilan untuk mencari transpose matriks mat [] []; Menyusun baris matriks - bijak; Kirakan transpose b [] []; Cetak matriks mat [] []; Kod pemacu; Input; Fungsi panggilan untuk mencetak matriks dalam lajur yang disusun dengan bijak"}
{"text": "Largest area possible after removal of a series of horizontal & vertical bars | C ++ program for the above approach ; Function to find the largest area when a series of horizontal & vertical bars are removed ; Stores all bars ; Insert horizontal bars ; Insert vertictal bars ; Remove horizontal separators from s1 ; Remove vertical separators from s2 ; Stores left out horizontal and vertical separators ; Sort both list in ascending order ; Find maximum difference of neighbors of list1 ; Find max difference of neighbors of list2 ; Print largest volume ; Driver code ; Given value of N & M ; Given arrays ; Function call to find the largest area when a series of horizontal & vertical bars are removed", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void largestArea ( int N , int M , int H [ ] , int V [ ] , int h , int v ) { set < int > s1 ; set < int > s2 ; for ( int i = 1 ; i <= N + 1 ; i ++ ) s1 . insert ( i ) ; for ( int i = 1 ; i <= M + 1 ; i ++ ) s2 . insert ( i ) ; for ( int i = 0 ; i < h ; i ++ ) { s1 . erase ( H [ i ] ) ; } for ( int i = 0 ; i < v ; i ++ ) { s2 . erase ( V [ i ] ) ; } int list1 [ s1 . size ( ) ] ; int list2 [ s2 . size ( ) ] ; int i = 0 ; for ( auto it1 = s1 . begin ( ) ; it1 != s1 . end ( ) ; it1 ++ ) { list1 [ i ++ ] = * it1 ; } i = 0 ; for ( auto it2 = s2 . begin ( ) ; it2 != s2 . end ( ) ; it2 ++ ) { list2 [ i ++ ] = * it2 ; } sort ( list1 , list1 + s1 . size ( ) ) ; sort ( list2 , list2 + s2 . size ( ) ) ; int maxH = 0 , p1 = 0 , maxV = 0 , p2 = 0 ; for ( int j = 0 ; j < s1 . size ( ) ; j ++ ) { maxH = max ( maxH , list1 [ j ] - p1 ) ; p1 = list1 [ j ] ; } for ( int j = 0 ; j < s2 . size ( ) ; j ++ ) { maxV = max ( maxV , list2 [ j ] - p2 ) ; p2 = list2 [ j ] ; } cout << ( maxV * maxH ) << endl ; } int main ( ) { int N = 3 , M = 3 ; int H [ ] = { 2 } ; int V [ ] = { 2 } ; int h = sizeof ( H ) / sizeof ( H [ 0 ] ) ; int v = sizeof ( V ) / sizeof ( V [ 0 ] ) ; largestArea ( N , M , H , V , h , v ) ; return 0 ; }", "text_ms": "Kawasan terbesar mungkin selepas penyingkiran siri bar mendatar & menegak | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari kawasan terbesar apabila satu siri bar mendatar & menegak dikeluarkan; Menyimpan semua bar; Masukkan bar mendatar; Masukkan bar verttik; Keluarkan pemisah mendatar dari S1; Keluarkan pemisah menegak dari S2; Kedai -kedai yang ditinggalkan pemisah mendatar dan menegak; Menyusun kedua -dua senarai dalam urutan menaik; Cari perbezaan maksimum jiran List1; Cari perbezaan maksimum jiran List2; Cetak kelantangan terbesar; Kod pemacu; Diberi nilai N & M; Diberikan susunan; Fungsi panggilan untuk mencari kawasan terbesar apabila satu siri bar mendatar & menegak dikeluarkan"}
{"text": "Check if an array can be sorted by swapping pairs from indices consisting of unequal elements in another array | C ++ Program for above approach ; Function to check if array , A [ ] can be converted into sorted array by swapping ( A [ i ] , A [ j ] ) if B [ i ] not equal to B [ j ] ; Stores if array A [ ] is sorted in descending order or not ; Traverse the array A [ ] ; If A [ i ] is greater than A [ i + 1 ] ; Update flag ; If array is sorted in ascending order ; count = 2 : Check if 0 s and 1 s both present in the B [ ] ; Traverse the array ; If current element is 0 ; Update count ; Traverse the array B [ ] ; If current element is 1 ; If both 0 s and 1 s are present in the array ; Driver Code ; Input array A [ ] ; Input array B [ ] ; Function call ; If true , print YES ; Else print NO", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkifSorted ( int A [ ] , int B [ ] , int N ) { bool flag = false ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { flag = true ; break ; } } if ( ! flag ) { return true ; } int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( B [ i ] == 0 ) { count ++ ; break ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( B [ i ] == 1 ) { count ++ ; break ; } } if ( count == 2 ) { return true ; } return false ; } int main ( ) { int A [ ] = { 3 , 1 , 2 } ; int B [ ] = { 0 , 1 , 1 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; bool check = checkifSorted ( A , B , N ) ; if ( check ) { cout << \" YES \" << endl ; } else { cout << \" NO \" << endl ; } return 0 ; }", "text_ms": "Semak jika array boleh disusun dengan menukar pasangan dari indeks yang terdiri daripada unsur -unsur yang tidak sama rata dalam array lain | Program C ++ untuk pendekatan di atas; Fungsi untuk memeriksa sama ada array, [] boleh ditukar menjadi array yang disusun dengan bertukar (a [i], a [j]) jika b [i] tidak sama dengan b [j]; Kedai jika array A [] disusun dalam urutan menurun atau tidak; Melintasi array a []; Jika [i] lebih besar daripada [i + 1]; Bendera kemas kini; Jika array disusun mengikut urutan menaik; kiraan = 2: periksa jika 0 s dan 1 s kedua -duanya hadir dalam b []; Melintasi array; Jika elemen semasa ialah 0; Kiraan kemas kini; Melintasi array b []; Jika elemen semasa ialah 1; Jika kedua -dua 0 s dan 1 s hadir dalam array; Kod pemacu; Array input a []; Arahan input B []; Panggilan fungsi; Jika benar, cetak ya; Lain cetak no"}
{"text": "Minimum swaps required between two strings to make one string strictly greater than the other | C ++ program for the above approach ; Function to find the minimum number of steps to make A > B ; If all character are same and M <= N ; If there lies any character in B which is greater than B [ 0 ] ; If there lies any character in A which is smaller than A [ 0 ] ; If there lies a character which is in A and greater than A [ 0 ] ; If there lies a character which is in B and less than B [ 0 ] ; Otherwise ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minSteps ( string A , string B , int M , int N ) { if ( A [ 0 ] > B [ 0 ] ) return 0 ; if ( B [ 0 ] > A [ 0 ] ) { return 1 ; } if ( M <= N && A [ 0 ] == B [ 0 ] && count ( A . begin ( ) , A . end ( ) , A [ 0 ] ) == M && count ( B . begin ( ) , B . end ( ) , B [ 0 ] ) == N ) return -1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( B [ i ] > B [ 0 ] ) return 1 ; } for ( int i = 1 ; i < M ; i ++ ) { if ( A [ i ] < A [ 0 ] ) return 1 ; } for ( int i = 1 ; i < M ; i ++ ) { if ( A [ i ] > A [ 0 ] ) { swap ( A [ i ] , B [ 0 ] ) ; swap ( A [ 0 ] , B [ 0 ] ) ; return 2 ; } } for ( int i = 1 ; i < N ; i ++ ) { if ( B [ i ] < B [ 0 ] ) { swap ( A [ 0 ] , B [ i ] ) ; swap ( A [ 0 ] , B [ 0 ] ) ; return 2 ; } } return 0 ; } int main ( ) { string A = \" adsfd \" ; string B = \" dffff \" ; int M = A . length ( ) ; int N = B . length ( ) ; cout << minSteps ( A , B , M , N ) ; return 0 ; }", "text_ms": "Swap minimum diperlukan di antara dua rentetan untuk membuat satu rentetan ketat lebih besar daripada yang lain | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari bilangan langkah minimum untuk membuat A> B; Jika semua watak adalah sama dan m <= n; Sekiranya terdapat sebarang watak dalam B yang lebih besar daripada B [0]; Jika terdapat apa -apa watak yang lebih kecil daripada [0]; Sekiranya terdapat watak yang berada di dalam dan lebih besar daripada [0]; Sekiranya terdapat watak yang berada di B dan kurang daripada B [0]; Jika tidak; Kod pemacu"}
{"text": "Count minimum number of moves to front or end to sort an array | C ++ algorithm of above approach ; Driver Code ; Function to find minimum number of operation required so that array becomes meaningful ; Initializing vector of pair type which contains value and index of arr ; Sorting array num on the basis of value ; Initializing variables used to find maximum length of increasing streak in index ; Updating streak ; Returning number of elements left except streak", "code": "#include <bits/stdc++.h> NEW_LINE #include <vector> NEW_LINE using namespace std ; int main ( ) { int arr [ ] = { 4 , 7 , 2 , 3 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int count = minOperations ( arr , n ) ; cout << count ; } int minOperations ( int arr [ ] , int n ) { vector < pair < int , int > > vect ; for ( int i = 0 ; i < n ; i ++ ) { vect . push_back ( make_pair ( arr [ i ] , i ) ) ; } sort ( vect . begin ( ) , vect . end ( ) ) ; int res = 1 ; int streak = 1 ; int prev = vect [ 0 ] . second ; for ( int i = 1 ; i < n ; i ++ ) { if ( prev < vect [ i ] . second ) { res ++ ; streak = max ( streak , res ) ; } else res = 1 ; prev = vect [ i ] . second ; } return n - streak ; }", "text_ms": "Kira bilangan minimum bergerak ke depan atau akhir untuk menyusun array | C ++ algoritma pendekatan di atas; Kod pemacu; Berfungsi untuk mencari bilangan minimum operasi yang diperlukan supaya array menjadi bermakna; Memulakan vektor jenis pasangan yang mengandungi nilai dan indeks ARR; Menyusun array num atas dasar nilai; Memulakan pembolehubah yang digunakan untuk mencari panjang maksimum yang semakin meningkat dalam indeks; Mengemas kini coretan; Mengembalikan bilangan elemen yang tersisa kecuali coretan"}
{"text": "Maximize sum of pairwise products generated from the given Arrays | C ++ Program to implement the above approach ; Variables which represent the size of the array ; Stores the results ; Function to return the maximum possible sum ; Stores the count of arrays processed ; If more than two arrays have been processed ; If an already computed subproblem occurred ; Explore all the possible pairs ; Recursive function call ; Memoize the maximum ; Returning the value ; Function to return the maximum sum of products of pairs possible ; Initialising the dp array to - 1 ; Sort the arrays in descending order ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define maxN  201 NEW_LINE int n1 , n2 , n3 ; int dp [ maxN ] [ maxN ] [ maxN ] ; int getMaxSum ( int i , int j , int k , int arr1 [ ] , int arr2 [ ] , int arr3 [ ] ) { int cnt = 0 ; if ( i >= n1 ) cnt ++ ; if ( j >= n2 ) cnt ++ ; if ( k >= n3 ) cnt ++ ; if ( cnt >= 2 ) return 0 ; if ( dp [ i ] [ j ] [ k ] != -1 ) return dp [ i ] [ j ] [ k ] ; int ans = 0 ; if ( i < n1 && j < n2 ) ans = max ( ans , getMaxSum ( i + 1 , j + 1 , k , arr1 , arr2 , arr3 ) + arr1 [ i ] * arr2 [ j ] ) ; if ( i < n1 && k < n3 ) ans = max ( ans , getMaxSum ( i + 1 , j , k + 1 , arr1 , arr2 , arr3 ) + arr1 [ i ] * arr3 [ k ] ) ; if ( j < n2 && k < n3 ) ans = max ( ans , getMaxSum ( i , j + 1 , k + 1 , arr1 , arr2 , arr3 ) + arr2 [ j ] * arr3 [ k ] ) ; dp [ i ] [ j ] [ k ] = ans ; return dp [ i ] [ j ] [ k ] ; } int maxProductSum ( int arr1 [ ] , int arr2 [ ] , int arr3 [ ] ) { memset ( dp , -1 , sizeof ( dp ) ) ; sort ( arr1 , arr1 + n1 ) ; reverse ( arr1 , arr1 + n1 ) ; sort ( arr2 , arr2 + n2 ) ; reverse ( arr2 , arr2 + n2 ) ; sort ( arr3 , arr3 + n3 ) ; reverse ( arr3 , arr3 + n3 ) ; return getMaxSum ( 0 , 0 , 0 , arr1 , arr2 , arr3 ) ; } int main ( ) { n1 = 2 ; int arr1 [ ] = { 3 , 5 } ; n2 = 2 ; int arr2 [ ] = { 2 , 1 } ; n3 = 3 ; int arr3 [ ] = { 4 , 3 , 5 } ; cout << maxProductSum ( arr1 , arr2 , arr3 ) ; return 0 ; }", "text_ms": "Memaksimumkan jumlah produk berpasangan yang dihasilkan dari tatasusunan yang diberikan | Program C ++ untuk melaksanakan pendekatan di atas; Pembolehubah yang mewakili saiz array; Menyimpan hasilnya; Berfungsi untuk mengembalikan jumlah maksimum yang mungkin; Menyimpan kiraan susunan yang diproses; Jika lebih daripada dua tatasusunan telah diproses; Sekiranya subproblem yang telah dikira telah berlaku; Terokai semua pasangan yang mungkin; Panggilan fungsi rekursif; Memoize maksimum; Mengembalikan nilai; Berfungsi untuk mengembalikan jumlah maksimum produk pasangan yang mungkin; Memulakan array DP ke - 1; Menyusun tatasusunan dalam urutan menurun; Kod pemacu"}
{"text": "Largest lexicographic triplet from a given Array that forms a triangle | C ++ Program to implement the the above approach ; Function to find lexicographically largest triplet that forms a triangle in the given array ; Sort the array ; Iterate from the end of the array ; If the triplet forms a triangle ; If triplet found ; Print the triplet ; Otherwise ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findTriplet ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; int flag = 0 , i ; for ( i = N - 1 ; i - 2 >= 0 ; i -- ) { if ( arr [ i - 2 ] + arr [ i - 1 ] > arr [ i ] ) { flag = 1 ; break ; } } if ( flag ) { cout << arr [ i - 2 ] << \" ▁ \" << arr [ i - 1 ] << \" ▁ \" << arr [ i ] << endl ; } else { cout << -1 << endl ; } } int main ( ) { int arr [ ] = { 4 , 2 , 10 , 3 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findTriplet ( arr , N ) ; return 0 ; }", "text_ms": "Triplet leksikografi terbesar dari array yang diberikan yang membentuk segitiga | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mencari triplet terbesar secara leksikografi yang membentuk segitiga dalam array yang diberikan; Susun array; Berulang dari akhir array; Jika triplet membentuk segitiga; Jika triplet dijumpai; Cetak triplet; Jika tidak; Kod pemacu"}
{"text": "Count of all pairs in an Array with minimum absolute difference | C ++ program for the above approach ; Function to return the count of all pairs having minimal absolute difference ; Stores the count of pairs ; Sort the array ; Stores the minimum difference between adjacent pairs ; Update the minimum difference between pairs ; Increase count of pairs with difference equal to that of minimum difference ; Return the final count ; Driver Code ; Given array arr [ ] ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberofpairs ( int arr [ ] , int N ) { int answer = 0 ; sort ( arr , arr + N ) ; int minDiff = INT_MAX ; for ( int i = 0 ; i < N - 1 ; i ++ ) minDiff = min ( minDiff , arr [ i + 1 ] - arr [ i ] ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i + 1 ] - arr [ i ] == minDiff ) answer ++ ; } return answer ; } int main ( ) { int arr [ ] = { 4 , 2 , 1 , 3 } ; int N = ( sizeof arr ) / ( sizeof arr [ 0 ] ) ; cout << numberofpairs ( arr , N ) << \" STRNEWLINE \" ; return 0 ; }", "text_ms": "Kira semua pasangan dalam array dengan perbezaan mutlak minimum | Program C ++ untuk pendekatan di atas; Berfungsi untuk mengembalikan kiraan semua pasangan yang mempunyai perbezaan mutlak yang minimum; Menyimpan kiraan pasangan; Susun array; Menyimpan perbezaan minimum antara pasangan bersebelahan; Mengemas kini perbezaan minimum antara pasangan; Meningkatkan kiraan pasangan dengan perbezaan yang sama dengan perbezaan minimum; Mengembalikan kiraan akhir; Kod pemacu; Diberikan array arr []; Panggilan fungsi"}
{"text": "Maximum size subset with given sum using Backtracking | C ++ Program to implement the above approach ; Initialise maximum possible length of subsequence ; Store elements to compare max_length with its size and change the value of max_length accordingly ; Store the elements of the longest subsequence ; Function to find the length of longest subsequence ; Update max_length ; Store the subsequence elements ; Recursively proceed with obtained sum ; poping elements from back of vector store ; if sum > 0 then we don 't  required thatsubsequence  so return and continue  with earlier elements ; Sort the given array ; Traverse the array ; If max_length is already greater than or equal than remaining length ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int max_length = 0 ; vector < int > store ; vector < int > ans ; void find_max_length ( vector < int > & arr , int index , int sum , int k ) { sum = sum + arr [ index ] ; store . push_back ( arr [ index ] ) ; if ( sum == k ) { if ( max_length < store . size ( ) ) { max_length = store . size ( ) ; ans = store ; } } for ( int i = index + 1 ; i < arr . size ( ) ; i ++ ) { if ( sum + arr [ i ] <= k ) { find_max_length ( arr , i , sum , k ) ; store . pop_back ( ) ; } else return ; } return ; } int longestSubsequence ( vector < int > arr , int n , int k ) { sort ( arr . begin ( ) , arr . end ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( max_length >= n - i ) break ; store . clear ( ) ; find_max_length ( arr , i , 0 , k ) ; } return max_length ; } int main ( ) { vector < int > arr { -3 , 0 , 1 , 1 , 2 } ; int n = arr . size ( ) ; int k = 1 ; cout << longestSubsequence ( arr , n , k ) ; return 0 ; }", "text_ms": "Subset saiz maksimum dengan jumlah yang diberikan menggunakan backtracking | Program C ++ untuk melaksanakan pendekatan di atas; Permulaan maksimum kemungkinan panjang berikutnya; Simpan elemen untuk membandingkan max_length dengan saiznya dan tukar nilai max_length dengan sewajarnya; Simpan unsur -unsur yang paling lama; Berfungsi untuk mencari panjang berikutnya terpanjang; Kemas kini max_length; Simpan unsur -unsur berikutnya; Secara rekursif meneruskan dengan jumlah yang diperoleh; unsur -unsur yang muncul dari belakang kedai vektor; jika jumlah> 0 maka kita tidak memerlukannya sehingga kembali dan teruskan dengan unsur -unsur terdahulu; Susun array yang diberikan; Melintasi array; Jika max_length sudah lebih besar daripada atau sama daripada panjang yang tinggal; Kod pemacu"}
{"text": "Sort decreasing permutation of N using triple swaps | C ++ implementation to sort decreasing permutation of N using triple swaps ; Function to sort Array ; The three indices that has to be chosen ; Check if possible to sort array ; Swapping to bring element at required position Bringing at least one element at correct position ; Tracing changes in Array ; Print the sorted array ; If not possible to sort ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void sortArray ( int A [ ] , int N ) { int x , y , z ; if ( N % 4 == 0 N % 4 == 1 ) { for ( int i = 0 ; i < N / 2 ; i ++ ) { x = i ; if ( i % 2 == 0 ) { y = N - i - 2 ; z = N - i - 1 ; } A [ z ] = A [ y ] ; A [ y ] = A [ x ] ; A [ x ] = x + 1 ; } cout << \" Sorted ▁ Array : ▁ \" ; for ( int i = 0 ; i < N ; i ++ ) cout << A [ i ] << \" ▁ \" ; } else cout << \" - 1\" ; } int main ( ) { int A [ ] = { 5 , 4 , 3 , 2 , 1 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; sortArray ( A , N ) ; return 0 ; }", "text_ms": "Susun Pengurangan Permutasi N Menggunakan Swap Triple | C ++ pelaksanaan untuk menyusun pengurangan permutasi N menggunakan swap tiga; Fungsi untuk menyusun array; Tiga indeks yang perlu dipilih; Semak jika boleh menyusun array; Bertukar untuk membawa elemen pada kedudukan yang diperlukan membawa sekurang -kurangnya satu elemen pada kedudukan yang betul; Mengesan perubahan dalam array; Cetak array yang disusun; Jika tidak mungkin untuk menyusun; Kod pemacu"}
{"text": "Find K such that changing all elements of the Array greater than K to K will make array sum N | C ++ implementation of the approach ; Function to return K such that changing all elements greater than K to K will make array sum N otherwise return - 1 ; Sorting the array in increasing order ; Loop through all the elements of the array ; Checking if sum of array equals N ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findK ( int arr [ ] , int size , int N ) { sort ( arr , arr + size ) ; int temp_sum = 0 ; for ( int i = 0 ; i < size ; i ++ ) { temp_sum += arr [ i ] ; if ( N - temp_sum == arr [ i ] * ( size - i - 1 ) ) { return arr [ i ] ; } } return -1 ; } int main ( ) { int arr [ ] = { 3 , 1 , 10 , 4 , 8 } ; int size = sizeof ( arr ) / sizeof ( int ) ; int N = 16 ; cout << findK ( arr , size , N ) ; return 0 ; }", "text_ms": "Cari k sedemikian rupa sehingga mengubah semua elemen array yang lebih besar daripada k ke k akan membuat jumlah array n | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan k sedemikian rupa sehingga mengubah semua elemen yang lebih besar daripada k ke k akan membuat jumlah array n sebaliknya kembali - 1; Menyusun array dalam peningkatan urutan; Gelung melalui semua elemen array; Memeriksa jika jumlah array sama dengan n; Kod pemacu"}
{"text": "Find three element from given three arrays such that their sum is X | Set 2 | C ++ implementation of the approach ; Function that returns true if there exists a triplet with sum x ; Sorting arrays such that a [ ] represents smallest array ; Iterating the smallest array ; Two pointers on second and third array ; If a valid triplet is found ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool existsTriplet ( int a [ ] , int b [ ] , int c [ ] , int x , int l1 , int l2 , int l3 ) { if ( l2 <= l1 and l2 <= l3 ) swap ( l2 , l1 ) , swap ( a , b ) ; else if ( l3 <= l1 and l3 <= l2 ) swap ( l3 , l1 ) , swap ( a , c ) ; for ( int i = 0 ; i < l1 ; i ++ ) { int j = 0 , k = l3 - 1 ; while ( j < l2 and k > = 0 ) { if ( a [ i ] + b [ j ] + c [ k ] == x ) return true ; if ( a [ i ] + b [ j ] + c [ k ] < x ) j ++ ; else k -- ; } } return false ; } int main ( ) { int a [ ] = { 2 , 7 , 8 , 10 , 15 } ; int b [ ] = { 1 , 6 , 7 , 8 } ; int c [ ] = { 4 , 5 , 5 } ; int l1 = sizeof ( a ) / sizeof ( int ) ; int l2 = sizeof ( b ) / sizeof ( int ) ; int l3 = sizeof ( c ) / sizeof ( int ) ; int x = 14 ; if ( existsTriplet ( a , b , c , x , l1 , l2 , l3 ) ) cout << \" Yes \" ; else cout << \" No \" ; return 0 ; }", "text_ms": "Cari tiga elemen dari tiga array yang diberikan supaya jumlah mereka adalah x | Tetapkan 2 | C ++ pelaksanaan pendekatan; Fungsi yang kembali benar jika terdapat triplet dengan jumlah x; Menyusun susunan sedemikian rupa sehingga [] mewakili array terkecil; Mengalihkan array terkecil; Dua petunjuk pada array kedua dan ketiga; Jika triplet yang sah dijumpai; Kod pemacu"}
{"text": "Arrange given numbers to form the smallest number | C ++ implementation of the approach ; Utility function to print the contents of an array ; A comparison function that return true if ' AB ' is smaller than ' BA ' when we concatenate two numbers ' A ' and ' B ' For example , it will return true if we pass 12 and 24 as arguments . This function will be used by sort ( ) function ; Convert first number to string format ; Convert second number to string format ; Check if ' AB ' is smaller or ' BA ' and return bool value since comparison operator ' < = ' returns true or false ; Function to print the arrangement with the smallest value ; If we pass the name of the comparison function it will sort the array according to the compare function ; Print the sorted array ; Driver code", "code": "#include <algorithm> NEW_LINE #include <iostream> NEW_LINE using namespace std ; void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] ; } bool compare ( int num1 , int num2 ) { string A = to_string ( num1 ) ; string B = to_string ( num2 ) ; return ( A + B ) <= ( B + A ) ; } void printSmallest ( int N , int arr [ ] ) { sort ( arr , arr + N , compare ) ; printArr ( arr , N ) ; } int main ( ) { int arr [ ] = { 5 , 6 , 2 , 9 , 21 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printSmallest ( N , arr ) ; return 0 ; }", "text_ms": "Susun nombor yang diberikan untuk membentuk nombor terkecil | C ++ pelaksanaan pendekatan; Fungsi utiliti untuk mencetak kandungan array; Fungsi perbandingan yang kembali benar jika 'ab' lebih kecil daripada 'ba' apabila kita menggabungkan dua nombor 'a' dan 'b' misalnya, ia akan kembali benar jika kita lulus 12 dan 24 sebagai argumen. Fungsi ini akan digunakan oleh fungsi sort (); Tukar nombor pertama ke format rentetan; Tukar nombor kedua ke format rentetan; Semak jika 'ab' lebih kecil atau 'ba' dan kembali nilai bool sejak pengendali perbandingan '<=' mengembalikan benar atau palsu; Berfungsi untuk mencetak susunan dengan nilai terkecil; Jika kita lulus nama fungsi perbandingan, ia akan menyusun array mengikut fungsi membandingkan; Cetak array yang disusun; Kod pemacu"}
{"text": "Stable Selection Sort | C ++ program for modifying Selection Sort so that it becomes stable . ; Iterate through array elements ; Find minimum element from arr [ i ] to arr [ n - 1 ] . ; Move minimum element at current i . ; Driver code", "code": "#include <iostream> NEW_LINE using namespace std ; void stableSelectionSort ( int a [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { int min = i ; for ( int j = i + 1 ; j < n ; j ++ ) if ( a [ min ] > a [ j ] ) min = j ; int key = a [ min ] ; while ( min > i ) { a [ min ] = a [ min - 1 ] ; min -- ; } a [ i ] = key ; } } void printArray ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << a [ i ] << \" ▁ \" ; cout << endl ; } int main ( ) { int a [ ] = { 4 , 5 , 3 , 2 , 4 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; stableSelectionSort ( a , n ) ; printArray ( a , n ) ; return 0 ; }", "text_ms": "Stabil Pemilihan Susun | Program C ++ untuk mengubah suai pilihan pemilihan supaya ia menjadi stabil. ; Melangkah melalui elemen array; Cari elemen minimum dari arr [i] ke arr [n - 1]. ; Gerakkan elemen minimum pada semasa i. ; Kod pemacu"}
{"text": "Permute two arrays such that sum of every pair is greater or equal to K | C ++ program to check whether permutation of two arrays satisfy the condition a [ i ] + b [ i ] >= k . ; Check whether any permutation exists which satisfy the condition . ; Sort the array a [ ] in decreasing order . ; Sort the array b [ ] in increasing order . ; Checking condition on each index . ; Driven Program", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPossible ( int a [ ] , int b [ ] , int n , int k ) { sort ( a , a + n ) ; sort ( b , b + n , greater < int > ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] + b [ i ] < k ) return false ; return true ; } int main ( ) { int a [ ] = { 2 , 1 , 3 } ; int b [ ] = { 7 , 8 , 9 } ; int k = 10 ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; isPossible ( a , b , n , k ) ? cout << \" Yes \" : cout << \" No \" ; return 0 ; }", "text_ms": "Permut dua tatasusunan sedemikian rupa sehingga jumlah setiap pasangan lebih besar atau sama dengan k | Program C ++ untuk memeriksa sama ada permutasi dua tatasusunan memenuhi syarat [i] + b [i]> = k. ; Semak sama ada apa -apa permutasi wujud yang memenuhi syarat. ; Susun array a [] dalam urutan yang berkurangan. ; Susun array B [] dalam peningkatan urutan. ; Memeriksa keadaan pada setiap indeks. ; Program yang didorong"}
{"text": "Sort an array according to count of set bits | C ++ program to implement simple approach to sort an array according to count of set bits . ; Function to count setbits ; Function to sort By SetBitCount ; Iterate over all values and insert into multimap ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int setBitCount ( int num ) { int count = 0 ; while ( num ) { if ( num & 1 ) count ++ ; num >>= 1 ; } return count ; } void sortBySetBitCount ( int arr [ ] , int n ) { multimap < int , int > count ; for ( int i = 0 ; i < n ; ++ i ) { count . insert ( { ( -1 ) * setBitCount ( arr [ i ] ) , arr [ i ] } ) ; } for ( auto i : count ) cout << i . second << \" ▁ \" ; cout << \" STRNEWLINE \" ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sortBySetBitCount ( arr , n ) ; }", "text_ms": "Sort Array mengikut kiraan bit set | Program C ++ untuk melaksanakan pendekatan mudah untuk menyusun array mengikut kiraan bit set. ; Fungsi untuk mengira setbit; Fungsi untuk disusun oleh SetBitCount; Melangkah ke atas semua nilai dan masukkan ke dalam multimap; Kod pemacu"}
{"text": "Check if end of given Binary string can be reached by choosing jump value in between given range | C ++ program for the above approach ; Function to check if it is possible to reach the end of the binary string using the given jumps ; Stores the DP states ; Initial state ; Stores count of indices from which it is possible to reach index i ; Traverse the given string ; Update the values of pre accordingly ; If the jump size is out of the range [ L , R ] ; Return answer ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; bool canReach ( string s , int L , int R ) { vector < int > dp ( s . length ( ) ) ; dp [ 0 ] = 1 ; int pre = 0 ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( i >= L ) { pre += dp [ i - L ] ; } if ( i > R ) { pre -= dp [ i - R - 1 ] ; } dp [ i ] = ( pre > 0 ) and ( s [ i ] == '0' ) ; } return dp [ s . length ( ) - 1 ] ; } int main ( ) { string S = \"01101110\" ; int L = 2 , R = 3 ; cout << ( canReach ( S , L , R ) ? \" Yes \" : \" No \" ) ; return 0 ; }", "text_ms": "Semak jika akhir rentetan binari yang diberikan dapat dicapai dengan memilih nilai lompat di antara julat yang diberikan | Program C ++ untuk pendekatan di atas; Fungsi untuk memeriksa sama ada mungkin untuk mencapai hujung rentetan binari menggunakan lompatan yang diberikan; Menyimpan negeri -negeri DP; Keadaan awal; Kedai -kedai mengira indeks dari mana ia mungkin untuk mencapai Indeks I; Melintasi rentetan yang diberikan; Mengemas kini nilai pra dengan sewajarnya; Jika saiz lompat keluar dari julat [l, r]; Jawapan kembali; Kod pemacu"}
{"text": "Split an array into subarrays with maximum Bitwise XOR of their respective Bitwise OR values | C ++ program for the above approach ; Recursive function to find all the possible breaking of arrays into subarrays and find the maximum Bitwise XOR ; If the value of N is 0 ; Stores the result if the new group is formed with the first element as arr [ i ] ; Stores if the result if the arr [ i ] is included in the last group ; Returns the maximum of x and y ; Function to find the maximum possible Bitwise XOR of all possible values of the array after breaking the arrays into subarrays ; Return the result ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxXORUtil ( int arr [ ] , int N , int xrr , int orr ) { if ( N == 0 ) return xrr ^ orr ; int x = maxXORUtil ( arr , N - 1 , xrr ^ orr , arr [ N - 1 ] ) ; int y = maxXORUtil ( arr , N - 1 , xrr , orr arr [ N - 1 ] ) ; return max ( x , y ) ; } int maximumXOR ( int arr [ ] , int N ) { return maxXORUtil ( arr , N , 0 , 0 ) ; } int main ( ) { int arr [ ] = { 1 , 5 , 7 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maximumXOR ( arr , N ) ; return 0 ; }", "text_ms": "Pecahkan array ke subarrays dengan bitwise maksimum XOR masing -masing bitwise atau nilai masing -masing | Program C ++ untuk pendekatan di atas; Fungsi rekursif untuk mencari semua kemungkinan pemecahan array ke subarrays dan cari maksimum bitwise XOR; Jika nilai n ialah 0; Menyimpan hasil jika kumpulan baru dibentuk dengan elemen pertama sebagai arr [i]; Kedai jika keputusan jika ARR [i] dimasukkan ke dalam kumpulan terakhir; Mengembalikan maksimum x dan y; Berfungsi untuk mencari maksimum bitwise xor dari semua nilai yang mungkin dari array selepas memecahkan tatasusunan ke subarrays; Mengembalikan hasilnya; Kod pemacu"}
{"text": "Construct an N | C ++ program to implement the above approach ; Keep track of visited nodes ; Function to construct a tree such that there are no two adjacent nodes with the same weight ; If minimum and maximum elements are equal , i . e . array contains one distinct element ; Tree cannot be constructed ; Otherwise ; Tree can be constructed ; Choose weights [ 0 ] as root ; First Node is visited ; Traverse the array ; Otherwise , make an edge ; Mark this node as visited ; Find a weight not same as the root & make edges with that node ; Join non - roots with remaining nodes ; Check if current node ' s ▁ weight ▁ ▁ is ▁ same ▁ as ▁ root ▁ node ' s weight and if it is not visited or not ; Driver Code ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int N = 1e5 + 5 ; int visited [ N ] ; void construct_tree ( int weights [ ] , int n ) { int minimum = * min_element ( weights , weights + n ) ; int maximum = * max_element ( weights , weights + n ) ; if ( minimum == maximum ) { cout << \" No \" ; return ; } else { cout << \" Yes \" << endl ; } int root = weights [ 0 ] ; visited [ 1 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( weights [ i ] != root && visited [ i + 1 ] == 0 ) { cout << 1 << \" ▁ \" << i + 1 << \" ▁ \" << endl ; visited [ i + 1 ] = 1 ; } } int notroot = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( weights [ i ] != root ) { notroot = i + 1 ; break ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( weights [ i ] == root && visited [ i + 1 ] == 0 ) { cout << notroot << \" ▁ \" << i + 1 << endl ; visited [ i + 1 ] = 1 ; } } } int main ( ) { int weights [ ] = { 1 , 2 , 1 , 2 , 5 } ; int N = sizeof ( weights ) / sizeof ( weights [ 0 ] ) ; construct_tree ( weights , N ) ; }", "text_ms": "Bina N | Program C ++ untuk melaksanakan pendekatan di atas; Menjejaki nod yang dikunjungi; Berfungsi untuk membina pokok supaya tidak ada dua nod bersebelahan dengan berat yang sama; Jika elemen minimum dan maksimum adalah sama, i. e. Array mengandungi satu elemen yang berbeza; Pokok tidak boleh dibina; Jika tidak; Pokok boleh dibina; Pilih berat [0] sebagai akar; Node pertama dikunjungi; Melintasi array; Jika tidak, buat kelebihan; Tandakan nod ini seperti yang dikunjungi; Cari berat badan yang tidak sama dengan root & membuat tepi dengan nod itu; Sertai bukan akar dengan nod yang tinggal; Semak jika nod semasa berat ~ sama dengan berat badan dan jika ia tidak dikunjungi atau tidak; Kod pemacu; Panggilan fungsi"}
{"text": "Minimize cost to convert given string into concatenation of equal substrings of length K | C ++ program for the above approach ; Function to find minimum cost to convert given String into String of K length same subString ; Stores length of String ; Stores the minimum cost ; Traverse left subString of k length ; Stores the frequency ; Stores minimum cost for sequence of S [ i ] % k indices ; Check for optimal character ; Find sum of distance ' a ' + ch from character S [ i ] % k indices ; Choose minimum cost for each index i ; Increment ans ; Print minimum cost to convert String ; Driver Code ; Given String S ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void minCost ( string s , int k ) { int n = s . size ( ) ; int ans = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int a [ 26 ] ; for ( int p = 0 ; p < 26 ; p ++ ) { a [ p ] = 0 ; } for ( int j = i ; j < n ; j += k ) { a [ s [ j ] - ' a ' ] ++ ; } int min_cost = INT_MAX ; for ( int ch = 0 ; ch < 26 ; ch ++ ) { int cost = 0 ; for ( int tr = 0 ; tr < 26 ; tr ++ ) cost += abs ( ch - tr ) * a [ tr ] ; min_cost = min ( min_cost , cost ) ; } ans += min_cost ; } cout << ( ans ) ; } int main ( ) { string S = \" abcdefabc \" ; int K = 3 ; minCost ( S , K ) ; }", "text_ms": "Kurangkan kos untuk menukar rentetan yang diberikan menjadi penyambungan substrings yang sama panjang k | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencari kos minimum untuk menukar rentetan yang diberikan ke dalam rentetan panjang K substring yang sama; Kedai panjang rentetan; Menyimpan kos minimum; Melintasi substring kiri panjang K; Menyimpan kekerapan; Kedai kos minimum untuk urutan indeks S [i] % K; Semak watak yang optimum; Cari jumlah jarak 'a' + ch dari indeks kara [i] % k; Pilih kos minimum untuk setiap indeks i; Kenaikan ans; Cetak kos minimum untuk menukar rentetan; Kod pemacu; Diberikan rentetan s; Panggilan fungsi"}
{"text": "Split first N natural numbers into two sets with minimum absolute difference of their sums | C ++ program to implement the above approach ; Function to split the first N natural numbers into two sets having minimum absolute difference of their sums ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minAbsDiff ( int N ) { if ( N % 4 == 0 N % 4 == 3 ) { return 0 ; } return 1 ; } int main ( ) { int N = 6 ; cout << minAbsDiff ( N ) ; }", "text_ms": "Split First N Natural Numbers menjadi dua set dengan perbezaan mutlak minimum jumlah mereka | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk memecah nombor semulajadi N pertama ke dalam dua set yang mempunyai perbezaan mutlak minimum jumlah mereka; Kod pemacu"}
{"text": "Find maximum matching in a given Binary Tree | C ++ program for the above approach ; Adjacency list to store edges ; Add an edge between U and V in tree ; Edge from u to v ; Edge from V to U ; Function that finds the maximum matching of the DFS ; Go further as we are not allowed to go towards its parent ; If U and its parent P is not taken then we must take & mark them as taken ; Increment size of edge set ; Function to find the maximum matching in a graph ; Taking 1 as a root of the tree ; Print maximum Matching ; Driver Code ; Joining edge between two nodes in tree ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  10000 NEW_LINE vector < int > adj [ N ] ; int used [ N ] ; int max_matching ; void AddEdge ( int u , int v ) { adj [ u ] . push_back ( v ) ; adj [ v ] . push_back ( u ) ; } void Matching_dfs ( int u , int p ) { for ( int i = 0 ; i < adj [ u ] . size ( ) ; i ++ ) { if ( adj [ u ] [ i ] != p ) { Matching_dfs ( adj [ u ] [ i ] , u ) ; } } if ( ! used [ u ] and ! used [ p ] and p != 0 ) { max_matching ++ ; used [ u ] = used [ p ] = 1 ; } } void maxMatching ( ) { Matching_dfs ( 1 , 0 ) ; cout << max_matching << \" STRNEWLINE \" ; } int main ( ) { int n = 5 ; AddEdge ( 1 , 2 ) ; AddEdge ( 1 , 3 ) ; AddEdge ( 3 , 4 ) ; AddEdge ( 3 , 5 ) ; maxMatching ( ) ; return 0 ; }", "text_ms": "Cari padanan maksimum dalam pokok binari yang diberikan | Program C ++ untuk pendekatan di atas; Senarai Adjacency untuk menyimpan tepi; Tambah kelebihan antara u dan v dalam pokok; Kelebihan dari u ke v; Tepi dari v ke u; Fungsi yang mendapati pemadanan maksimum DFS; Pergi lebih jauh kerana kami tidak dibenarkan pergi ke arah ibu bapanya; Jika u dan ibu induknya tidak diambil maka kita mesti mengambil & menandakannya sebagai diambil; Saiz kenaikan set tepi; Berfungsi untuk mencari padanan maksimum dalam graf; Mengambil 1 sebagai akar pokok; Cetak padanan maksimum; Kod pemacu; Menyertai kelebihan antara dua nod dalam pokok; Panggilan fungsi"}
{"text": "Minimize cost to Swap two given Arrays | C ++ program to implement the above approach ; Function to calculate and return the minimum cost required to swap two arrays ; Return the total minimum cost ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMinCost ( vector < int > A , vector < int > B , int N ) { int mini = INT_MAX ; for ( int i = 0 ; i < N ; i ++ ) { mini = min ( mini , min ( A [ i ] , B [ i ] ) ) ; } return mini * ( 2 * N - 1 ) ; } int main ( ) { int N = 3 ; vector < int > A = { 1 , 4 , 2 } ; vector < int > B = { 10 , 6 , 12 } ; cout << getMinCost ( A , B , N ) ; return 0 ; }", "text_ms": "Kurangkan kos untuk menukar dua tatasusunan yang diberikan | Program C ++ untuk melaksanakan pendekatan di atas; Fungsi untuk mengira dan mengembalikan kos minimum yang diperlukan untuk menukar dua tatasusunan; Mengembalikan jumlah kos minimum; Kod pemacu"}
{"text": "Print all possible ways to write N as sum of two or more positive integers | C ++ program for the above approach ; Function to print the values stored in vector arr ; Traverse the vector arr ; Recursive function to print different ways in which N can be written as a sum of at 2 or more positive integers ; If n is zero then print this ways of breaking numbers ; Start from previous element in the representation till n ; Include current element from representation ; Call function again with reduced sum ; Backtrack to remove current element from representation ; Driver Code ; Given sum N ; To store the representation of breaking N ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void printVector ( vector < int > & arr ) { if ( arr . size ( ) != 1 ) { for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { cout << arr [ i ] << \" ▁ \" ; } cout << endl ; } } void findWays ( vector < int > & arr , int i , int n ) { if ( n == 0 ) printVector ( arr ) ; for ( int j = i ; j <= n ; j ++ ) { arr . push_back ( j ) ; findWays ( arr , j , n - j ) ; arr . pop_back ( ) ; } } int main ( ) { int n = 4 ; vector < int > arr ; findWays ( arr , 1 , n ) ; return 0 ; }", "text_ms": "Cetak semua cara yang mungkin untuk menulis n sebagai jumlah dua atau lebih integer positif | Program C ++ untuk pendekatan di atas; Berfungsi untuk mencetak nilai yang disimpan dalam arr vektor; Melintasi arr vektor; Fungsi rekursif untuk mencetak cara yang berbeza di mana n boleh ditulis sebagai jumlah pada 2 atau lebih bilangan bulat positif; Jika n adalah sifar maka cetak cara ini memecahkan nombor; Bermula dari elemen sebelumnya dalam perwakilan sehingga n; Termasuk elemen semasa dari perwakilan; Fungsi panggilan sekali lagi dengan jumlah yang dikurangkan; Backtrack untuk mengeluarkan elemen semasa dari perwakilan; Kod pemacu; Diberikan jumlah n; Untuk menyimpan perwakilan melanggar N; Panggilan fungsi"}
{"text": "Maximize count of Decreasing Subsequences from the given Array | C ++ Program to implement the above approach ; Function to count maximum subsequence ; Stores the frequency of array elements ; Stores max frequency ; Update frequency of A [ i ] ; Update max subsequence ; Print the count ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void Maximum_subsequence ( int A [ ] , int N ) { unordered_map < int , int > frequency ; int max_freq = 0 ; for ( int i = 0 ; i < N ; i ++ ) { frequency [ A [ i ] ] ++ ; } for ( auto it : frequency ) { if ( it . second > max_freq ) { max_freq = it . second ; } } cout << max_freq << endl ; } int main ( ) { int arr [ ] = { 5 , 2 , 6 , 5 , 2 , 4 , 5 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; Maximum_subsequence ( arr , N ) ; return 0 ; }", "text_ms": "Memaksimumkan kiraan penurunan berikutnya dari array yang diberikan | Program C ++ untuk melaksanakan pendekatan di atas; Berfungsi untuk mengira berikutnya maksimum; Menyimpan kekerapan elemen array; Kedai frekuensi maksimum; Kemas kini kekerapan [i]; Mengemas kini maksimum Max; Cetak kiraan; Kod pemacu"}
{"text": "Check if a string can be split into two strings with same number of K | C ++ implementation of the above approach ; Function to print the arrangement of characters ; Stores frequency of characters ; Count the character having frequency K ; Count the character having frequency greater than K and not equal to 2 K ; Case 1 ; Case 2 ; Case 3 ; If all cases fail ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void DivideString ( string s , int n , int k ) { int i , c = 0 , no = 1 ; int c1 = 0 , c2 = 0 ; int fr [ 26 ] = { 0 } ; string ans = \" \" ; for ( i = 0 ; i < n ; i ++ ) { fr [ s [ i ] - ' a ' ] ++ ; } char ch , ch1 ; for ( i = 0 ; i < 26 ; i ++ ) { if ( fr [ i ] == k ) { c ++ ; } if ( fr [ i ] > k && fr [ i ] != 2 * k ) { c1 ++ ; ch = i + ' a ' ; } if ( fr [ i ] == 2 * k ) { c2 ++ ; ch1 = i + ' a ' ; } } for ( i = 0 ; i < n ; i ++ ) ans = ans + \"1\" ; map < char , int > mp ; if ( c % 2 == 0 c1 > 0 c2 > 0 ) { for ( i = 0 ; i < n ; i ++ ) { if ( fr [ s [ i ] - ' a ' ] == k ) { if ( mp . find ( s [ i ] ) != mp . end ( ) ) { ans [ i ] = '2' ; } else { if ( no <= ( c / 2 ) ) { ans [ i ] = '2' ; no ++ ; mp [ s [ i ] ] = 1 ; } } } } if ( c % 2 == 1 && c1 > 0 ) { no = 1 ; for ( i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ch && no <= k ) { ans [ i ] = '2' ; no ++ ; } } } if ( c % 2 == 1 && c1 == 0 ) { no = 1 ; int flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ch1 && no <= k ) { ans [ i ] = '2' ; no ++ ; } if ( fr [ s [ i ] - ' a ' ] == k && flag == 0 && ans [ i ] == '1' ) { ans [ i ] = '2' ; flag = 1 ; } } } cout << ans << endl ; } else { cout << \" NO \" << endl ; } } int main ( ) { string S = \" abbbccc \" ; int N = S . size ( ) ; int K = 1 ; DivideString ( S , N , K ) ; return 0 ; }", "text_ms": "Semak jika rentetan boleh dibahagikan kepada dua rentetan dengan bilangan k | yang sama C ++ pelaksanaan pendekatan di atas; Berfungsi untuk mencetak susunan aksara; Kedai kekerapan aksara; Hitung watak yang mempunyai kekerapan k; Hitung watak yang mempunyai kekerapan lebih besar daripada k dan tidak sama dengan 2 k; Kes 1; Kes 2; Kes 3; Jika semua kes gagal; Kod pemacu"}
{"text": "Check if two items can be selected from two different categories without exceeding price | C ++ implementation to check if two items can be selected from two different categories without exceeding the total price ; Function to check if two items can be selected from two different categories without exceeding the total price ; Loop to choose two different pairs using two nested loops ; Condition to check if the price of these two elements is less than S ; Driver Code ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string check ( int S , int prices [ ] , int type [ ] , int n ) { for ( int j = 0 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( ( type [ j ] == 0 && type [ k ] == 1 ) || ( type [ j ] == 1 && type [ k ] == 0 ) ) { if ( prices [ j ] + prices [ k ] <= S ) { return \" Yes \" ; } } } } return \" No \" ; } int main ( ) { int prices [ ] = { 3 , 8 , 6 , 5 } ; int type [ ] = { 0 , 1 , 1 , 0 } ; int S = 10 ; int n = 4 ; cout << check ( S , prices , type , n ) ; return 0 ; }", "text_ms": "Semak jika dua item boleh dipilih dari dua kategori yang berbeza tanpa harga yang melebihi | C ++ pelaksanaan untuk memeriksa sama ada dua item boleh dipilih dari dua kategori yang berbeza tanpa melebihi jumlah harga; Fungsi untuk memeriksa sama ada dua item boleh dipilih dari dua kategori yang berbeza tanpa melebihi jumlah harga; Gelung untuk memilih dua pasangan yang berbeza menggunakan dua gelung bersarang; Keadaan untuk memeriksa sama ada harga kedua -dua elemen ini kurang daripada S; Kod pemacu; Panggilan fungsi"}
{"text": "Find the maximum sum ( a + b ) for a given input integer N satisfying the given condition | C ++ implementation to find the largest value of a + b satisfying the given condition ; Function to return the maximum sum of a + b satisfying the given condition ; Consider all possible pairs and check the sum divides product property ; To find the largest factor k ; Check if the product is divisible by the sum ; Storing the maximum sum in the max_sum variable ; Return the max_sum value ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int getLargestSum ( int N ) { for ( int i = 1 ; i * i <= N ; i ++ ) { for ( int j = i + 1 ; j * j <= N ; j ++ ) { int k = N / j ; int a = k * i ; int b = k * j ; if ( a <= N && b <= N && a * b % ( a + b ) == 0 ) max_sum = max ( max_sum , a + b ) ; } } return max_sum ; } int main ( ) { int N = 25 ; int max_sum = getLargestSum ( N ) ; cout << max_sum << endl ; return 0 ; }", "text_ms": "Cari jumlah maksimum (a + b) untuk integer input yang diberikan dan memenuhi syarat yang diberikan | C ++ pelaksanaan untuk mencari nilai terbesar A + B yang memenuhi syarat yang diberikan; Berfungsi untuk mengembalikan jumlah maksimum A + B yang memenuhi syarat yang diberikan; Pertimbangkan semua pasangan yang mungkin dan periksa jumlah yang membahagikan harta produk; Untuk mencari faktor terbesar k; Semak sama ada produk itu boleh dibahagikan dengan jumlah; Menyimpan jumlah maksimum dalam pembolehubah max_sum; Kembalikan nilai max_sum; Kod pemacu"}
{"text": "Encrypt a string by repeating i | C ++ implementation of the approach ; Function to return the encrypted string ; Number of times the current character will be repeated ; Repeat the current character in the encrypted string ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; string encryptString ( string str , int n ) { int i = 0 , cnt = 0 ; string encryptedStr = \" \" ; while ( i < n ) { cnt = i + 1 ; while ( cnt -- ) encryptedStr += str [ i ] ; i ++ ; } return encryptedStr ; } int main ( ) { string str = \" geeks \" ; int n = str . length ( ) ; cout << encryptString ( str , n ) ; return 0 ; }", "text_ms": "Menyulitkan rentetan dengan mengulangi i | C ++ pelaksanaan pendekatan; Berfungsi untuk mengembalikan rentetan yang disulitkan; Bilangan kali watak semasa akan diulang; Ulangi watak semasa dalam rentetan yang disulitkan; Kod pemacu"}
{"text": "Minimize the difference between the maximum and minimum values of the modified array | C ++ program to find the minimum difference . ; Function to return required minimum difference ; finding minimum and maximum values ; returning minimum possible difference ; Driver program ; function to return the answer", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int minDiff ( int n , int x , int A [ ] ) { int mn = A [ 0 ] , mx = A [ 0 ] ; for ( int i = 0 ; i < n ; ++ i ) { mn = min ( mn , A [ i ] ) ; mx = max ( mx , A [ i ] ) ; } return max ( 0 , mx - mn - 2 * x ) ; } int main ( ) { int n = 3 , x = 3 ; int A [ ] = { 1 , 3 , 6 } ; cout << minDiff ( n , x , A ) ; return 0 ; }", "text_ms": "Kurangkan perbezaan antara nilai maksimum dan minimum array yang diubah suai | Program C ++ untuk mencari perbezaan minimum. ; Fungsi untuk mengembalikan perbezaan minimum yang diperlukan; mencari nilai minimum dan maksimum; mengembalikan perbezaan minimum yang mungkin; Program pemacu; berfungsi untuk mengembalikan jawapannya"}
{"text": "Minimum Swaps for Bracket Balancing | C ++ program to count swaps required to balance string ; Stores total number of Left and Right brackets encountered ; swap stores the number of swaps required imbalance maintains the number of imbalance pair ; Increment count of Left bracket ; swaps count is last swap count + total number imbalanced brackets ; imbalance decremented by 1 as it solved only one imbalance of Left and Right ; Increment count of Right bracket ; imbalance is reset to current difference between Left and Right brackets ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; long swapCount ( string chars ) { int countLeft = 0 , countRight = 0 ; int swap = 0 , imbalance = 0 ; for ( int i = 0 ; i < chars . length ( ) ; i ++ ) { if ( chars [ i ] == ' [ ' ) { countLeft ++ ; if ( imbalance > 0 ) { swap += imbalance ; imbalance -- ; } } else if ( chars [ i ] == ' ] ' ) { countRight ++ ; imbalance = ( countRight - countLeft ) ; } } return swap ; } int main ( ) { string s = \" [ ] ] [ ] [ \" ; cout << swapCount ( s ) << endl ; s = \" [ [ ] [ ] ] \" ; cout << swapCount ( s ) << endl ; return 0 ; }", "text_ms": "Swap minimum untuk mengimbangi pendakap | Program C ++ untuk mengira swap yang diperlukan untuk mengimbangi rentetan; Kedai Jumlah bilangan kurungan kiri dan kanan yang ditemui; Swap menyimpan bilangan swap yang diperlukan ketidakseimbangan mengekalkan bilangan pasangan ketidakseimbangan; Kiraan kenaikan kurungan kiri; kiraan swap adalah kiraan swap terakhir + jumlah kurungan tidak seimbang; ketidakseimbangan yang diturunkan oleh 1 kerana ia hanya menyelesaikan satu ketidakseimbangan kiri dan kanan; Kiraan kenaikan kurungan kanan; Ketidakseimbangan diset semula kepada perbezaan semasa antara kurungan kiri dan kanan; Kod pemacu"}
{"text": "Longest subsequence from an array of pairs having first element increasing and second element decreasing . | C ++ program for the above approach ; Function to find the length of the longest subsequence of pairs whose first element is increasing and second is decreasing ; dp [ i ] : Stores the longest subsequence upto i ; Base case ; When the conditions hold ; Finally , print the required answer ; Driver Code ; Given Input ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void longestSubSequence ( pair < int , int > A [ ] , int N ) { int dp [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { dp [ i ] = 1 ; for ( int j = 0 ; j < i ; j ++ ) { if ( A [ j ] . first < A [ i ] . first && A [ j ] . second > A [ i ] . second ) { dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 ) ; } } } cout << dp [ N - 1 ] << endl ; } int main ( ) { pair < int , int > A [ ] = { { 1 , 2 } , { 2 , 2 } , { 3 , 1 } } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; longestSubSequence ( A , N ) ; return 0 ; }", "text_ms": "Paling terpanjang dari pelbagai pasangan yang mempunyai elemen pertama yang semakin meningkat dan elemen kedua berkurangan. | Program C ++ untuk pendekatan di atas; Fungsi untuk mencari panjang pasang pasang terpanjang yang elemen pertama yang semakin meningkat dan kedua berkurangan; dp [i]: Menyimpan selanjutnya yang terpanjang sehingga i; Kes asas; Apabila keadaan memegang; Akhirnya, cetak jawapan yang diperlukan; Kod pemacu; Diberikan input; Panggilan fungsi"}
{"text": "Count ways to obtain given sum by repeated throws of a dice | C ++ Program for the above approach ; Function to calculate the total number of ways to have sum N ; Base Case ; Return already stored result ; Recur for all 6 states ; Return the result ; Driver Code ; Given sum N ; Initialize the dp array ; Function Call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; int findWays ( int N , int dp [ ] ) { if ( N == 0 ) { return 1 ; } if ( dp [ N ] != -1 ) { return dp [ N ] ; } int cnt = 0 ; for ( int i = 1 ; i <= 6 ; i ++ ) { if ( N - i >= 0 ) { cnt = cnt + findWays ( N - i , dp ) ; } } return dp [ N ] = cnt ; } int main ( ) { int N = 4 ; int dp [ N + 1 ] ; memset ( dp , -1 , sizeof ( dp ) ) ; cout << findWays ( N , dp ) ; return 0 ; }", "text_ms": "Kira cara untuk mendapatkan jumlah yang diberikan oleh lontaran berulang dadu | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira jumlah cara untuk mempunyai jumlah n; Kes asas; Kembali hasil yang telah disimpan; Berulang untuk semua 6 negeri; Mengembalikan hasilnya; Kod pemacu; Diberikan jumlah n; Memulakan array DP; Panggilan fungsi"}
{"text": "Count ways to obtain given sum by repeated throws of a dice | C ++ Program for the above approach ; Function to calculate the total number of ways to have sum N ; Initialize dp array ; Iterate over all the possible intermediate values to reach N ; Calculate the sum for all 6 faces ; Print the total number of ways ; Driver Code ; Given sum N ; Function call", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; void findWays ( int N ) { int dp [ N + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { dp [ i ] = 0 ; for ( int j = 1 ; j <= 6 ; j ++ ) { if ( i - j >= 0 ) { dp [ i ] = dp [ i ] + dp [ i - j ] ; } } } cout << dp [ N ] ; } int main ( ) { int N = 4 ; findWays ( N ) ; return 0 ; }", "text_ms": "Kira cara untuk mendapatkan jumlah yang diberikan oleh lontaran berulang dadu | Program C ++ untuk pendekatan di atas; Fungsi untuk mengira jumlah cara untuk mempunyai jumlah n; Memulakan array DP; Melangkah ke atas semua nilai perantaraan yang mungkin untuk mencapai n; Kirakan jumlah untuk semua 6 muka; Cetak jumlah cara; Kod pemacu; Diberikan jumlah n; Panggilan fungsi"}
{"text": "Split the string into minimum parts such that each part is in the another string | C ++ implementation to split the string into minimum number of parts such that each part is also present in the another string ; Node of Trie ; Function to insert a node in the Trie Data Structure ; Inserting every character from idx till end to string into trie ; if there is no edge corresponding to the ith character , then make a new node ; Function to find the minimum number of parts such that each part is present into another string ; Making a new trie ; Inserting every substring of S2 in trie ; Creating dp array and init it with infinity ; Base Case ; Starting the cut from ith character taking temporary node pointer for checking whether the substring [ i , j ) is present in trie of not ; if the jth character is not in trie we 'll break ; Updating the the ending of jth character with dp [ i ] + 1 ; Descending the trie pointer ; Answer not possible ; Driver Code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int INF = 1e9 + 9 ; struct TrieNode { TrieNode * child [ 26 ] = { NULL } ; } ; void insert ( int idx , string & s , TrieNode * root ) { TrieNode * temp = root ; for ( int i = idx ; i < s . length ( ) ; i ++ ) { if ( temp -> child [ s [ i ] - ' a ' ] == NULL ) temp -> child [ s [ i ] - ' a ' ] = new TrieNode ; temp = temp -> child [ s [ i ] - ' a ' ] ; } } int minCuts ( string S1 , string S2 ) { int n1 = S1 . length ( ) ; int n2 = S2 . length ( ) ; TrieNode * root = new TrieNode ; for ( int i = 0 ; i < n2 ; i ++ ) { insert ( i , S2 , root ) ; } vector < int > dp ( n1 + 1 , INF ) ; dp [ 0 ] = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { TrieNode * temp = root ; for ( int j = i + 1 ; j <= n1 ; j ++ ) { if ( temp -> child [ S1 [ j - 1 ] - ' a ' ] == NULL ) break ; dp [ j ] = min ( dp [ j ] , dp [ i ] + 1 ) ; temp = temp -> child [ S1 [ j - 1 ] - ' a ' ] ; } } if ( dp [ n1 ] >= INF ) return -1 ; else return dp [ n1 ] ; } int main ( ) { string S1 = \" abcdab \" ; string S2 = \" dabc \" ; cout << minCuts ( S1 , S2 ) ; }", "text_ms": "Pecahkan rentetan ke bahagian minimum supaya setiap bahagian berada dalam rentetan lain | C ++ pelaksanaan untuk memecah rentetan ke dalam bilangan minimum bahagian supaya setiap bahagian juga terdapat dalam rentetan lain; Nod trie; Berfungsi untuk memasukkan nod dalam struktur data trie; Memasukkan setiap watak dari IDX hingga hujung ke rentetan ke dalam trie; Sekiranya tidak ada kelebihan yang sepadan dengan watak ITH, maka buat nod baru; Berfungsi untuk mencari bilangan minimum bahagian supaya setiap bahagian hadir ke dalam rentetan lain; Membuat trie baru; Memasukkan setiap substring S2 di Trie; Mewujudkan array DP dan init dengan tak terhingga; Kes asas; Memulakan pemotongan dari watak yang mengambil penunjuk nod sementara untuk memeriksa sama ada substring [i, j) hadir dalam trie tidak; Sekiranya watak JTH tidak berada di Trie, kami akan berehat; Mengemas kini berakhirnya watak jth dengan dp [i] + 1; Menurunkan penunjuk Trie; Jawapan tidak mungkin; Kod pemacu"}
{"text": "Largest Square in a Binary Matrix with at most K 1 s for multiple Queries | C ++ implementation to find the largest square in the matrix such that it contains atmost K 1 's ; Function to find the largest square in the matrix such that it contains atmost K 1 's ; Precomputation of the countDP prefix sum of the matrix ; Loop to solve each query ; Binary Search to the side which have atmost in K 1 's in square ; Count total number of 1 s in the sub square considered ; If the count is less than or equals to the maximum move to right half ; Driver code", "code": "#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; void largestSquare ( int matrix [ ] [ MAX ] , int R , int C , int q_i [ ] , int q_j [ ] , int K , int Q ) { int countDP [ R ] [ C ] ; memset ( countDP , 0 , sizeof ( countDP ) ) ; countDP [ 0 ] [ 0 ] = matrix [ 0 ] [ 0 ] ; for ( int i = 1 ; i < R ; i ++ ) countDP [ i ] [ 0 ] = countDP [ i - 1 ] [ 0 ] + matrix [ i ] [ 0 ] ; for ( int j = 1 ; j < C ; j ++ ) countDP [ 0 ] [ j ] = countDP [ 0 ] [ j - 1 ] + matrix [ 0 ] [ j ] ; for ( int i = 1 ; i < R ; i ++ ) for ( int j = 1 ; j < C ; j ++ ) countDP [ i ] [ j ] = matrix [ i ] [ j ] + countDP [ i - 1 ] [ j ] + countDP [ i ] [ j - 1 ] - countDP [ i - 1 ] [ j - 1 ] ; for ( int q = 0 ; q < Q ; q ++ ) { int i = q_i [ q ] ; int j = q_j [ q ] ; int min_dist = min ( min ( i , j ) , min ( R - i - 1 , C - j - 1 ) ) ; int ans = -1 , l = 0 , u = min_dist ; while ( l <= u ) { int mid = ( l + u ) / 2 ; int x1 = i - mid , x2 = i + mid ; int y1 = j - mid , y2 = j + mid ; int count = countDP [ x2 ] [ y2 ] ; if ( x1 > 0 ) count -= countDP [ x1 - 1 ] [ y2 ] ; if ( y1 > 0 ) count -= countDP [ x2 ] [ y1 - 1 ] ; if ( x1 > 0 && y1 > 0 ) count += countDP [ x1 - 1 ] [ y1 - 1 ] ; if ( count <= K ) { ans = 2 * mid + 1 ; l = mid + 1 ; } else u = mid - 1 ; } cout << ans << \" STRNEWLINE \" ; } } int main ( ) { int matrix [ ] [ MAX ] = { { 1 , 0 , 1 , 0 , 0 } , { 1 , 0 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 } , { 1 , 0 , 0 , 1 , 0 } } ; int K = 9 , Q = 1 ; int q_i [ ] = { 1 } ; int q_j [ ] = { 2 } ; largestSquare ( matrix , 4 , 5 , q_i , q_j , K , Q ) ; return 0 ; }", "text_ms": "Dataran terbesar dalam matriks binari dengan paling banyak k 1 s untuk pelbagai pertanyaan | C ++ pelaksanaan untuk mencari dataran terbesar dalam matriks supaya ia mengandungi atmost k 1 's; Berfungsi untuk mencari dataran terbesar dalam matriks supaya ia mengandungi atmost k 1 's; Precomputation of Prefix CountDP Jumlah matriks; Gelung untuk menyelesaikan setiap pertanyaan; Carian binari ke sisi yang mempunyai atmost dalam k 1 's di persegi; Kira jumlah 1 s dalam sub persegi yang dipertimbangkan; Jika kiraan kurang daripada atau sama dengan langkah maksimum ke separuh kanan; Kod pemacu"}
